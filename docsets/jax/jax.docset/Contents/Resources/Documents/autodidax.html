
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator"/>
<title>Autodidax: JAX core from scratch ‚Äî JAX  documentation</title>
<!-- Loaded before other Sphinx assets -->
<link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet"/>
<link href="_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css">
<link href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" rel="stylesheet" type="text/css">
<link href="_static/plot_directive.css" rel="stylesheet" type="text/css">
<link href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" rel="stylesheet" type="text/css">
<link href="_static/copybutton.css" rel="stylesheet" type="text/css">
<link href="_static/style.css" rel="stylesheet" type="text/css"/>
<!-- Pre-loaded scripts that we'll load fully later -->
<link as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf" rel="preload"/>
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/clipboard.min.js"></script>
<script src="_static/copybutton.js"></script>
<script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
<link href="_static/favicon.png" rel="shortcut icon">
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="jep/index.html" rel="next" title="JAX Enhancement Proposals (JEPs)"/>
<link href="_autosummary/jax.core.ClosedJaxpr.html" rel="prev" title="jax.core.ClosedJaxpr"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
</link></link></link></link></link></link></head>
<body data-offset="60" data-spy="scroll" data-target="#bd-toc-nav">
<!-- Checkboxes to toggle the left sidebar -->
<input aria-label="Toggle navigation sidebar" class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
<label class="overlay overlay-navbar" for="__navigation">
<div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input aria-label="Toggle in-page Table of Contents" class="sidebar-toggle" id="__page-toc" name="__page-toc" type="checkbox"/>
<label class="overlay overlay-pagetoc" for="__page-toc">
<div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>
<div class="container-fluid" id="banner"></div>
<div class="container-xl">
<div class="row">
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
<div class="bd-sidebar__content">
<div class="bd-sidebar__top"><div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
<!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
<img alt="logo" class="logo" src="_static/jax_logo_250px.png"/>
</a>
</div><form action="search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search the docs ..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." type="search"/>
</form><nav aria-label="Main" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="installation.html">
   Installing JAX
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/quickstart.html">
   JAX Quickstart
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/Common_Gotchas_in_JAX.html">
   üî™ JAX - The Sharp Bits üî™
  </a>
</li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children">
<a class="reference internal" href="jax-101/index.html">
   Tutorial: JAX 101
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox">
<label for="toctree-checkbox-1">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax-101/08-pjit.html">
     Introduction to pjit
    </a>
</li>
</ul>
</input></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children">
<a class="reference internal" href="debugging/index.html">
   Runtime value debugging in JAX
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox">
<label for="toctree-checkbox-2">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="debugging/print_breakpoint.html">
<code class="docutils literal notranslate">
<span class="pre">
       jax.debug.print
      </span>
</code>
     and
     <code class="docutils literal notranslate">
<span class="pre">
       jax.debug.breakpoint
      </span>
</code>
</a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
<span class="pre">
       checkify
      </span>
</code>
     transformation
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="debugging/flags.html">
     JAX debugging flags
    </a>
</li>
</ul>
</input></li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="async_dispatch.html">
   Asynchronous dispatch
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="aot.html">
   Ahead-of-time lowering and compilation
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="jaxpr.html">
   Understanding Jaxprs
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/convolutions.html">
   Convolutions in JAX
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="pytrees.html">
   Pytrees
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="type_promotion.html">
   Type promotion semantics
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="errors.html">
   JAX Errors
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="transfer_guard.html">
   Transfer guard
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="glossary.html">
   JAX Glossary of Terms
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="changelog.html">
   Change log
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="api_compatibility.html">
   API compatibility
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="deprecation.html">
   Python and NumPy version support policy
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="concurrency.html">
   Concurrency
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="gpu_memory_allocation.html">
   GPU memory allocation
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="profiling.html">
   Profiling JAX programs
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="device_memory_profiling.html">
   Device Memory Profiling
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="rank_promotion_warning.html">
   Rank promotion warning
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="contributing.html">
   Contributing to JAX
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="developer.html">
   Building from source
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="jax_internal_api.html">
   Internal APIs
  </a>
</li>
<li class="toctree-l1 current active">
<a class="current reference internal" href="#">
   Autodidax: JAX core from scratch
  </a>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox">
<label for="toctree-checkbox-3">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="jep/263-prng.html">
     263: JAX PRNG Design
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
</li>
</ul>
</input></li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children">
<a class="reference internal" href="jax.html">
   Public API: jax package
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
<label for="toctree-checkbox-4">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="jax.numpy.html">
     jax.numpy package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.scipy.html">
     jax.scipy package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.config.html">
     JAX configuration
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.debug.html">
     jax.debug package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.dlpack.html">
     jax.dlpack module
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.distributed.html">
     jax.distributed module
    </a>
</li>
<li class="toctree-l2 has-children">
<a class="reference internal" href="jax.example_libraries.html">
     jax.example_libraries package
    </a>
<input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
<label for="toctree-checkbox-5">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l3">
<a class="reference internal" href="jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
</li>
</ul>
</li>
<li class="toctree-l2 has-children">
<a class="reference internal" href="jax.experimental.html">
     jax.experimental package
    </a>
<input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
<label for="toctree-checkbox-6">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
</li>
<li class="toctree-l3">
<a class="reference internal" href="jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
</li>
</ul>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.flatten_util.html">
     jax.flatten_util package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.image.html">
     jax.image package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.lax.html">
     jax.lax package
    </a>
</li>
<li class="toctree-l2 has-children">
<a class="reference internal" href="jax.nn.html">
     jax.nn package
    </a>
<input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
<label for="toctree-checkbox-7">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l3">
<a class="reference internal" href="jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
</li>
</ul>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.ops.html">
     jax.ops package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.profiler.html">
     jax.profiler module
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.random.html">
     jax.random package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.stages.html">
     jax.stages package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.tree_util.html">
     jax.tree_util package
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="jax.lib.html">
     jax.lib package
    </a>
</li>
</ul>
</li>
</ul>
</div>
</nav></div>
<div class="bd-sidebar__bottom">
<!-- To handle the deprecated key -->
<div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>
</div>
</div>
<div id="rtd-footer-container"></div>
</div>
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
<div class="header-article row sticky-top noprint">
<div class="col py-1 d-flex header-article-main">
<div class="header-article__left">
<label class="headerbtn" data-placement="right" data-toggle="tooltip" for="__navigation" title="Toggle navigation">
<span class="headerbtn__icon-container">
<i class="fas fa-bars"></i>
</span>
</label>
</div>
<div class="header-article__right">
<button class="headerbtn" data-placement="bottom" data-toggle="tooltip" onclick="toggleFullScreen()" title="Fullscreen mode">
<span class="headerbtn__icon-container">
<i class="fas fa-expand"></i>
</span>
</button>
<a class="headerbtn" data-placement="bottom" data-toggle="tooltip" href="https://github.com/google/jax" title="Source repository">
<span class="headerbtn__icon-container">
<i class="fab fa-github"></i>
</span>
</a>
<div class="menu-dropdown menu-dropdown-download-buttons">
<button aria-label="Download this page" class="headerbtn menu-dropdown__trigger">
<i class="fas fa-download"></i>
</button>
<div class="menu-dropdown__content">
<ul>
<li>
<a class="headerbtn" data-placement="left" data-toggle="tooltip" href="_sources/autodidax.ipynb.txt" title="Download source file">
<span class="headerbtn__icon-container">
<i class="fas fa-file"></i>
</span>
<span class="headerbtn__text-container">.ipynb</span>
</a>
</li>
<li>
<button class="headerbtn" data-placement="left" data-toggle="tooltip" onclick="printPdf(this)" title="Print to PDF">
<span class="headerbtn__icon-container">
<i class="fas fa-file-pdf"></i>
</span>
<span class="headerbtn__text-container">.pdf</span>
</button>
</li>
</ul>
</div>
</div>
<label class="headerbtn headerbtn-page-toc" for="__page-toc">
<span class="headerbtn__icon-container">
<i class="fas fa-list"></i>
</span>
</label>
</div>
</div>
<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
<div class="tocsection onthispage pt-5 pb-3">
<i class="fas fa-list"></i> Contents
    </div>
<nav aria-label="Page" id="bd-toc-nav">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">
   Part 1: Transformations as interpreters: standard evaluation,
   <code class="docutils literal notranslate">
<span class="pre">
     jvp
    </span>
</code>
   , and
   <code class="docutils literal notranslate">
<span class="pre">
     vmap
    </span>
</code>
</a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#jax-core-machinery">
     JAX core machinery
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#evaluation-interpreter">
     Evaluation interpreter
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#forward-mode-autodiff-with-jvp">
     Forward-mode autodiff with
     <code class="docutils literal notranslate">
<span class="pre">
       jvp
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#pytrees-and-flattening-user-functions-inputs-and-outputs">
   Pytrees and flattening user functions‚Äô inputs and outputs
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#vectorized-batching-with-vmap">
     Vectorized batching with
     <code class="docutils literal notranslate">
<span class="pre">
       vmap
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-2-jaxprs">
   Part 2: Jaxprs
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#jaxpr-data-structures">
     Jaxpr data structures
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#building-jaxprs-with-tracing">
     Building jaxprs with tracing
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-3-jit-simplified">
   Part 3:
   <code class="docutils literal notranslate">
<span class="pre">
     jit
    </span>
</code>
   , simplified
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#on-the-fly-final-style-and-staged-initial-style-processing">
     On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-4-linearize-and-vjp-and-grad">
   Part 4:
   <code class="docutils literal notranslate">
<span class="pre">
     linearize
    </span>
</code>
   and
   <code class="docutils literal notranslate">
<span class="pre">
     vjp
    </span>
</code>
   (and
   <code class="docutils literal notranslate">
<span class="pre">
     grad
    </span>
</code>
   !)
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#linearize">
<code class="docutils literal notranslate">
<span class="pre">
       linearize
      </span>
</code>
</a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#vjp-and-grad">
<code class="docutils literal notranslate">
<span class="pre">
       vjp
      </span>
</code>
     and
     <code class="docutils literal notranslate">
<span class="pre">
       grad
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-5-the-control-flow-primitives-cond">
   Part 5: the control flow primitives
   <code class="docutils literal notranslate">
<span class="pre">
     cond
    </span>
</code>
</a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#adding-cond">
     Adding
     <code class="docutils literal notranslate">
<span class="pre">
       cond
      </span>
</code>
</a>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class="article row">
<div class="col pl-md-3 pl-lg-5 content-container">
<!-- Table of contents that is only displayed when printing the page -->
<div class="onlyprint" id="jb-print-docs-body">
<h1>Autodidax: JAX core from scratch</h1>
<!-- Table of contents -->
<div id="print-main-content">
<div id="jb-print-toc">
<div>
<h2> Contents </h2>
</div>
<nav aria-label="Page">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">
   Part 1: Transformations as interpreters: standard evaluation,
   <code class="docutils literal notranslate">
<span class="pre">
     jvp
    </span>
</code>
   , and
   <code class="docutils literal notranslate">
<span class="pre">
     vmap
    </span>
</code>
</a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#jax-core-machinery">
     JAX core machinery
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#evaluation-interpreter">
     Evaluation interpreter
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#forward-mode-autodiff-with-jvp">
     Forward-mode autodiff with
     <code class="docutils literal notranslate">
<span class="pre">
       jvp
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#pytrees-and-flattening-user-functions-inputs-and-outputs">
   Pytrees and flattening user functions‚Äô inputs and outputs
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#vectorized-batching-with-vmap">
     Vectorized batching with
     <code class="docutils literal notranslate">
<span class="pre">
       vmap
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-2-jaxprs">
   Part 2: Jaxprs
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#jaxpr-data-structures">
     Jaxpr data structures
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#building-jaxprs-with-tracing">
     Building jaxprs with tracing
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-3-jit-simplified">
   Part 3:
   <code class="docutils literal notranslate">
<span class="pre">
     jit
    </span>
</code>
   , simplified
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#on-the-fly-final-style-and-staged-initial-style-processing">
     On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-4-linearize-and-vjp-and-grad">
   Part 4:
   <code class="docutils literal notranslate">
<span class="pre">
     linearize
    </span>
</code>
   and
   <code class="docutils literal notranslate">
<span class="pre">
     vjp
    </span>
</code>
   (and
   <code class="docutils literal notranslate">
<span class="pre">
     grad
    </span>
</code>
   !)
  </a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#linearize">
<code class="docutils literal notranslate">
<span class="pre">
       linearize
      </span>
</code>
</a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#vjp-and-grad">
<code class="docutils literal notranslate">
<span class="pre">
       vjp
      </span>
</code>
     and
     <code class="docutils literal notranslate">
<span class="pre">
       grad
      </span>
</code>
</a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-5-the-control-flow-primitives-cond">
   Part 5: the control flow primitives
   <code class="docutils literal notranslate">
<span class="pre">
     cond
    </span>
</code>
</a>
<ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#adding-cond">
     Adding
     <code class="docutils literal notranslate">
<span class="pre">
       cond
      </span>
</code>
</a>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
</div>
<main id="main-content" role="main">
<div>
<p><a class="reference external" href="https://colab.research.google.com/github/google/jax/blob/main/docs/autodidax.ipynb"><img alt="Open inColab" src="https://colab.research.google.com/assets/colab-badge.svg"/></a></p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Autodidax: JAX core from scratch"></a><section class="tex2jax_ignore mathjax_ignore" id="autodidax-jax-core-from-scratch">
<h1>Autodidax: JAX core from scratch<a class="headerlink" href="#autodidax-jax-core-from-scratch" title="Permalink to this headline">#</a></h1>
<p>Ever want to learn how JAX works, but the implementation seemed impenetrable?
Well, you‚Äôre in luck! By reading this tutorial, you‚Äôll learn every big idea in
JAX‚Äôs core system. You‚Äôll even get clued into our weird jargon!</p>
<p><strong>This is a work-in-progress draft.</strong> There are some important ingredients
missing, still to come in parts 5 and 6 (and more?). There are also some
simplifications here that we haven‚Äôt yet applied to the main system, but we
will.</p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Part 1: Transformations as interpreters: standard evaluation, jvp, and vmap"></a><section id="part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap">
<h2>Part 1: Transformations as interpreters: standard evaluation, <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, and <code class="docutils literal notranslate"><span class="pre">vmap</span></code><a class="headerlink" href="#part-1-transformations-as-interpreters-standard-evaluation-jvp-and-vmap" title="Permalink to this headline">#</a></h2>
<p>We want to transform functions that look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>
</pre></div>
</div>
<p>Think of functions like <code class="docutils literal notranslate"><span class="pre">sin</span></code> and the arithmetic operations underlying the
infix operators (<code class="docutils literal notranslate"><span class="pre">mul</span></code>, <code class="docutils literal notranslate"><span class="pre">add</span></code>, and <code class="docutils literal notranslate"><span class="pre">neg</span></code>) as primitive operations, meaning
atomic units of processing rather than compositions.</p>
<p>‚ÄúTransform‚Äù means ‚Äúinterpret differently.‚Äù Instead of standard interpretation
where we apply primitive operations to numerical inputs to produce numerical
outputs, we want to override primitive application and let different values
flow through our program. For example, we might want to replace the
application of every primitive with an application of <a class="reference external" href="https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html">its JVP
rule</a>,
and let primal-tangent pairs flow through our program. Moreover, we want to be
able to compose multiple transformations, leading to stacks of interpreters.</p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/JAX core machinery"></a><section id="jax-core-machinery">
<h3>JAX core machinery<a class="headerlink" href="#jax-core-machinery" title="Permalink to this headline">#</a></h3>
<p>We can implement stacks of interpreters and even have them all discharge on
the fly as we execute the Python function to be transformed. To start, let‚Äôs
define these primitives so that we can intercept their application:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="k">class</span> <span class="nc">Primitive</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">add_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">'add'</span><span class="p">)</span>
<span class="n">mul_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">'mul'</span><span class="p">)</span>
<span class="n">neg_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"neg"</span><span class="p">)</span>
<span class="n">sin_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"sin"</span><span class="p">)</span>
<span class="n">cos_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"cos"</span><span class="p">)</span>
<span class="n">reduce_sum_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"reduce_sum"</span><span class="p">)</span>
<span class="n">greater_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"greater"</span><span class="p">)</span>
<span class="n">less_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"less"</span><span class="p">)</span>
<span class="n">transpose_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"transpose"</span><span class="p">)</span>
<span class="n">broadcast_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">"broadcast"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">add_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">mul_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">neg_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">sin_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">cos_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">greater_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">less_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">transpose_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">perm</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span> <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">broadcast_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">bind1</span><span class="p">(</span><span class="n">reduce_sum_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bind1</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">out</span><span class="p">,</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<p>We‚Äôll set up array data types and infix operator methods in a moment.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Primitive</span></code> is just an object with a name, to which we attach our
interpretation rules (one for each transformation). The <code class="docutils literal notranslate"><span class="pre">bind</span></code> function is our
interception point: it‚Äôll figure out which transformation rule to apply, based
on how the arguments are boxed in tracers and what interpreters are active.</p>
<p>The functions that user code calls, like <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">sin</span></code>, are just wrappers
around calls to <code class="docutils literal notranslate"><span class="pre">bind</span></code>. These wrappers let us control how arguments are passed
to <code class="docutils literal notranslate"><span class="pre">bind</span></code>, and in particular we follow a handy internal convention: when we
call <code class="docutils literal notranslate"><span class="pre">bind</span></code>, we pass values representing array data as positional arguments,
and we pass metadata like the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">sum_p</span></code> via keyword. This
calling convention simplifies some core logic (since e.g. instances of the
<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> class to be defined below can only occur in positional arguments to
<code class="docutils literal notranslate"><span class="pre">bind</span></code>). The wrappers can also provide docstrings!</p>
<p>We represent active interpreters as a stack. The stack is just a simple
<code class="docutils literal notranslate"><span class="pre">list</span></code>, and each element is a container with an integer level (corresponding
to the element‚Äôs height in the stack), an interpreter type (which we‚Äôll call a
<code class="docutils literal notranslate"><span class="pre">trace_type</span></code>), and an optional field for any global data the interpreter
needs. We call each element a <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code>, though maybe ‚ÄúInterpreter‚Äù would be
more descriptive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">MainTrace</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">trace_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s1">'Trace'</span><span class="p">]</span>
  <span class="n">global_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>

<span class="n">trace_stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dynamic_trace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be employed in Part 3</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s1">'Trace'</span><span class="p">],</span> <span class="n">global_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace_stack</span><span class="p">)</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="n">global_data</span><span class="p">)</span>
  <span class="n">trace_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">trace_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>When we‚Äôre about to apply a transformation, we‚Äôll push another interpreter
onto the stack using <code class="docutils literal notranslate"><span class="pre">new_main</span></code>. Then, as we apply primitives in the function,
we can think of the <code class="docutils literal notranslate"><span class="pre">bind</span></code> first being interpreted by the trace at the top of
the stack (i.e. with the highest level). If that first interpreter itself
binds other primitives in its interpretation rule for the primitive, like how
the JVP rule of <code class="docutils literal notranslate"><span class="pre">sin_p</span></code> might bind <code class="docutils literal notranslate"><span class="pre">cos_p</span></code> and <code class="docutils literal notranslate"><span class="pre">mul_p</span></code>, then those <code class="docutils literal notranslate"><span class="pre">bind</span></code>
calls will be handled by the interpreter at the next level down.</p>
<p>What goes at the bottom of the interpreter stack? At the bottom, we know all
the transformation interpreters are finished, and we just want to do standard
evaluation. So at the bottom we‚Äôll put an evaluation interpreter.</p>
<p>Let‚Äôs sketch out the interface for interpreters, which is based on the <code class="docutils literal notranslate"><span class="pre">Trace</span></code>
and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> base classes. A <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> represents a boxed-up value, perhaps
carrying some extra context data used by the interpreter. A <code class="docutils literal notranslate"><span class="pre">Trace</span></code> handles
boxing up values into <code class="docutils literal notranslate"><span class="pre">Tracers</span></code> and also handles primitive application.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Trace</span><span class="p">:</span>
  <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">main</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>
  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>
</pre></div>
</div>
</div>
</div>
<p>The first two methods are about boxing up values in <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s, which are the
objects that flow through the Python programs we transform. The last method is
the callback we‚Äôll use to interpret primitive application.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Trace</span></code> itself doesn‚Äôt contain any data, other than a reference to its
corresponding <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code> instance. In fact, multiple instances of a <code class="docutils literal notranslate"><span class="pre">Trace</span></code>
might be created and discarded during an application of a transformation,
whereas only a single <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code> instance is created per application of a
transformation.</p>
<p>As for <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s themselves, each one carries an abstract value (and forwards
infix operators to it), and the rest is up to the transformation. (The
relationship between <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s and <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code>s is that there‚Äôs one
<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> per transformation, and at least one <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code> per base type,
like arrays.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">Tracer</span><span class="p">:</span>
  <span class="n">_trace</span><span class="p">:</span> <span class="n">Trace</span>

  <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># must override</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># default implementation</span>

  <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_radd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ShapedArray</span><span class="p">:</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

  <span class="n">_neg</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
  <span class="n">_add</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_radd</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">add</span><span class="p">))</span>
  <span class="n">_mul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_rmul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">mul</span><span class="p">))</span>
  <span class="n">_gt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
  <span class="n">_lt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">less</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_bool</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"ShapedArray can't be unambiguously converted to bool"</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_nonzero</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"ShapedArray can't be unambiguously converted to bool"</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="s2">","</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">]'</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">"ShapedArray(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">)"</span>

<span class="k">class</span> <span class="nc">ConcreteArray</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">):</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_bool</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">_nonzero</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ConcreteArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">jax_types</span> <span class="o">=</span> <span class="p">{</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we actually have two <code class="docutils literal notranslate"><span class="pre">AbstractValue</span></code>s for arrays, representing
different levels of abstraction. A <code class="docutils literal notranslate"><span class="pre">ShapedArray</span></code> represents the set of all
possible arrays with a given shape and dtype. A <code class="docutils literal notranslate"><span class="pre">ConcreteArray</span></code> represents a
singleton set consisting of a single array value.</p>
<p>Now that we‚Äôve set up the interpreter stack, the Trace/Tracer API for
interpreters, and abstract values, we can come back to implement <code class="docutils literal notranslate"><span class="pre">bind</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">process_primitive</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">full_lower</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The main action is that we call <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code> to figure out which
interpreter should handle this primitive application. We then call that top
trace‚Äôs <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> so that the trace can apply its interpretation
rule. The calls to <code class="docutils literal notranslate"><span class="pre">full_raise</span></code> just ensure that the inputs are boxed in the
top trace‚Äôs <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> instances, and the call to <code class="docutils literal notranslate"><span class="pre">full_lower</span></code> is an optional
optimization so that we unbox values out of <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s as much as possible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>

<span class="k">def</span> <span class="nf">find_top_trace</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trace</span><span class="p">:</span>
  <span class="n">top_main</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)),</span>
                 <span class="n">default</span><span class="o">=</span><span class="n">trace_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">'level'</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dynamic_trace</span> <span class="ow">and</span> <span class="n">dynamic_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">top_main</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="n">dynamic_trace</span>
  <span class="k">return</span> <span class="n">top_main</span><span class="o">.</span><span class="n">trace_type</span><span class="p">(</span><span class="n">top_main</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In words, ignoring the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> step until Part 3, <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code>
returns the highest-level interpreter associated with the <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s on its
inputs, and otherwise returns the interpreter at the bottom of the stack
(which is always an evaluation trace, at least for now). This is a deviation
from the description above, where we always start by running the interpreter
at the top of the stack and then work our way down, applying every interpreter
in the stack. Instead, we‚Äôre only applying an interpreter when the input
arguments to a primitive bind are boxed in a <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> corresponding to that
interpreter. This optimization lets us skip irrelevant transformations, but
bakes in an assumption that transformations mostly follow data dependence
(except for the special bottom-of-the-stack interpreter, which interprets
everything).</p>
<p>An alternative would be to have every interpreter in the stack interpret every
operation. That‚Äôs worth exploring! JAX is designed around data dependence in
large part because that‚Äôs so natural for automatic differentiation, and JAX‚Äôs
roots are in autodiff. But it may be over-fit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">full_lower</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">def</span> <span class="nf">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">:</span> <span class="n">Trace</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tracer</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">pure</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">level</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span>
  <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="ow">is</span> <span class="n">trace</span><span class="o">.</span><span class="n">main</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>
  <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Can't lift level </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>  <span class="c1"># val._trace.level == level</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Different traces at same level: </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">trace</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The logic in <code class="docutils literal notranslate"><span class="pre">full_raise</span></code> serves to box values into <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s for a particular
<code class="docutils literal notranslate"><span class="pre">Trace</span></code>, calling different methods on the <code class="docutils literal notranslate"><span class="pre">Trace</span></code> based on context:
<code class="docutils literal notranslate"><span class="pre">Trace.pure</span></code> is called on non-<code class="docutils literal notranslate"><span class="pre">Tracer</span></code> constants, and <code class="docutils literal notranslate"><span class="pre">Trace.lift</span></code> is called
for values that are already <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>s from a lower-level interpreter. These
two methods could share the same implementation, but by distinguishing them in
the core logic we can provide more information to the <code class="docutils literal notranslate"><span class="pre">Trace</span></code> subclass.</p>
<p>That‚Äôs it for the JAX core! Now we can start adding interpreters.</p>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Evaluation interpreter"></a><section id="evaluation-interpreter">
<h3>Evaluation interpreter<a class="headerlink" href="#evaluation-interpreter" title="Permalink to this headline">#</a></h3>
<p>We‚Äôll start with the simplest interpreter: the evaluation interpreter that
will sit at the bottom of the interpreter stack.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>  <span class="c1"># no boxing in Tracers needed</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">impl_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="n">trace_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># special bottom of the stack</span>

<span class="c1"># NB: in JAX, instead of a dict we attach impl rules to the Primitive instance</span>
<span class="n">impl_rules</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">impl_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">transpose_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">perm</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">broadcast_impl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">)]</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_impl</span>
</pre></div>
</div>
</div>
</div>
<p>With this interpreter, we can evaluate user functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
</pre></div>
</div>
</div>
</div>
<p>Woo! Like going around in a big circle. But the point of this indirection is
that now we can add some real transformations.</p>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Forward-mode autodiff with jvp"></a><section id="forward-mode-autodiff-with-jvp">
<h3>Forward-mode autodiff with <code class="docutils literal notranslate"><span class="pre">jvp</span></code><a class="headerlink" href="#forward-mode-autodiff-with-jvp" title="Permalink to this headline">#</a></h3>
<p>First, a few helper functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unzip2</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
  <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
    <span class="n">lst1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">lst2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span>

<span class="n">map_</span> <span class="o">=</span> <span class="nb">map</span>
<span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">map_</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">))</span>

<span class="n">zip_</span> <span class="o">=</span> <span class="nb">zip</span>
<span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">fst</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">zip_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> for forward-mode autodiff carries a primal-tangent pair. The
<code class="docutils literal notranslate"><span class="pre">Trace</span></code> applies JVP rules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JVPTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">primal</span><span class="p">,</span> <span class="n">tangent</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">primal</span> <span class="o">=</span> <span class="n">primal</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primal</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">JVPTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">JVPTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">primals_in</span><span class="p">,</span> <span class="n">tangents_in</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tangent</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">)</span>
    <span class="n">jvp_rule</span> <span class="o">=</span> <span class="n">jvp_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">primal_outs</span><span class="p">,</span> <span class="n">tangent_outs</span> <span class="o">=</span> <span class="n">jvp_rule</span><span class="p">(</span><span class="n">primals_in</span><span class="p">,</span> <span class="n">tangents_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primal_outs</span><span class="p">,</span> <span class="n">tangent_outs</span><span class="p">)]</span>

<span class="n">jvp_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice both <code class="docutils literal notranslate"><span class="pre">pure</span></code> and <code class="docutils literal notranslate"><span class="pre">lift</span></code> package a value into a <code class="docutils literal notranslate"><span class="pre">JVPTracer</span></code> with the
minimal amount of context, which is a zero tangent value.</p>
<p>Let‚Äôs add some JVP rules for primitives:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x_dot</span> <span class="o">+</span> <span class="n">y_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_jvp</span>

<span class="k">def</span> <span class="nf">mul_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x_dot</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul_jvp</span>

<span class="k">def</span> <span class="nf">sin_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_jvp</span>

<span class="k">def</span> <span class="nf">cos_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_dot</span><span class="p">]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_jvp</span>

<span class="k">def</span> <span class="nf">neg_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">x_dot</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_jvp</span>

<span class="k">def</span> <span class="nf">reduce_sum_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)],</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x_dot</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_jvp</span>

<span class="k">def</span> <span class="nf">greater_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="n">out_primal</span> <span class="o">=</span> <span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">out_primal</span><span class="p">],</span> <span class="p">[</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">out_primal</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">greater_jvp</span>

<span class="k">def</span> <span class="nf">less_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="n">out_primal</span> <span class="o">=</span> <span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">out_primal</span><span class="p">],</span> <span class="p">[</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">out_primal</span><span class="p">)]</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">less_jvp</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we add a transformation API to kick off the trace:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JVPTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JVPTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracer_out</span> <span class="o">=</span> <span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span> <span class="o">=</span> <span class="n">tracer_out</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">tracer_out</span><span class="o">.</span><span class="n">tangent</span>
  <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span>
</pre></div>
</div>
</div>
</div>
<p>And with that, we can differentiate!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">y</span><span class="p">,</span> <span class="n">sin_deriv_at_3</span> <span class="o">=</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sin_deriv_at_3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.9899924966004454
-0.9899924966004454
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jvp_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">sin</span><span class="p">))))(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.9899924966004454
-0.1411200080598672
0.9899924966004454
0.1411200080598672
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c1"># Python control flow</span>
    <span class="k">return</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="o">-</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
1.0
</pre></div>
</div>
</div>
</div>
</section>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Pytrees and flattening user functions' inputs and outputs"></a><section id="pytrees-and-flattening-user-functions-inputs-and-outputs">
<h2>Pytrees and flattening user functions‚Äô inputs and outputs<a class="headerlink" href="#pytrees-and-flattening-user-functions-inputs-and-outputs" title="Permalink to this headline">#</a></h2>
<p>A limitation with <code class="docutils literal notranslate"><span class="pre">jvp_v1</span></code> is that it assumes the user function accepts arrays
as positional arguments and produces a single array as output. What if it
produced a list as output? Or accepted nested containers as inputs? It would
be a pain to deal with all the possible containers in inputs and outputs at
every layer of the stack. Instead, we can wrap the user function so that the
wrapped version accepts arrays as inputs and returns a flat list of arrays as
output. The wrapper just needs to unflatten its input, call the user function,
and flatten the output.</p>
<p>Here‚Äôs how we‚Äôd like to write <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, assuming the user always gives us
functions that take arrays as inputs and produces a flat list of arrays as
outputs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JVPTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JVPTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">JVPTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tangent</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
</pre></div>
</div>
</div>
</div>
<p>To support user functions that have arbitrary containers in the inputs and
outputs, here‚Äôs how we‚Äôd write the user-facing <code class="docutils literal notranslate"><span class="pre">jvp</span></code> wrapper:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">primals_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span>
  <span class="n">tangents_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">tangents</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">tangents_out_flat</span> <span class="o">=</span> <span class="n">jvp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">primals_flat</span><span class="p">,</span> <span class="n">tangents_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>
  <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">tangents_out_flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we had to plumb the tree structure of the user function output
back to the caller of <code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code>. That information isn‚Äôt available until we
actually run the user function, so <code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code> just returns a reference to a
mutable cell, represented as a thunk. These side-effects are safe because we
always run the user function exactly once. (This safe regime is the reason for
the ‚Äúlinear‚Äù name in <code class="docutils literal notranslate"><span class="pre">linear_util.py</span></code>, in the sense of <a class="reference external" href="https://en.wikipedia.org/wiki/Substructural_type_system">linear
types</a>.)</p>
<p>All that remains is to write <code class="docutils literal notranslate"><span class="pre">tree_flatten</span></code>, <code class="docutils literal notranslate"><span class="pre">tree_unflatten</span></code>, and
<code class="docutils literal notranslate"><span class="pre">flatten_fun</span></code>.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">):</span>
  <span class="n">store</span> <span class="o">=</span> <span class="n">Store</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">flat_fun</span><span class="p">(</span><span class="o">*</span><span class="n">args_flat</span><span class="p">):</span>
    <span class="n">pytree_args</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">args_flat</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">pytree_args</span><span class="p">)</span>
    <span class="n">out_flat</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">out_tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_flat</span>

  <span class="k">return</span> <span class="n">flat_fun</span><span class="p">,</span> <span class="n">store</span>

<span class="k">class</span> <span class="nc">Empty</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Store</span><span class="p">:</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">empty</span>

  <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">empty</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">NodeType</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
  <span class="n">to_iterable</span><span class="p">:</span> <span class="n">Callable</span>
  <span class="n">from_iterable</span><span class="p">:</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">register_pytree_node</span><span class="p">(</span><span class="n">ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">to_iter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">:</span> <span class="n">Callable</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="n">node_types</span><span class="p">[</span><span class="n">ty</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ty</span><span class="p">),</span> <span class="n">to_iter</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">)</span>

<span class="n">node_types</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">NodeType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span>  <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span>  <span class="nb">list</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">register_pytree_node</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span>
                     <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">unzip2</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))),</span>
                     <span class="k">lambda</span> <span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">)))</span>

<span class="k">class</span> <span class="nc">PyTreeDef</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">node_type</span><span class="p">:</span> <span class="n">NodeType</span>
  <span class="n">node_metadata</span><span class="p">:</span> <span class="n">Hashable</span>
  <span class="n">child_treedefs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">'PyTreeDef'</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">leaf</span> <span class="o">=</span> <span class="n">Leaf</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">children_iter</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">_tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_iter</span><span class="p">),</span> <span class="n">treedef</span>

<span class="k">def</span> <span class="nf">_tree_flatten</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">node_type</span> <span class="o">=</span> <span class="n">node_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">node_type</span><span class="p">:</span>
    <span class="n">node_metadata</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">node_type</span><span class="o">.</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">children_flat</span><span class="p">,</span> <span class="n">child_trees</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_tree_flatten</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">children_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flattened</span><span class="p">,</span> <span class="n">PyTreeDef</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">node_metadata</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child_trees</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">leaf</span>

<span class="k">def</span> <span class="nf">tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">:</span> <span class="n">PyTreeDef</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">_tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_tree_unflatten</span><span class="p">(</span><span class="n">treedef</span><span class="p">:</span> <span class="n">PyTreeDef</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">treedef</span> <span class="ow">is</span> <span class="n">leaf</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">_tree_unflatten</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">treedef</span><span class="o">.</span><span class="n">child_treedefs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">treedef</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">treedef</span><span class="o">.</span><span class="n">node_metadata</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>With this pytree-handling <code class="docutils literal notranslate"><span class="pre">jvp</span></code> implementation, we can now handle arbitrary
input and output containers. That‚Äôll come in handy with future transformations
too!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="p">{</span><span class="s1">'hi'</span><span class="p">:</span> <span class="n">z</span><span class="p">,</span> <span class="s1">'there'</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]}</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{'hi': 2.7177599838802657, 'there': [3.0, 0.2822400161197344]}
{'hi': 2.979984993200891, 'there': [1.0, -1.9799849932008908]}
</pre></div>
</div>
</div>
</div>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Vectorized batching with vmap"></a><section id="vectorized-batching-with-vmap">
<h3>Vectorized batching with <code class="docutils literal notranslate"><span class="pre">vmap</span></code><a class="headerlink" href="#vectorized-batching-with-vmap" title="Permalink to this headline">#</a></h3>
<p>First, a couple helper functions, one for producing mapped abstract values
from unmapped ones (by removing an axis), and one for moving batch dimensions
around:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mapped_aval</span><span class="p">(</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">shape</span><span class="p">[</span><span class="n">batch_dim</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
    <span class="n">target_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">target_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">,</span> <span class="p">[</span><span class="n">dst</span><span class="p">])</span>
  <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">src</span><span class="p">]</span>
  <span class="n">perm</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> for vectorized batching carries a batched value and an optional
integer indicating which axis (if any) is the batch axis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">class</span> <span class="nc">NotMapped</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">not_mapped</span> <span class="o">=</span> <span class="n">NotMapped</span><span class="p">()</span>

<span class="n">BatchAxis</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">NotMapped</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">BatchTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">batch_dim</span><span class="p">:</span> <span class="n">BatchAxis</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="o">=</span> <span class="n">batch_dim</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">mapped_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">get_aval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">BatchTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">BatchTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">not_mapped</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">vals_in</span><span class="p">,</span> <span class="n">bdims_in</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">)</span>
    <span class="n">vmap_rule</span> <span class="o">=</span> <span class="n">vmap_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">val_outs</span><span class="p">,</span> <span class="n">bdim_outs</span> <span class="o">=</span> <span class="n">vmap_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">BatchTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">val_outs</span><span class="p">,</span> <span class="n">bdim_outs</span><span class="p">)]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">axis_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">global_data</span>

<span class="n">vmap_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Here we‚Äôve implemented the optional <code class="docutils literal notranslate"><span class="pre">Tracer.full_lower</span></code> method, which lets us
peel off a batching tracer if it‚Äôs not needed because it doesn‚Äôt represent a
batched value.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">BatchTrace</span></code>, analogous to <code class="docutils literal notranslate"><span class="pre">JVPTrace</span></code>, the methods <code class="docutils literal notranslate"><span class="pre">pure</span></code> and <code class="docutils literal notranslate"><span class="pre">lift</span></code> just
box a value in a <code class="docutils literal notranslate"><span class="pre">BatchTracer</span></code> with the minimal amount of context, which in
this case is a <code class="docutils literal notranslate"><span class="pre">batch_dim</span></code> taking the sentinel value <code class="docutils literal notranslate"><span class="pre">not_mapped</span></code>. Notice we
use the <code class="docutils literal notranslate"><span class="pre">MainTrace</span></code>‚Äôs interpreter-global data field to store the batch axis
size.</p>
<p>Next we can define batching interpreter rules for each primitive:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">binop_batching_rule</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="k">if</span> <span class="n">x_bdim</span> <span class="o">!=</span> <span class="n">y_bdim</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x_bdim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
      <span class="n">x_bdim</span> <span class="o">=</span> <span class="n">y_bdim</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">y_bdim</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)],</span> <span class="p">[</span><span class="n">x_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">binop_batching_rule</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">binop_batching_rule</span><span class="p">,</span> <span class="n">mul</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vectorized_unop_batching_rule</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">x_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">sin</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">cos</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vectorized_unop_batching_rule</span><span class="p">,</span> <span class="n">neg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reduce_sum_batching_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_bdim</span><span class="p">,)</span> <span class="o">=</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span>
  <span class="n">new_axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_bdim</span> <span class="o">&lt;=</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
  <span class="n">out_bdim</span> <span class="o">=</span> <span class="n">x_bdim</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ax</span> <span class="o">&lt;</span> <span class="n">x_bdim</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_axis</span><span class="p">)],</span> <span class="p">[</span><span class="n">out_bdim</span><span class="p">]</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_batching_rule</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we add a transformation API to kick off the trace:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vmap_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">axis_size</span><span class="p">,</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">not_mapped</span><span class="p">}</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">BatchTrace</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">BatchTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">BatchTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
                  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">vals_out</span><span class="p">,</span> <span class="n">bdims_out</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">batch_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="n">outs_transposed</span> <span class="o">=</span> <span class="p">[</span><span class="n">move_batch_axis</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val_out</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">val_out</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals_out</span><span class="p">,</span> <span class="n">bdims_out</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">outs_transposed</span>

<span class="k">def</span> <span class="nf">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">batched_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">in_axes_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">in_axes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">f_flat</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
    <span class="n">outs_flat</span> <span class="o">=</span> <span class="n">vmap_flat</span><span class="p">(</span><span class="n">f_flat</span><span class="p">,</span> <span class="n">in_axes_flat</span><span class="p">,</span> <span class="o">*</span><span class="n">args_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">outs_flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">batched_f</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_one_to_a_scalar</span><span class="p">(</span><span class="n">scalar</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">scalar</span>

<span class="n">vector_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">vector_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">add_one_to_a_scalar</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">vector_in</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">vector_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vector_out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0. 1. 2.]
[1. 2. 3.]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jacfwd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">pushfwd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">v</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">vecs_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">vmap</span><span class="p">(</span><span class="n">pushfwd</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">vecs_in</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">jacfwd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 1.        ,  0.        , -0.        ],
       [ 0.        ,  0.54030231, -0.        ],
       [ 0.        ,  0.        , -0.41614684]])
</pre></div>
</div>
</div>
</div>
<p>That‚Äôs it for <code class="docutils literal notranslate"><span class="pre">jvp</span></code> and <code class="docutils literal notranslate"><span class="pre">vmap</span></code>!</p>
</section>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Part 2: Jaxprs"></a><section id="part-2-jaxprs">
<h2>Part 2: Jaxprs<a class="headerlink" href="#part-2-jaxprs" title="Permalink to this headline">#</a></h2>
<p>The next transformations on the horizon are <code class="docutils literal notranslate"><span class="pre">jit</span></code> for just-in-time
compilation and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> for reverse-mode autodiff.  (<code class="docutils literal notranslate"><span class="pre">grad</span></code> is just a small
wrapper around <code class="docutils literal notranslate"><span class="pre">vjp</span></code>.) Whereas <code class="docutils literal notranslate"><span class="pre">jvp</span></code> and <code class="docutils literal notranslate"><span class="pre">vmap</span></code> only needed each <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> to
carry a little bit of extra context, for both <code class="docutils literal notranslate"><span class="pre">jit</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> we need much
richer context: we need to represent <em>programs</em>. That is, we need jaxprs!</p>
<p>Jaxprs are JAX‚Äôs internal intermediate representation of programs. They are
explicitly typed, functional, first-order, and in ANF form. We need a
program representation for <code class="docutils literal notranslate"><span class="pre">jit</span></code> because the purpose of <code class="docutils literal notranslate"><span class="pre">jit</span></code> is to stage
computation out of Python. For any computation we want to stage out, we need
to be able to represent it as data, and build it up as we trace a Python
function. Similarly, <code class="docutils literal notranslate"><span class="pre">vjp</span></code> needs a way to represent the computation for the
backward pass of reverse-mode autodiff. We use the same jaxpr program
representation for both needs.</p>
<p>(Building a program representation is the most
<a class="reference external" href="https://en.wikipedia.org/wiki/Free_object">free</a> kind of
trace-transformation, and so except for issues around handling native Python
control flow, any transformation could be implemented by first tracing to a
jaxpr and then interpreting the jaxpr.)</p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Jaxpr data structures"></a><section id="jaxpr-data-structures">
<h3>Jaxpr data structures<a class="headerlink" href="#jaxpr-data-structures" title="Permalink to this headline">#</a></h3>
<p>The jaxpr term syntax is roughly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">{</span> <span class="k">lambda</span> <span class="o">&lt;</span><span class="n">binder</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="o">.</span>
    <span class="n">let</span> <span class="o">&lt;</span><span class="n">eqn</span><span class="o">&gt;</span>
        <span class="o">...</span>
    <span class="ow">in</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">atom</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">)</span> <span class="p">}</span>

<span class="n">binder</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="p">:</span><span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span>
<span class="n">var</span> <span class="p">:</span><span class="o">:=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span> <span class="o">|</span> <span class="o">...</span>
<span class="n">atom</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">literal</span><span class="o">&gt;</span>
<span class="n">literal</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">float32</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">float64</span><span class="o">&gt;</span>

<span class="n">eqn</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">binder</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">primitive</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">params</span><span class="o">&gt;</span> <span class="p">]</span> <span class="o">&lt;</span><span class="n">atom</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>The syntax of types is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr_type</span> <span class="p">:</span><span class="o">:=</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">array_type</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
<span class="n">array_type</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">dtype</span><span class="o">&gt;</span><span class="p">[</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">&gt;</span><span class="p">]</span>
<span class="n">dtype</span> <span class="p">:</span><span class="o">:=</span> <span class="n">f32</span> <span class="o">|</span> <span class="n">f64</span> <span class="o">|</span> <span class="n">i32</span> <span class="o">|</span> <span class="n">i64</span>
<span class="n">shape</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>How do we represent these as Python data structures? We reuse ShapedArrays to
represent types, and we can represent the term syntax with a few Python
structs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Set</span>

<span class="k">class</span> <span class="nc">Var</span><span class="p">:</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>

<span class="k">class</span> <span class="nc">Lit</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="n">Atom</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Lit</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">JaxprEqn</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">out_binders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Jaxpr</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">in_binders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">outs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">is_</span>

<span class="k">def</span> <span class="nf">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Type-checking a jaxpr involves checking that there are no unbound variables,
that variables are only bound once, and that for each equation the type of
the primitive application matches the type of the output binders.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JaxprType</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">in_types</span><span class="p">:</span>  <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>
  <span class="n">out_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">in_types</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_types</span><span class="p">)</span>
    <span class="n">out_types</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_types</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">'(</span><span class="si">{</span><span class="n">in_types</span><span class="si">}</span><span class="s1">) -&gt; (</span><span class="si">{</span><span class="n">out_types</span><span class="si">}</span><span class="s1">)'</span>

<span class="k">def</span> <span class="nf">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprType</span><span class="p">:</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
    <span class="n">out_types</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">out_binder</span><span class="p">,</span> <span class="n">out_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">out_types</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">out_type</span> <span class="o">==</span> <span class="n">out_binder</span><span class="o">.</span><span class="n">aval</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">for</span> <span class="n">out_binder</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">out_binder</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
      <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">out_binder</span><span class="p">)</span>

  <span class="n">in_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">]</span>
  <span class="n">out_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">JaxprType</span><span class="p">(</span><span class="n">in_types</span><span class="p">,</span> <span class="n">out_types</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">typecheck_atom</span><span class="p">(</span><span class="n">env</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"unbound variable"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Lit</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>We can apply the function represented by a jaxpr to arguments with a simple
interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span>  <span class="c1"># single-assignment</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_vals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="o">*</span><span class="n">in_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By using <code class="docutils literal notranslate"><span class="pre">bind</span></code> in the interpreter, this interpreter itself is traceable.</p>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Building jaxprs with tracing"></a><section id="building-jaxprs-with-tracing">
<h3>Building jaxprs with tracing<a class="headerlink" href="#building-jaxprs-with-tracing" title="Permalink to this headline">#</a></h3>
<p>Now that we have jaxprs as a data structure, we need ways to produce these
from tracing Python code. In general there are two variants of how we trace to
a jaxpr; <code class="docutils literal notranslate"><span class="pre">jit</span></code> uses one and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> uses the other. We‚Äôll start with the one
used by <code class="docutils literal notranslate"><span class="pre">jit</span></code>, which is also used by control flow primitives like <code class="docutils literal notranslate"><span class="pre">lax.cond</span></code>,
<code class="docutils literal notranslate"><span class="pre">lax.while_loop</span></code>, and <code class="docutils literal notranslate"><span class="pre">lax.scan</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_list</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">partition_list</span><span class="p">(</span><span class="n">bs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
  <span class="n">lists</span> <span class="o">=</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">lists</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NB: the analogous class in JAX is called 'DynamicJaxprTracer'</span>
<span class="k">class</span> <span class="nc">JaxprTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'aval'</span><span class="p">]</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>

<span class="c1"># NB: the analogous class in JAX is called 'DynamicJaxprTrace'</span>
<span class="k">class</span> <span class="nc">JaxprTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">new_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>

  <span class="k">def</span> <span class="nf">get_or_make_const_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">const_tracers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tracer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">tracer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_const</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">=</span> <span class="n">get_or_make_const_tracer</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">avals_out</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">avals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">out_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">avals_out</span><span class="p">]</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">getvar</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_tracers</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">add_eqn</span><span class="p">(</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">outvars</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out_tracers</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">global_data</span>

<span class="c1"># NB: in JAX, we instead attach abstract eval rules to Primitive instances</span>
<span class="n">abstract_eval_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we keep as interpreter-global data a builder object, which keeps
track of variables, constants, and eqns as we build up the jaxpr.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">JaxprBuilder</span><span class="p">:</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">tracer_to_var</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span>
  <span class="n">const_tracers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">JaxprTracer</span><span class="p">]</span>
  <span class="n">constvals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">tracers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">const_tracers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constvals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">new_tracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprTracer</span><span class="p">:</span>
    <span class="n">tracer</span> <span class="o">=</span> <span class="n">JaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tracer</span>

  <span class="k">def</span> <span class="nf">add_eqn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">add_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">getvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">tracer</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">add_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">JaxprTracer</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">const_tracers</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tracer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constvals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">var</span>

  <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_tracers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">],</span> <span class="n">out_tracers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprTracer</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
    <span class="n">constvars</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constvals</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">t2v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
    <span class="n">in_binders</span> <span class="o">=</span> <span class="n">constvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">t2v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">in_tracers</span><span class="p">]</span>
    <span class="n">out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">t2v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_tracers</span><span class="p">]</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">in_binders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">out_vars</span><span class="p">)</span>
    <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">_inline_literals</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_inline_literals</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">const_binders</span><span class="p">,</span> <span class="n">other_binders</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">))</span>
  <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jax_types</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">]</span>
  <span class="n">new_const_binders</span><span class="p">,</span> <span class="n">lit_binders</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">const_binders</span><span class="p">)</span>
  <span class="n">new_consts</span><span class="p">,</span> <span class="n">lit_vals</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="n">literals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lit_binders</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">Lit</span><span class="p">,</span> <span class="n">lit_vals</span><span class="p">)))</span>
  <span class="n">new_eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="p">[</span><span class="n">literals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
                       <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">]</span>
  <span class="n">new_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">literals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">new_const_binders</span> <span class="o">+</span> <span class="n">other_binders</span><span class="p">,</span> <span class="n">new_eqns</span><span class="p">,</span> <span class="n">new_outs</span><span class="p">)</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">new_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>
</pre></div>
</div>
</div>
</div>
<p>The rules we need for <code class="docutils literal notranslate"><span class="pre">JaxprTrace.process_primitive</span></code> are essentially typing
rules for primitive applications: given the primitive, its parameters, and
types for the inputs, the rule must produce a type for the output, which is
then packaged with the output <code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code>. We can use abstract evaluation
rules for this same purpose, even though they can be more general (since
abstract evaluation rules must accept ConcreteArray inputs, and since they
need only return an upper bound on the set of possible outputs, they can
produce ConcreteArray outputs as well). We‚Äôll reuse these abstract evaluation
rules for the other jaxpr-producing trace machinery, where the potential extra
generality is useful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binop_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>

<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">binop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">binop_abstract_eval</span>

<span class="k">def</span> <span class="nf">compare_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">))]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">compare_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">compare_abstract_eval</span>

<span class="k">def</span> <span class="nf">vectorized_unop_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>

<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorized_unop_abstract_eval</span>

<span class="k">def</span> <span class="nf">reduce_sum_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="n">axis_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axis_</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_abstract_eval</span>

<span class="k">def</span> <span class="nf">broadcast_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                            <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_abstract_eval</span>
</pre></div>
</div>
</div>
</div>
<p>To check our implementation of jaxprs, we can add a <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code>
transformation and a pretty-printer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="nd">@lru_cache</span><span class="p">()</span>  <span class="c1"># ShapedArrays are hashable</span>
<span class="k">def</span> <span class="nf">make_jaxpr_v1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">):</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>

  <span class="n">builder</span> <span class="o">=</span> <span class="n">JaxprBuilder</span><span class="p">()</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">JaxprTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_in</span><span class="p">]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">DefaultDict</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">string</span>

<span class="k">class</span> <span class="nc">PPrint</span><span class="p">:</span>
  <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span>

  <span class="k">def</span> <span class="nf">indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'PPrint'</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">([(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">orig_indent</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">orig_indent</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">])</span>

  <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="s1">'PPrint'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'PPrint'</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="s1">'PPrint'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'PPrint'</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span> <span class="k">return</span> <span class="n">rhs</span>
    <span class="n">indent</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">indented_block</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">common_line</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">*</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">PPrint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                  <span class="o">+</span> <span class="p">[(</span><span class="n">indent</span><span class="p">,</span> <span class="n">common_line</span><span class="p">)]</span>
                  <span class="o">+</span> <span class="n">indented_block</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">' '</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">indent</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">PPrint</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()])</span>

<span class="k">def</span> <span class="nf">vcat</span><span class="p">(</span><span class="n">ps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PPrint</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">pp</span><span class="p">(</span><span class="s1">''</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">namegen</span> <span class="o">=</span> <span class="p">(</span><span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
  <span class="n">names</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">namegen</span><span class="p">))</span>
  <span class="n">in_binders</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">([</span><span class="n">pp_eqn</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">])</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="se">{{</span><span class="s1"> lambda </span><span class="si">{</span><span class="n">in_binders</span><span class="si">}</span><span class="s1"> .'</span><span class="p">)</span> <span class="o">+</span>
          <span class="p">((</span><span class="n">pp</span><span class="p">(</span><span class="s1">'let '</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">eqns</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">'in ( </span><span class="si">{</span><span class="n">outs</span><span class="si">}</span><span class="s1"> ) </span><span class="se">}}</span><span class="s1">'</span><span class="p">))</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s1">'</span>

<span class="k">def</span> <span class="nf">pp_eqn</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">rule</span> <span class="o">=</span> <span class="n">pp_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rule</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">rule</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">eqn</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
           <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' = '</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">pp_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
  <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' [ '</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">vcat</span><span class="p">([</span><span class="n">pp</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' ] '</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>

<span class="n">Jaxpr</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
<span class="n">pp_rules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">PPrint</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr_v1</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="mf">3.</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda a:float64[] .
  let b:float64[] = mul 2.0 a
  in ( b ) }
(float64[]) -&gt; (float64[])
</pre></div>
</div>
</div>
</div>
<p>But there‚Äôs a limitation here: because of how <code class="docutils literal notranslate"><span class="pre">find_top_trace</span></code> operates by
data dependence, <code class="docutils literal notranslate"><span class="pre">make_jaxpr_v1</span></code> can‚Äôt stage out all the primitive operations
performed by the Python callable it‚Äôs given. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr_v1</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda  .
  let 
  in ( 4.0 ) }
</pre></div>
</div>
</div>
</div>
<p>This is precisely the issue that
<a class="reference external" href="https://github.com/google/jax/pull/3370">omnistaging</a> fixed.
We want to ensure that the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> started by <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> is always
applied, regardless of whether any inputs to <code class="docutils literal notranslate"><span class="pre">bind</span></code> are boxed in corresponding
<code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code> instances. We can achieve this by employing the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code>
global defined in Part 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_dynamic</span><span class="p">(</span><span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">dynamic_trace</span>
  <span class="n">prev_dynamic_trace</span><span class="p">,</span> <span class="n">dynamic_trace</span> <span class="o">=</span> <span class="n">dynamic_trace</span><span class="p">,</span> <span class="n">main</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">dynamic_trace</span> <span class="o">=</span> <span class="n">prev_dynamic_trace</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_jaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">PyTreeDef</span><span class="p">]:</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>

  <span class="n">builder</span> <span class="o">=</span> <span class="n">JaxprBuilder</span><span class="p">()</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">JaxprTrace</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">new_dynamic</span><span class="p">(</span><span class="n">main</span><span class="p">):</span>
      <span class="n">trace</span> <span class="o">=</span> <span class="n">JaxprTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
      <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_in</span><span class="p">]</span>
      <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
      <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
      <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">()</span>

<span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{ lambda  .
  let a:float64[] = mul 2.0 2.0
  in ( a ) }
</pre></div>
</div>
</div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> this way is conceptually the same as stashing the
current interpreter stack and starting a new one with the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> at the
bottom. That is, no interpreters lower in the stack than the <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code>
are applied (since <code class="docutils literal notranslate"><span class="pre">JaxprTrace.process_primitive</span></code> doesn‚Äôt call <code class="docutils literal notranslate"><span class="pre">bind</span></code>), though
if the Python callable being traced to a jaxpr itself uses transformations
then those can be pushed onto the interpreter stack above the <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code>.
But temporarily stashing the interpreter stack would break up the system
state. The <code class="docutils literal notranslate"><span class="pre">dynamic_trace</span></code> tag achieves the same goals while keeping the
system state simpler.</p>
<p>That‚Äôs it for jaxprs! With jaxprs in hand, we can implement the remaining
major JAX features.</p>
</section>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Part 3: jit, simplified"></a><section id="part-3-jit-simplified">
<h2>Part 3: <code class="docutils literal notranslate"><span class="pre">jit</span></code>, simplified<a class="headerlink" href="#part-3-jit-simplified" title="Permalink to this headline">#</a></h2>
<p>While <code class="docutils literal notranslate"><span class="pre">jit</span></code> has a transformation-like API in that it accepts a Python callable
as an argument, under the hood it‚Äôs really a higher-order primitive rather
than a transformation. A primitive is <em>higher-order</em> when it‚Äôs parameterized
by a function.</p>
<a class="dashAnchor" name='//apple_ref/cpp/Section/On-the-fly ("final style") and staged ("initial style") processing'></a><section id="on-the-fly-final-style-and-staged-initial-style-processing">
<h3>On-the-fly (‚Äúfinal style‚Äù) and staged (‚Äúinitial style‚Äù) processing<a class="headerlink" href="#on-the-fly-final-style-and-staged-initial-style-processing" title="Permalink to this headline">#</a></h3>
<p>There are two options for how to handle higher-order primitives. Each requires
a different approach to tracing and engenders different tradeoffs:</p>
<ol class="arabic simple">
<li><p><strong>On-the-fly processing, where <code class="docutils literal notranslate"><span class="pre">bind</span></code> takes a Python callable as an
argument.</strong> We defer forming a jaxpr until as late as possible, namely
until we‚Äôre running the final interpreter at the bottom of the interpreter
stack. That way we can swap a <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> in at the bottom of the
interpreter stack and thus stage out rather than execute all primitive
operations. With this approach, transformations in the stack get applied as
we execute the Python callable as usual. This approach can be very tricky
to implement, but it‚Äôs as general as possible because it allows
higher-order primitives not to raise the abstraction level of their
arguments and thus allows data-dependent Python control flow. We refer to
this approach as using a ‚Äúfinal-style higher-order primitive‚Äù employing the
discharge-at-tracing-time ‚Äúfinal-style transformations‚Äù we‚Äôve used so far.</p></li>
<li><p><strong>Staged processing, where <code class="docutils literal notranslate"><span class="pre">bind</span></code> takes a jaxpr as an argument.</strong> Before we
call <code class="docutils literal notranslate"><span class="pre">bind</span></code>, in the primitive wrapper we can just use <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> to form
a jaxpr up-front and be done with the Python callable entirely. In this
case, <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> puts its <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code> at the top of the interpreter
stack, and no transformations lower in the stack, which might enter via
closed-over Tracers, are applied to the Python callable as we trace it.
(Transformations applied within the Python callable are applied as usual,
being added to the stack above the JaxprTrace.) Instead, the
transformations lower in the stack are later applied to the call primitive,
and the call primitive‚Äôs rules must then transform the jaxpr itself.
Because we trace to a jaxpr up-front, this approach can‚Äôt support
data-dependent Python control flow, but it is more straightforward to
implement. We refer to this kind of higher-order primitive as an
‚Äúinitial-style higher-order primitive‚Äù, and say that its jaxpr-processing
transformation rules are ‚Äúinitial-style transformation rules.‚Äù</p></li>
</ol>
<p>The latter approach fits for <code class="docutils literal notranslate"><span class="pre">jit</span></code> because we don‚Äôt need to support
data-dependent Python control flow in the user-provided Python callable, as
the whole purpose of <code class="docutils literal notranslate"><span class="pre">jit</span></code> is to stage computation out of Python to be
executed by XLA. (In contrast, <code class="docutils literal notranslate"><span class="pre">custom_jvp</span></code> is a higher-order primitive in
which we want to support data-dependent Python control flow.)</p>
<p>Historically, we started using the ‚Äúinitial-style‚Äù and ‚Äúfinal-style‚Äù
terminology after reading the <a class="reference external" href="http://okmij.org/ftp/tagless-final/index.html">typed tagless final
interpreters</a> paper, and
jokingly referring to JAX as an implementation of ‚Äúuntyped tagful final
interpreters.‚Äù We don‚Äôt claim to carry over (or understand) any deep meaning
behind these terms; we loosely use ‚Äúinitial style‚Äù to mean ‚Äúbuild an AST and
then transform it‚Äù, and we use ‚Äúfinal style‚Äù to mean ‚Äútransform as we trace.‚Äù
But it‚Äôs just imprecise yet sticky jargon.</p>
<p>With the initial-style approach, here‚Äôs the user-facing <code class="docutils literal notranslate"><span class="pre">jit</span></code> wrapper:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jit</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">f_jitted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f_jitted</span>

<span class="n">xla_call_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">'xla_call'</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With any new primitive, we need to give it transformation rules, starting with
its evaluation rule. When we evaluate an application of the <code class="docutils literal notranslate"><span class="pre">xla_call</span></code>
primitive, we want to stage out out the computation to XLA. That involves
translating the jaxpr to an XLA HLO program, transferring the argument values
to the XLA device, executing the XLA program, and transferring back the
results. We‚Äôll cache the XLA HLO compilation so that for each <code class="docutils literal notranslate"><span class="pre">jit</span></code>ted
function it only needs to be performed once per argument shape and dtype
signature.</p>
<p>First, some utilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IDHashable</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">IDHashable</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we‚Äôll define the evaluation rule for <code class="docutils literal notranslate"><span class="pre">xla_call</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_bridge</span> <span class="k">as</span> <span class="n">xb</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_client</span> <span class="k">as</span> <span class="n">xc</span>
<span class="n">xe</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">_xla</span>
<span class="n">xops</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">_xla</span><span class="o">.</span><span class="n">ops</span>

<span class="k">def</span> <span class="nf">xla_call_impl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">consts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">num_consts</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">num_consts</span><span class="p">:]</span>
  <span class="n">hashable_consts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">IDHashable</span><span class="p">,</span> <span class="n">consts</span><span class="p">))</span>
  <span class="n">execute</span> <span class="o">=</span> <span class="n">xla_callable</span><span class="p">(</span><span class="n">IDHashable</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="n">hashable_consts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">execute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_impl</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">xla_callable</span><span class="p">(</span><span class="n">hashable_jaxpr</span><span class="p">:</span> <span class="n">IDHashable</span><span class="p">,</span>
                 <span class="n">hashable_consts</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">IDHashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
  <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span> <span class="o">=</span> <span class="n">hashable_jaxpr</span><span class="o">.</span><span class="n">val</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hashable_consts</span><span class="p">]</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">):]]</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">(</span><span class="s1">'xla_call'</span><span class="p">)</span>
  <span class="n">xla_consts</span> <span class="o">=</span> <span class="n">_xla_consts</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="n">xla_params</span> <span class="o">=</span> <span class="n">_xla_params</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">xla_consts</span> <span class="o">+</span> <span class="n">xla_params</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
  <span class="n">compiled</span> <span class="o">=</span> <span class="n">xb</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">execute_compiled</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_xla_consts</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">]:</span>
  <span class="n">unique_consts</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">cnst</span><span class="p">):</span> <span class="n">cnst</span> <span class="k">for</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">}</span>
  <span class="n">xla_consts</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">id_</span><span class="p">:</span> <span class="n">xops</span><span class="o">.</span><span class="n">ConstantLiteral</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnst</span><span class="p">)</span> <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">unique_consts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">xla_consts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">cnst</span><span class="p">)]</span> <span class="k">for</span> <span class="n">cnst</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_xla_params</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">]:</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">xops</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">_xla_shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avals_in</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_xla_shape</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xe</span><span class="o">.</span><span class="n">Shape</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">xc</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">array_shape</span><span class="p">(</span><span class="n">xc</span><span class="o">.</span><span class="n">dtype_to_etype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The main action is in <code class="docutils literal notranslate"><span class="pre">xla_callable</span></code>, which compiles a jaxpr into an XLA HLO
program using <code class="docutils literal notranslate"><span class="pre">jaxpr_subcomp</span></code>, then returns a callable which executes the
compiled program:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">]</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">:</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">xops</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaOp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
    <span class="n">in_vals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">xla_translations</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">,</span> <span class="n">out_vals</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">execute_compiled</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">input_bufs</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_handlers</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)](</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">out_bufs</span> <span class="o">=</span> <span class="n">compiled</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_bufs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span><span class="p">,</span> <span class="n">buf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_avals</span><span class="p">,</span> <span class="n">out_bufs</span><span class="p">)]</span>

<span class="n">default_input_handler</span> <span class="o">=</span> <span class="n">xb</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">buffer_from_pyval</span>
<span class="n">input_handlers</span> <span class="o">=</span> <span class="p">{</span><span class="n">ty</span><span class="p">:</span> <span class="n">default_input_handler</span> <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span>
                  <span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">]}</span>

<span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">aval</span>  <span class="c1"># Unused for now</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

<span class="n">xla_translations</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">jaxpr_subcomp</span></code> has the structure of a simple interpreter. That‚Äôs
a common pattern: the way we process jaxprs is usually with an interpreter.
And as with any interpreter, we need an interpretation rule for each
primitive:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">direct_translation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">in_vals</span><span class="p">)]</span>

<span class="n">xla_translations</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Add</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Mul</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Neg</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">sin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Sin</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">cos_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Cos</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">greater_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Gt</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">less_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">direct_translation</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Lt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reduce_sum_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x_aval</span><span class="p">,),</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">=</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">ConstantLiteral</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">subc</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">(</span><span class="s1">'add'</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">_xla_shape</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">xops</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">subc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span> <span class="n">xops</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">subc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">xops</span><span class="o">.</span><span class="n">Reduce</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">zero</span><span class="p">],</span> <span class="n">subc</span><span class="o">.</span><span class="n">build</span><span class="p">(),</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_translation</span>

<span class="k">def</span> <span class="nf">broadcast_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">in_vals</span>
  <span class="n">dims_complement</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">xops</span><span class="o">.</span><span class="n">BroadcastInDim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dims_complement</span><span class="p">)]</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">broadcast_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_translation</span>
</pre></div>
</div>
</div>
</div>
<p>With that, we can now use <code class="docutils literal notranslate"><span class="pre">jit</span></code> to stage out, compile, and execute programs
with XLA!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">'tracing!'</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">)</span>  <span class="c1"># 'tracing!' prints the first time</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tracing!
-0.09224219304455371
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>  <span class="c1"># 'tracing!' doesn't print, compilation cache hit!</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.21467624978306998
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="k">def</span> <span class="nf">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span>    <span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">deriv</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2822400161197344
0.2822400161197344
</pre></div>
</div>
</div>
</div>
<p>Instead of implementing <code class="docutils literal notranslate"><span class="pre">jit</span></code> to first trace to a jaxpr and then to lower the
jaxpr to XLA HLO, it might appear that we could have skipped the jaxpr step
and just lowered to HLO while tracing. That is, perhaps we could have instead
implemented <code class="docutils literal notranslate"><span class="pre">jit</span></code> with a <code class="docutils literal notranslate"><span class="pre">Trace</span></code> and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> that appended to the XLA HLO
graph incrementally on each primitive bind. That‚Äôs correct for now, but won‚Äôt
be possible when we introduce compiled SPMD computations because there we must
know the number of replicas needed before compiling the program.</p>
<p>We haven‚Äôt yet defined any transformation rules for <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code> other than
its evaluation rule. That is, we can‚Äôt yet do <code class="docutils literal notranslate"><span class="pre">vmap</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code> or
<code class="docutils literal notranslate"><span class="pre">jvp</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code> or even <code class="docutils literal notranslate"><span class="pre">jit</span></code>-of<code class="docutils literal notranslate"><span class="pre">-jit</span></code>. Instead <code class="docutils literal notranslate"><span class="pre">jit</span></code> has to be at the ‚Äútop
level.‚Äù Let‚Äôs fix that!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">new_jaxpr</span><span class="p">,</span>
              <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">outs</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">outs</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_jvp_rule</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">jvp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">def</span> <span class="nf">jvp_traceable</span><span class="p">(</span><span class="o">*</span><span class="n">primals_and_tangents</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">primals_and_tangents</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span> <span class="o">=</span> <span class="n">primals_and_tangents</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">primals_and_tangents</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)</span>

  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">]</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">jvp_traceable</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_vmap_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">new_jaxpr</span><span class="p">,</span>
              <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_vmap_rule</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">vmap_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">BatchAxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">vmap_traceable</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bdims_in</span><span class="p">))</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">bdims_in</span><span class="p">)]</span>
  <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">vmap_traceable</span><span class="p">,</span> <span class="o">*</span><span class="n">in_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span>

<span class="k">def</span> <span class="nf">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_dim</span><span class="p">:</span> <span class="n">BatchAxis</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">batch_dim</span> <span class="ow">is</span> <span class="n">not_mapped</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">batch_dim</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_abstract_eval_rule</span><span class="p">(</span><span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">jaxpr_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="n">in_types</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="n">jaxpr_type</span><span class="o">.</span><span class="n">out_types</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_abstract_eval_rule</span>

<span class="k">def</span> <span class="nf">xla_call_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Only used at top-level.</span>
  <span class="c1"># Calling jaxpr_subcomp directly would inline. We generate a Call HLO instead.</span>
  <span class="n">subc</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">(</span><span class="s1">'inner xla_call'</span><span class="p">)</span>
  <span class="n">xla_params</span> <span class="o">=</span> <span class="n">_xla_params</span><span class="p">(</span><span class="n">subc</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">subc</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">xla_params</span><span class="p">)</span>
  <span class="n">subc</span> <span class="o">=</span> <span class="n">subc</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">subc</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">destructure_tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">subc</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">))</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_translation</span>

<span class="k">def</span> <span class="nf">destructure_tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tup</span><span class="p">):</span>
  <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span><span class="o">.</span><span class="n">tuple_shapes</span><span class="p">())</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">xops</span><span class="o">.</span><span class="n">GetTupleElement</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_elements</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">'tracing!'</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tracing!
2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>  <span class="c1"># 'tracing!' not printed</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ys</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0.         -0.68294197  0.18140515]
</pre></div>
</div>
</div>
</div>
<p>One piece missing is device memory persistence for arrays. That is, we‚Äôve
defined <code class="docutils literal notranslate"><span class="pre">handle_result</span></code> to transfer results back to CPU memory as NumPy
arrays, but it‚Äôs often preferable to avoid transferring results just to
transfer them back for the next operation. We can do that by introducing a
<code class="docutils literal notranslate"><span class="pre">DeviceArray</span></code> class, which can wrap XLA buffers and otherwise duck-type
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>s:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
  <span class="k">return</span> <span class="n">DeviceArray</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DeviceArray</span><span class="p">:</span>
  <span class="n">buf</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span>

  <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">ndim</span>  <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">))</span>
  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buf</span><span class="p">))</span>

  <span class="n">_neg</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
  <span class="n">_add</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_radd</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
  <span class="n">_mul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_rmul</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
  <span class="n">_gt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
  <span class="n">_lt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">less</span><span class="p">)</span>
<span class="n">input_handlers</span><span class="p">[</span><span class="n">DeviceArray</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">buf</span>

<span class="n">jax_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DeviceArray</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">x</span><span class="p">,</span> <span class="n">xdot</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span>
<span class="n">y</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">xdot</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657
2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pprint_xla_call</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
  <span class="n">params_without_jaxpr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">'jaxpr'</span><span class="p">}</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">params_without_jaxpr</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
         <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">vcat</span><span class="p">([</span><span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' = '</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span><span class="p">,</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'jaxpr'</span><span class="p">])</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">pp_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint_xla_call</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Part 4: linearize and vjp (and grad!)"></a><section id="part-4-linearize-and-vjp-and-grad">
<h2>Part 4: <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> (and <code class="docutils literal notranslate"><span class="pre">grad</span></code>!)<a class="headerlink" href="#part-4-linearize-and-vjp-and-grad" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">vjp</span></code> autodiff functions are built on <code class="docutils literal notranslate"><span class="pre">jvp</span></code>, but involve
jaxprs as well. That‚Äôs because both involve staging out, or delaying,
computation.</p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/linearize"></a><section id="linearize">
<h3><code class="docutils literal notranslate"><span class="pre">linearize</span></code><a class="headerlink" href="#linearize" title="Permalink to this headline">#</a></h3>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">linearize</span></code>, we want to stage out the linear part of a <code class="docutils literal notranslate"><span class="pre">jvp</span></code>
computation. That is, in terms of
<a class="reference external" href="https://wiki.haskell.org/Type_signature">Haskell-like type signatures</a>,
if we have <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">T</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">T</span> <span class="pre">b)</span></code>,
then we write <code class="docutils literal notranslate"><span class="pre">linearize</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b)</span></code>, using <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a</span></code> to
mean ‚Äúthe tangent type of <code class="docutils literal notranslate"><span class="pre">a</span></code>‚Äù and using the ‚Äúlollipop‚Äù <code class="docutils literal notranslate"><span class="pre">-o</span></code> rather than the
arrow <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> to indicate a <em>linear</em> function. We define the semantics of
<code class="docutils literal notranslate"><span class="pre">linearize</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">jvp</span></code> too:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="n">x_dot</span><span class="p">)</span>
</pre></div>
</div>
<p>gives the same result for <code class="docutils literal notranslate"><span class="pre">(y,</span> <span class="pre">y_dot)</span></code> as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">x_dot</span><span class="p">,))</span>
</pre></div>
</div>
<p>where the application of <code class="docutils literal notranslate"><span class="pre">f_lin</span></code> does not redo any of the linearization work.
We‚Äôll represent the delayed linear part <code class="docutils literal notranslate"><span class="pre">f_lin</span> <span class="pre">:</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b</span></code> as a jaxpr.</p>
<p>Tangentially, now that we have linear arrows <code class="docutils literal notranslate"><span class="pre">-o</span></code>, we can provide a slightly
more informative type for <code class="docutils literal notranslate"><span class="pre">jvp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jvp</span> <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">UnrestrictedUse</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span><span class="n">o</span> <span class="p">(</span><span class="n">UnrestrictedUse</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we‚Äôre writing <code class="docutils literal notranslate"><span class="pre">UnrestrictedUse</span></code> just to indicate that we have a special
pair where the first element can be used in an unrestricted (nonlinear) way.
In conjunction with the linear arrow, this notation is just meant to express
that the function <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">f</span></code> uses its first input in a nonlinear way but its
second input in a linear way, producing a corresponding nonlinear output
(which can be used in a nonlinear way) paired with a linear output. This more
refined type signature encodes the data dependencies in <code class="docutils literal notranslate"><span class="pre">jvp</span> <span class="pre">f</span></code>, which are
useful for partial evaluation.</p>
<p>To build the <code class="docutils literal notranslate"><span class="pre">f_lin</span></code> jaxpr from a JVP, we need to perform partial evaluation:
we evaluate all the primal values as we trace, but stage the tangent
computations into a jaxpr. This is our second way to build jaxprs. But where
<code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> and its underlying <code class="docutils literal notranslate"><span class="pre">JaxprTrace</span></code>/<code class="docutils literal notranslate"><span class="pre">JaxprTracer</span></code> interpreters aim
to stage out every primitive bind, this second approach stages out only those
primitive binds with a data dependence on tangent inputs.</p>
<p>First, some utilities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_half</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">split_list</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge_lists</span><span class="p">(</span><span class="n">which</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">l1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="nb">next</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span>
  <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">next</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we‚Äôll write <code class="docutils literal notranslate"><span class="pre">linearize</span></code> by combining <code class="docutils literal notranslate"><span class="pre">jvp</span></code> together with a general
partial evaluation transformation, to be added next:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linearize_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">pvals_in</span> <span class="o">=</span> <span class="p">([</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">]</span> <span class="o">+</span>
              <span class="p">[</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">vspace</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">])</span>
  <span class="k">def</span> <span class="nf">f_jvp</span><span class="p">(</span><span class="o">*</span><span class="n">primals_tangents_in</span><span class="p">):</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">split_half</span><span class="p">(</span><span class="n">primals_tangents_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents_out</span><span class="p">]</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">partial_eval_flat</span><span class="p">(</span><span class="n">f_jvp</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">)</span>
  <span class="n">primal_pvals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_out</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">]</span>
  <span class="n">f_lin</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">tangents</span><span class="p">:</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_lin</span>

<span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">primals_in_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">f_lin_flat</span> <span class="o">=</span> <span class="n">linearize_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">f_lin</span><span class="p">(</span><span class="o">*</span><span class="n">tangents_in</span><span class="p">):</span>
    <span class="n">tangents_in_flat</span><span class="p">,</span> <span class="n">in_tree2</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">tangents_in</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_tree</span> <span class="o">!=</span> <span class="n">in_tree2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">tangents_out_flat</span> <span class="o">=</span> <span class="n">f_lin_flat</span><span class="p">(</span><span class="o">*</span><span class="n">tangents_in_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">tangents_out_flat</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_lin</span>

<span class="k">def</span> <span class="nf">vspace</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>  <span class="c1"># TODO handle integers?</span>
</pre></div>
</div>
</div>
</div>
<p>Now we turn to the general partial evaluation transformation. The goal is to
accept a Python callable and a list of inputs, some known and some unknown,
and to produce (1) all the outputs which can be computed from the known
inputs, together with (2) a jaxpr representing the part of the Python
callable‚Äôs computation which can only be performed after the remaining inputs
are known.</p>
<p>This transformation is tricky to summarize in a type signature. If we
assume the input function‚Äôs type signature is <code class="docutils literal notranslate"><span class="pre">(a1,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">(b1,</span> <span class="pre">b2)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">a1</span></code> and <code class="docutils literal notranslate"><span class="pre">a2</span></code> represent the known and unknown inputs, respectively, and where
<code class="docutils literal notranslate"><span class="pre">b1</span></code> only has a data dependency on <code class="docutils literal notranslate"><span class="pre">a1</span></code> while <code class="docutils literal notranslate"><span class="pre">b2</span></code> has some data dependency on
<code class="docutils literal notranslate"><span class="pre">a2</span></code>, then we might write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">partial_eval</span> <span class="p">:</span> <span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">exists</span> <span class="n">r</span><span class="o">.</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b2</span><span class="p">)</span>
</pre></div>
</div>
<p>In words, given values for the inputs of type <code class="docutils literal notranslate"><span class="pre">a1</span></code>, <code class="docutils literal notranslate"><span class="pre">partial_eval</span></code> produces
the outputs of type <code class="docutils literal notranslate"><span class="pre">b1</span></code> along with ‚Äúresidual‚Äù values of
existentially-quantified type <code class="docutils literal notranslate"><span class="pre">r</span></code> representing the intermediates required to
complete the computation in the second stage. It also produces a function of
type <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">b2</span></code> which accepts the residual values as well as the
remaining inputs and produces the remaining outputs.</p>
<p>We like to think of partial evaluation as ‚Äúunzipping‚Äù one computation into
two. For example, consider this jaxpr:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">b</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>A jaxpr for the JVP would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">cos</span> <span class="n">a</span>
      <span class="n">e</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">d</span> <span class="n">b</span>
      <span class="n">f</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">c</span>
      <span class="n">g</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">e</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>If we imagine applying partial evaluation to this jaxpr with the first input
known and the second unknown, we end up ‚Äòunzipping‚Äô the JVP jaxpr into primal
and tangent jaxprs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">c</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">sin</span> <span class="n">a</span>
      <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">cos</span> <span class="n">a</span>
      <span class="n">f</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">c</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">d</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="n">b</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span> <span class="n">e</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">d</span> <span class="n">b</span>
      <span class="n">g</span><span class="p">:</span><span class="n">float64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">neg</span> <span class="n">e</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">g</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>This second jaxpr represents the linear computation that we want from
<code class="docutils literal notranslate"><span class="pre">linearize</span></code>.</p>
<p>However, unlike in this jaxpr example, we want the computation on known values
to occur while evaluating the input Python callable. That is, rather than
forming a jaxpr for the entire function <code class="docutils literal notranslate"><span class="pre">(a1,</span> <span class="pre">a2)</span> <span class="pre">-&gt;</span> <span class="pre">(b1,</span> <span class="pre">b2)</span></code>, staging all
operations out of Python first before sorting out what can be evaluated now
and what must be delayed, we want only to form a jaxpr for those operations
that <em>must</em> be delayed due to a dependence on unknown inputs. In the context
of automatic differentiation, this is the feature that ultimately enables us
to handle functions like <code class="docutils literal notranslate"><span class="pre">grad(lambda</span> <span class="pre">x:</span> <span class="pre">x**2</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">0.)</span></code>. Python
control flow works because partial evaluation keeps the primal computation in
Python. As a consequence, our <code class="docutils literal notranslate"><span class="pre">Trace</span></code> and <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> subclasses must on the fly
sort out what can be evaluated and what must be staged out into a jaxpr.</p>
<p>First, we start with a <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code> class, which represents a value that can
be either known or unknown:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialVal</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
  <span class="n">const</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">known</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PartialVal</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">unknown</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PartialVal</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

  <span class="n">is_known</span>   <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">is_unknown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span>     <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Partial evaluation will take a list of <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code>s representing inputs, and
return a list of <code class="docutils literal notranslate"><span class="pre">PartialVal</span></code> outputs along with a jaxpr representing the
delayed computation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">partial_eval_flat</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PartialVal</span><span class="p">]</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">PartialVal</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="k">with</span> <span class="n">new_main</span><span class="p">(</span><span class="n">PartialEvalTrace</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">PartialEvalTrace</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">new_arg</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">pvals_in</span><span class="p">]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">tracers_in</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
    <span class="n">pvals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">]</span>
    <span class="n">unk_tracers_in</span>  <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span>  <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">]</span>
    <span class="n">unk_tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">]</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">tracers_to_jaxpr</span><span class="p">(</span><span class="n">unk_tracers_in</span><span class="p">,</span> <span class="n">unk_tracers_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span>
</pre></div>
</div>
</div>
</div>
<p>Next we need to implement <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code> and its <code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code>. This
interpreter will build a jaxpr on the fly while tracking data dependencies. To
do so, it builds a bipartite directed acyclic graph (DAG) between
<code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code> nodes, representing staged-out values, and <code class="docutils literal notranslate"><span class="pre">JaxprRecipe</span></code>
nodes, representing formulas for how to compute some values from others. One
kind of recipe is a <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>, corresponding to a <code class="docutils literal notranslate"><span class="pre">JaxprEqn</span></code>‚Äôs
primitive application, but we also have recipe types for constants and lambda
binders:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">ref</span><span class="p">,</span> <span class="n">ReferenceType</span>

<span class="k">class</span> <span class="nc">LambdaBindingRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ConstRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">JaxprEqnRecipe</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">prim</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">tracers_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">'PartialEvalTracer'</span><span class="p">]</span>
  <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">avals_out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span>
  <span class="n">tracer_refs_out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">'ReferenceType[PartialEvalTracer]'</span><span class="p">]</span>

<span class="n">JaxprRecipe</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">LambdaBindingRecipe</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialEvalTracer</span><span class="p">(</span><span class="n">Tracer</span><span class="p">):</span>
  <span class="n">pval</span><span class="p">:</span> <span class="n">PartialVal</span>
  <span class="n">recipe</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">JaxprRecipe</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">recipe</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pval</span> <span class="o">=</span> <span class="n">pval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">recipe</span>

  <span class="n">aval</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">full_lower</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code> contains the logic for constructing the graph of
<code class="docutils literal notranslate"><span class="pre">JaxprRecipe</span></code>s and <code class="docutils literal notranslate"><span class="pre">PartialEvalTracer</span></code>s. Each argument corresponds to a
<code class="docutils literal notranslate"><span class="pre">LambdaBindingRecipe</span></code> leaf node, and each constant is a <code class="docutils literal notranslate"><span class="pre">ConstRecipe</span></code> leaf
node holding a reference to the constant. All other tracers and recipes come
from <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code>, which forms tracers with <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s.</p>
<p>For most primitives, the <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> logic is straightforward: if all
inputs are known then we can bind the primitive on the known values
(evaluating it in Python) and avoid forming tracers corresponding to the
output. If instead any input is unknown then we instead stage out into a
<code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code> representing the primitive application. To build the tracers
representing unknown outputs, we need avals, which we get from the abstract
eval rules. (Notice that tracers reference <code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s, and
<code class="docutils literal notranslate"><span class="pre">JaxprEqnRecipe</span></code>s reference tracers; we avoid circular garbage by using
weakrefs.)</p>
<p>That <code class="docutils literal notranslate"><span class="pre">process_primitive</span></code> logic applies to most primitives, but <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code>
requires recursive treatment. So we special-case its rule in a
<code class="docutils literal notranslate"><span class="pre">partial_eval_rules</span></code> dict.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PartialEvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">new_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">:</span> <span class="n">PartialVal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">LambdaBindingRecipe</span><span class="p">())</span>

  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PartialEvalTracer</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">lift</span>

  <span class="k">def</span> <span class="nf">instantiate_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">:</span> <span class="n">PartialEvalTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PartialEvalTracer</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">tracer</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pval</span> <span class="o">=</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">bind</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">tracers</span><span class="p">),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">partial_eval_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">primitive</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rule</span><span class="p">:</span> <span class="k">return</span> <span class="n">rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">tracers_in</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">]</span>
    <span class="n">avals_out</span> <span class="o">=</span> <span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="o">*</span><span class="n">avals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">tracers_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals_out</span><span class="p">]</span>
    <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">tracers_in</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span>
                         <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">tracers_out</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
    <span class="k">return</span> <span class="n">tracers_out</span>

<span class="n">partial_eval_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we can build graph representations of jaxprs with <code class="docutils literal notranslate"><span class="pre">PartialEvalTrace</span></code>,
we need a mechanism to convert the graph representation to a standard jaxpr.
The jaxpr corresponds to a topological sort of the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tracers_to_jaxpr</span><span class="p">(</span><span class="n">tracers_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">],</span>
                     <span class="n">tracers_out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">]):</span>
  <span class="n">tracer_to_var</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="n">Var</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span>
                                   <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">}</span>
  <span class="n">constvar_to_val</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">constid_to_var</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">processed_eqns</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">toposort</span><span class="p">(</span><span class="n">tracers_out</span><span class="p">,</span> <span class="n">tracer_parents</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">LambdaBindingRecipe</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">tracers_in</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">ConstRecipe</span><span class="p">):</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="o">.</span><span class="n">val</span>
      <span class="n">var</span> <span class="o">=</span> <span class="n">constid_to_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">constid_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
        <span class="n">constvar_to_val</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
      <span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="o">=</span> <span class="n">var</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_eqns</span><span class="p">:</span>
        <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recipe_to_eqn</span><span class="p">(</span><span class="n">tracer_to_var</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">))</span>
        <span class="n">processed_eqns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">)</span>

  <span class="n">constvars</span><span class="p">,</span> <span class="n">constvals</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="n">constvar_to_val</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
  <span class="n">in_binders</span> <span class="o">=</span> <span class="n">constvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_in</span><span class="p">]</span>
  <span class="n">out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers_out</span><span class="p">]</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">out_vars</span><span class="p">)</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">constvals</span>

<span class="k">def</span> <span class="nf">recipe_to_eqn</span><span class="p">(</span><span class="n">tracer_to_var</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Var</span><span class="p">],</span> <span class="n">recipe</span><span class="p">:</span> <span class="n">JaxprEqnRecipe</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JaxprEqn</span><span class="p">:</span>
  <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">tracers_in</span><span class="p">]</span>
  <span class="n">out_binders</span> <span class="o">=</span> <span class="p">[</span><span class="n">Var</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">avals_out</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">t_ref</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">recipe</span><span class="o">.</span><span class="n">tracer_refs_out</span><span class="p">,</span> <span class="n">out_binders</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t_ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tracer_to_var</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t_ref</span><span class="p">())]</span> <span class="o">=</span> <span class="n">var</span>
  <span class="k">return</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">recipe</span><span class="o">.</span><span class="n">prim</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">recipe</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">out_binders</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tracer_parents</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">PartialEvalTracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="o">.</span><span class="n">tracers_in</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">recipe</span><span class="p">,</span> <span class="n">JaxprEqnRecipe</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">toposort</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">parents</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">out_nodes</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
  <span class="n">out_nodes</span> <span class="o">=</span> <span class="n">remove_duplicates</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">)</span>

  <span class="n">child_counts</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">child_counts</span><span class="p">:</span>
      <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">out_nodes</span><span class="p">:</span>
    <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">childless_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">out_nodes</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)]]</span>
  <span class="k">while</span> <span class="n">childless_nodes</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">childless_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">sorted_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">childless_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">child_counts</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="n">sorted_nodes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">check_toposort</span><span class="p">(</span><span class="n">sorted_nodes</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sorted_nodes</span>

<span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">check_toposort</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">parents</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]):</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>Now we can linearize!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">sin_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sin_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.1411200080598672 0.1411200080598672
-0.9899924966004454 -0.9899924966004454
</pre></div>
</div>
</div>
</div>
<p>To handle <code class="docutils literal notranslate"><span class="pre">linearize</span></code>-of-<code class="docutils literal notranslate"><span class="pre">jit</span></code>, we still need to write a partial evaluation
rule for <code class="docutils literal notranslate"><span class="pre">xla_call_p</span></code>. Other than tracer bookkeeping, the main task is to
perform partial evaluation of a jaxpr, ‚Äòunzipping‚Äô it into two jaxprs.</p>
<p>There are actually two rules to write: one for trace-time partial evaluation,
which we‚Äôll call <code class="docutils literal notranslate"><span class="pre">xla_call_partial_eval</span></code>, and one for partial evaluation of
jaxprs, which we‚Äôll call <code class="docutils literal notranslate"><span class="pre">xla_call_peval_eqn</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xla_call_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">in_unknowns</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
  <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">)</span>
  <span class="n">known_tracers</span><span class="p">,</span> <span class="n">unknown_tracers</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_unknowns</span><span class="p">,</span> <span class="n">tracers</span><span class="p">)</span>
  <span class="n">known_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_tracers</span><span class="p">]</span>
  <span class="n">outs1_res</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">known_vals</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr1</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">res_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
  <span class="n">outs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">res_tracers</span> <span class="o">+</span> <span class="n">unknown_tracers</span><span class="p">,</span>
                       <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr2</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                       <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">outs2</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">outs2</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">merge_lists</span><span class="p">(</span><span class="n">out_unknowns</span><span class="p">,</span> <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
<span class="n">partial_eval_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_partial_eval</span>

<span class="k">def</span> <span class="nf">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                       <span class="n">instantiate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">residuals</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="ow">and</span> <span class="n">env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">unk</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">unk</span>

  <span class="k">def</span> <span class="nf">new_res</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span><span class="p">:</span> <span class="n">residuals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

  <span class="n">eqns1</span><span class="p">,</span> <span class="n">eqns2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">unks_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rule</span><span class="p">:</span>
      <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="p">)</span>
      <span class="n">eqns1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn1</span><span class="p">);</span> <span class="n">eqns2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn2</span><span class="p">);</span> <span class="n">residuals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">unks_in</span><span class="p">):</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="n">unk</span> <span class="k">else</span> <span class="n">new_res</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">unk</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)]</span>
      <span class="n">eqns2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">JaxprEqn</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">eqns1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">out_unknowns</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">instantiate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">uk</span><span class="p">,</span> <span class="n">inst</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">instantiate</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">inst</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">uk</span><span class="p">:</span> <span class="n">new_res</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">out_unknowns</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">instantiate</span><span class="p">)</span>

  <span class="n">residuals</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">residuals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">),</span> <span class="n">residuals</span>

  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">out_unknowns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>

  <span class="n">jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">ins1</span><span class="p">,</span> <span class="n">eqns1</span><span class="p">,</span> <span class="n">outs1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">residuals</span> <span class="o">+</span> <span class="n">ins2</span><span class="p">,</span> <span class="n">eqns2</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
  <span class="n">typecheck_partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">out_unknowns</span><span class="p">,</span> <span class="n">num_res</span>

<span class="k">def</span> <span class="nf">typecheck_partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">):</span>
  <span class="n">jaxprty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>    <span class="c1"># (a1,  a2) -&gt; (b1, b2 )</span>
  <span class="n">jaxpr1ty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">)</span>  <span class="c1">#  a1       -&gt; (b1, res)</span>
  <span class="n">jaxpr2ty</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>  <span class="c1"># (res, a2) -&gt; b2</span>

  <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">jaxprty</span><span class="o">.</span><span class="n">in_types</span><span class="p">)</span>
  <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">jaxprty</span><span class="o">.</span><span class="n">out_types</span><span class="p">)</span>
  <span class="n">b1_</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1ty</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
  <span class="n">res_</span><span class="p">,</span> <span class="n">a2_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
  <span class="n">b2_</span> <span class="o">=</span> <span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">out_types</span>

  <span class="k">if</span> <span class="n">jaxpr1ty</span><span class="o">.</span><span class="n">in_types</span> <span class="o">!=</span> <span class="n">a1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">jaxpr2ty</span><span class="o">.</span><span class="n">out_types</span> <span class="o">!=</span> <span class="n">b2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b1_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="n">res_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">a2</span> <span class="o">!=</span> <span class="n">a2_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="n">b2</span> <span class="o">!=</span> <span class="n">b2_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>

<span class="n">partial_eval_jaxpr_rules</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">xla_call_peval_eqn</span><span class="p">(</span><span class="n">unks_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]]:</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'jaxpr'</span><span class="p">]</span>
  <span class="n">jaxpr1</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">)</span>
  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
  <span class="n">out_binders1</span><span class="p">,</span> <span class="n">out_binders2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">[:</span><span class="n">num_res</span><span class="p">]]</span>
  <span class="n">eqn1</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">ins1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr1</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                  <span class="n">out_binders1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">eqn2</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="n">residuals</span> <span class="o">+</span> <span class="n">ins2</span><span class="p">,</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr2</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">out_binders2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">residuals</span>
<span class="n">partial_eval_jaxpr_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_peval_eqn</span>
</pre></div>
</div>
</div>
</div>
<p>With that, we can compose <code class="docutils literal notranslate"><span class="pre">linearize</span></code> and <code class="docutils literal notranslate"><span class="pre">jit</span></code> however we like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7177599838802657 2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="n">y_dot</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.7077524804807109 -2.121105001260758
</pre></div>
</div>
</div>
</div>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/vjp and grad"></a><section id="vjp-and-grad">
<h3><code class="docutils literal notranslate"><span class="pre">vjp</span></code> and <code class="docutils literal notranslate"><span class="pre">grad</span></code><a class="headerlink" href="#vjp-and-grad" title="Permalink to this headline">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">vjp</span></code> transformation works a lot like linearize. Its type signature is
analogous:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">linearize</span> <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">a</span> <span class="o">-</span><span class="n">o</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="n">vjp</span>       <span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span> <span class="o">-</span><span class="n">o</span> <span class="n">T</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The only difference is that we transpose the linear part of the computation
before returning it, so that it goes from type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">b</span></code> to type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">b</span> <span class="pre">-o</span> <span class="pre">T</span> <span class="pre">a</span></code>. That is, we‚Äôll implement <code class="docutils literal notranslate"><span class="pre">vjp</span></code> as, essentially,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">y</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">f_vjp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y_bar</span><span class="p">:</span> <span class="n">transpose</span><span class="p">(</span><span class="n">f_lin</span><span class="p">)(</span><span class="n">y_bar</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span>
</pre></div>
</div>
<p>Since we have the linear computation as a jaxpr, not just a Python callable,
we can implement the transpose transformation as a jaxpr interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vjp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">pvals_in</span> <span class="o">=</span> <span class="p">([</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">]</span> <span class="o">+</span>
              <span class="p">[</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">vspace</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals_in</span><span class="p">])</span>
  <span class="n">primal_pvals_in</span><span class="p">,</span> <span class="n">tangent_pvals_in</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_in</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f_jvp</span><span class="p">(</span><span class="o">*</span><span class="n">primals_tangents_in</span><span class="p">):</span>
    <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">split_half</span><span class="p">(</span><span class="n">primals_tangents_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">primals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents_out</span><span class="p">]</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">pvals_out</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">partial_eval_flat</span><span class="p">(</span><span class="n">f_jvp</span><span class="p">,</span> <span class="n">pvals_in</span><span class="p">)</span>  <span class="c1"># linearize</span>
  <span class="n">primal_pvals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">pvals_out</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">primal_pvals</span><span class="p">]</span>
  <span class="n">transpose_inputs</span> <span class="o">=</span> <span class="n">consts</span> <span class="o">+</span> <span class="p">[</span><span class="n">UndefPrimal</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tangent_pvals_in</span><span class="p">]</span>
  <span class="n">f_vjp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">cts</span><span class="p">:</span> <span class="n">eval_jaxpr_transposed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">transpose_inputs</span><span class="p">,</span> <span class="n">cts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_vjp</span>

<span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">):</span>
  <span class="n">primals_in_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">primals_in</span><span class="p">)</span>
  <span class="n">f</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">flatten_fun</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">primals_out_flat</span><span class="p">,</span> <span class="n">f_vjp_flat</span> <span class="o">=</span> <span class="n">vjp_flat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in_flat</span><span class="p">)</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">(),</span> <span class="n">primals_out_flat</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">f_vjp</span><span class="p">(</span><span class="o">*</span><span class="n">cotangents_out</span><span class="p">):</span>
    <span class="n">cotangents_out_flat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">cotangents_out</span><span class="p">)</span>
    <span class="n">cotangents_in_flat</span> <span class="o">=</span> <span class="n">f_vjp_flat</span><span class="p">(</span><span class="o">*</span><span class="n">cotangents_out_flat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">cotangents_in_flat</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">f_vjp</span>

<span class="k">class</span> <span class="nc">UndefPrimal</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>

<span class="n">register_pytree_node</span><span class="p">(</span><span class="n">UndefPrimal</span><span class="p">,</span>
                     <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="p">()),</span>
                     <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">UndefPrimal</span><span class="p">(</span><span class="n">aval</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We use <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code> instances to indicate which arguments with respect to
which we want to transpose. These arise because in general, being explicit
about closed-over values, we want to transpose functions of type
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-o</span> <span class="pre">c</span></code> to functions of type <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span> <span class="pre">-o</span> <span class="pre">b</span></code>. Even more generally, the
inputs with respect to which the function is linear could be scattered through
the argument list. So we indicate the linear positions using <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code>.
We register <code class="docutils literal notranslate"><span class="pre">UndefPrimal</span></code> as a pytree node because the pytree mechanism gives
a handy way to prune these placeholders out of argument lists.</p>
<p>Next, we can write <code class="docutils literal notranslate"><span class="pre">eval_jaxpr_transposed</span></code>, along with transpose rules for
all primitives which can be linear in at least one argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NB: the analogous function in JAX is called 'backward_pass'</span>
<span class="k">def</span> <span class="nf">eval_jaxpr_transposed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">cotangents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="n">primal_env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">ct_env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">read_primal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UndefPrimal</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">))</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="k">def</span> <span class="nf">write_primal</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UndefPrimal</span><span class="p">:</span>
      <span class="n">primal_env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="k">def</span> <span class="nf">read_cotangent</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ct_env</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">write_cotangent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">ct_env</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">ct_env</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ct_env</span> <span class="k">else</span> <span class="n">val</span>

  <span class="nb">map</span><span class="p">(</span><span class="n">write_primal</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write_cotangent</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="n">cotangents</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">primals_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read_primal</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">cts_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read_cotangent</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">transpose_rules</span><span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">]</span>
    <span class="n">cts_out</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">cts_in</span><span class="p">,</span> <span class="o">*</span><span class="n">primals_in</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">write_cotangent</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">cts_out</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">[</span><span class="n">read_cotangent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">]</span>

<span class="n">transpose_rules</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mul_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">z_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">assert</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">mul</span><span class="p">(</span><span class="n">z_bar</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z_bar</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul_transpose_rule</span>

<span class="k">def</span> <span class="nf">neg_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">ybar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">ybar</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">neg_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_transpose_rule</span>

<span class="k">def</span> <span class="nf">add_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">z_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">z_bar</span><span class="p">,</span> <span class="n">z_bar</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_transpose_rule</span>

<span class="k">def</span> <span class="nf">reduce_sum_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="n">y_bar</span><span class="p">,</span> <span class="o">=</span> <span class="n">cts</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">broadcast</span><span class="p">(</span><span class="n">y_bar</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_sum_transpose_rule</span>

<span class="k">def</span> <span class="nf">xla_call_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="o">*</span><span class="n">invals</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">num_consts</span>  <span class="c1"># Unused</span>
  <span class="n">undef_primals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">]</span>
  <span class="n">transposed_jaxpr</span><span class="p">,</span> <span class="n">new_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">undef_primals</span><span class="p">))</span>
  <span class="n">residuals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">undef_primals</span><span class="p">,</span> <span class="n">invals</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xla_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">new_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">residuals</span><span class="p">,</span> <span class="o">*</span><span class="n">cts</span><span class="p">,</span>
              <span class="n">jaxpr</span><span class="o">=</span><span class="n">transposed_jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_consts</span><span class="p">))</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="k">if</span> <span class="n">undef</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">undef</span> <span class="ow">in</span> <span class="n">undef_primals</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">xla_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">xla_call_transpose_rule</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">transpose_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">traceable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">eval_jaxpr_transposed</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">UndefPrimal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avals_in</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)]</span>
  <span class="n">trans_jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">traceable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">avals_out</span><span class="p">))</span>
  <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">trans_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">trans_jaxpr</span><span class="p">,</span> <span class="n">consts</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we can linearize and transpose, we can finally write <code class="docutils literal notranslate"><span class="pre">grad</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">gradfun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">):</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span> <span class="o">=</span> <span class="n">vjp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="p">():</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="n">x_bar</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">f_vjp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">x_bar</span>
  <span class="k">return</span> <span class="n">gradfun</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">,</span> <span class="n">f_vjp</span> <span class="o">=</span> <span class="n">vjp</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mf">3.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_vjp</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-0.9899924966004454,) -0.9899924966004454
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.979984993200891
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">2.</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.1176619927957034
</pre></div>
</div>
</div>
</div>
<p>Here‚Äôs something of a compositionality stress test:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># from core_test.py fun_with_nested_calls_2</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="nd">@jit</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">baz</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">y</span><span class="p">)()</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">w</span> <span class="o">+</span> <span class="n">y</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">jit</span><span class="p">(</span><span class="n">sin</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">q</span>
      <span class="k">return</span> <span class="n">q</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">baz</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,),</span> <span class="p">(</span><span class="n">y</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">assert_allclose</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

<span class="n">ans1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">ans2</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">ans3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,))</span>
<span class="n">ans4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">ans1</span><span class="p">,</span> <span class="n">ans2</span><span class="p">,</span> <span class="n">ans3</span><span class="p">,</span> <span class="n">ans4</span><span class="p">)</span>

<span class="n">deriv1</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">deriv2</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">deriv3</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">deriv4</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">deriv5</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">deriv1</span><span class="p">,</span> <span class="n">deriv2</span><span class="p">,</span> <span class="n">deriv3</span><span class="p">,</span> <span class="n">deriv4</span><span class="p">,</span> <span class="n">deriv5</span><span class="p">)</span>

<span class="n">hess1</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess2</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess3</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">hess4</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)))(</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess5</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess6</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">_</span><span class="p">,</span> <span class="n">hess7</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="n">assert_allclose</span><span class="p">(</span><span class="n">hess1</span><span class="p">,</span> <span class="n">hess2</span><span class="p">,</span> <span class="n">hess3</span><span class="p">,</span> <span class="n">hess4</span><span class="p">,</span> <span class="n">hess5</span><span class="p">,</span> <span class="n">hess6</span><span class="p">,</span> <span class="n">hess7</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Part 5: the control flow primitives cond"></a><section id="part-5-the-control-flow-primitives-cond">
<h2>Part 5: the control flow primitives <code class="docutils literal notranslate"><span class="pre">cond</span></code><a class="headerlink" href="#part-5-the-control-flow-primitives-cond" title="Permalink to this headline">#</a></h2>
<p>Next we‚Äôll add higher-order primitives for staged-out control flow. These
resemble <code class="docutils literal notranslate"><span class="pre">jit</span></code> from Part 3, another higher-order primitive, but differ in that
they are parameterized by multiple callables rather than just one.</p>
<a class="dashAnchor" name="//apple_ref/cpp/Section/Adding cond"></a><section id="adding-cond">
<h3>Adding <code class="docutils literal notranslate"><span class="pre">cond</span></code><a class="headerlink" href="#adding-cond" title="Permalink to this headline">#</a></h3>
<p>We introduce a <code class="docutils literal notranslate"><span class="pre">cond</span></code> primitive to represent conditional application of one
function or another inside a jaxpr. We write the type of <code class="docutils literal notranslate"><span class="pre">cond</span></code> as
<code class="docutils literal notranslate"><span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. In words, <code class="docutils literal notranslate"><span class="pre">cond</span></code> takes a boolean
representing the predicate and two functions of equal types. Depending on the
value of the predicate, it applies one function or the other to its final
argument.</p>
<p>In Python, we represent it as a function which itself takes two functions as
arguments. As with <code class="docutils literal notranslate"><span class="pre">jit</span></code>, the first step is to call <code class="docutils literal notranslate"><span class="pre">make_jaxpr</span></code> on its
callable arguments to turn them into jaxprs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">true_fn</span><span class="p">,</span> <span class="n">false_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="n">avals_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">true_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span><span class="p">,</span> <span class="n">out_tree_</span> <span class="o">=</span> <span class="n">make_jaxpr</span><span class="p">(</span><span class="n">false_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out_tree</span> <span class="o">!=</span> <span class="n">out_tree_</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
<span class="n">cond_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">'cond'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_join_jaxpr_consts</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="nb">int</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="n">jaxpr1_type</span><span class="p">,</span> <span class="n">jaxpr2_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">),</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">jaxpr1_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">jaxpr2_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">[</span><span class="n">n2</span><span class="p">:]</span>
  <span class="n">consts1</span><span class="p">,</span> <span class="n">rest1</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">consts2</span><span class="p">,</span> <span class="n">rest2</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
  <span class="n">new_jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">consts1</span> <span class="o">+</span> <span class="n">consts2</span> <span class="o">+</span> <span class="n">rest1</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="n">new_jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">consts1</span> <span class="o">+</span> <span class="n">consts2</span> <span class="o">+</span> <span class="n">rest2</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr1</span><span class="p">,</span> <span class="n">new_jaxpr2</span>

<span class="k">def</span> <span class="nf">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="o">.</span><span class="n">in_binders</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">bind</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We require <code class="docutils literal notranslate"><span class="pre">true_jaxpr</span></code> and <code class="docutils literal notranslate"><span class="pre">false_jaxpr</span></code> to have the same type, but because
they might close over different constants (and because jaxprs can only
represent closed terms, i.e. can‚Äôt have free variables and are instead
closure-converted) we need to use the helper <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code> to make
consistent the input binder lists of the two jaxprs. (To be more economical we
could try to identify pairs of constants with the same shapes, but instead we
just concatenate the lists of constants.)</p>
<p>Next we can turn to adding interpreter rules for <code class="docutils literal notranslate"><span class="pre">cond</span></code>. Its evaluation rule
is simple:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_impl</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">pred</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span>
<span class="n">impl_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_impl</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>For its JVP and vmap rules, we only need to call the same <code class="docutils literal notranslate"><span class="pre">jvp_jaxpr</span></code> and
<code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> utilities we created for <code class="docutils literal notranslate"><span class="pre">jit</span></code>, followed by another pass of
<code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">_</span>   <span class="p">,</span> <span class="o">*</span><span class="n">tangents</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">true_consts</span>  <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">jvp_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">primals</span><span class="p">,</span> <span class="o">*</span><span class="n">tangents</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">split_half</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>
<span class="n">jvp_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_jvp_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">,</span> <span class="n">out_tan</span> <span class="o">=</span> <span class="n">jvp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out_tan</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_vmap_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">vals_in</span><span class="p">,</span> <span class="n">dims_in</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred</span>    <span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span> <span class="o">=</span> <span class="n">vals_in</span>
  <span class="n">pred_dim</span><span class="p">,</span> <span class="o">*</span><span class="n">dims_in</span> <span class="o">=</span> <span class="n">dims_in</span>
  <span class="k">if</span> <span class="n">pred_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">not_mapped</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># TODO</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">vmap_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_in</span><span class="p">))</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">vals_in</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
<span class="n">vmap_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_vmap_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))(</span><span class="n">xs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2. 3. 4.]
</pre></div>
</div>
</div>
</div>
<p>Notice that we‚Äôre not currently supporting the case where the predicate value
itself is batched. In mainline JAX, we handle this case by transforming the
conditional to a <a class="reference external" href="https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html">select primitive</a>.
That transformation is semantically correct so long as <code class="docutils literal notranslate"><span class="pre">true_fun</span></code> and
<code class="docutils literal notranslate"><span class="pre">false_fun</span></code> do not involve any side-effecting primitives.</p>
<p>Another thing not represented here, but present in the mainline JAX, is that
applying transformations to two jaxprs of equal type might result in jaxprs of
different types. For example, applying the mainline JAX version of
<code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> to the identity-function jaxpr</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float32</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>would result in a jaxpr with a batched output, of type
<code class="docutils literal notranslate"><span class="pre">[float32[10]]</span> <span class="pre">-&gt;</span> <span class="pre">[float32[10]]</span></code> if the batch size were 10, while applying it
to the zero-function jaxpr</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">float32</span><span class="p">[]</span> <span class="o">.</span>
  <span class="n">let</span>
  <span class="ow">in</span> <span class="p">(</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>would result in a jaxpr with an unbatched output, of type
<code class="docutils literal notranslate"><span class="pre">[float32[10]]</span> <span class="pre">-&gt;</span> <span class="pre">[float32[]]</span></code>. This is an optimization, aimed at not batching
values unnecessarily. But it means that in <code class="docutils literal notranslate"><span class="pre">cond</span></code> we‚Äôd need an extra step of
joining the two transformed jaxprs to have consistent output types. We don‚Äôt
need this step here because we chose <code class="docutils literal notranslate"><span class="pre">vmap_jaxpr</span></code> always to batch all outputs
over the leading axis.</p>
<p>Next we can turn to abstract evaluation and XLA lowering rules:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_abstract_eval</span><span class="p">(</span><span class="n">pred_type</span><span class="p">,</span> <span class="o">*</span><span class="n">in_types</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">pred_type</span> <span class="o">!=</span> <span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="n">jaxpr_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">jaxpr_type</span> <span class="o">!=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr_type</span><span class="o">.</span><span class="n">in_types</span><span class="p">,</span> <span class="n">in_types</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span>
  <span class="k">return</span> <span class="n">jaxpr_type</span><span class="o">.</span><span class="n">out_types</span>
<span class="n">abstract_eval_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_abstract_eval</span>

<span class="k">def</span> <span class="nf">cond_translation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">in_vals</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">in_avals</span>  <span class="c1"># Unused</span>
  <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">in_vals</span> <span class="o">=</span> <span class="n">in_vals</span>
  <span class="n">flat_vals</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">in_vals</span><span class="p">)</span>
  <span class="n">operand</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">flat_vals</span><span class="p">)</span>
  <span class="n">operand_shape</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">make_comp</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xe</span><span class="o">.</span><span class="n">XlaComputation</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">XlaBuilder</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">operand_shape</span><span class="p">)</span>
    <span class="n">operands</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">destructure_tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">operand</span><span class="p">))</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>

  <span class="n">true_comp</span> <span class="o">=</span> <span class="n">make_comp</span><span class="p">(</span><span class="s1">'true_fn'</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">)</span>
  <span class="n">false_comp</span> <span class="o">=</span> <span class="n">make_comp</span><span class="p">(</span><span class="s1">'false_fn'</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">)</span>

  <span class="n">int_etype</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">dtype_to_etype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">))</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">Conditional</span><span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">ConvertElementType</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">int_etype</span><span class="p">),</span>
                         <span class="p">[</span><span class="n">false_comp</span><span class="p">,</span> <span class="n">true_comp</span><span class="p">],</span> <span class="p">[</span><span class="n">operand</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">destructure_tuple</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
<span class="n">xla_translations</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_translation</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">2</span><span class="p">))()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Finally, to support reverse-mode automatic differentiation, we need partial
evaluation and transposition rules. For partial evaluation, we need to
introduce another jaxpr-munging utility, <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_res</span></code>, to handle the fact
that applying partial evaluation to <code class="docutils literal notranslate"><span class="pre">true_fun</span></code> and <code class="docutils literal notranslate"><span class="pre">false_fun</span></code> will in general
result in distinct residuals. We use <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_res</span></code> to make the output
types of the transformed jaxprs consistent (while <code class="docutils literal notranslate"><span class="pre">_join_jaxpr_consts</span></code> dealt
with input types).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">pred_tracer</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">tracers</span>
  <span class="k">assert</span> <span class="n">pred_tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span>
  <span class="n">pred</span> <span class="o">=</span> <span class="n">pred_tracer</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span>
  <span class="n">in_uks</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>

  <span class="o">*</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">jaxprs</span>

  <span class="n">known_tracers</span><span class="p">,</span> <span class="n">unknown_tracers</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">in_uks</span><span class="p">,</span> <span class="n">tracers</span><span class="p">)</span>
  <span class="n">known_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">const</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_tracers</span><span class="p">]</span>
  <span class="n">outs1_res</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">known_vals</span><span class="p">,</span>
                        <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr1</span><span class="p">)</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs1_res</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">pred_tracer_</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">pred_tracer</span><span class="p">))</span>
  <span class="n">res_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">full_raise</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
  <span class="n">outs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartialEvalTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">]</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">JaxprEqnRecipe</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">pred_tracer_</span><span class="p">,</span> <span class="o">*</span><span class="n">res_tracers</span><span class="p">,</span> <span class="o">*</span><span class="n">unknown_tracers</span><span class="p">],</span>
                       <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr2</span><span class="p">),</span>
                       <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">outs2</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">outs2</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">merge_lists</span><span class="p">(</span><span class="n">out_uks</span><span class="p">,</span> <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span><span class="p">)</span>
<span class="n">partial_eval_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_partial_eval</span>

<span class="k">def</span> <span class="nf">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t_out_uks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_out_uks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">)</span>
  <span class="n">out_uks</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">t_out_uks</span><span class="p">,</span> <span class="n">f_out_uks</span><span class="p">)</span>

  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t_nres</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span> <span class="p">,</span> <span class="n">in_uks</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">)</span>
  <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_nres</span> <span class="o">=</span> <span class="n">partial_eval_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">in_uks</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">)</span>

  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span> <span class="o">=</span> <span class="n">_join_jaxpr_res</span><span class="p">(</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_nres</span><span class="p">,</span> <span class="n">f_nres</span><span class="p">)</span>
  <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">t_nres</span><span class="p">,</span> <span class="n">f_nres</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">t_jaxpr1</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">f_jaxpr1</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="p">)</span> <span class="o">==</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">f_jaxpr2</span><span class="p">)</span>
  <span class="n">num_res</span> <span class="o">=</span> <span class="n">t_nres</span> <span class="o">+</span> <span class="n">f_nres</span>

  <span class="k">return</span> <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span><span class="p">,</span> <span class="n">out_uks</span><span class="p">,</span> <span class="n">num_res</span>

<span class="k">def</span> <span class="nf">_join_jaxpr_res</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">n1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="nb">int</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="n">jaxpr1_type</span><span class="p">,</span> <span class="n">jaxpr2_type</span> <span class="o">=</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="p">),</span> <span class="n">typecheck_jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="p">)</span>
  <span class="n">out_types1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1_type</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">out_types2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2_type</span><span class="o">.</span><span class="n">out_types</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">out_types1</span> <span class="o">==</span> <span class="n">out_types2</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span>
  <span class="n">outs2</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">outs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span>
  <span class="n">zeros_like1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res1</span><span class="p">]</span>
  <span class="n">zeros_like2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res2</span><span class="p">]</span>
  <span class="n">new_jaxpr1</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">jaxpr1</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">jaxpr1</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">outs1</span> <span class="o">+</span> <span class="n">res1</span> <span class="o">+</span> <span class="n">zeros_like2</span><span class="p">)</span>
  <span class="n">new_jaxpr2</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">jaxpr2</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">+</span> <span class="n">zeros_like1</span> <span class="o">+</span> <span class="n">res2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr1</span><span class="p">,</span> <span class="n">new_jaxpr2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">),</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.14
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_peval_eqn</span><span class="p">(</span><span class="n">unks_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]]:</span>
  <span class="n">pred_unk</span><span class="p">,</span> <span class="o">*</span><span class="n">unks_in</span> <span class="o">=</span> <span class="n">unks_in</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="n">pred_unk</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'true_jaxpr'</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'false_jaxpr'</span><span class="p">]</span>
  <span class="o">*</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> <span class="n">_cond_partial_eval</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">)</span>
  <span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">f_jaxpr1</span><span class="p">,</span> <span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">f_jaxpr2</span> <span class="o">=</span> <span class="n">jaxprs</span>
  <span class="n">ins1</span><span class="p">,</span> <span class="n">ins2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="n">outs1</span><span class="p">,</span> <span class="n">outs2</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">)</span>
  <span class="n">residuals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">t_jaxpr2</span><span class="o">.</span><span class="n">in_binders</span><span class="p">,</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">eqn1</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">ins1</span><span class="p">],</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr1</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr1</span><span class="p">),</span>
                  <span class="n">outs1</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">)</span>
  <span class="n">eqn2</span> <span class="o">=</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">cond_p</span><span class="p">,</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">residuals</span><span class="p">,</span> <span class="o">*</span><span class="n">ins2</span><span class="p">],</span>
                  <span class="nb">dict</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="o">=</span><span class="n">t_jaxpr2</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">f_jaxpr2</span><span class="p">),</span>
                  <span class="n">outs2</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">residuals</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">residuals</span>
  <span class="k">return</span> <span class="n">eqn1</span><span class="p">,</span> <span class="n">eqn2</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">res</span>
<span class="n">partial_eval_jaxpr_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_peval_eqn</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">f_lin</span> <span class="o">=</span> <span class="n">linearize</span><span class="p">(</span><span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">)),</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">f_lin</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.14
</pre></div>
</div>
</div>
</div>
<p>Transposition is a fairly straightforward application of <code class="docutils literal notranslate"><span class="pre">transpose_jaxpr</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">invals</span><span class="p">,</span> <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">):</span>
  <span class="n">undef_primals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">true_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)</span>
  <span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">false_consts</span> <span class="o">=</span> <span class="n">transpose_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">,</span> <span class="n">undef_primals</span><span class="p">)</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">_join_jaxpr_consts</span><span class="p">(</span>
      <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_consts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_consts</span><span class="p">))</span>
  <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UndefPrimal</span><span class="p">]</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">bind_cond</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">true_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">false_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">cts</span><span class="p">,</span>
                   <span class="n">true_jaxpr</span><span class="o">=</span><span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span><span class="o">=</span><span class="n">false_jaxpr</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">UndefPrimal</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">invals</span><span class="p">]</span>
<span class="n">transpose_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_transpose_rule</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cond</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.</span><span class="p">))(</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pprint_cond</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPrint</span><span class="p">:</span>
  <span class="n">true_jaxpr</span><span class="p">,</span> <span class="n">false_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'true_jaxpr'</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">'false_jaxpr'</span><span class="p">]</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'jaxpr'</span><span class="p">)}</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_str</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">out_binders</span><span class="p">))</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pp_params</span><span class="p">(</span><span class="n">new_params</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
         <span class="n">pp</span><span class="p">(</span><span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">vcat</span><span class="p">([</span><span class="n">lhs</span> <span class="o">&gt;&gt;</span> <span class="n">pp</span><span class="p">(</span><span class="s1">' = '</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhs</span><span class="p">,</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">true_jaxpr</span><span class="p">)</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
               <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">false_jaxpr</span><span class="p">)</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">pp_rules</span><span class="p">[</span><span class="n">cond_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint_cond</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
</section>
</div>
</main>
<footer class="footer-article noprint">
<!-- Previous / next buttons -->
<div class="prev-next-area">
<a class="left-prev" href="_autosummary/jax.core.ClosedJaxpr.html" id="prev-link" title="previous page">
<i class="fas fa-angle-left"></i>
<div class="prev-next-info">
<p class="prev-next-subtitle">previous</p>
<p class="prev-next-title">jax.core.ClosedJaxpr</p>
</div>
</a>
<a class="right-next" href="jep/index.html" id="next-link" title="next page">
<div class="prev-next-info">
<p class="prev-next-subtitle">next</p>
<p class="prev-next-title">JAX Enhancement Proposals (JEPs)</p>
</div>
<i class="fas fa-angle-right"></i>
</a>
</div>
</footer>
</div>
</div>
<div class="footer-content row">
<footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      ¬© Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
</footer>
</div>
</div>
</div>
</div>
<!-- Scripts loaded after <body> so the DOM is not blocked -->
<script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
</body>
</html>