
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax._src.numpy.lax_numpy &#8212; JAX  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" href="../../../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../../_static/jax_logo_250px.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../installation.html">
   Installing JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/quickstart.html">
   JAX Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Common_Gotchas_in_JAX.html">
   ðŸ”ª JAX - The Sharp Bits ðŸ”ª
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jax-101/index.html">
   Tutorial: JAX 101
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/08-pjit.html">
     Introduction to pjit
    </a>
   </li>
  </ul>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../debugging/index.html">
   Runtime value debugging in JAX
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/print_breakpoint.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.print
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.breakpoint
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       checkify
      </span>
     </code>
     transformation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/flags.html">
     JAX debugging flags
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../async_dispatch.html">
   Asynchronous dispatch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../aot.html">
   Ahead-of-time lowering and compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../jaxpr.html">
   Understanding Jaxprs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/convolutions.html">
   Convolutions in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../pytrees.html">
   Pytrees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../type_promotion.html">
   Type promotion semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../errors.html">
   JAX Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../transfer_guard.html">
   Transfer guard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../glossary.html">
   JAX Glossary of Terms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../changelog.html">
   Change log
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../api_compatibility.html">
   API compatibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../deprecation.html">
   Python and NumPy version support policy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../concurrency.html">
   Concurrency
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../gpu_memory_allocation.html">
   GPU memory allocation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../profiling.html">
   Profiling JAX programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../device_memory_profiling.html">
   Device Memory Profiling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../rank_promotion_warning.html">
   Rank promotion warning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../contributing.html">
   Contributing to JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../developer.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../jax_internal_api.html">
   Internal APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../autodidax.html">
   Autodidax: JAX core from scratch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/263-prng.html">
     263: JAX PRNG Design
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jax.html">
   Public API: jax package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.numpy.html">
     jax.numpy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.scipy.html">
     jax.scipy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.config.html">
     JAX configuration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.debug.html">
     jax.debug package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.dlpack.html">
     jax.dlpack module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.distributed.html">
     jax.distributed module
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.example_libraries.html">
     jax.example_libraries package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.experimental.html">
     jax.experimental package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.flatten_util.html">
     jax.flatten_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.image.html">
     jax.image package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.lax.html">
     jax.lax package
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.nn.html">
     jax.nn package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.ops.html">
     jax.ops package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.profiler.html">
     jax.profiler module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.random.html">
     jax.random package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.stages.html">
     jax.stages package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.tree_util.html">
     jax.tree_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.lib.html">
     jax.lib package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/google/jax"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for jax._src.numpy.lax_numpy</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pytype: skip-file</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements the NumPy API, using the primitives in :mod:`jax.lax`.</span>

<span class="sd">NumPy operations are implemented in Python in terms of the primitive operations</span>
<span class="sd">in :mod:`jax.lax`. Since NumPy operations are not primitive and instead are</span>
<span class="sd">implemented in terms of :mod:`jax.lax` operations, we do not need to define</span>
<span class="sd">transformation rules such as gradient or batching rules. Instead,</span>
<span class="sd">transformations for NumPy primitives can be derived from the transformation</span>
<span class="sd">rules for the underlying :code:`lax` primitives.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span> <span class="k">as</span> <span class="n">functools_wraps</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span> <span class="k">as</span> <span class="n">_dedent</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">opt_einsum</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">errors</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">lax</span>
<span class="kn">from</span> <span class="nn">jax.core</span> <span class="kn">import</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">,</span> <span class="n">ConcreteArray</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">pxla</span>
<span class="kn">from</span> <span class="nn">jax.tree_util</span> <span class="kn">import</span> <span class="n">tree_leaves</span><span class="p">,</span> <span class="n">tree_flatten</span><span class="p">,</span> <span class="n">tree_map</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">device_array</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax._src.api_util</span> <span class="kn">import</span> <span class="n">_ensure_index_tuple</span>
<span class="kn">from</span> <span class="nn">jax._src.lax.lax</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_array_copy</span><span class="p">,</span> <span class="n">_sort_lt_comparator</span><span class="p">,</span>
                              <span class="n">_sort_le_comparator</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">lax</span> <span class="k">as</span> <span class="n">lax_internal</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.ndarray</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.reductions</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa: F401</span>
  <span class="n">_ensure_optional_axes</span><span class="p">,</span> <span class="n">_reduction_dims</span><span class="p">,</span>
  <span class="n">alltrue</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">all</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="n">count_nonzero</span><span class="p">,</span> <span class="n">cumsum</span><span class="p">,</span> <span class="n">cumprod</span><span class="p">,</span> <span class="n">cumproduct</span><span class="p">,</span>
  <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">nancumsum</span><span class="p">,</span> <span class="n">nancumprod</span><span class="p">,</span> <span class="n">nanmax</span><span class="p">,</span> <span class="n">nanmean</span><span class="p">,</span> <span class="n">nanmin</span><span class="p">,</span> <span class="n">nanprod</span><span class="p">,</span> <span class="n">nanstd</span><span class="p">,</span>
  <span class="n">nansum</span><span class="p">,</span> <span class="n">nanvar</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">ptp</span><span class="p">,</span> <span class="n">sometrue</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.ufuncs</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa: F401</span>
  <span class="nb">abs</span><span class="p">,</span> <span class="n">absolute</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">arccos</span><span class="p">,</span> <span class="n">arccosh</span><span class="p">,</span> <span class="n">arcsin</span><span class="p">,</span> <span class="n">arcsinh</span><span class="p">,</span> <span class="n">arctan</span><span class="p">,</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">arctanh</span><span class="p">,</span>
  <span class="n">bitwise_and</span><span class="p">,</span> <span class="n">bitwise_not</span><span class="p">,</span> <span class="n">bitwise_or</span><span class="p">,</span> <span class="n">bitwise_xor</span><span class="p">,</span> <span class="n">cbrt</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">conj</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span>
  <span class="n">copysign</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">deg2rad</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">divide</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">,</span> <span class="n">equal</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="n">expm1</span><span class="p">,</span>
  <span class="n">fabs</span><span class="p">,</span> <span class="n">float_power</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">floor_divide</span><span class="p">,</span> <span class="n">fmod</span><span class="p">,</span> <span class="n">frexp</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span> <span class="n">greater_equal</span><span class="p">,</span>
  <span class="n">heaviside</span><span class="p">,</span> <span class="n">hypot</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">isfinite</span><span class="p">,</span> <span class="n">isinf</span><span class="p">,</span> <span class="n">isnan</span><span class="p">,</span> <span class="n">isneginf</span><span class="p">,</span> <span class="n">isposinf</span><span class="p">,</span>
  <span class="n">ldexp</span><span class="p">,</span> <span class="n">left_shift</span><span class="p">,</span> <span class="n">less</span><span class="p">,</span> <span class="n">less_equal</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">log10</span><span class="p">,</span> <span class="n">log1p</span><span class="p">,</span> <span class="n">log2</span><span class="p">,</span> <span class="n">logaddexp</span><span class="p">,</span> <span class="n">logaddexp2</span><span class="p">,</span>
  <span class="n">logical_and</span><span class="p">,</span> <span class="n">logical_not</span><span class="p">,</span> <span class="n">logical_or</span><span class="p">,</span> <span class="n">logical_xor</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">modf</span><span class="p">,</span>
  <span class="n">multiply</span><span class="p">,</span> <span class="n">negative</span><span class="p">,</span> <span class="n">nextafter</span><span class="p">,</span> <span class="n">not_equal</span><span class="p">,</span> <span class="n">positive</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rad2deg</span><span class="p">,</span> <span class="n">radians</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span>
  <span class="n">reciprocal</span><span class="p">,</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span> <span class="n">rint</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">signbit</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sinc</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span>
  <span class="n">square</span><span class="p">,</span> <span class="n">subtract</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">true_divide</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.util</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa: F401</span>
  <span class="n">_arraylike</span><span class="p">,</span> <span class="n">_broadcast_arrays</span><span class="p">,</span> <span class="n">_broadcast_to</span><span class="p">,</span> <span class="n">_check_arraylike</span><span class="p">,</span>
  <span class="n">_complex_elem_type</span><span class="p">,</span> <span class="n">_promote_args</span><span class="p">,</span> <span class="n">_promote_args_inexact</span><span class="p">,</span> <span class="n">_promote_dtypes</span><span class="p">,</span>
  <span class="n">_promote_dtypes_numeric</span><span class="p">,</span> <span class="n">_promote_dtypes_inexact</span><span class="p">,</span> <span class="n">_promote_shapes</span><span class="p">,</span>
  <span class="n">_register_stackable</span><span class="p">,</span> <span class="n">_stackable</span><span class="p">,</span> <span class="n">_where</span><span class="p">,</span> <span class="n">_wraps</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.vectorize</span> <span class="kn">import</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">jax._src.ops</span> <span class="kn">import</span> <span class="n">scatter</span>
<span class="kn">from</span> <span class="nn">jax._src.typing</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">DTypeLike</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">unzip2</span><span class="p">,</span> <span class="n">prod</span> <span class="k">as</span> <span class="n">_prod</span><span class="p">,</span> <span class="n">subvals</span><span class="p">,</span> <span class="n">safe_zip</span><span class="p">,</span>
                           <span class="n">ceil_of_ratio</span><span class="p">,</span> <span class="n">partition_list</span><span class="p">,</span>
                           <span class="n">canonicalize_axis</span> <span class="k">as</span> <span class="n">_canonicalize_axis</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.array</span> <span class="kn">import</span> <span class="n">ArrayImpl</span>

<span class="n">newaxis</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># Like core.canonicalize_shape, but also accept int-like (non-sequence)</span>
<span class="c1"># arguments for `shape`.</span>
<span class="k">def</span> <span class="nf">canonicalize_shape</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">],</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">Shape</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">((</span><span class="n">shape</span><span class="p">,),</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

<span class="c1"># Common docstring additions:</span>

<span class="n">_PRECISION_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">In addition to the original NumPy arguments listed below, also supports</span>
<span class="s2">``precision`` for extra control over matrix-multiplication precision</span>
<span class="s2">on supported devices. ``precision`` may be set to ``None``, which means</span>
<span class="s2">default precision for the backend, a :class:`~jax.lax.Precision` enum value</span>
<span class="s2">(``Precision.DEFAULT``, ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple</span>
<span class="s2">of two :class:`~jax.lax.Precision` enums indicating separate precision for each argument.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># Some objects below rewrite their __module__ attribute to this name.</span>
<span class="n">_PUBLIC_MODULE_NAME</span> <span class="o">=</span> <span class="s2">&quot;jax.numpy&quot;</span>

<span class="c1"># We replace some builtin names to follow Numpy&#39;s API, so we capture here.</span>
<span class="n">_abs</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">abs</span>
<span class="n">_all</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span>
<span class="n">_any</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span>
<span class="n">_max</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">max</span>
<span class="n">_min</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">min</span>
<span class="n">_sum</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">sum</span>
<span class="n">_divmod</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">divmod</span>

<span class="c1"># NumPy constants</span>

<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>
<span class="n">euler_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">euler_gamma</span>
<span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="n">NINF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>
<span class="n">PZERO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">PZERO</span>
<span class="n">NZERO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NZERO</span>
<span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="c1"># NumPy utility functions</span>

<span class="n">get_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span>
<span class="n">printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span>
<span class="n">set_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span>

<div class="viewcode-block" id="iscomplexobj"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.iscomplexobj.html#jax.numpy.iscomplexobj">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
  <span class="k">return</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">)</span></div>

<span class="n">shape</span> <span class="o">=</span> <span class="n">_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span>
<span class="n">ndim</span> <span class="o">=</span> <span class="n">_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span>
<span class="n">_dtype</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># At present JAX doesn&#39;t have a reason to distinguish between scalars and arrays</span>
<span class="c1"># in its object system. Further, we want JAX scalars to have the same type</span>
<span class="c1"># promotion behaviors as JAX arrays. Rather than introducing a new type of JAX</span>
<span class="c1"># scalar object with JAX promotion behaviors, instead we make the JAX scalar</span>
<span class="c1"># types return JAX arrays when instantiated.</span>

<span class="k">class</span> <span class="nc">_ScalarMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_make_scalar_type</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">):</span>
  <span class="n">meta</span> <span class="o">=</span> <span class="n">_ScalarMeta</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span>
                     <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">)})</span>
  <span class="n">meta</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">_PUBLIC_MODULE_NAME</span>
  <span class="k">return</span> <span class="n">meta</span>

<span class="n">bool_</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="n">uint8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">uint16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
<span class="n">uint32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">uint64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="n">int8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="n">int16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="n">int32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">int64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">bfloat16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">)</span>
<span class="n">float16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">float32</span> <span class="o">=</span> <span class="n">single</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">float64</span> <span class="o">=</span> <span class="n">double</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">complex64</span> <span class="o">=</span> <span class="n">csingle</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">complex128</span> <span class="o">=</span> <span class="n">cdouble</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

<span class="n">int_</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="k">else</span> <span class="n">int64</span>
<span class="n">uint</span> <span class="o">=</span> <span class="n">uint32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">uint</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span> <span class="k">else</span> <span class="n">uint64</span>
<span class="n">float_</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">float32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="k">else</span> <span class="n">float64</span>
<span class="n">complex_</span> <span class="o">=</span> <span class="n">complex64</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">complex_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span> <span class="k">else</span> <span class="n">complex128</span>

<span class="n">generic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span>
<span class="n">number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span>
<span class="n">inexact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span>
<span class="n">complexfloating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span>
<span class="n">floating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span>
<span class="n">integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span>
<span class="n">signedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span>
<span class="n">unsignedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span>

<span class="n">flexible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flexible</span>
<span class="n">character</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">character</span>
<span class="n">object_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

<span class="n">iinfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">iinfo</span>
<span class="n">finfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">finfo</span>

<span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">can_cast</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">can_cast</span>
<span class="n">issubsctype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubsctype</span>
<span class="n">promote_types</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">promote_types</span>

<span class="n">ComplexWarning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ComplexWarning</span>

<span class="n">array_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_str</span>
<span class="n">array_repr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span>

<span class="n">save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">save</span>
<span class="n">savez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">savez</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_jnp_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Similar to np.dtype, but respects JAX dtype defaults.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">python_scalar_dtypes</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">_DEFAULT_TYPEMAP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

<span class="c1">### utility functions</span>

<span class="n">_DEFAULT_TYPEMAP</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="n">bool_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">:</span> <span class="n">int_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">:</span> <span class="n">float_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">:</span> <span class="n">complex_</span>
<span class="p">}</span>

<span class="n">_lax_const</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_const</span>


<span class="k">def</span> <span class="nf">_result_dtype</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Compute result dtype of applying op to arguments with given dtypes.&quot;&quot;&quot;</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_convert_and_clip_integer</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Convert integer-typed val to specified integer dtype, clipping to dtype</span>
<span class="sd">  range rather than wrapping.</span>

<span class="sd">  Args:</span>
<span class="sd">    val: value to be converted</span>
<span class="sd">    dtype: dtype of output</span>

<span class="sd">  Returns:</span>
<span class="sd">    equivalent of val in new dtype</span>

<span class="sd">  Examples</span>
<span class="sd">  --------</span>
<span class="sd">  Normal integer type conversion will wrap:</span>

<span class="sd">  &gt;&gt;&gt; val = jnp.uint32(0xFFFFFFFF)</span>
<span class="sd">  &gt;&gt;&gt; val.astype(&#39;int32&#39;)</span>
<span class="sd">  DeviceArray(-1, dtype=int32)</span>

<span class="sd">  This function clips to the values representable in the new type:</span>

<span class="sd">  &gt;&gt;&gt; _convert_and_clip_integer(val, &#39;int32&#39;)</span>
<span class="sd">  DeviceArray(2147483647, dtype=int32)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;_convert_and_clip_integer only accepts integer dtypes.&quot;</span><span class="p">)</span>

  <span class="n">val_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">val_dtype</span> <span class="o">!=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
    <span class="c1"># TODO(jakevdp): this is a weird corner case; need to figure out how to handle it.</span>
    <span class="c1"># This happens in X32 mode and can either come from a jax value created in another</span>
    <span class="c1"># context, or a Python integer converted to int64.</span>
    <span class="k">pass</span>
  <span class="n">min_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_max</span><span class="p">(</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">))</span>
  <span class="n">max_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_min</span><span class="p">(</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">clip</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.load.html#jax.numpy.load">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="c1"># The main purpose of this wrapper is to recover bfloat16 data types.</span>
  <span class="c1"># Note: this will only work for files created via np.save(), not np.savez().</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="c1"># numpy does not recognize bfloat16, so arrays are serialized as void16</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;V2&#39;</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bfloat16</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Unsupported dtype</span>
      <span class="k">pass</span>
  <span class="k">return</span> <span class="n">out</span></div>

<span class="c1">### implementations of numpy functions in terms of lax</span>

<div class="viewcode-block" id="fmin"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fmin.html#jax.numpy.fmin">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">((</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="fmax"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fmax.html#jax.numpy.fmax">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">((</span><span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="issubdtype"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.issubdtype.html#jax.numpy.issubdtype">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span></div>

<div class="viewcode-block" id="isscalar"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.isscalar.html#jax.numpy.isscalar">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_python_scalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span></div>

<span class="n">iterable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span>

<div class="viewcode-block" id="result_type"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.result_type.html#jax.numpy.result_type">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="trapz"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.trapz.html#jax.numpy.trapz">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">y</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.trunc.html#jax.numpy.trunc">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;trunc&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_conv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">() only support 1-dimensional inputs.&quot;</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">: inputs cannot be empty, got shapes </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

  <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">conj</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
      <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;convolve&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be one of [&#39;full&#39;, &#39;same&#39;, &#39;valid&#39;]&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">conv_general_dilated</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                    <span class="n">padding</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_order</span><span class="p">]</span>


<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.convolve.html#jax.numpy.convolve">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;convolve&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="correlate"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.correlate.html#jax.numpy.correlate">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;correlate&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="histogram_bin_edges"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.histogram_bin_edges.html#jax.numpy.histogram_bin_edges">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">weights</span>  <span class="c1"># unused, because string bins is not supported.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;string values for `bins` not implemented.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram_bin_edges&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">bins</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span>
                                <span class="s2">&quot;bins argument of histogram_bin_edges&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">range</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`range` must be either None or a sequence of scalars.&quot;</span><span class="p">)</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
           <span class="n">where</span><span class="p">(</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="k">return</span> <span class="n">linspace</span><span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="histogram"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.histogram.html#jax.numpy.histogram">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights should have the same shape as a.&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ravel</span><span class="p">,</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

  <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">bin_widths</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">bin_edges</span></div>

<div class="viewcode-block" id="histogram2d"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.histogram2d.html#jax.numpy.histogram2d">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram2d&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">if</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">x_edges</span> <span class="o">=</span> <span class="n">y_edges</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">]</span>

  <span class="n">sample</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>
  <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="histogramdd"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.histogramdd.html#jax.numpy.histogramdd">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogramdd&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
    <span class="n">sample</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogramdd&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should have one weight for each sample.&quot;</span><span class="p">)</span>
    <span class="n">sample</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
  <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
      <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">!=</span> <span class="n">D</span> <span class="ow">or</span> <span class="n">_any</span><span class="p">(</span><span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For sample.shape=</span><span class="si">{</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span><span class="si">}</span><span class="s2">, range must be a sequence &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s2"> pairs or Nones; got range=</span><span class="si">{</span><span class="nb">range</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_bins</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should be a bin for each dimension.&quot;</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="c1"># when bin_size is integer, the same bin is used for each dimension</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="n">bins</span><span class="p">]</span>

  <span class="n">bin_idx_by_dim</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">bin_edges_by_dim</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
  <span class="n">dedges</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
    <span class="n">range_i</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">range</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">range_i</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
    <span class="n">bin_idx_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_idx</span>
    <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">bin_edges_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span>
    <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">bin_edges_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

  <span class="n">xy</span> <span class="o">=</span> <span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">bin_idx_by_dim</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">nbins</span><span class="o">.</span><span class="n">prod</span><span class="p">())</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
  <span class="n">core</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">core</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">/=</span> <span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">dedges</span><span class="p">):</span>
      <span class="n">hist</span> <span class="o">/=</span> <span class="n">norm</span>

  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges_by_dim</span></div>


<span class="n">_ARRAY_VIEW_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The JAX version of this function may in some cases return a copy rather than a</span>
<span class="s2">view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="transpose"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.transpose.html#jax.numpy.transpose">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span></div>


<div class="viewcode-block" id="rot90"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.rot90.html#jax.numpy.rot90">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;axes&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;rot90&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="n">ax1</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="n">ax2</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ax1</span> <span class="o">==</span> <span class="n">ax2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">4</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">m</span>
  <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax1</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax2</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span></div>


<div class="viewcode-block" id="flip"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.flip.html#jax.numpy.flip">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">_ensure_optional_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;flip&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)))))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">])</span>


<div class="viewcode-block" id="fliplr"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fliplr.html#jax.numpy.fliplr">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="flipud"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.flipud.html#jax.numpy.flipud">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="iscomplex"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.iscomplex.html#jax.numpy.iscomplex">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="isreal"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.isreal.html#jax.numpy.isreal">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.angle.html#jax.numpy.angle">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">im</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
      <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">degrees</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="n">deg</span> <span class="k">else</span> <span class="n">result</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diff.html#jax.numpy.diff">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;&#39;n&#39; argument of jnp.diff&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.diff&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order must be non-negative but got </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;diff requires input that is at least one dimensional; got </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

  <span class="n">combined</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="n">prepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">prepend</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">prepend</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">prepend</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">prepend</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>

  <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">append</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">append</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

  <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">slice1_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
  <span class="n">slice2_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>

  <span class="n">op</span> <span class="o">=</span> <span class="n">not_equal</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">subtract</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">slice1_tuple</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">slice2_tuple</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">a</span></div>

<span class="n">_EDIFF1D_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike NumPy&#39;s implementation of ediff1d, :py:func:`jax.numpy.ediff1d` will not</span>
<span class="s2">issue an error if casting ``to_end`` or ``to_begin`` to the type of ``ary``</span>
<span class="s2">loses precision.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ediff1d"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ediff1d.html#jax.numpy.ediff1d">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_EDIFF1D_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">)</span>
  <span class="n">ary</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ary</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">to_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_begin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">result</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">to_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">to_end</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_end</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="gradient"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.gradient.html#jax.numpy.gradient">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;edge_order&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;edge_order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">edge_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">edge_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;edge_order&#39; argument to jnp.gradient is not supported.&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">sliced</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">a_grad</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>  <span class="c1"># upper edge</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># inner</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>  <span class="c1"># lower edge</span>
    <span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_grad</span> <span class="o">/</span> <span class="n">h</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">f</span>
  <span class="n">axis_tuple</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Give `axis` either as int or iterable&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[]</span>
    <span class="n">axis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">_min</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis_tuple</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of array too small to calculate &quot;</span>
                     <span class="s2">&quot;a numerical gradient, &quot;</span>
                     <span class="s2">&quot;at least 2 elements are required.&quot;</span><span class="p">)</span>
  <span class="n">len_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">varargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># no spacing</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len_axes</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># single value for all axes</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">len_axes</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">len_axes</span><span class="p">:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid number of spacing arguments </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-constant spacing not implemented&quot;</span><span class="p">)</span>

  <span class="c1"># TODO: use jax.lax loop tools if possible</span>
  <span class="n">a_grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">,</span> <span class="n">dx</span><span class="p">)]</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">a_grad</span> <span class="o">=</span> <span class="n">a_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">a_grad</span></div>


<div class="viewcode-block" id="isrealobj"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.isrealobj.html#jax.numpy.isrealobj">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isrealobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.reshape.html#jax.numpy.reshape">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># forward to method for ndarrays</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_compute_newshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Fixes a -1 value in newshape, if present.&quot;&quot;&quot;</span>
  <span class="c1"># other errors, like having more than one -1, are caught downstream, in</span>
  <span class="c1"># reshape_shape_rule.</span>
  <span class="k">try</span><span class="p">:</span> <span class="nb">iter</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span>
  <span class="k">except</span><span class="p">:</span> <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">newshape</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">newshape</span> <span class="k">if</span> <span class="n">iterable</span> <span class="k">else</span> <span class="p">[</span><span class="n">newshape</span><span class="p">])</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">-</span> <span class="n">core</span><span class="o">.</span><span class="n">divide_shape_sizes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">newshape</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">d</span>
               <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">newshape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="n">newshape</span> <span class="o">=</span> <span class="n">_compute_newshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;np.reshape order=A is not implemented.&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected value for &#39;order&#39; argument: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

<div class="viewcode-block" id="ravel"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ravel.html#jax.numpy.ravel">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ravel&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Ravel not implemented for order=&#39;K&#39;.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">),),</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="ravel_multi_index"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ravel_multi_index.html#jax.numpy.ravel_multi_index">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel_multi_index</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(multi_index)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> != len(dims)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;in `dims` argument of ravel_multi_index().&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ravel_multi_index&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
  <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_index</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multi_index</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
        <span class="s2">&quot;The error occurred because ravel_multi_index was jit-compiled&quot;</span>
        <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only int indices permitted&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="nb">any</span><span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in coordinates array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2">. Expected &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid order=</span><span class="si">{</span><span class="n">order</span><span class="si">!r}</span><span class="s2">. Expected &#39;C&#39; or &#39;F&#39;&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">(</span><span class="n">multi_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">multi_index</span>
                           <span class="k">else</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">)))</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span></div>


<span class="n">_UNRAVEL_INDEX_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy&#39;s implementation of unravel_index, negative indices are accepted</span>
<span class="s2">and out-of-bounds indices are clipped into the valid range.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="unravel_index"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.unravel_index.html#jax.numpy.unravel_index">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_UNRAVEL_INDEX_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;unravel_index&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="c1"># Note: we do not convert shape to an array, because it may be passed as a</span>
  <span class="c1"># tuple of weakly-typed values, and asarray() would strip these weak types.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unravel_index: shape should be a scalar or 1D sequence.&quot;</span><span class="p">)</span>
  <span class="n">out_indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
    <span class="n">indices</span><span class="p">,</span> <span class="n">out_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">oob_pos</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">oob_neg</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">oob_pos</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">where</span><span class="p">(</span><span class="n">oob_neg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
               <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">out_indices</span><span class="p">))</span></div>

<div class="viewcode-block" id="resize"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.resize.html#jax.numpy.resize">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;new_shape&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;resize&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">dim_length</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">dim_length</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all elements of `new_shape` must be non-negative&quot;</span><span class="p">)</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="n">new_size</span> <span class="o">=</span> <span class="n">_prod</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>

  <span class="n">repeats</span> <span class="o">=</span> <span class="n">ceil_of_ratio</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">)[:</span><span class="n">new_size</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.squeeze.html#jax.numpy.squeeze">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.expand_dims.html#jax.numpy.expand_dims">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;expand_dims&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;expand_dims&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.swapaxes.html#jax.numpy.swapaxes">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span></div>


<div class="viewcode-block" id="moveaxis"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.moveaxis.html#jax.numpy.moveaxis">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
             <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
  <span class="k">return</span> <span class="n">_moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                   <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">destination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;moveaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">source</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">source</span><span class="p">)</span>
  <span class="n">destination</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">destination</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent number of elements: </span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination</span><span class="p">)))</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)):</span>
    <span class="n">perm</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>


<div class="viewcode-block" id="isclose"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.isclose.html#jax.numpy.isclose">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;equal_nan&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;isclose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">_complex_elem_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">atol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
    <span class="c1"># This corrects the comparisons for infinite and nan values</span>
    <span class="n">a_inf</span> <span class="o">=</span> <span class="n">isinf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_inf</span> <span class="o">=</span> <span class="n">isinf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_inf</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="n">both_inf</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="c1"># Make all elements where either a or b are infinite to False</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">logical_not</span><span class="p">(</span><span class="n">any_inf</span><span class="p">))</span>
    <span class="c1"># Make all elements where both a or b are the same inf to True</span>
    <span class="n">same_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">same_inf</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">both_inf</span><span class="p">,</span> <span class="n">same_value</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">same_inf</span><span class="p">)</span>

    <span class="c1"># Make all elements where either a or b is NaN to False</span>
    <span class="n">a_nan</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_nan</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_nan</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">logical_not</span><span class="p">(</span><span class="n">any_nan</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
      <span class="c1"># Make all elements where both a and b is NaN to True</span>
      <span class="n">both_nan</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">both_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.interp.html#jax.numpy.interp">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;interp&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xp and fp must be one-dimensional arrays of equal size&quot;</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">)</span>
  <span class="n">fp</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.interp: complex x values not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;period must be a scalar; got </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">period</span><span class="p">])</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">df</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">dx</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">delta</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

  <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
  <span class="n">dx0</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span>  <span class="c1"># Prevent NaN gradients when `dx` is small.</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">dx0</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">where</span><span class="p">(</span><span class="n">dx0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">left</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">right</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.where.html#jax.numpy.where">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    At present, JAX does not support JIT-compilation of the single-argument form</span>
<span class="s2">    of :py:func:`jax.numpy.where` because its output shape is data-dependent. The</span>
<span class="s2">    three-argument form does not have a data-dependent shape and can be JIT-compiled</span>
<span class="s2">    successfully. Alternatively, you can use the optional ``size`` keyword to</span>
<span class="s2">    statically specify the expected size of the output.&quot;&quot;&quot;</span><span class="p">),</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    size : int, optional</span>
<span class="s2">        Only referenced when ``x`` and ``y`` are ``None``. If specified, the indices of the first</span>
<span class="s2">        ``size`` elements of the result will be returned. If there are fewer elements than ``size``</span>
<span class="s2">        indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">    fill_value : array_like, optional</span>
<span class="s2">        When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size and fill_value arguments cannot be used in three-term where function.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="select"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.select.html#jax.numpy.select">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;condlist must have length equal to choicelist (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">)&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condlist must be non-empty&quot;</span><span class="p">)</span>
  <span class="n">choices</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>
  <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="bincount"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.bincount.html#jax.numpy.bincount">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Jax adds the optional `length` parameter which specifies the output length, and</span>
<span class="s2">defaults to ``x.max() + 1``. It must be specified for bincount to be compiled</span>
<span class="s2">with non-static operands. Values larger than the specified length will be discarded.</span>
<span class="s2">If `length` is specified, `minlength` will be ignored.</span>

<span class="s2">Additionally, while ``np.bincount`` raises an error if the input array contains</span>
<span class="s2">negative values, ``jax.numpy.bincount`` clips negative values to zero.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;bincount&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;x argument to bincount must have an integer type; got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only 1-dimensional input supported.&quot;</span><span class="p">)</span>
  <span class="n">minlength</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">minlength</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because of argument &#39;minlength&#39; of jnp.bincount.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because of argument &#39;x&#39; of jnp.bincount. &quot;</span>
      <span class="s2">&quot;To avoid this error, pass a static `length` argument.&quot;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="n">minlength</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
        <span class="s2">&quot;The error occurred because of argument &#39;length&#39; of jnp.bincount.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int_</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of weights must match shape of x.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="broadcast_shapes"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.broadcast_shapes.html#jax.numpy.broadcast_shapes">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;broadcast_shapes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">()</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span></div>


<span class="n">broadcast_arrays</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The JAX version does not necessarily return a view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)(</span><span class="n">_broadcast_arrays</span><span class="p">)</span>


<span class="n">broadcast_to</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The JAX version does not necessarily return a view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)(</span><span class="n">_broadcast_to</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">)</span>
  <span class="n">ary</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument `axis`&quot;</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span>
  <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span>
        <span class="n">indices_or_sections</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                                 <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
    <span class="n">part_size</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_divmod</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indices_or_sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;array_split&quot;</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
          <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
           <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indices_or_sections</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span>
           <span class="o">+</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array split does not result in an equal division&quot;</span><span class="p">)</span>
  <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">ary</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">_subval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">subvals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)])</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">_subval</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="n">_subval</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">split_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">split_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.split.html#jax.numpy.split">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_split_on_axis</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">op</span><span class="p">),</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f</span>

<span class="n">vsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;vsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">hsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;hsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;dsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="array_split"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.array_split.html#jax.numpy.array_split">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;array_split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.clip.html#jax.numpy.clip">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.clip is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At most one of a_min and a_max may be None&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">a_max</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.round.html#jax.numpy.round">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;decimals&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">decimals</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="s2">&quot;&#39;decimals&#39; argument of jnp.round&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.round is not supported.&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;integer np.round not implemented for decimals &lt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>  <span class="c1"># no-op on integer types</span>

  <span class="k">def</span> <span class="nf">_round_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">)</span>

    <span class="c1"># TODO(phawkins): the strategy of rescaling the value isn&#39;t necessarily a</span>
    <span class="c1"># good one since we may be left with an incorrectly rounded value at the</span>
    <span class="c1"># end due to precision problems. As a workaround for float16, convert to</span>
    <span class="c1"># float32,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">decimals</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">factor</span><span class="p">),</span>
                            <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">),</span> <span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">out</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>
<span class="n">around</span> <span class="o">=</span> <span class="nb">round</span>
<span class="n">round_</span> <span class="o">=</span> <span class="nb">round</span>


<div class="viewcode-block" id="fix"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fix.html#jax.numpy.fix">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;fix&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.fix is not supported.&quot;</span><span class="p">)</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<div class="viewcode-block" id="nan_to_num"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nan_to_num.html#jax.numpy.nan_to_num">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">copy</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nan_to_num&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">),</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">))</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">posinf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">posinf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">posinf</span>
  <span class="n">neginf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="n">neginf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">neginf</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isposinf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">posinf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isneginf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">neginf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="allclose"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.allclose.html#jax.numpy.allclose">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;equal_nan&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;allclose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">))</span></div>


<span class="n">_NONZERO_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because the size of the output of ``nonzero`` is data-dependent, the function is not</span>
<span class="s2">typically compatible with JIT. The JAX version adds the optional ``size`` argument which</span>
<span class="s2">must be specified statically for ``jnp.nonzero`` to be used within some of JAX&#39;s</span>
<span class="s2">transformations.</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">_NONZERO_EXTRA_PARAMS</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">size : int, optional</span>
<span class="s2">    If specified, the indices of the first ``size`` True elements will be returned. If there are</span>
<span class="s2">    fewer unique elements than ``size`` indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">fill_value : array_like, optional</span>
<span class="s2">    When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">    remaining elements will be filled with ``fill_value``, which defaults to zero.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nonzero.html#jax.numpy.nonzero">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NONZERO_DOC</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="n">_NONZERO_EXTRA_PARAMS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nonzero&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
    <span class="s2">&quot;The size argument of jnp.nonzero must be statically specified &quot;</span>
    <span class="s2">&quot;to use jnp.nonzero within JAX transformations.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">flat_indices</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">bincount</span><span class="p">(</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="n">size</span><span class="p">))</span>
  <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int_</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">flat_indices</span> <span class="o">//</span> <span class="n">stride</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span> <span class="k">for</span> <span class="n">stride</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="n">fill_value</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">_shape</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">,):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fill_value must be a scalar or a tuple of length </span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">fill_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fill_mask</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">fill_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">fval</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="flatnonzero"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.flatnonzero.html#jax.numpy.flatnonzero">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NONZERO_DOC</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="n">_NONZERO_EXTRA_PARAMS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flatnonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="unwrap"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.unwrap.html#jax.numpy.unwrap">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;unwrap&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.unwrap does not support complex inputs.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">discont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">discont</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">interval</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">+</span> <span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span> <span class="o">-</span> <span class="n">interval</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">where</span><span class="p">((</span><span class="n">ddmod</span> <span class="o">==</span> <span class="o">-</span><span class="n">interval</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">interval</span><span class="p">,</span> <span class="n">ddmod</span><span class="p">)</span>

  <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span><span class="p">)</span>

  <span class="n">up</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">up</span></div>


<span class="c1">### Array-creation functions</span>

<span class="k">def</span> <span class="nf">_check_no_padding</span><span class="p">(</span><span class="n">axis_padding</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">axis_padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis_padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot apply &#39;</span><span class="si">{}</span><span class="s2">&#39; padding to empty axis&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">constant_values</span><span class="p">),</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
      <span class="n">constant_values</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="n">left_remainder</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">)</span> <span class="o">=</span> <span class="n">_divmod</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">total_repeats</span> <span class="o">=</span> <span class="n">repeats</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">left_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">left_remainder</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">parts</span> <span class="o">+=</span> <span class="n">total_repeats</span> <span class="o">*</span> <span class="p">[</span><span class="n">array</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">reflect_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;reflect&quot;</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">before</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

      <span class="k">while</span> <span class="n">padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_pad</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">-=</span> <span class="n">curr_pad</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">curr_pad</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">curr_pad</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;symmetric&quot;</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reflect_type</span> <span class="o">==</span> <span class="s1">&#39;odd&#39;</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge</span> <span class="o">-</span> <span class="n">x</span>
          <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">array</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">array</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">array</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">end_values</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ramp_before</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_before</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>
    <span class="n">ramp_before</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">ramp_before</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_after</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">ramp_after</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="c1"># Reverse linear space in appropriate dimension</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">ramp_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ramp_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">ramp_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">stat_func</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_before</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">array_length</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">length_before</span><span class="p">,</span> <span class="n">length_after</span> <span class="o">=</span> <span class="n">stat_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">length_before</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">length_after</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stat_length of 0 yields no value for padding&quot;</span><span class="p">)</span>

      <span class="c1"># Limit stat_length to length of array.</span>
      <span class="n">length_before</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">length_before</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>
      <span class="n">length_after</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">length_after</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>

      <span class="n">slice_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="n">length_after</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_before</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_after</span><span class="p">)</span>

    <span class="n">stat_before</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">stat_before</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
    <span class="n">stat_after</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">stat_after</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="c1"># Note: jax.numpy.empty = jax.numpy.zeros</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">shape_before</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape_before</span><span class="p">)</span>

    <span class="n">shape_after</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape_after</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">padded</span> <span class="o">=</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">padded</span><span class="p">)):</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">padded</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">padded</span>


<span class="k">def</span> <span class="nf">_broadcast_to_pairs</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tree_map</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> argument of jnp.pad&quot;</span><span class="p">),</span>
    <span class="n">nvals</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">nvals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">` entries must be the same shape.&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before_1, after_1), ..., (before_N, after_N))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nval</span><span class="p">)</span> <span class="k">for</span> <span class="n">nval</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before, after),)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
    <span class="c1"># (before, after)  (not in the numpy docstring but works anyway)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
    <span class="c1"># (pad,)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
    <span class="c1"># pad</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">nvals</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nvals</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jnp.pad: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with nd=</span><span class="si">{</span><span class="n">nd</span><span class="si">}</span><span class="s2"> has unsupported shape </span><span class="si">{</span><span class="n">nvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;Valid shapes are (</span><span class="si">{</span><span class="n">nd</span><span class="si">}</span><span class="s2">, 2), (1, 2), (2,), (1,), or ().&quot;</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">end_values</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">):</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span>

  <span class="n">stat_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">amax</span><span class="p">,</span> <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">amin</span><span class="p">,</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">median</span><span class="p">}</span>

  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">pad_width</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pad_width</span>

  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pad_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index can&#39;t contain negative values&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear_ramp&quot;</span><span class="p">:</span>
    <span class="n">end_values</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">end_values</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;end_values&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">end_values</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_length</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">stat_length</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;stat_length&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">stat_funcs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Should not be reached since pad already handled unsupported and&quot;</span>
                   <span class="s2">&quot;not implemented modes&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.pad.html#jax.numpy.pad">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy, JAX &quot;function&quot; mode&#39;s argument (which is another function) should return</span>
<span class="s2">the modified array. This is because Jax arrays are immutable.</span>
<span class="s2">(In numpy, &quot;function&quot; mode&#39;s argument should modify a rank 1 array in-place.)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">pad_width</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`pad_width` must be of integral type.&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="n">allowed_kwargs</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;empty&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="p">[],</span>
      <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;constant_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;linear_ramp&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
      <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
  <span class="p">}</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">unsupported_kwargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">allowed_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
  <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unimplemented padding mode &#39;</span><span class="si">{}</span><span class="s2">&#39; for np.pad.&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">unsupported_kwargs</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unsupported keyword arguments for mode &#39;</span><span class="si">{}</span><span class="s2">&#39;: </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">unsupported_kwargs</span><span class="p">))</span>
  <span class="c1"># Set default value if not given.</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;constant_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">stat_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stat_length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">end_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">reflect_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">end_values</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.stack.html#jax.numpy.stack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to stack.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.stack is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arrays</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_stackable</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">shape0</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_arrays</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All input arrays must have the same shape.&quot;</span><span class="p">)</span>
      <span class="n">new_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">new_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="tile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.tile.html#jax.numpy.tile">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nb">iter</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,)</span>
  <span class="n">reps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">else</span> <span class="n">rep</span>
               <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">)</span>
  <span class="n">A_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
  <span class="n">reps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span> <span class="o">+</span> <span class="n">reps</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A_shape</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]),</span>
                        <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">A_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">A_shape</span><span class="p">,</span> <span class="n">reps</span><span class="p">)))</span></div>

<span class="k">def</span> <span class="nf">_concatenate_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># Fast path for concatenation when the input is an ndarray rather than a list.</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to concatenate.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">size</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>

<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.concatenate.html#jax.numpy.concatenate">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">_concatenate_array</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">_stackable</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;concatenate&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to concatenate.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;concatenate&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
  <span class="c1"># lax.concatenate can be slow to compile for wide concatenations, so form a</span>
  <span class="c1"># tree of concatenations as a workaround especially for op-by-op mode.</span>
  <span class="c1"># (https://github.com/google/jax/issues/653).</span>
  <span class="n">k</span> <span class="o">=</span> <span class="mi">16</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span> <span class="n">k</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="vstack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.vstack.html#jax.numpy.vstack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_2d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>
<span class="n">row_stack</span> <span class="o">=</span> <span class="n">vstack</span>


<div class="viewcode-block" id="hstack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.hstack.html#jax.numpy.hstack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
    <span class="n">arr0_ndim</span> <span class="o">=</span> <span class="n">arrs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
    <span class="n">arr0_ndim</span> <span class="o">=</span> <span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="n">arr0_ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="dstack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.dstack.html#jax.numpy.dstack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dstack</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_3d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="column_stack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.column_stack.html#jax.numpy.column_stack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">column_stack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span> <span class="k">if</span> <span class="n">tup</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">tup</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">arr</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">tup</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="choose"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.choose.html#jax.numpy.choose">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.choose is not supported.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`a` array must be integer typed&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because jnp.choose was jit-compiled&quot;</span>
      <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in choice array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">N</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2"> not understood. Must be &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">choices</span><span class="p">)[(</span><span class="n">a</span><span class="p">,)</span> <span class="o">+</span> <span class="n">indices</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span></div>


<span class="k">def</span> <span class="nf">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">_block</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow tuples, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow empty list arguments&quot;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">depths</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">([</span><span class="n">_block</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatched list depths in jax.numpy.block&quot;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_max</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">))</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="mi">1</span>

<div class="viewcode-block" id="block"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.block.html#jax.numpy.block">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
  <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_block</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="atleast_1d"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.atleast_1d.html#jax.numpy.atleast_1d">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span></div>


<div class="viewcode-block" id="atleast_2d"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.atleast_2d.html#jax.numpy.atleast_2d">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span></div>


<div class="viewcode-block" id="atleast_3d"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.atleast_3d.html#jax.numpy.atleast_3d">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_3d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span></div>


<span class="n">_ARRAY_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This function will create arrays on JAX&#39;s default device. For control of the</span>
<span class="s2">device placement of data, see :func:`jax.device_put`. More information is</span>
<span class="s2">available in the JAX FAQ at :ref:`faq-data-placement` (full FAQ at</span>
<span class="s2">https://jax.readthedocs.io/en/latest/faq.html).</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="array"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.array.html#jax.numpy.array">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="nb">object</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
          <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="n">ndmin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">!=</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only implemented for order=&#39;K&#39;&quot;</span><span class="p">)</span>

  <span class="c1"># check if the given dtype is compatible with JAX</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">)</span>

  <span class="c1"># Here we make a judgment call: we only return a weakly-typed array when the</span>
  <span class="c1"># input object itself is weakly typed. That ensures asarray(x) is a no-op</span>
  <span class="c1"># whenever x is weak, but avoids introducing weak types with something like</span>
  <span class="c1"># array([1, 2, 3])</span>
  <span class="n">weak_type</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

  <span class="c1"># For Python scalar literals, call coerce_to_array to catch any overflow</span>
  <span class="c1"># errors. We don&#39;t use dtypes.is_python_scalar because we don&#39;t want this</span>
  <span class="c1"># triggering for traced values. We do this here because it matters whether or</span>
  <span class="c1"># not dtype is None. We don&#39;t assign the result because we want the raw object</span>
  <span class="c1"># to be used for type inference below.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">coerce_to_array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="nb">object</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">leaf</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="s2">&quot;__jax_array__&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">leaf</span><span class="p">,</span>
                    <span class="nb">object</span><span class="p">)</span>
  <span class="n">leaves</span> <span class="o">=</span> <span class="n">tree_leaves</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Use lattice_result_type rather than result_type to avoid canonicalization.</span>
    <span class="c1"># Otherwise, weakly-typed inputs would have their dtypes canonicalized.</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_lattice_result_type</span><span class="p">(</span><span class="o">*</span><span class="n">leaves</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">leaves</span> <span class="k">else</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="c1"># This happens if, e.g. one of the entries is a memoryview object.</span>
      <span class="c1"># This is rare, so we only handle it if the normal path fails.</span>
      <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">_convert_to_array_if_dtype_fails</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_lattice_result_type</span><span class="p">(</span><span class="o">*</span><span class="n">leaves</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">weak_type</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

  <span class="c1"># We can&#39;t use the ndarray class because we need to handle internal buffers</span>
  <span class="c1"># (See https://github.com/google/jax/issues/8950)</span>
  <span class="n">ndarray_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">ArrayImpl</span><span class="p">)</span>

  <span class="n">out</span><span class="p">:</span> <span class="n">ArrayLike</span>

  <span class="k">if</span> <span class="n">_all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ndarray_types</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">):</span>
    <span class="c1"># TODO(jakevdp): falling back to numpy here fails to overflow for lists</span>
    <span class="c1"># containing large integers; see discussion in</span>
    <span class="c1"># https://github.com/google/jax/pull/6047. More correct would be to call</span>
    <span class="c1"># coerce_to_array on each leaf, but this may have performance implications.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">ndarray_types</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">object</span><span class="o">.</span><span class="n">aval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_array_copy</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="nb">object</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="k">if</span> <span class="nb">object</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">stack</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">object</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">view</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">pass</span>  <span class="c1"># `object` does not support the buffer interface.</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected input type for array: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">out_array</span><span class="p">:</span> <span class="n">Array</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndmin</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out_array</span><span class="p">):</span>
    <span class="n">out_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">out_array</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndmin</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out_array</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">out_array</span></div>


<span class="k">def</span> <span class="nf">_convert_to_array_if_dtype_fails</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="asarray"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.asarray.html#jax.numpy.asarray">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;asarray&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="copy"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.copy.html#jax.numpy.copy">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.zeros_like.html#jax.numpy.zeros_like">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;zeros_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ones_like.html#jax.numpy.ones_like">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ones_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.empty_like.html#jax.numpy.empty_like">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because XLA cannot create uninitialized arrays, the JAX version will</span>
<span class="s2">return an array initialized with zeros.&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;empty_like&quot;</span><span class="p">,</span> <span class="n">prototype</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;empty_like&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="full"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.full.html#jax.numpy.full">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shape</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.full_like.html#jax.numpy.full_like">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full_like&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;full_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">shape</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="zeros"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.zeros.html#jax.numpy.zeros">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros&quot;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ones.html#jax.numpy.ones">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>


<div class="viewcode-block" id="empty"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.empty.html#jax.numpy.empty">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because XLA cannot create uninitialized arrays, the JAX version will</span>
<span class="s2">return an array initialized with zeros.&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="array_equal"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.array_equal.html#jax.numpy.array_equal">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a2</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="n">eq</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span></div>


<div class="viewcode-block" id="array_equiv"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.array_equiv.html#jax.numpy.array_equiv">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equiv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="c1"># shapes are not broadcastable</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span></div>


<span class="c1"># General np.from* style functions mostly delegate to numpy.</span>

<div class="viewcode-block" id="frombuffer"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.frombuffer.html#jax.numpy.frombuffer">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">frombuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">))</span></div>


<div class="viewcode-block" id="fromfile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fromfile.html#jax.numpy.fromfile">[docs]</a><span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromfile.</span>

<span class="sd">  This function is left deliberately unimplemented because it may be non-pure and thus</span>
<span class="sd">  unsafe for use with JIT and other JAX transformations. Consider using</span>
<span class="sd">  ``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile``</span>
<span class="sd">  is used within jax transformations because of its potential side-effect of consuming the</span>
<span class="sd">  file object; for more information see `Common Gotchas: Pure Functions</span>
<span class="sd">  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
    <span class="s2">&quot;jnp.fromfile() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s2">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromfile(...)) &quot;</span>
    <span class="s2">&quot;instead, although care should be taken if np.fromfile is used within a jax transformations &quot;</span>
    <span class="s2">&quot;because of its potential side-effect of consuming the file object; for more information see &quot;</span>
    <span class="s2">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fromiter"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fromiter.html#jax.numpy.fromiter">[docs]</a><span class="k">def</span> <span class="nf">fromiter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromiter.</span>

<span class="sd">  This function is left deliberately unimplemented because it may be non-pure and thus</span>
<span class="sd">  unsafe for use with JIT and other JAX transformations. Consider using</span>
<span class="sd">  ``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter``</span>
<span class="sd">  is used within jax transformations because of its potential side-effect of consuming the</span>
<span class="sd">  iterable object; for more information see `Common Gotchas: Pure Functions</span>
<span class="sd">  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
    <span class="s2">&quot;jnp.fromiter() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s2">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromiter(...)) &quot;</span>
    <span class="s2">&quot;instead, although care should be taken if np.fromiter is used within a jax transformations &quot;</span>
    <span class="s2">&quot;because of its potential side-effect of consuming the iterable object; for more information see &quot;</span>
    <span class="s2">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="from_dlpack"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.from_dlpack.html#jax.numpy.from_dlpack">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;from_dlpack&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="kn">from</span> <span class="nn">jax.dlpack</span> <span class="kn">import</span> <span class="n">from_dlpack</span>  <span class="c1"># pylint: disable=g-import-not-at-top</span>
  <span class="k">return</span> <span class="n">from_dlpack</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__dlpack__</span><span class="p">())</span></div>

<div class="viewcode-block" id="fromfunction"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fromfunction.html#jax.numpy.fromfunction">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fromfunction</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;shape argument of jnp.fromfunction()&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)):</span>
    <span class="n">in_axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))]</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">in_axes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
  <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="fromstring"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.fromstring.html#jax.numpy.fromstring">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sep</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">))</span></div>


<div class="viewcode-block" id="eye"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.eye.html#jax.numpy.eye">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;eye&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;&#39;N&#39; argument of jnp.eye()&quot;</span><span class="p">)</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">N</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_dim</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s2">&quot;&#39;M&#39; argument of jnp.eye()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative dimensions are not allowed, got </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_eye</span><span class="p">(</span><span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.identity.html#jax.numpy.identity">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;identity&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="arange"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.arange.html#jax.numpy.arange">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">DimSize</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">DimSize</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">DimSize</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;arange&quot;</span><span class="p">)</span>
  <span class="n">require</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;It arose in jax.numpy.arange argument `</span><span class="si">{}</span><span class="s2">`.&quot;</span><span class="o">.</span><span class="n">format</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">is_special_dim_size</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
          <span class="s2">&quot;jax.numpy.arange supports non-constant arguments only in single-argument form. &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;Found jax.numpy.arange(start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, stop=</span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">, step=</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">int_</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">and</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractBInt</span><span class="p">)</span> <span class="ow">and</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">core</span><span class="o">.</span><span class="n">ConcreteArray</span><span class="p">)):</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># note using jnp here</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">BInt</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractBInt</span><span class="p">)):</span>
      <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">))</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">))</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">require</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">))</span>
    <span class="n">step</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">require</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Adapts `f` to return a DeviceArray instead of an np.ndarray.</span>

<span class="sd">  `f` cannot have any non-static array arguments.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the error occurred in argument </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the error occurred in argument &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="linspace"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.linspace.html#jax.numpy.linspace">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.linspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.linspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;retstep&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of linspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;linspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of samples, </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2">, must be non-negative.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;linspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>

  <span class="n">bounds_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
  <span class="n">broadcast_start</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">broadcast_stop</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>
  <span class="n">bounds_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">num</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">computation_dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
    <span class="n">iota_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span>
    <span class="n">iota_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span>
    <span class="c1"># This approach recovers the endpoints with float32 arithmetic,</span>
    <span class="c1"># but can lead to rounding errors for integer outputs.</span>
    <span class="n">real_dtype</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">real_dtype</span><span class="p">,</span> <span class="n">div</span><span class="p">),</span> <span class="n">iota_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">step</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span>
      <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">endpoint</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">broadcast_stop</span><span class="p">,</span> <span class="p">(</span><span class="n">axis</span><span class="p">,))],</span>
                            <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

  <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">nan</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># num == 0 degenerate case, match numpy behavior</span>
    <span class="n">empty_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
    <span class="n">empty_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">nan</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">empty_shape</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">retstep</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span> <span class="n">delta</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="logspace"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.logspace.html#jax.numpy.logspace">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.logspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.logspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of logspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;logspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;logspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">lin</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
                 <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">lin</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="geomspace"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.geomspace.html#jax.numpy.geomspace">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.geomspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.geomspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of geomspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;geomspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;geomspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="c1"># follow the numpy geomspace convention for negative and complex endpoints</span>
  <span class="n">signflip</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">signflip</span> <span class="o">=</span> <span class="n">signflip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">signflip</span> <span class="o">*</span> <span class="n">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">stop</span><span class="p">),</span> <span class="n">num</span><span class="p">,</span>
                            <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.meshgrid.html#jax.numpy.meshgrid">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;meshgrid&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">xi</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.meshgrid only supports copy=True&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;ij&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid values for indexing are &#39;xy&#39; and &#39;ij&#39;, got </span><span class="si">{</span><span class="n">indexing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.meshgrid must be 1D, got shapes &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">_a_shape</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_a_shape</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="i0"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.i0.html#jax.numpy.i0">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x_orig</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;i0&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported input type to jax.numpy.i0: </span><span class="si">{</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x_orig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">bessel_i0e</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<div class="viewcode-block" id="ix_"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.ix_.html#jax.numpy.ix_">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ix&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Arguments to jax.numpy.ix_ must be 1-dimensional, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;Boolean arguments to jax.numpy.ix_ are not implemented&quot;</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Numpy uses an integer index type for empty arrays.</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="indices"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.indices.html#jax.numpy.indices">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;dimensions argument of jnp.indices&quot;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">dimensions</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">output</span> <span class="k">else</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<span class="n">_TOTAL_REPEAT_LENGTH_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">JAX adds the optional `total_repeat_length` parameter which specifies the total</span>
<span class="s2">number of repeat, and defaults to sum(repeats). It must be specified for repeat</span>
<span class="s2">to be compilable. If `sum(repeats)` is larger than the specified</span>
<span class="s2">`total_repeat_length` the remaining values will be discarded. In the case of</span>
<span class="s2">`sum(repeats)` being smaller than the specified target length, the final value</span>
<span class="s2">will be repeated.</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.repeat.html#jax.numpy.repeat">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_TOTAL_REPEAT_LENGTH_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">total_repeat_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">core</span><span class="o">.</span><span class="n">is_special_dim_size</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">repeats</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.repeat()&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># to appease mypy</span>

  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_special_dim_size</span><span class="p">(</span><span class="n">repeats</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.repeat with a DimPolynomial `repeats` is supported only &quot;</span>
                       <span class="s2">&quot;when `total_repeat_length` is None&quot;</span><span class="p">)</span>

  <span class="c1"># If total_repeat_length is not given, use a default.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span>
      <span class="s2">&quot;When jit-compiling jnp.repeat, the total number of repeats must be static. &quot;</span>
      <span class="s2">&quot;To fix this, either specify a static value for `repeats`, or pass a static &quot;</span>
      <span class="s2">&quot;value to `total_repeat_length`.&quot;</span><span class="p">)</span>

    <span class="c1"># Fast path for when repeats is a scalar.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">input_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
      <span class="n">aux_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aux_axis</span><span class="p">)</span>
      <span class="n">reps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">reps</span><span class="p">[</span><span class="n">aux_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">repeats</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
      <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
      <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*=</span> <span class="n">repeats</span>
      <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">result_shape</span><span class="p">)</span>

    <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]])</span>
    <span class="n">total_repeat_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]])</span>

  <span class="c1"># Special case when a is a scalar.</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">repeats</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
      <span class="k">return</span> <span class="n">full</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`repeat` with a scalar parameter `a` is only &#39;</span>
      <span class="s1">&#39;implemented for scalar values of the parameter `repeats`.&#39;</span><span class="p">)</span>

  <span class="c1"># Special case if total_repeat_length is zero.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">result_shape</span><span class="p">)</span>

  <span class="c1"># If repeats is on a zero sized axis, then return the array.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span>

  <span class="c1"># This implementation of repeat avoid having to instantiate a large.</span>
  <span class="c1">#Â intermediate tensor.</span>

  <span class="c1"># Modify repeats from e.g. [1,2,0,5] -&gt; [0,1,2,0] for exclusive repeat.</span>
  <span class="n">exclusive_repeats</span> <span class="o">=</span> <span class="n">roll</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1"># Cumsum to get indices of new number in repeated tensor, e.g. [0, 1, 3, 3]</span>
  <span class="n">scatter_indices</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">exclusive_repeats</span><span class="p">)</span>
  <span class="c1"># Scatter these onto a zero buffer, e.g. [1,1,0,2,0,0,0,0]</span>
  <span class="n">block_split_indicators</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
  <span class="n">block_split_indicators</span> <span class="o">=</span> <span class="n">block_split_indicators</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">scatter_indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># Cumsum again to get scatter indices for repeat, e.g. [0,1,1,3,3,3,3,3]</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">block_split_indicators</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="tri"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.tri.html#jax.numpy.tri">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tri&quot;</span><span class="p">)</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">N</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">float32</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_tri</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="tril"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.tril.html#jax.numpy.tril">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tril&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.tril must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="o">*</span><span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">m</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">))</span></div>


<div class="viewcode-block" id="triu"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.triu.html#jax.numpy.triu">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;triu&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.triu must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="o">*</span><span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.trace.html#jax.numpy.trace">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.trace is not supported.&quot;</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;trace&quot;</span><span class="p">)</span>

  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
      <span class="n">default_int</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">default_int</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">default_int</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

  <span class="c1"># Mask out the diagonal and reduce.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_wrap_indices_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
              <span class="kc">None</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;argument </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> of jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;argument &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; of jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">tril_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">)</span>
<span class="n">triu_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">)</span>
<span class="n">mask_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">)</span>


<div class="viewcode-block" id="triu_indices_from"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.triu_indices_from.html#jax.numpy.triu_indices_from">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">triu_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">triu_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="tril_indices_from"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.tril_indices_from.html#jax.numpy.tril_indices_from">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tril_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">tril_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="diag_indices"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diag_indices.html#jax.numpy.diag_indices">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;&#39;n&#39; argument of jnp.diag_indices()&quot;</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="s2">&quot;&#39;ndim&#39; argument of jnp.diag_indices()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndim argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">int_</span><span class="p">,</span> <span class="n">n</span><span class="p">),)</span> <span class="o">*</span> <span class="n">ndim</span></div>

<div class="viewcode-block" id="diag_indices_from"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diag_indices_from.html#jax.numpy.diag_indices_from">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag_indices_from&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be at least 2-d&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions of input must be of equal length&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">diag_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span></div>

<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diagonal.html#jax.numpy.diagonal">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diagonal requires an array of at least two dimensions.&quot;</span><span class="p">)</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="s2">&quot;&#39;offset&#39; argument of jnp.diagonal()&quot;</span><span class="p">)</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

  <span class="n">diag_size</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_min</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">_min</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">-</span> <span class="n">_max</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">diag_size</span><span class="p">)</span>
  <span class="n">j</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">_abs</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="n">_abs</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">diag_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span></div>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diag.html#jax.numpy.diag">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">zero</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">((</span><span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="mi">0</span><span class="p">),))</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diag input must be 1d or 2d&quot;</span><span class="p">)</span>

<span class="n">_SCALAR_VALUE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">This differs from np.diagflat for some scalar values of v,</span>
<span class="s2">jax always returns a two-dimensional array, whereas numpy may</span>
<span class="s2">return a scalar depending on the type of v.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="diagflat"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.diagflat.html#jax.numpy.diagflat">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_SCALAR_VALUE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diagflat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagflat&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">v_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">adj_length</span> <span class="o">=</span> <span class="n">v_length</span> <span class="o">+</span> <span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">adj_length</span><span class="o">*</span><span class="n">adj_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adj_length</span><span class="o">-</span><span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">adj_length</span><span class="p">,</span> <span class="n">adj_length</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="trim_zeros"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.trim_zeros.html#jax.numpy.trim_zeros">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
  <span class="n">filt</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span>
    <span class="s2">&quot;Error arose in the `filt` argument of trim_zeros()&quot;</span><span class="p">)</span>
  <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="n">filt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">filt</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">trim_zeros_tol</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
  <span class="n">filt</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span>
    <span class="s2">&quot;Error arose in the `filt` argument of trim_zeros_tol()&quot;</span><span class="p">)</span>
  <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">filt</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span><span class="p">]</span>


<div class="viewcode-block" id="append"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.append.html#jax.numpy.append">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="delete"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.delete.html#jax.numpy.delete">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

  <span class="c1"># Case 1: obj is a static integer.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">pass</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">obj</span><span class="p">),)],</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)]],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="c1"># Case 2: obj is a static slice.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
    <span class="c1"># TODO(jakevdp): we should be able to do this dynamically with care.</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]),</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="c1"># Case 3: obj is an array</span>
  <span class="c1"># NB: pass both arrays to check for appropriate error message.</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;&#39;obj&#39; array argument of jnp.delete()&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="c1"># TODO(jakevdp): in theory this could be done dynamically if obj has no duplicates,</span>
    <span class="c1"># but this would require the complement of lax.gather.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;np.delete(arr, obj): for boolean indices, obj must be one-dimensional &quot;</span>
                       <span class="s2">&quot;with length matching specified axis.&quot;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.delete(arr, obj): got obj.dtype=</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">; must be integer or bool.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span><span class="p">,)]</span></div>

<div class="viewcode-block" id="insert"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.insert.html#jax.numpy.insert">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;insert&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">values</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;axis argument of jnp.insert()&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.insert(): obj must be a slice, a one-dimensional &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;array, or a scalar; got </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Note: np.insert allows boolean inputs but the behavior is deprecated.</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.insert(): index array must be &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;integer typed; got </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">values</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">values</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">full</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
  <span class="n">n_input</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="n">n_insert</span> <span class="o">=</span> <span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">out_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_insert</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">))</span>

  <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">n_input</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_input</span><span class="p">)</span>

  <span class="n">values_ind</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">argsort</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">n_insert</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">arr_mask</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">n_input</span> <span class="o">+</span> <span class="n">n_insert</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">values_ind</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">arr_ind</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">arr_mask</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_input</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">at</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">values_ind</span><span class="p">,)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">at</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr_ind</span><span class="p">,)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="apply_along_axis"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.apply_along_axis.html#jax.numpy.apply_along_axis">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">num_dims</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">)</span>
  <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_dims</span> <span class="o">-</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_over_axes"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.apply_over_axes.html#jax.numpy.apply_over_axes">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_over_axes</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;function is not returning an array of the correct shape&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span></div>


<span class="c1">### Tensor contraction operations</span>


<div class="viewcode-block" id="dot"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.dot.html#jax.numpy.dot">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_max</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">b_ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,))</span>
  <span class="n">batch_dims</span> <span class="o">=</span> <span class="p">((),</span> <span class="p">())</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">contract_dims</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">),</span> <span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.matmul.html#jax.numpy.matmul">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;matmul&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matmul input operand </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must have ndim at least 1, &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;but it has ndim </span><span class="si">{</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

  <span class="n">a_is_mat</span><span class="p">,</span> <span class="n">b_is_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">a_batch_dims</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">b_batch_dims</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">num_batch_dims</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span>
  <span class="n">a_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">a_batch_dims</span>
  <span class="n">b_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">b_batch_dims</span>

  <span class="c1"># Dimensions to squeeze from the inputs.</span>
  <span class="n">a_squeeze</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_squeeze</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Positions of batch dimensions in squeezed inputs.</span>
  <span class="n">a_batch</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_batch</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Desired index in final output of each kind of dimension, in the order that</span>
  <span class="c1"># lax.dot_general will emit them.</span>
  <span class="n">idx_batch</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">idx_a_other</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># other = non-batch, non-contracting.</span>
  <span class="n">idx_b_other</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">,</span> <span class="n">b_batch_dims</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ba</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">a_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">b_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bb</span><span class="p">):</span>
      <span class="n">a_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">))</span>
      <span class="n">b_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">))</span>
      <span class="n">idx_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for matmul arguments: </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">a_is_mat</span><span class="p">:</span> <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">b_is_mat</span><span class="p">:</span> <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">+</span> <span class="n">a_is_mat</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">idx_batch</span><span class="p">,</span> <span class="n">idx_a_other</span><span class="p">,</span> <span class="n">idx_b_other</span><span class="p">]))</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(((</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b_is_mat</span><span class="p">,)),</span> <span class="p">(</span><span class="n">a_batch</span><span class="p">,</span> <span class="n">b_batch</span><span class="p">)),</span>
    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span></div>


<div class="viewcode-block" id="vdot"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.vdot.html#jax.numpy.vdot">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;vdot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">conj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="tensordot"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.tensordot.html#jax.numpy.tensordot">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tensordot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="o">&gt;</span> <span class="n">_min</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Number of tensordot axes (axes </span><span class="si">{}</span><span class="s2">) exceeds input ranks (</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">)&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">contracting_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="n">axes</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">),),</span>
                          <span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">),))</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;tensordot requires axes lists to have equal length, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax1</span><span class="p">),</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot requires both axes lists to be either ints, tuples or &quot;</span>
             <span class="s2">&quot;lists, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot axes argument must be an int, a pair of ints, or a pair &quot;</span>
           <span class="s2">&quot;of lists/tuples of ints.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">contracting_dims</span><span class="p">,</span> <span class="p">((),</span> <span class="p">())),</span>
                         <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>


<span class="n">_EINSUM_DOC</span> <span class="o">=</span> <span class="n">_PRECISION_DOC</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">A tuple ``precision`` does not necessarily map to multiple arguments of ``einsum()``;</span>
<span class="s2">rather, the specified ``precision`` is forwarded to each ``dot_general`` call used in</span>
<span class="s2">the implementation.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="einsum"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.einsum.html#jax.numpy.einsum">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_EINSUM_DOC</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">_use_xeinsum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.einsum is not supported.&quot;</span><span class="p">)</span>

  <span class="n">spec</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_use_xeinsum</span> <span class="ow">or</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">named_call</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">xeinsum</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="p">)(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>

  <span class="n">optimize</span> <span class="o">=</span> <span class="s1">&#39;optimal&#39;</span> <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">optimize</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>

  <span class="c1"># Allow handling of shape polymorphism</span>
  <span class="n">non_constant_dim_types</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operands</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">non_constant_dim_types</span><span class="p">:</span>
    <span class="n">contract_path</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">non_constant_dim_types</span><span class="p">))</span>
    <span class="n">contract_path</span> <span class="o">=</span> <span class="n">_poly_einsum_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ty</span><span class="p">,</span> <span class="n">_default_poly_einsum_handler</span><span class="p">)</span>
  <span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span> <span class="o">=</span> <span class="n">contract_path</span><span class="p">(</span>
        <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">einsum_call</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_blas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

  <span class="n">contractions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">)</span>

  <span class="n">_einsum_computation</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">named_call</span><span class="p">(</span>
      <span class="n">_einsum</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span> <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_einsum</span>
  <span class="k">return</span> <span class="n">_einsum_computation</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span></div>

<span class="c1"># Enable other modules to override einsum_contact_path.</span>
<span class="c1"># Indexed by the type of the non constant dimension</span>
<span class="n">_poly_einsum_handlers</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: ignore</span>

<span class="k">def</span> <span class="nf">_default_poly_einsum_handler</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">dummy</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
  <span class="n">dummies</span> <span class="o">=</span> <span class="p">[</span><span class="n">dummy</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="mi">8</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
             <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dummies</span><span class="p">)}</span>
  <span class="n">out_dummies</span><span class="p">,</span> <span class="n">contractions</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="o">*</span><span class="n">dummies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="n">contract_operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">operands</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_dummies</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">contract_operands</span><span class="p">,</span> <span class="n">contractions</span>

<div class="viewcode-block" id="einsum_path"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.einsum_path.html#jax.numpy.einsum_path">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">einsum_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">):</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>
  <span class="k">return</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_removechars</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">chars</span><span class="p">)))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_einsum</span><span class="p">(</span><span class="n">operands</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
            <span class="n">contractions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
            <span class="n">precision</span><span class="p">):</span>
  <span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">))</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                      <span class="n">lax</span><span class="o">.</span><span class="n">add</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">bool_</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">uniques</span><span class="p">:</span>
      <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">uniques</span><span class="p">]</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
      <span class="n">names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">keep_names</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_delta</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_names</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span> <span class="o">*</span> <span class="n">eye</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span> <span class="o">*</span> <span class="n">eye</span><span class="p">,</span> <span class="n">axes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">filter_singleton_dims</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">other_shape</span><span class="p">,</span> <span class="n">other_names</span><span class="p">):</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">eq</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">eq</span><span class="p">(</span><span class="n">other_shape</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">other_names</span><span class="o">.</span><span class="n">find</span><span class="p">,</span> <span class="n">names</span><span class="p">))]</span>
    <span class="n">sqez_axes</span><span class="p">,</span> <span class="n">keep_axes</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">sqez_axes</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_axes</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">operand_indices</span><span class="p">,</span> <span class="n">contracted_names_set</span><span class="p">,</span> <span class="n">einstr</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">:</span>
    <span class="n">contracted_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">contracted_names_set</span><span class="p">)</span>
    <span class="n">input_str</span><span class="p">,</span> <span class="n">result_names</span> <span class="o">=</span> <span class="n">einstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)</span>
    <span class="n">input_names</span> <span class="o">=</span> <span class="n">input_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

    <span class="c1"># switch on the number of operands to be processed in this loop iteration.</span>
    <span class="c1"># every case here sets &#39;operand&#39; and &#39;names&#39;.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">names</span><span class="p">,</span> <span class="o">=</span> <span class="n">input_names</span>
      <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices with a single reduce-sum</span>
      <span class="n">uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, do a contraction against an identity matrix</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">result_names</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="n">operand_indices</span><span class="p">)</span>
      <span class="n">lhs_names</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">input_names</span>

      <span class="c1"># handle cases where one side of a contracting or batch dimension is 1</span>
      <span class="c1"># but its counterpart is not.</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span>
                                             <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span>
                                             <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span>
      <span class="n">rhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices in lhs and rhs</span>
      <span class="n">lhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_uniques</span><span class="p">)</span>

      <span class="n">rhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, contract against an identity matrix</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_or_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">contracted_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_or_rhs_names</span><span class="p">]</span>
      <span class="n">lhs_and_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">batch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_and_rhs_names</span><span class="p">]</span>

      <span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">batch_names</span><span class="p">)</span>

      <span class="c1"># NOTE(mattjj): this can fail non-deterministically in python3, maybe</span>
      <span class="c1"># due to opt_einsum</span>
      <span class="k">assert</span> <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">or</span> <span class="n">_all</span><span class="p">(</span>
        <span class="n">name</span> <span class="ow">in</span> <span class="n">lhs_names</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">rhs_names</span> <span class="ow">and</span>
        <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">)</span>

      <span class="c1"># contract using lax.dot_general</span>
      <span class="n">batch_names_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">batch_names</span><span class="p">)</span>
      <span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">deleted_names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">remaining_lhs_names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">)</span>
      <span class="n">remaining_rhs_names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">)</span>
      <span class="c1"># Try both orders of lhs and rhs, in the hope that one of them means we</span>
      <span class="c1"># don&#39;t need an explicit transpose. opt_einsum likes to contract from</span>
      <span class="c1"># right to left, so we expect (rhs,lhs) to have the best chance of not</span>
      <span class="c1"># needing a transpose.</span>
      <span class="n">names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="n">remaining_rhs_names</span> <span class="o">+</span> <span class="n">remaining_lhs_names</span>
      <span class="k">if</span> <span class="n">names</span> <span class="o">==</span> <span class="n">result_names</span><span class="p">:</span>
        <span class="n">dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">rhs_cont</span><span class="p">,</span> <span class="n">lhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">rhs_batch</span><span class="p">,</span> <span class="n">lhs_batch</span><span class="p">))</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="n">remaining_lhs_names</span> <span class="o">+</span> <span class="n">remaining_rhs_names</span>
        <span class="n">dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">))</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># if this is actually reachable, open an issue!</span>

    <span class="c1"># the resulting &#39;operand&#39; with axis labels &#39;names&#39; should be a permutation</span>
    <span class="c1"># of the desired result</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="o">!=</span> <span class="n">result_names</span><span class="p">:</span>
      <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">result_names</span><span class="p">)</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>  <span class="c1"># used in next iteration</span>

  <span class="k">return</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_movechars</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper for einsum string munging, like moveaxis on identifier strings.&quot;&quot;&quot;</span>
  <span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)):</span>
    <span class="n">chars</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
  <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.inner.html#jax.numpy.inner">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
  <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.outer.html#jax.numpy.outer">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.outer is not supported.&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="cross"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.cross.html#jax.numpy.cross">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axisa&#39;</span><span class="p">,</span> <span class="s1">&#39;axisb&#39;</span><span class="p">,</span> <span class="s1">&#39;axisc&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axisa</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisb</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisc</span> <span class="o">=</span> <span class="n">axis</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension must be either 2 or 3 for cross product&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

  <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
  <span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">a1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b2</span><span class="p">,</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="p">)</span></div>


<div class="viewcode-block" id="kron"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.kron.html#jax.numpy.kron">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
  <span class="n">a_reshaped</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">b_reshaped</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a_reshaped</span><span class="p">,</span> <span class="n">b_reshaped</span><span class="p">),</span> <span class="n">out_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.vander.html#jax.numpy.vander">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;increasing&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;vander&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be a one-dimensional array&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;&#39;N&#39; argument of jnp.vander()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be nonnegative&quot;</span><span class="p">)</span>

  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iota</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))))</span></div>


<span class="c1">### Misc</span>

<span class="n">_ARGWHERE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because the size of the output of ``argwhere`` is data-dependent, the function is not</span>
<span class="s2">typically compatible with JIT. The JAX version adds the optional ``size`` argument, which</span>
<span class="s2">specifies the size of the leading dimension of the output - it must be specified statically</span>
<span class="s2">for ``jnp.argwhere`` to be compiled with non-static operands. If ``size`` is specified,</span>
<span class="s2">the indices of the first ``size`` True elements will be returned; if there are fewer</span>
<span class="s2">nonzero elements than `size` indicates, the index arrays will be zero-padded.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="argwhere"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.argwhere.html#jax.numpy.argwhere">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Because the size of the output of ``argwhere`` is data-dependent, the function is not</span>
<span class="s2">    typically compatible with JIT. The JAX version adds the optional ``size`` argument which</span>
<span class="s2">    must be specified statically for ``jnp.argwhere`` to be used within some of JAX&#39;s</span>
<span class="s2">    transformations.&quot;&quot;&quot;</span><span class="p">),</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    size : int, optional</span>
<span class="s2">        If specified, the indices of the first ``size`` True elements will be returned. If there</span>
<span class="s2">        are fewer results than ``size`` indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">    fill_value : array_like, optional</span>
<span class="s2">        When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">vstack</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)))</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span></div>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.argmax.html#jax.numpy.argmax">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmax is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">result</span>

<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.argmin.html#jax.numpy.argmin">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmin is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">result</span>


<span class="n">_NANARG_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Warning: jax.numpy.arg</span><span class="si">{}</span><span class="s2"> returns -1 for all-NaN slices and does not raise</span>
<span class="s2">an error.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="nanargmax"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nanargmax.html#jax.numpy.nanargmax">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">),</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanargmax is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

<div class="viewcode-block" id="nanargmin"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nanargmin.html#jax.numpy.nanargmin">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">),</span>  <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span> <span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanargmin is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.sort.html#jax.numpy.sort">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;quicksort&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to sort is ignored.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to sort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span></div>

<div class="viewcode-block" id="sort_complex"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.sort_complex.html#jax.numpy.sort_complex">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort_complex&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_complex_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="lexsort"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.lexsort.html#jax.numpy.lexsort">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">lexsort</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need sequence of keys with len &gt; 0 in lexsort&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">shape</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all keys need to be the same shape&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span>
  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int_</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">((</span><span class="o">*</span><span class="n">keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">iota</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<span class="n">_ARGSORT_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Only :code:`kind=&#39;stable&#39;` is supported. Other :code:`kind` values will produce</span>
<span class="s2">a warning and be treated as if they were :code:`&#39;stable&#39;`.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.argsort.html#jax.numpy.argsort">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARGSORT_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argsort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to argsort is ignored; only &#39;stable&#39; sorts &quot;</span>
                  <span class="s2">&quot;are supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to argsort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_num</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_num</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int_</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis_num</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis_num</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">perm</span></div>


<div class="viewcode-block" id="msort"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.msort.html#jax.numpy.msort">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">msort</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">msort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">_roll</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">a_shape</span><span class="p">)</span>
  <span class="n">shift</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">b_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shift</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;shift&#39; and &#39;axis&#39; arguments to roll must be scalars or 1D arrays&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">)):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>


<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.roll.html#jax.numpy.roll">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;roll&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="rollaxis"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.rollaxis.html#jax.numpy.rollaxis">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;rollaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;&#39;start&#39; argument of jnp.rollaxis()&quot;</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="n">a_ndim</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">a_ndim</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> must satisfy </span><span class="si">{</span><span class="o">-</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&lt;=start&lt;=</span><span class="si">{</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">a_ndim</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span></div>


<div class="viewcode-block" id="packbits"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.packbits.html#jax.numpy.packbits">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;bitorder&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">packbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bitorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;packbits&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an input array of integer or boolean data type&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">8</span>
  <span class="k">if</span> <span class="n">remainder</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="n">packed</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">packed</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="unpackbits"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.unpackbits.html#jax.numpy.unpackbits">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;bitorder&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">unpackbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;unpackbits&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uint8</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected an input array of unsigned byte data type&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unpacked</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">count</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="take"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.take.html#jax.numpy.take">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">],</span>
        <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The JAX version adds several extra parameters, described below, which are forwarded</span>
<span class="s2">to :func:`jax.lax.gather` for finer control over indexing.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">extra_params</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">mode : string, default=&quot;fill&quot;</span>
<span class="s2">    Out-of-bounds indexing mode. The default mode=&quot;fill&quot; returns invalid values</span>
<span class="s2">    (e.g. NaN) for out-of bounds indices. See :attr:`jax.numpy.ndarray.at` for</span>
<span class="s2">    more discussion of out-of-bounds indexing in JAX.</span>
<span class="s2">unique_indices : bool, default=False</span>
<span class="s2">    If True, the implementation will assume that the indices are unique,</span>
<span class="s2">    which can result in more efficient execution on some backends.</span>
<span class="s2">indices_are_sorted : bool, default=False</span>
<span class="s2">    If True, the implementation will assume that the indices are sorted in</span>
<span class="s2">    ascending order, which can lead to more efficient execution on some backends.</span>
<span class="s2">fill_value : optional</span>
<span class="s2">    The fill value to return for out-of-bounds slices when mode is &#39;fill&#39;. Ignored</span>
<span class="s2">    otherwise. Defaults to NaN for inexact types, the largest negative value for</span>
<span class="s2">    signed types, the largest positive value for unsigned types, and True for booleans.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">out</span><span class="p">,</span>
               <span class="n">mode</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
               <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;unique_indices&#39;</span><span class="p">,</span> <span class="s1">&#39;indices_are_sorted&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.take is not supported.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;fill&quot;</span><span class="p">:</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">FILL_OR_DROP</span>
    <span class="c1"># lax.gather() does not support negative indices, so we wrap them here</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">],</span> <span class="n">indices</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="c1"># TODO(phawkins): we have no way to report out of bounds errors yet.</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;raise&#39; mode to jnp.take is not supported.&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]))</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">PROMISE_IN_BOUNDS</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">CLIP</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mode &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; for np.take&quot;</span><span class="p">)</span>

  <span class="n">index_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot do a non-empty jnp.take() from an empty axis.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_sizes</span><span class="p">[:</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                 <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">)</span>

  <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">))</span> <span class="o">+</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span> <span class="o">+</span> <span class="n">index_dims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">index_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                    <span class="n">slice_sizes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">),</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">gather_mode</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span>
                    <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Normalizes an index value in the range [-N, N) to the range [0, N).&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">index</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">axis_size</span><span class="p">):</span>
    <span class="n">axis_size_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_size_val</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">dimension_as_value</span><span class="p">(</span><span class="n">axis_size</span><span class="p">),</span>
                                             <span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">index</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size_val</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>


<span class="n">TAKE_ALONG_AXIS_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Unlike :func:`numpy.take_along_axis`, :func:`jax.numpy.take_along_axis` takes</span>
<span class="s2">an optional ``mode`` parameter controlling how out-of-bounds indices should be</span>
<span class="s2">handled. By default, out-of-bounds indices yield invalid values (e.g., ``NaN``).</span>
<span class="s2">See :attr:`jax.numpy.ndarray.at` for further discussion of out-of-bounds</span>
<span class="s2">indexing in JAX.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="take_along_axis"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.take_along_axis.html#jax.numpy.take_along_axis">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lax_description</span><span class="o">=</span><span class="n">TAKE_ALONG_AXIS_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                    <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;take_along_axis&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;take_along_axis indices must be of integer type, got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;take_along_axis indices must be 1D if axis=None, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">rank</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;indices and arr must have the same number of dimensions; </span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
    <span class="n">lst</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">_any</span><span class="p">([</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>

  <span class="n">axis_size</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">idx_shape</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">,</span> <span class="n">arr_shape</span><span class="p">)</span>

  <span class="n">index_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

  <span class="n">gather_index_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)[</span><span class="n">index_dims</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">offset_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">))</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># If idx_shape[i] == 1, we can just take the entirety of the arr&#39;s axis</span>
      <span class="c1"># and avoid forming an iota index.</span>
      <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># If the array dimension is 1 but the index dimension is not, we</span>
      <span class="c1"># broadcast the array dimension to the index dimension by repeatedly</span>
      <span class="c1"># gathering the first element.</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">gather_index_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">))</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Otherwise, idx_shape[i] == arr_shape[i]. Use an iota index so</span>
      <span class="c1"># corresponding elements of array and index are gathered.</span>
      <span class="c1"># TODO(mattjj): next line needs updating for dynamic shapes</span>
      <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iota</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>


  <span class="n">gather_indices_arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">gather_indices_arr</span><span class="p">,</span> <span class="n">dnums</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">),</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;fill&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mode</span><span class="p">)</span></div>

<span class="c1">### Indexing</span>

<span class="k">def</span> <span class="nf">_rewriting_take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># Computes arr[idx].</span>
  <span class="c1"># All supported cases of indexing can be implemented as an XLA gather,</span>
  <span class="c1"># followed by an optional reverse and broadcast_in_dim.</span>

  <span class="c1"># Handle some special cases, falling back if error messages might differ.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span>
      <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_index_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">index_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
      <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span>
      <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
      <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>  <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span>  <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
      <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>  <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span>  <span class="kc">None</span><span class="p">)):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">stop</span>  <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span>  <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span>
    <span class="n">step</span>  <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span>  <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">step</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># TODO(mattjj, sharadmv): handle step != 1</span>
          <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

  <span class="c1"># TODO(mattjj,dougalm): expand dynamic shape indexing support</span>
  <span class="k">if</span> <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span>
          <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_index_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span> <span class="o">=</span> <span class="n">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="p">,</span>
                 <span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

<span class="c1"># TODO(phawkins): re-enable jit after fixing excessive recompilation for</span>
<span class="c1"># slice indexes (e.g., slice(0, 5, None), slice(10, 15, None), etc.).</span>
<span class="c1"># @partial(jit, static_argnums=(1, 2))</span>
<span class="k">def</span> <span class="nf">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="p">,</span>
            <span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">)</span>
  <span class="n">indexer</span> <span class="o">=</span> <span class="n">_index_to_gather</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># shared with _scatter_update</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">arr</span>

  <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span>
                           <span class="s2">&quot;fill_value argument to indexed get()&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill_value argument to indexed get() must be a scalar&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
      <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

  <span class="c1"># Avoid calling gather if the slice shape is empty, both as a fast path and to</span>
  <span class="c1"># handle cases like zeros(0)[array([], int32)].</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_empty_shape</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">)</span>

  <span class="c1"># We avoid generating a gather when indexer.gather_indices.size is empty.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_empty_shape</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
      <span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">dnums</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_slice_shape</span><span class="p">,</span>
      <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">unique_indices</span><span class="p">,</span>
      <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">indices_are_sorted</span><span class="p">,</span>
      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

  <span class="c1"># Reverses axes with negative strides.</span>
  <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">)</span>

  <span class="c1"># This adds np.newaxis/None dimensions.</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">newaxis_dims</span><span class="p">)</span>

<span class="n">_Indexer</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;_Indexer&quot;</span><span class="p">,</span> <span class="p">[</span>
  <span class="c1"># The expected shape of the slice output.</span>
  <span class="s2">&quot;slice_shape&quot;</span><span class="p">,</span>

  <span class="c1"># The slice shape to pass to lax.gather().</span>
  <span class="s2">&quot;gather_slice_shape&quot;</span><span class="p">,</span>

  <span class="c1"># The gather indices to use.</span>
  <span class="s2">&quot;gather_indices&quot;</span><span class="p">,</span>

  <span class="c1"># A GatherDimensionNumbers object describing the gather to perform.</span>
  <span class="s2">&quot;dnums&quot;</span><span class="p">,</span>

  <span class="c1"># Are the gather_indices known to be non-overlapping and/or sorted?</span>
  <span class="c1"># (In practice, these translate to &quot;there no advanced indices&quot;, because</span>
  <span class="c1"># only advanced indices could lead to index repetition.)</span>
  <span class="s2">&quot;unique_indices&quot;</span><span class="p">,</span>
  <span class="s2">&quot;indices_are_sorted&quot;</span><span class="p">,</span>

  <span class="c1"># Slice dimensions that have negative strides, and so must be reversed after</span>
  <span class="c1"># the gather.</span>
  <span class="s2">&quot;reversed_y_dims&quot;</span><span class="p">,</span>

  <span class="c1"># Keep track of any axes created by `newaxis`. These must be inserted for</span>
  <span class="c1"># gathers and eliminated for scatters.</span>
  <span class="s2">&quot;newaxis_dims&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="k">def</span> <span class="nf">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Splits indices into necessarily-static and dynamic parts.</span>

<span class="sd">  Used to pass indices into `jit`-ted function.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Convert list indices to tuples in cases (deprecated by NumPy.)</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

  <span class="c1"># Expand any (concrete) boolean indices. We can then use advanced integer</span>
  <span class="c1"># indexing logic to handle them.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

  <span class="n">leaves</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="n">dynamic</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="n">static</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="c1"># slice objects aren&#39;t hashable.</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dynamic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">static</span><span class="p">),</span> <span class="n">dynamic</span>

<span class="k">def</span> <span class="nf">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Recombines indices that were split by _split_index_for_jit.&quot;&quot;&quot;</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_int</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_index_to_gather</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">normalize_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="c1"># Remove ellipses and add trailing slice(None)s.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_canonicalize_tuple_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>

  <span class="c1"># Check for advanced indexing:</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>

  <span class="c1"># Do the advanced indexing axes appear contiguously? If not, NumPy semantics</span>
  <span class="c1"># move the advanced axes to the front.</span>
  <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="c1"># The positions of the advanced indexing axes in `idx`.</span>
  <span class="n">idx_advanced_axes</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># The positions of the advanced indexes in x&#39;s shape.</span>
  <span class="c1"># collapsed, after None axes have been removed. See below.</span>
  <span class="n">x_advanced_axes</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="n">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">idx_no_nones</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_no_nones</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">normalize_indices</span><span class="p">:</span>
      <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">((</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_indexes</span><span class="p">,</span> <span class="n">idx_advanced_axes</span><span class="p">,</span> <span class="n">x_advanced_axes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_advanced_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">x_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in x.</span>
  <span class="n">y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, before collapsing. See below.</span>
  <span class="n">collapsed_y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, after collapsing.</span>

  <span class="c1"># Scatter dimension numbers.</span>
  <span class="n">offset_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">_any</span><span class="p">([</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x_shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span>

  <span class="c1"># Gather indices.</span>
  <span class="c1"># Pairs of (array, start_dim) values. These will be broadcast into</span>
  <span class="c1"># gather_indices_shape, with the array dimensions aligned to start_dim, and</span>
  <span class="c1"># then concatenated.</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">gather_indices_shape</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># We perform three transformations to y before the scatter op, in order:</span>
  <span class="c1"># First, y is broadcast to slice_shape. In general `y` only need broadcast to</span>
  <span class="c1"># the right shape.</span>
  <span class="n">slice_shape</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Next, y is squeezed to remove newaxis_dims. This removes np.newaxis/`None`</span>
  <span class="c1"># indices, which the scatter cannot remove itself.</span>
  <span class="n">newaxis_dims</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Finally, we reverse reversed_y_dims to handle slices with negative strides.</span>
  <span class="n">reversed_y_dims</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">gather_slice_shape</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="c1"># Handle the advanced indices here if:</span>
    <span class="c1"># * the advanced indices were not contiguous and we are the start.</span>
    <span class="c1"># * we are at the position of the first advanced index.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="n">idx_advanced_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
         <span class="ow">not</span> <span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
      <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_indexes</span><span class="p">)</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">advanced_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
      <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

      <span class="n">start_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span>
      <span class="n">gather_indices</span> <span class="o">+=</span> <span class="p">((</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">),</span> <span class="n">start_dim</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">advanced_indexes</span><span class="p">)</span>
      <span class="n">gather_indices_shape</span> <span class="o">+=</span> <span class="n">shape</span>

      <span class="n">start_index_map</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>
      <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>

    <span class="c1"># Per-index bookkeeping for advanced indexes.</span>
    <span class="k">if</span> <span class="n">idx_pos</span> <span class="ow">in</span> <span class="n">idx_advanced_axes</span><span class="p">:</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Handle basic int indexes.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="p">(</span><span class="n">ConcreteArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">_int</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># XLA gives error when indexing into an axis of size 0</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index is out of bounds for axis </span><span class="si">{</span><span class="n">x_axis</span><span class="si">}</span><span class="s2"> with size 0&quot;</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span> <span class="k">if</span> <span class="n">normalize_indices</span> <span class="k">else</span> <span class="n">i</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Handle np.newaxis (None)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">newaxis_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="c1"># Normalize the slice to use None when possible</span>
      <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
          <span class="n">step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">core</span><span class="o">.</span><span class="n">greater_equal_dim</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])):</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">InconclusiveDimensionOperation</span><span class="p">):</span>
        <span class="k">pass</span>

      <span class="c1"># Handle slice(None) and slice(None, None, -1)</span>
      <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
          <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">reversed_y_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="c1"># Handle slice index (only static, otherwise an error is raised)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_all</span><span class="p">(</span><span class="n">_is_slice_element_none_or_constant</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)):</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Array slice indices must have static start/stop/step to be used &quot;</span>
                 <span class="s2">&quot;with NumPy indexing syntax. &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;Found slice(</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">). &quot;</span>
                 <span class="s2">&quot;To index a statically sized &quot;</span>
                 <span class="s2">&quot;array at a dynamic position, try lax.dynamic_slice/&quot;</span>
                 <span class="s2">&quot;dynamic_update_slice (JAX does not support dynamically sized &quot;</span>
                 <span class="s2">&quot;arrays within JIT compiled functions).&quot;</span><span class="p">)</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]):</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot use NumPy slice indexing on an array dimension whose &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;size is not statically known (</span><span class="si">{</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]</span><span class="si">}</span><span class="s2">). &quot;</span>
                 <span class="s2">&quot;Try using lax.dynamic_slice/dynamic_update_slice&quot;</span><span class="p">)</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">needs_rev</span> <span class="o">=</span> <span class="n">_static_idx</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span>
                                                      <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">needs_rev</span><span class="p">:</span>
          <span class="n">reversed_y_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
          <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
          <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
          <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
          <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
          <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>
          <span class="n">size</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
          <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
          <span class="n">gather_indices_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

          <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
          <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>

        <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">abstract_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">))):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Indexer must have integer or boolean type, got indexer &quot;</span>
               <span class="s2">&quot;with type </span><span class="si">{}</span><span class="s2"> at position </span><span class="si">{}</span><span class="s2">, indexer value </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Indexing mode not yet supported. Open a feature request!</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">gather_indices_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gather_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gather_indices_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ndim</span><span class="p">,))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">last_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span>
    <span class="n">gather_indices_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gather_indices_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gather_indices_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
      <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gather_indices</span><span class="p">],</span>
      <span class="n">last_dim</span><span class="p">)</span>

  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">)),</span>
    <span class="n">start_index_map</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">)</span>
  <span class="p">)</span>
  <span class="k">return</span> <span class="n">_Indexer</span><span class="p">(</span>
    <span class="n">slice_shape</span><span class="o">=</span><span class="n">slice_shape</span><span class="p">,</span>
    <span class="n">newaxis_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newaxis_dims</span><span class="p">),</span>
    <span class="n">gather_slice_shape</span><span class="o">=</span><span class="n">gather_slice_shape</span><span class="p">,</span>
    <span class="n">reversed_y_dims</span><span class="o">=</span><span class="n">reversed_y_dims</span><span class="p">,</span>
    <span class="n">dnums</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
    <span class="n">gather_indices</span><span class="o">=</span><span class="n">gather_indices_array</span><span class="p">,</span>
    <span class="n">unique_indices</span><span class="o">=</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_should_unpack_list_index</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper for _eliminate_deprecated_list_indexing.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span>
          <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="c1"># &quot;Basic slicing is initiated if the selection object is a non-array,</span>
  <span class="c1"># non-tuple sequence containing slice objects, [Ellipses, or newaxis</span>
  <span class="c1"># objects]&quot;. Detects this and raises a TypeError.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
      <span class="c1"># As of numpy 1.16, some non-tuple sequences of indices result in a warning, while</span>
      <span class="c1"># others are converted to arrays, based on a set of somewhat convoluted heuristics</span>
      <span class="c1"># (See https://github.com/numpy/numpy/blob/v1.19.2/numpy/core/src/multiarray/mapping.c#L179-L343)</span>
      <span class="c1"># In JAX, we raise an informative TypeError for *all* non-tuple sequences.</span>
      <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">_should_unpack_list_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[tuple(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[array(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_is_boolean_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">_all</span><span class="p">(</span><span class="n">_is_scalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
          <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">i</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Converts concrete bool indexes into advanced integer indexes.&quot;&quot;&quot;</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">total_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">num_ellipsis</span> <span class="o">=</span> <span class="n">_sum</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num_ellipsis</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;an index can only have a single ellipsis (&#39;...&#39;)&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">num_ellipsis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">total_dims</span> <span class="o">=</span> <span class="n">_sum</span><span class="p">(</span><span class="n">_ndim</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_boolean_index</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span>
                      <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="n">ellipsis_offset</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">dim_number</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">_is_boolean_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ConcreteArray</span><span class="p">:</span>
        <span class="c1"># TODO(mattjj): improve this error by tracking _why_ the indices are not concrete</span>
        <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NonConcreteBooleanIndexError</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;JAX arrays do not support boolean scalar indices&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">i_shape</span> <span class="o">=</span> <span class="n">_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="n">ellipsis_offset</span>
        <span class="n">expected_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">i_shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;boolean index did not match shape of indexed array in index &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim_number</span><span class="si">}</span><span class="s2">: got </span><span class="si">{</span><span class="n">i_shape</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
      <span class="n">ellipsis_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">total_dims</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_slice_element_none_or_constant</span><span class="p">(</span><span class="n">elt</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Return True if elt is a constant or None.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">elt</span><span class="p">))</span> <span class="ow">is</span> <span class="n">ConcreteArray</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># TODO(mattjj): clean up this logic</span>
<span class="k">def</span> <span class="nf">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns True if idx should trigger int array indexing, False otherwise.&quot;&quot;&quot;</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_all</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
          <span class="ow">or</span> <span class="n">_is_scalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="n">_all</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
              <span class="ow">or</span> <span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_int_arraylike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns True if x is array-like with integer dtype, False otherwise.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
          <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">_all</span><span class="p">(</span><span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_is_scalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks if a Python or NumPy scalar.&quot;&quot;&quot;</span>
  <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span>
                             <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_canonicalize_tuple_index</span><span class="p">(</span><span class="n">arr_ndim</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">array_name</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper to remove Ellipsis and add in the implicit trailing slice(None).&quot;&quot;&quot;</span>
  <span class="n">len_without_none</span> <span class="o">=</span> <span class="n">_sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">len_without_none</span> <span class="o">&gt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Too many indices for </span><span class="si">{</span><span class="n">array_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">len_without_none</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;non-None/Ellipsis indices for dim </span><span class="si">{</span><span class="n">arr_ndim</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="n">ellipses</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="n">ellipsis_index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ellipsis_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;Multiple ellipses (...) not supported: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">ellipsis_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">colons</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="n">ellipsis_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
  <span class="k">elif</span> <span class="n">len_without_none</span> <span class="o">&lt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">colons</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_static_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">DimSize</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper function to compute the static slice start/limit/stride values.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span>  <span class="c1"># sliced to size zero</span>

  <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">k</span>  <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">step</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">,</span> <span class="kc">True</span>


<span class="n">blackman</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">)</span>
<span class="n">bartlett</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">)</span>
<span class="n">hamming</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span>
<span class="n">hanning</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">)</span>
<span class="c1"># TODO: lower `kaiser` via lax to allow non-constant beta values.</span>
<span class="n">kaiser</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_gcd_cond_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_gcd_body_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span>
            <span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<div class="viewcode-block" id="gcd"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.gcd.html#jax.numpy.gcd">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.gcd must be integers.&quot;</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">gcd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span><span class="n">_gcd_cond_fn</span><span class="p">,</span> <span class="n">_gcd_body_fn</span><span class="p">,</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">gcd</span></div>


<div class="viewcode-block" id="lcm"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.lcm.html#jax.numpy.lcm">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;lcm&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.lcm must be integers.&quot;</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
               <span class="nb">abs</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">floor_divide</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span></div>


<div class="viewcode-block" id="extract"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.extract.html#jax.numpy.extract">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span></div>


<div class="viewcode-block" id="compress"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.compress.html#jax.numpy.compress">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.compress is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition must be a 1D array&quot;</span><span class="p">)</span>
  <span class="n">condition</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">condition</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">condition</span><span class="p">[:</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">condition</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">extra</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition contains entries that are out of bounds&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">condition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">condition</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="cov"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.cov.html#jax.numpy.cov">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;rowvar&#39;</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;ddof&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y has more than 2 dimensions&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m has more than 2 dimensions&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
  <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

  <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">fweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">fweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">fweights</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fweights must be integer.&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive fweights; note that numpy raises an error on negative fweights.</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fweights</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">aweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">aweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive aweights: note that numpy raises an error for negative aweights.</span>
    <span class="n">aweights</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">aweights</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">w</span> <span class="o">*</span> <span class="n">aweights</span>

  <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span>
  <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">aweights</span><span class="p">)</span> <span class="o">/</span> <span class="n">w_sum</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">avg</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
  <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_to_rank</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
  <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="corrcoef"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.corrcoef.html#jax.numpy.corrcoef">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;rowvar&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;corrcoef&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># scalar - this should yield nan for values (nan/nan, inf/inf, 0/0), 1 otherwise</span>
    <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">stddev</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

  <span class="n">real_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">complex_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">real_part</span><span class="p">,</span> <span class="n">complex_part</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">real_part</span>
  <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="quantile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.quantile.html#jax.numpy.quantile">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">overwrite_input</span> <span class="ow">or</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;jax.numpy.quantile does not support overwrite_input=True or &quot;</span>
           <span class="s2">&quot;out != None&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The interpolation= argument to &#39;quantile&#39; is deprecated. &quot;</span>
                  <span class="s2">&quot;Use &#39;method=&#39; instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span> <span class="ow">or</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="nanquantile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nanquantile.html#jax.numpy.nanquantile">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanquantile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">overwrite_input</span> <span class="ow">or</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;jax.numpy.nanquantile does not support overwrite_input=True or &quot;</span>
           <span class="s2">&quot;out != None&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The interpolation= argument to &#39;nanquantile&#39; is deprecated. &quot;</span>
                  <span class="s2">&quot;Use &#39;method=&#39; instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span> <span class="ow">or</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">squash_nans</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interpolation can only be &#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &quot;</span>
                     <span class="s2">&quot;&#39;midpoint&#39;, or &#39;nearest&#39;&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">keepdim</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;quantile does not support complex input, as the operation is poorly defined.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="n">keepdim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;repeated axis&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
      <span class="n">keepdim</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># prepare permutation</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)):</span>
      <span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">do_not_touch_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">touch_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">do_not_touch_shape</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">touch_shape</span><span class="p">)),),</span> <span class="n">dimensions</span><span class="p">)</span>
    <span class="n">keepdim</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keepdim</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="n">q_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
  <span class="n">q_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">q_ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;q must be have rank &lt;= 1, got shape </span><span class="si">{</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">squash_nans</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">nan</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># Ensure nans are positive so they sort to the end.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">logical_not</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                 <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="n">shape_after_reduction</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
      <span class="n">q</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">q_ndim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_after_reduction</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span><span class="p">)))</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">q_ndim</span><span class="p">)))</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">)</span>

    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">q_shape</span> <span class="o">+</span> <span class="n">shape_after_reduction</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="n">q_ndim</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_after_reduction</span><span class="p">))]</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
      <span class="n">index</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">index</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
    <span class="n">index</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span>
    <span class="n">high_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">nan</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">)</span>

    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">low</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">high</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>

    <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
    <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
      <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span>
        <span class="n">q_ndim</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
      <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="p">()</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="p">(</span><span class="n">axis</span><span class="p">,),</span>
      <span class="n">start_index_map</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span><span class="p">,))</span>
    <span class="n">low_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                           <span class="n">slice_sizes</span><span class="o">=</span><span class="n">slice_sizes</span><span class="p">)</span>
    <span class="n">high_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">high</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                            <span class="n">slice_sizes</span><span class="o">=</span><span class="n">slice_sizes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">low_weight</span><span class="p">,</span> <span class="n">low_value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
      <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="n">high_value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>

  <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">low_value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">low_weight</span><span class="p">),</span>
                     <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">high_value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">low_value</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;higher&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">high_value</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">low_value</span><span class="p">,</span> <span class="n">high_value</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">low_value</span><span class="p">,</span> <span class="n">high_value</span><span class="p">),</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">low_value</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;interpolation=</span><span class="si">{</span><span class="n">interpolation</span><span class="si">!r}</span><span class="s2"> not recognized&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">and</span> <span class="n">keepdim</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">q_ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">keepdim</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">keepdim</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>  <span class="n">keepdim</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">vectorize</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
<span class="k">def</span> <span class="nf">_searchsorted_via_scan</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">_sort_le_comparator</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">_sort_lt_comparator</span>
  <span class="k">def</span> <span class="nf">body_fun</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">state</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">go_left</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">))</span>
  <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="n">init</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">fori_loop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_levels</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">,</span> <span class="n">init</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_searchsorted_via_sort</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="n">working_dtype</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="n">sorted_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">query</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">else</span> <span class="n">int64</span>
  <span class="k">def</span> <span class="nf">_rank</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">working_dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="n">query_flat</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_rank</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">query_flat</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">],</span> <span class="mi">0</span><span class="p">))[:</span><span class="n">query</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_rank</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sorted_arr</span><span class="p">,</span> <span class="n">query_flat</span><span class="p">],</span> <span class="mi">0</span><span class="p">))[</span><span class="n">sorted_arr</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_rank</span><span class="p">(</span><span class="n">query_flat</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">query</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.searchsorted.html#jax.numpy.searchsorted">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sorter&#39;</span><span class="p">],</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    method : str</span>
<span class="s2">        One of &#39;scan&#39; (default) or &#39;sort&#39;. Controls the method used by the implementation; &#39;scan&#39;</span>
<span class="s2">        tends to be more performant on CPU (particularly when ``a`` is very large), while</span>
<span class="s2">        &#39;sort&#39; is often more performant on accelerator backends like GPU and TPU (particularly</span>
<span class="s2">        when ``v`` is very large).&quot;&quot;&quot;</span><span class="p">))</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;side&#39;</span><span class="p">,</span> <span class="s1">&#39;sorter&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;scan&#39;</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;searchsorted&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">side</span><span class="si">!r}</span><span class="s2"> is an invalid value for keyword &#39;side&#39;. &quot;</span>
                     <span class="s2">&quot;Expected one of [&#39;left&#39;, &#39;right&#39;].&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">,</span> <span class="s1">&#39;sort&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">!r}</span><span class="s2"> is an invalid value for keyword &#39;method&#39;. &quot;</span>
                     <span class="s2">&quot;Expected one of [&#39;sort&#39;, &#39;scan&#39;].&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sorter is not implemented&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a should be 1-dimensional&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">else</span> <span class="n">int64</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">impl</span> <span class="o">=</span> <span class="n">_searchsorted_via_scan</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scan&#39;</span> <span class="k">else</span> <span class="n">_searchsorted_via_sort</span>
  <span class="k">return</span> <span class="n">impl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="digitize"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.digitize.html#jax.numpy.digitize">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;digitize&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
  <span class="n">right</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s2">&quot;right argument of jnp.digitize()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;digitize: bins must be a 1-dimensional array; got bins=</span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span>
    <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">),</span>
    <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
  <span class="p">)</span></div>

<span class="n">_PIECEWISE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike `np.piecewise`, :py:func:`jax.numpy.piecewise` requires functions in</span>
<span class="s2">`funclist` to be traceable by JAX, as it is implemented via :func:`jax.lax.switch`.</span>
<span class="s2">See the :func:`jax.lax.switch` documentation for more information.</span>
<span class="s2">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="piecewise"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.piecewise.html#jax.numpy.piecewise">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PIECEWISE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;piecewise&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">condlist</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>
  <span class="n">nc</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">funclist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> condition(s), either </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">nc</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> functions are expected; got </span><span class="si">{</span><span class="n">nf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">c</span><span class="p">)}</span>
  <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)}</span>
  <span class="k">return</span> <span class="n">_piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span>
                    <span class="nb">frozenset</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>  <span class="c1"># dict is not hashable.</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;funcs&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">_piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="n">funcs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
  <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">consts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">funcs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">cumsum</span><span class="p">(</span><span class="n">concatenate</span><span class="p">([</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">condlist</span><span class="p">[:</span><span class="mi">1</span><span class="p">]),</span> <span class="n">condlist</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_const</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">_call</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span> <span class="n">_const</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funclist</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">switch</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))(</span><span class="n">indices</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<div class="viewcode-block" id="percentile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.percentile.html#jax.numpy.percentile">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
               <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">q</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                  <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>

<div class="viewcode-block" id="nanpercentile"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nanpercentile.html#jax.numpy.nanpercentile">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                  <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanpercentile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">float32</span><span class="p">(</span><span class="mf">100.0</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                     <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                     <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>

<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.median.html#jax.numpy.median">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                  <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="nanmedian"><a class="viewcode-back" href="../../../../_autosummary/jax.numpy.nanmedian.html#jax.numpy.nanmedian">[docs]</a><span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite_input&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanmedian&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                     <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_astype</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Copy the array and cast to a specified dtype.</span>

<span class="sd">  This is implemeted via :func:`jax.lax.convert_element_type`, which may</span>
<span class="sd">  have slightly different behavior than :meth:`numpy.ndarray.astype` in</span>
<span class="sd">  some cases. In particular, the details of float-to-int and int-to-float</span>
<span class="sd">  casts are implementation dependent.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;astype&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nbytes</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">*</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>


<span class="k">def</span> <span class="nf">_itemsize</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>


<span class="k">def</span> <span class="nf">_clip</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
  <span class="k">return</span> <span class="n">clip</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_view</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax_internal</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;view&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;`type` argument of array.view()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="n">arr_dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr_dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="c1"># bool is implemented as lax:PRED, which is not compatible with lax.bitcast_convert_type.</span>
  <span class="c1"># We work around this by casting bool to uint8.</span>
  <span class="k">if</span> <span class="n">arr_dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">uint8</span><span class="p">)</span>
  <span class="n">nbits_in</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">arr_dtype</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="n">nbits_out</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="o">==</span> <span class="n">nbits_out</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_out</span> <span class="o">&gt;</span> <span class="n">nbits_in</span> <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbits_in</span><span class="p">)</span> <span class="o">%</span> <span class="n">nbits_out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When changing to a larger dtype, its size must be a divisor &quot;</span>
                     <span class="s2">&quot;of the total size in bytes of the last axis of the array.&quot;</span><span class="p">)</span>
  <span class="n">byte_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="n">uint8</span><span class="p">,</span> <span class="mi">16</span><span class="p">:</span> <span class="n">uint16</span><span class="p">,</span> <span class="mi">32</span><span class="p">:</span> <span class="n">uint32</span><span class="p">,</span> <span class="mi">64</span><span class="p">:</span> <span class="n">uint64</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">byte_dtypes</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;arr.view() for arr.dtype=</span><span class="si">{</span><span class="n">arr_dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">byte_dtypes</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;arr.view(dtype) for dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">dt_in</span> <span class="o">=</span> <span class="n">byte_dtypes</span><span class="p">[</span><span class="n">nbits_in</span><span class="p">]</span>
  <span class="n">dt_out</span> <span class="o">=</span> <span class="n">byte_dtypes</span><span class="p">[</span><span class="n">nbits_out</span><span class="p">]</span>
  <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dt_in</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="o">&lt;</span> <span class="n">nbits_out</span><span class="p">:</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">arr_bytes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbits_out</span> <span class="o">//</span> <span class="n">nbits_in</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbits_out</span><span class="p">,</span> <span class="n">nbits_in</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_out</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr_bytes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr_bytes</span> <span class="o">&lt;&lt;</span> <span class="n">shifts</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbits_in</span><span class="p">,</span> <span class="n">nbits_out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_in</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr_bytes</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr_bytes</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">shifts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">arr_bytes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr_bytes</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr_bytes</span><span class="p">,</span> <span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr_bytes</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_notimplemented_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;JAX DeviceArrays do not implement the arr.flat property: &quot;</span>
                            <span class="s2">&quot;consider arr.flatten() instead.&quot;</span><span class="p">)</span>

<span class="c1">### track unimplemented functions</span>

<span class="n">_NOT_IMPLEMENTED_DESC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">*** This function is not yet implemented by jax.numpy, and will raise NotImplementedError ***</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_not_implemented</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NOT_IMPLEMENTED_DESC</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Numpy function </span><span class="si">{}</span><span class="s2"> not yet implemented&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapped</span>


<span class="c1">### add method and operator overloads to arraylike classes</span>

<span class="c1"># We add operator overloads to DeviceArray and ShapedArray. These method and</span>
<span class="c1"># operator overloads mainly just forward calls to the corresponding lax_numpy</span>
<span class="c1"># functions, which can themselves handle instances from any of these classes.</span>

<span class="n">_scalar_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)</span>
<span class="n">_accepted_binop_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span>
<span class="n">_rejected_binop_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">opchar</span><span class="p">,</span> <span class="n">binary_op</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="c1"># Ensure that other array types have the chance to override arithmetic.</span>
  <span class="k">def</span> <span class="nf">deferring_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">swap</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_accepted_binop_types</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">binary_op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_rejected_binop_types</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for </span><span class="si">{</span><span class="n">opchar</span><span class="si">}</span><span class="s2">: &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">NotImplemented</span>
  <span class="k">return</span> <span class="n">deferring_binary_op</span>

<span class="k">def</span> <span class="nf">_unimplemented_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; object does not support item assignment. JAX arrays are &quot;</span>
         <span class="s2">&quot;immutable. Instead of ``x[idx] = y``, use ``x = x.at[idx].set(y)`` &quot;</span>
         <span class="s2">&quot;or another .at[] method: &quot;</span>
         <span class="s2">&quot;https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html&quot;</span><span class="p">)</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_operator_round</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">out</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">ndigits</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1"># If `ndigits` is None, for a builtin float round(7.5) returns an integer.</span>
  <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">ndigits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">memo</span>  <span class="c1"># unused</span>
  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">_operators</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;getitem&quot;</span><span class="p">:</span> <span class="n">_rewriting_take</span><span class="p">,</span>
    <span class="s2">&quot;setitem&quot;</span><span class="p">:</span> <span class="n">_unimplemented_setitem</span><span class="p">,</span>
    <span class="s2">&quot;copy&quot;</span><span class="p">:</span> <span class="n">_copy</span><span class="p">,</span>
    <span class="s2">&quot;deepcopy&quot;</span><span class="p">:</span> <span class="n">_deepcopy</span><span class="p">,</span>
    <span class="s2">&quot;neg&quot;</span><span class="p">:</span> <span class="n">negative</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="n">positive</span><span class="p">,</span>
    <span class="s2">&quot;eq&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="n">equal</span><span class="p">),</span>
    <span class="s2">&quot;ne&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;!=&quot;</span><span class="p">,</span> <span class="n">not_equal</span><span class="p">),</span>
    <span class="s2">&quot;lt&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">less</span><span class="p">),</span>
    <span class="s2">&quot;le&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">less_equal</span><span class="p">),</span>
    <span class="s2">&quot;gt&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">greater</span><span class="p">),</span>
    <span class="s2">&quot;ge&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="n">greater_equal</span><span class="p">),</span>
    <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">,</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">),</span>
    <span class="s2">&quot;radd&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;sub&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">subtract</span><span class="p">),</span>
    <span class="s2">&quot;rsub&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">subtract</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;mul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">multiply</span><span class="p">),</span>
    <span class="s2">&quot;rmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;div&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="p">),</span>
    <span class="s2">&quot;rdiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;truediv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">true_divide</span><span class="p">),</span>
    <span class="s2">&quot;rtruediv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">true_divide</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;floordiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">,</span> <span class="n">floor_divide</span><span class="p">),</span>
    <span class="s2">&quot;rfloordiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">,</span> <span class="n">floor_divide</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;divmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;divmod&quot;</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">),</span>
    <span class="s2">&quot;rdivmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;divmod&quot;</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;mod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">),</span>
    <span class="s2">&quot;rmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;pow&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">power</span><span class="p">),</span>
    <span class="s2">&quot;rpow&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;matmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">matmul</span><span class="p">),</span>
    <span class="s2">&quot;rmatmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="n">matmul</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;and&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">,</span> <span class="n">bitwise_and</span><span class="p">),</span>
    <span class="s2">&quot;rand&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">,</span> <span class="n">bitwise_and</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;or&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">bitwise_or</span><span class="p">),</span>
    <span class="s2">&quot;ror&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">bitwise_or</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;xor&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">bitwise_xor</span><span class="p">),</span>
    <span class="s2">&quot;rxor&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">bitwise_xor</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;invert&quot;</span><span class="p">:</span> <span class="n">bitwise_not</span><span class="p">,</span>
    <span class="s2">&quot;lshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">,</span> <span class="n">left_shift</span><span class="p">),</span>
    <span class="s2">&quot;rshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&gt;&gt;&quot;</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">),</span>
    <span class="s2">&quot;rlshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">,</span> <span class="n">left_shift</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;rrshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="s2">&quot;&gt;&gt;&quot;</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="s2">&quot;round&quot;</span><span class="p">:</span> <span class="n">_operator_round</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># These numpy.ndarray methods are just refs to an equivalent numpy function</span>
<span class="n">_nondiff_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="s2">&quot;argpartition&quot;</span><span class="p">,</span> <span class="s2">&quot;argsort&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;nonzero&quot;</span><span class="p">,</span> <span class="s2">&quot;searchsorted&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">]</span>
<span class="n">_diff_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;choose&quot;</span><span class="p">,</span> <span class="s2">&quot;conj&quot;</span><span class="p">,</span> <span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;cumprod&quot;</span><span class="p">,</span> <span class="s2">&quot;cumsum&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;ptp&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;ravel&quot;</span><span class="p">,</span> <span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span> <span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">]</span>

<span class="c1"># These methods are mentioned explicitly by nondiff_methods, so we create</span>
<span class="c1"># _not_implemented implementations of them here rather than in __init__.py.</span>
<span class="c1"># TODO(phawkins): implement these.</span>
<span class="n">argpartition</span> <span class="o">=</span> <span class="n">_not_implemented</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">)</span>
<span class="n">_NOT_IMPLEMENTED</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;argpartition&#39;</span><span class="p">]</span>


<span class="c1"># Experimental support for NumPy&#39;s module dispatch with NEP-37.</span>
<span class="c1"># Currently requires https://github.com/seberg/numpy-dispatch</span>
<span class="n">_JAX_ARRAY_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">ArrayImpl</span><span class="p">)</span>
<span class="n">_HANDLED_ARRAY_TYPES</span> <span class="o">=</span> <span class="n">_JAX_ARRAY_TYPES</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,)</span>

<span class="k">def</span> <span class="nf">__array_module__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_HANDLED_ARRAY_TYPES</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">NotImplemented</span>


<span class="k">def</span> <span class="nf">_compress_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@core</span><span class="o">.</span><span class="n">stash_axis_env</span><span class="p">()</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_multi_slice</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                 <span class="n">start_indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
                 <span class="n">limit_indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
                 <span class="n">removed_dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]):</span>
  <span class="sd">&quot;&quot;&quot;Extracts multiple slices from `arr`.</span>

<span class="sd">  This is used to shard DeviceArray arguments to pmap. It&#39;s implemented as a</span>
<span class="sd">  DeviceArray method here to avoid circular imports.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">starts</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">removed</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">start_indices</span><span class="p">,</span> <span class="n">limit_indices</span><span class="p">,</span> <span class="n">removed_dims</span><span class="p">):</span>
    <span class="n">sliced</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">removed</span><span class="p">:</span>
      <span class="n">sliced</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sliced</span><span class="p">,</span> <span class="n">removed</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">results</span>

<span class="c1"># The next two functions are related to iter(device_array), implemented here to</span>
<span class="c1"># avoid circular imports.</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">_unstack</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">index_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="s2">&quot;_unstack&quot;</span><span class="p">,</span> <span class="n">_unstack</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ArrayImpl</span><span class="p">,</span> <span class="s1">&#39;_unstack&#39;</span><span class="p">,</span> <span class="n">_unstack</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_chunk_iter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="k">yield</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">num_chunks</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">):</span>
      <span class="k">yield</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tail</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_chunks</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="s2">&quot;_chunk_iter&quot;</span><span class="p">,</span> <span class="n">_chunk_iter</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ArrayImpl</span><span class="p">,</span> <span class="s1">&#39;_chunk_iter&#39;</span><span class="p">,</span> <span class="n">_chunk_iter</span><span class="p">)</span>

<span class="c1"># Syntactic sugar for scatter operations.</span>
<span class="k">class</span> <span class="nc">_IndexUpdateHelper</span><span class="p">:</span>
  <span class="c1"># Note: this docstring will appear as the docstring for the `at` property.</span>
  <span class="sd">&quot;&quot;&quot;Helper property for index update functionality.</span>

<span class="sd">  The ``at`` property provides a functionally pure equivalent of in-place</span>
<span class="sd">  array modificatons.</span>

<span class="sd">  In particular:</span>

<span class="sd">  ==============================  ================================</span>
<span class="sd">  Alternate syntax                Equivalent In-place expression</span>
<span class="sd">  ==============================  ================================</span>
<span class="sd">  ``x = x.at[idx].set(y)``        ``x[idx] = y``</span>
<span class="sd">  ``x = x.at[idx].add(y)``        ``x[idx] += y``</span>
<span class="sd">  ``x = x.at[idx].multiply(y)``   ``x[idx] *= y``</span>
<span class="sd">  ``x = x.at[idx].divide(y)``     ``x[idx] /= y``</span>
<span class="sd">  ``x = x.at[idx].power(y)``      ``x[idx] **= y``</span>
<span class="sd">  ``x = x.at[idx].min(y)``        ``x[idx] = minimum(x[idx], y)``</span>
<span class="sd">  ``x = x.at[idx].max(y)``        ``x[idx] = maximum(x[idx], y)``</span>
<span class="sd">  ``x = x.at[idx].apply(ufunc)``  ``ufunc.at(x, idx)``</span>
<span class="sd">  ``x = x.at[idx].get()``         ``x = x[idx]``</span>
<span class="sd">  ==============================  ================================</span>

<span class="sd">  None of the ``x.at`` expressions modify the original ``x``; instead they return</span>
<span class="sd">  a modified copy of ``x``. However, inside a :py:func:`~jax.jit` compiled function,</span>
<span class="sd">  expressions like :code:`x = x.at[idx].set(y)` are guaranteed to be applied in-place.</span>

<span class="sd">  Unlike NumPy in-place operations such as :code:`x[idx] += y`, if multiple</span>
<span class="sd">  indices refer to the same location, all updates will be applied (NumPy would</span>
<span class="sd">  only apply the last update, rather than applying all updates.) The order</span>
<span class="sd">  in which conflicting updates are applied is implementation-defined and may be</span>
<span class="sd">  nondeterministic (e.g., due to concurrency on some hardware platforms).</span>

<span class="sd">  By default, JAX assumes that all indices are in-bounds. There is experimental</span>
<span class="sd">  support for giving more precise semantics to out-of-bounds indexed accesses,</span>
<span class="sd">  via the ``mode`` parameter (see below).</span>

<span class="sd">  Arguments</span>
<span class="sd">  ---------</span>
<span class="sd">  mode : str</span>
<span class="sd">      Specify out-of-bound indexing mode. Options are:</span>

<span class="sd">      - ``&quot;promise_in_bounds&quot;``: (default) The user promises that indices are in bounds.</span>
<span class="sd">        No additional checking will be performed. In practice, this means that</span>
<span class="sd">        out-of-bounds indices in ``get()`` will be clipped, and out-of-bounds indices</span>
<span class="sd">        in ``set()``, ``add()``, etc. will be dropped.</span>
<span class="sd">      - ``&quot;clip&quot;``: clamp out of bounds indices into valid range.</span>
<span class="sd">      - ``&quot;drop&quot;``: ignore out-of-bound indices.</span>
<span class="sd">      - ``&quot;fill&quot;``: alias for ``&quot;drop&quot;``.  For `get()`, the optional ``fill_value``</span>
<span class="sd">        argument specifies the value that will be returned.</span>

<span class="sd">        See :class:`jax.lax.GatherScatterMode` for more details.</span>

<span class="sd">  indices_are_sorted : bool</span>
<span class="sd">      If True, the implementation will assume that the indices passed to ``at[]``</span>
<span class="sd">      are sorted in ascending order, which can lead to more efficient execution</span>
<span class="sd">      on some backends.</span>
<span class="sd">  unique_indices : bool</span>
<span class="sd">      If True, the implementation will assume that the indices passed to ``at[]``</span>
<span class="sd">      are unique, which can result in more efficient execution on some backends.</span>
<span class="sd">  fill_value : Any</span>
<span class="sd">      Only applies to the ``get()`` method: the fill value to return for out-of-bounds</span>
<span class="sd">      slices when `mode` is ``&#39;fill&#39;``. Ignored otherwise. Defaults to ``NaN`` for</span>
<span class="sd">      inexact types, the largest negative value for signed types, the largest positive</span>
<span class="sd">      value for unsigned types, and ``True`` for booleans.</span>

<span class="sd">  Examples</span>
<span class="sd">  --------</span>
<span class="sd">  &gt;&gt;&gt; x = jnp.arange(5.0)</span>
<span class="sd">  &gt;&gt;&gt; x</span>
<span class="sd">  DeviceArray([0., 1., 2., 3., 4.], dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[2].add(10)</span>
<span class="sd">  DeviceArray([ 0.,  1., 12.,  3.,  4.], dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[10].add(10)  # out-of-bounds indices are ignored</span>
<span class="sd">  DeviceArray([0., 1., 2., 3., 4.], dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[20].add(10, mode=&#39;clip&#39;)</span>
<span class="sd">  DeviceArray([ 0.,  1.,  2.,  3., 14.], dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[2].get()</span>
<span class="sd">  DeviceArray(2., dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[20].get()  # out-of-bounds indices clipped</span>
<span class="sd">  DeviceArray(4., dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[20].get(mode=&#39;fill&#39;)  # out-of-bounds indices filled with NaN</span>
<span class="sd">  DeviceArray(nan, dtype=float32)</span>
<span class="sd">  &gt;&gt;&gt; x.at[20].get(mode=&#39;fill&#39;, fill_value=-1)  # custom fill value</span>
<span class="sd">  DeviceArray(-1., dtype=float32)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>

  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_IndexUpdateRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_IndexUpdateHelper(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
<span class="n">ndarray</span><span class="o">.</span><span class="n">at</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_IndexUpdateHelper</span><span class="o">.</span><span class="vm">__doc__</span>

<span class="n">_power_fn</span> <span class="o">=</span> <span class="n">power</span>
<span class="n">_divide_fn</span> <span class="o">=</span> <span class="n">divide</span>

<span class="k">class</span> <span class="nc">_IndexUpdateRef</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Helper object to call indexed update functions for an (advanced) index.</span>

<span class="sd">  This object references a source array and a specific indexer into that array.</span>
<span class="sd">  Methods on this object return copies of the source array that have been</span>
<span class="sd">  modified at the positions specified by the indexer.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_IndexUpdateRef(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

  <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equivalent to ``x[idx]``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexing &lt;numpy.doc.indexing&gt;` ``x[idx]``. This function differs from</span>
<span class="sd">    the usual array indexing syntax in that it allows additional keyword</span>
<span class="sd">    arguments ``indices_are_sorted`` and ``unique_indices`` to be passed.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_rewriting_take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                           <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                           <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                           <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = y``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:`indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] = y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">scatter</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``func.at(x, idx)`` for a unary ufunc ``func``.</span>

<span class="sd">    Returns the value of ``x`` that would result from applying the unary</span>
<span class="sd">    function ``func`` to ``x`` at the given indices. This is similar to</span>
<span class="sd">    ``x.at[idx].set(func(x[idx]))``, but differs in the case of repeated indices:</span>
<span class="sd">    in ``x.at[idx].apply(func)``, repeated indices result in the function being</span>
<span class="sd">    applied multiple times.</span>

<span class="sd">    Note that in the current implementation, ``scatter_apply`` is not compatible</span>
<span class="sd">    with automatic differentiation.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_scatter_apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">scatter_apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                   <span class="n">lax_internal</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                                   <span class="n">_scatter_apply</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] += y``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] += y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                   <span class="n">lax</span><span class="o">.</span><span class="n">scatter_add</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] *= y``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] *= y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                   <span class="n">lax</span><span class="o">.</span><span class="n">scatter_mul</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span>
                                   <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
  <span class="n">mul</span> <span class="o">=</span> <span class="n">multiply</span>

  <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] /= y``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] /= y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_divide_fn</span><span class="p">(</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
      <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                              <span class="n">lax</span><span class="o">.</span><span class="n">scatter_mul</span><span class="p">,</span>
                              <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                              <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] **= y``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] **= y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_power_fn</span><span class="p">(</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
      <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                              <span class="n">lax</span><span class="o">.</span><span class="n">scatter_mul</span><span class="p">,</span>
                              <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                              <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># noqa: F811</span>
          <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = minimum(x[idx], y)``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;`</span>
<span class="sd">    ``x[idx] = minimum(x[idx], y)``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                   <span class="n">lax</span><span class="o">.</span><span class="n">scatter_min</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># noqa: F811</span>
          <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = maximum(x[idx], y)``.</span>

<span class="sd">    Returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;`</span>
<span class="sd">    ``x[idx] = maximum(x[idx], y)``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scatter</span><span class="o">.</span><span class="n">_scatter_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                   <span class="n">lax</span><span class="o">.</span><span class="n">scatter_max</span><span class="p">,</span>
                                   <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                                   <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_set_shaped_array_attributes</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">):</span>
  <span class="c1"># Set up operator, method, and property forwarding on Tracer instances</span>
  <span class="c1"># containing</span>
  <span class="c1"># ShapedArray avals by following the forwarding conventions for Tracer.</span>
  <span class="c1"># Forward operators using a single-underscore-prefix naming convention:</span>
  <span class="k">for</span> <span class="n">operator_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">_operators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">operator_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">function</span><span class="p">))</span>
  <span class="c1"># Forward methods and properties using core.{aval_method, aval_property}:</span>
  <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_nondiff_methods</span> <span class="o">+</span> <span class="n">_diff_methods</span><span class="p">:</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">method_name</span><span class="p">]))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_reshape</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_transpose</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;flatten&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">ravel</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_notimplemented_flat</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">transpose</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">real</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">imag</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;astype&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_astype</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;view&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_view</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;nbytes&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_nbytes</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;itemsize&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_itemsize</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_clip</span><span class="p">))</span>

  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;_array_module&quot;</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">__array_module__</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;broadcast&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;broadcast_in_dim&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">_compress_method</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_IndexUpdateHelper</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">shaped_array</span><span class="p">,</span> <span class="s2">&quot;item&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="o">.</span><span class="n">item</span><span class="p">))</span>

<span class="n">_set_shaped_array_attributes</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">)</span>
<span class="n">_set_shaped_array_attributes</span><span class="p">(</span><span class="n">DShapedArray</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_set_device_array_base_attributes</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># Forward operators, methods, and properties on DeviceArray to lax_numpy</span>
  <span class="c1"># functions (with no Tracers involved; this forwarding is direct)</span>
  <span class="k">def</span> <span class="nf">maybe_setattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
      <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span> <span class="ow">or</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">include</span><span class="p">:</span>
      <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">operator_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">_operators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">maybe_setattr</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">operator_name</span><span class="si">}</span><span class="s2">__&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_nondiff_methods</span> <span class="o">+</span> <span class="n">_diff_methods</span><span class="p">:</span>
    <span class="n">maybe_setattr</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">method_name</span><span class="p">])</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">_reshape</span><span class="p">)</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="n">_transpose</span><span class="p">)</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;flatten&quot;</span><span class="p">,</span> <span class="n">ravel</span><span class="p">)</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;flat&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_notimplemented_flat</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">real</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">imag</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;astype&quot;</span><span class="p">,</span> <span class="n">_astype</span><span class="p">)</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;view&quot;</span><span class="p">,</span> <span class="n">_view</span><span class="p">)</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;nbytes&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_nbytes</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;itemsize&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_itemsize</span><span class="p">))</span>
  <span class="n">maybe_setattr</span><span class="p">(</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="n">_clip</span><span class="p">)</span>

<span class="n">_set_device_array_base_attributes</span><span class="p">(</span><span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">)</span>
<span class="n">_set_device_array_base_attributes</span><span class="p">(</span><span class="n">ArrayImpl</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">})</span>


<span class="k">def</span> <span class="nf">_set_device_array_attributes</span><span class="p">(</span><span class="n">device_array</span><span class="p">):</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;__array_module__&quot;</span><span class="p">,</span> <span class="n">__array_module__</span><span class="p">)</span>
  <span class="c1"># Extra methods that are handy</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;broadcast&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;broadcast_in_dim&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">split</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">_compress_method</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;_multi_slice&quot;</span><span class="p">,</span> <span class="n">_multi_slice</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_IndexUpdateHelper</span><span class="p">))</span>

<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">device_array</span><span class="o">.</span><span class="n">device_array_types</span><span class="p">:</span>
  <span class="n">_set_device_array_attributes</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">_set_device_array_attributes</span><span class="p">(</span><span class="n">pxla</span><span class="o">.</span><span class="n">_ShardedDeviceArray</span><span class="p">)</span>
<span class="n">_set_device_array_attributes</span><span class="p">(</span><span class="n">pxla</span><span class="o">.</span><span class="n">pmap_lib</span><span class="o">.</span><span class="n">ShardedDeviceArray</span><span class="p">)</span>
<span class="n">_set_device_array_attributes</span><span class="p">(</span><span class="n">ArrayImpl</span><span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      &copy; Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>