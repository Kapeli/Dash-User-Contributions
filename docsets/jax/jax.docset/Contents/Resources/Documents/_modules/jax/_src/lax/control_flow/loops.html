
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax._src.lax.control_flow.loops &#8212; JAX  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/copybutton.css" />
    <link rel="stylesheet" href="../../../../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/clipboard.min.js"></script>
    <script src="../../../../../_static/copybutton.js"></script>
    <script src="../../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../../../_static/jax_logo_250px.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../installation.html">
   Installing JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/quickstart.html">
   JAX Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/Common_Gotchas_in_JAX.html">
   ðŸ”ª JAX - The Sharp Bits ðŸ”ª
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../../jax-101/index.html">
   Tutorial: JAX 101
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax-101/08-pjit.html">
     Introduction to pjit
    </a>
   </li>
  </ul>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../../debugging/index.html">
   Runtime value debugging in JAX
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../debugging/print_breakpoint.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.print
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.breakpoint
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       checkify
      </span>
     </code>
     transformation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../debugging/flags.html">
     JAX debugging flags
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../async_dispatch.html">
   Asynchronous dispatch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../aot.html">
   Ahead-of-time lowering and compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../jaxpr.html">
   Understanding Jaxprs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/convolutions.html">
   Convolutions in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../pytrees.html">
   Pytrees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../type_promotion.html">
   Type promotion semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../errors.html">
   JAX Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../transfer_guard.html">
   Transfer guard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../glossary.html">
   JAX Glossary of Terms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../changelog.html">
   Change log
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../api_compatibility.html">
   API compatibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../deprecation.html">
   Python and NumPy version support policy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../concurrency.html">
   Concurrency
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../gpu_memory_allocation.html">
   GPU memory allocation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../profiling.html">
   Profiling JAX programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../device_memory_profiling.html">
   Device Memory Profiling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../rank_promotion_warning.html">
   Rank promotion warning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../contributing.html">
   Contributing to JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../developer.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../jax_internal_api.html">
   Internal APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../../autodidax.html">
   Autodidax: JAX core from scratch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../../jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/263-prng.html">
     263: JAX PRNG Design
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../../jax.html">
   Public API: jax package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.numpy.html">
     jax.numpy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.scipy.html">
     jax.scipy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.config.html">
     JAX configuration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.debug.html">
     jax.debug package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.dlpack.html">
     jax.dlpack module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.distributed.html">
     jax.distributed module
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../../jax.example_libraries.html">
     jax.example_libraries package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../../jax.experimental.html">
     jax.experimental package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.flatten_util.html">
     jax.flatten_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.image.html">
     jax.image package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.lax.html">
     jax.lax package
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../../jax.nn.html">
     jax.nn package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../../jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.ops.html">
     jax.ops package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.profiler.html">
     jax.profiler module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.random.html">
     jax.random package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.stages.html">
     jax.stages package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.tree_util.html">
     jax.tree_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../../jax.lib.html">
     jax.lib package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/google/jax"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for jax._src.lax.control_flow.loops</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2022 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;Module for the loop primitives.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">linear_util</span> <span class="k">as</span> <span class="n">lu</span>
<span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax.core</span> <span class="kn">import</span> <span class="n">ConcreteArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">raise_to_shaped</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">ad</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">batching</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">mlir</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">partial_eval</span> <span class="k">as</span> <span class="n">pe</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">xla</span>
<span class="kn">import</span> <span class="nn">jax._src.pretty_printer</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">jax.tree_util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">tree_flatten</span><span class="p">,</span> <span class="n">tree_unflatten</span><span class="p">,</span> <span class="n">treedef_is_leaf</span><span class="p">,</span>
                           <span class="n">tree_map</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">ad_checkpoint</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">ad_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">source_info_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">lax</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">slicing</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">windowed_reductions</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir</span> <span class="kn">import</span> <span class="n">ir</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir.dialects</span> <span class="kn">import</span> <span class="n">mhlo</span>
<span class="kn">from</span> <span class="nn">jax._src.traceback_util</span> <span class="kn">import</span> <span class="n">api_boundary</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">cache</span><span class="p">,</span>
    <span class="n">extend_name_stack</span><span class="p">,</span>
    <span class="n">partition_list</span><span class="p">,</span>
    <span class="n">safe_map</span><span class="p">,</span>
    <span class="n">safe_zip</span><span class="p">,</span>
    <span class="n">split_list</span><span class="p">,</span>
    <span class="n">unzip2</span><span class="p">,</span>
    <span class="n">weakref_lru_cache</span><span class="p">,</span>
    <span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">jax._src.lax.control_flow.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_abstractify</span><span class="p">,</span>
    <span class="n">_avals_short</span><span class="p">,</span>
    <span class="n">_check_tree_and_avals</span><span class="p">,</span>
    <span class="n">_initial_style_jaxpr</span><span class="p">,</span>
    <span class="n">_make_closed_jaxpr</span><span class="p">,</span>
    <span class="n">_prune_zeros</span><span class="p">,</span>
    <span class="n">_typecheck_param</span><span class="p">,</span>
    <span class="n">allowed_effects</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">_map</span> <span class="o">=</span> <span class="n">safe_map</span>
<span class="nb">zip</span> <span class="o">=</span> <span class="n">safe_zip</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Array</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">BooleanNumeric</span> <span class="o">=</span> <span class="n">Any</span>  <span class="c1"># A bool, or a Boolean array.</span>

<span class="c1">### Helper functions</span>

<span class="k">def</span> <span class="nf">_promote_weak_typed_inputs</span><span class="p">(</span><span class="n">in_vals</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Promote weakly-typed in_vals to be compatible with out_avals.</span>

<span class="sd">  Args:</span>
<span class="sd">    in_vals : flattened list of input values.</span>
<span class="sd">    in_avals : corresponding list of avals.</span>
<span class="sd">    out_avals : list of target output avals.</span>
<span class="sd">  Returns:</span>
<span class="sd">    in_vals_new : flattened list of modified in_vals with no weak types.</span>
<span class="sd">    changed : bool; true if in_vals required modification.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_vals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_avals</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_avals</span><span class="p">):</span>
    <span class="c1"># Calling function is responsible for catching this.</span>
    <span class="k">return</span> <span class="n">in_vals</span><span class="p">,</span> <span class="kc">False</span>
  <span class="n">weak_mismatches</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="s1">&#39;weak_type&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">typematch</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">weak_mismatches</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">in_vals</span><span class="p">,</span> <span class="kc">False</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">weak_mismatches</span><span class="p">:</span>
    <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">in_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out_avals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">in_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">in_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">in_vals</span><span class="p">,</span> <span class="kc">True</span>


<span class="c1">### scan</span>

<span class="n">Carry</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Carry&#39;</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="scan"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.scan.html#jax.lax.scan">[docs]</a><span class="nd">@api_boundary</span>
<span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Carry</span><span class="p">,</span> <span class="n">X</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Carry</span><span class="p">,</span> <span class="n">Y</span><span class="p">]],</span>
         <span class="n">init</span><span class="p">:</span> <span class="n">Carry</span><span class="p">,</span>
         <span class="n">xs</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span>
         <span class="n">length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
         <span class="n">unroll</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Carry</span><span class="p">,</span> <span class="n">Y</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Scan a function over leading array axes while carrying along state.</span>

<span class="sd">  The `Haskell-like type signature`_ in brief is</span>

<span class="sd">  .. code-block:: haskell</span>

<span class="sd">    scan :: (c -&gt; a -&gt; (c, b)) -&gt; c -&gt; [a] -&gt; (c, [b])</span>

<span class="sd">  where we use [t] here to denote the type t with an additional leading axis.</span>
<span class="sd">  That is, if t is an array type then [t] represents the type with an additional</span>
<span class="sd">  leading axis, and if t is a pytree (container) type with array leaves then [t]</span>
<span class="sd">  represents the type with the same pytree structure and corresponding leaves</span>
<span class="sd">  each with an additional leading axis.</span>

<span class="sd">  When ``a`` is an array type or None, and ``b`` is an array type, the semantics</span>
<span class="sd">  of ``scan`` are given roughly by this Python implementation::</span>

<span class="sd">    def scan(f, init, xs, length=None):</span>
<span class="sd">      if xs is None:</span>
<span class="sd">        xs = [None] * length</span>
<span class="sd">      carry = init</span>
<span class="sd">      ys = []</span>
<span class="sd">      for x in xs:</span>
<span class="sd">        carry, y = f(carry, x)</span>
<span class="sd">        ys.append(y)</span>
<span class="sd">      return carry, np.stack(ys)</span>

<span class="sd">  Unlike that Python version, both ``a`` and ``b`` may be arbitrary pytree</span>
<span class="sd">  types, and so multiple arrays can be scanned over at once and produce multiple</span>
<span class="sd">  output arrays. (None is actually an empty pytree.)</span>

<span class="sd">  Also unlike that Python version, ``scan`` is a JAX primitive and is lowered to</span>
<span class="sd">  a single XLA While HLO. That makes it useful for reducing compilation times</span>
<span class="sd">  for jit-compiled functions, since native Python loop constructs in an ``@jit``</span>
<span class="sd">  function are unrolled, leading to large XLA computations.</span>

<span class="sd">  Finally, the loop-carried value ``carry`` must hold a fixed shape and dtype</span>
<span class="sd">  across all iterations (and not just be consistent up to NumPy rank/shape</span>
<span class="sd">  broadcasting and dtype promotion rules, for example). In other words, the type</span>
<span class="sd">  ``c`` in the type signature above represents an array with a fixed shape and</span>
<span class="sd">  dtype (or a nested tuple/list/dict container data structure with a fixed</span>
<span class="sd">  structure and arrays with fixed shape and dtype at the leaves).</span>

<span class="sd">  .. note::</span>
<span class="sd">    :py:func:`scan` compiles ``f``, so while it can be combined with</span>
<span class="sd">    :py:func:`jit`, it&#39;s usually unnecessary.</span>

<span class="sd">  Args:</span>
<span class="sd">    f: a Python function to be scanned of type ``c -&gt; a -&gt; (c, b)``, meaning</span>
<span class="sd">      that ``f`` accepts two arguments where the first is a value of the loop</span>
<span class="sd">      carry and the second is a slice of ``xs`` along its leading axis, and that</span>
<span class="sd">      ``f`` returns a pair where the first element represents a new value for</span>
<span class="sd">      the loop carry and the second represents a slice of the output.</span>
<span class="sd">    init: an initial loop carry value of type ``c``, which can be a scalar,</span>
<span class="sd">      array, or any pytree (nested Python tuple/list/dict) thereof, representing</span>
<span class="sd">      the initial loop carry value. This value must have the same structure as</span>
<span class="sd">      the first element of the pair returned by ``f``.</span>
<span class="sd">    xs: the value of type ``[a]`` over which to scan along the leading axis,</span>
<span class="sd">      where ``[a]`` can be an array or any pytree (nested Python</span>
<span class="sd">      tuple/list/dict) thereof with consistent leading axis sizes.</span>
<span class="sd">    length: optional integer specifying the number of loop iterations, which</span>
<span class="sd">      must agree with the sizes of leading axes of the arrays in ``xs`` (but can</span>
<span class="sd">      be used to perform scans where no input ``xs`` are needed).</span>
<span class="sd">    reverse: optional boolean specifying whether to run the scan iteration</span>
<span class="sd">      forward (the default) or in reverse, equivalent to reversing the leading</span>
<span class="sd">      axes of the arrays in both ``xs`` and in ``ys``.</span>
<span class="sd">    unroll: optional positive int specifying, in the underlying operation of the</span>
<span class="sd">      scan primitive, how many scan iterations to unroll within a single</span>
<span class="sd">      iteration of a loop.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A pair of type ``(c, [b])`` where the first element represents the final</span>
<span class="sd">    loop carry value and the second element represents the stacked outputs of</span>
<span class="sd">    the second output of ``f`` when scanned over the leading axis of the inputs.</span>

<span class="sd">  .. _Haskell-like type signature: https://wiki.haskell.org/Type_signature</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lax.scan: f argument should be a callable.&quot;</span><span class="p">)</span>
  <span class="n">xs_flat</span><span class="p">,</span> <span class="n">xs_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span><span class="p">]</span>
  <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;scan got value with no leading axis to scan over: </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span>
                           <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">))))</span> <span class="kn">from</span> <span class="nn">err</span>

  <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;scan got `length` argument of </span><span class="si">{}</span><span class="s2"> which disagrees with &quot;</span>
             <span class="s2">&quot;leading axis sizes </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span><span class="p">]))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">unique_lengths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;scan got values with different leading axis sizes: </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_lengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;scan got no values to scan over and `length` not provided.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">length</span><span class="p">,</span> <span class="o">=</span> <span class="n">unique_lengths</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_disable_jit</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zero-length scan is not supported in disable_jit() mode because the output type is unknown.&quot;</span><span class="p">)</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="n">init</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maybe_reversed</span> <span class="o">=</span> <span class="nb">reversed</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">maybe_reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)):</span>
      <span class="n">xs_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">_index_array</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span><span class="p">]</span>
      <span class="n">carry</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">xs_tree</span><span class="p">,</span> <span class="n">xs_slice</span><span class="p">))</span>
      <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">ys</span><span class="p">:</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="n">stacked_y</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="o">*</span><span class="n">maybe_reversed</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">carry</span><span class="p">,</span> <span class="n">stacked_y</span>

  <span class="n">xs_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_flat</span><span class="p">]</span>
  <span class="n">x_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">mapped_aval</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">xs_avals</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">_create_jaxpr</span><span class="p">(</span><span class="n">init</span><span class="p">):</span>
    <span class="n">init_flat</span><span class="p">,</span> <span class="n">init_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
    <span class="n">in_flat</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">((</span><span class="n">init</span><span class="p">,</span> <span class="n">xs</span><span class="p">))</span>

    <span class="n">carry_avals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">_abstractify</span><span class="p">,</span> <span class="n">init_flat</span><span class="p">))</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">_initial_style_jaxpr</span><span class="p">(</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">carry_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">x_avals</span><span class="p">),</span> <span class="s2">&quot;scan&quot;</span><span class="p">)</span>
    <span class="n">out_tree_children</span> <span class="o">=</span> <span class="n">out_tree</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tree_children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;scan body output must be a pair, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)))</span>
    <span class="n">carry_avals_out</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[:</span><span class="n">out_tree_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">init_flat</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">carry_avals_out</span><span class="p">,</span> <span class="n">init_tree</span><span class="p">,</span> <span class="n">in_flat</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">,</span> <span class="n">out_tree_children</span>

  <span class="c1"># The carry input and output avals must match exactly. However, we want to account for</span>
  <span class="c1"># the case when init contains weakly-typed values (e.g. Python scalars), with avals that</span>
  <span class="c1"># may not match the output despite being compatible by virtue of their weak type.</span>
  <span class="c1"># To do this, we compute the jaxpr in two passes: first with the raw inputs, and if</span>
  <span class="c1"># necessary, a second time with modified init values.</span>
  <span class="n">init_flat</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">carry_avals_out</span><span class="p">,</span> <span class="n">init_tree</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">_create_jaxpr</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
  <span class="n">new_init_flat</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">_promote_weak_typed_inputs</span><span class="p">(</span><span class="n">init_flat</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">carry_avals_out</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
    <span class="n">new_init</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">init_tree</span><span class="p">,</span> <span class="n">new_init_flat</span><span class="p">)</span>
    <span class="n">init_flat</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">carry_avals_out</span><span class="p">,</span> <span class="n">init_tree</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">_create_jaxpr</span><span class="p">(</span><span class="n">new_init</span><span class="p">)</span>
  <span class="n">in_flat</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span><span class="p">,</span> <span class="n">out_tree_children</span> <span class="o">=</span> <span class="n">rest</span>

  <span class="n">_check_tree_and_avals</span><span class="p">(</span><span class="s2">&quot;scan carry output and input&quot;</span><span class="p">,</span>
                        <span class="c1"># Extract the subtree and avals for the first element of the return tuple</span>
                        <span class="n">out_tree_children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">carry_avals_out</span><span class="p">,</span>
                        <span class="n">init_tree</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">)</span>
  <span class="n">disallowed_effects</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span> <span class="o">-</span> <span class="n">allowed_effects</span>
  <span class="k">if</span> <span class="n">disallowed_effects</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Effects not supported in `scan`: </span><span class="si">{</span><span class="n">disallowed_effects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="n">out</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">in_flat</span><span class="p">,</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="p">,</span>
                    <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">),</span> <span class="n">num_carry</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">init_flat</span><span class="p">),</span>
                    <span class="n">linear</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_flat</span><span class="p">)),</span>
                    <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_scan_impl_unrolled</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span>
                        <span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">):</span>
  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="n">carry</span> <span class="o">=</span> <span class="n">init</span>
  <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="n">i_</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">i</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_index_array</span><span class="p">,</span> <span class="n">i_</span><span class="p">),</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">f_impl</span><span class="p">(</span><span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
    <span class="n">carry</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

  <span class="n">ys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">ys</span>
  <span class="n">ys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ys</span><span class="p">))</span>
  <span class="n">ys</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">_stack</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">ys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_scan_impl_loop</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span>
                    <span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">):</span>
  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">cond_fun</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">vals</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span>

  <span class="k">def</span> <span class="nf">body_fun</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
    <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">carry</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
    <span class="n">i_</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">i</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_dynamic_index_array</span><span class="p">,</span> <span class="n">i_</span><span class="p">),</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">out_flat</span> <span class="o">=</span> <span class="n">f_impl</span><span class="p">(</span><span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
    <span class="n">carry_out</span><span class="p">,</span> <span class="n">y_updates</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out_flat</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="n">ys_out</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_update_array</span><span class="p">,</span> <span class="n">i_</span><span class="p">),</span> <span class="n">y_avals</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">y_updates</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry_out</span> <span class="o">+</span> <span class="n">ys_out</span>

  <span class="n">ys_init</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_empty_array</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">y_avals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">init</span> <span class="o">+</span> <span class="n">ys_init</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">init_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">init</span> <span class="o">+</span> <span class="n">ys_init</span>
    <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">outs</span> <span class="o">=</span> <span class="n">while_loop</span><span class="p">(</span><span class="n">cond_fun</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">,</span> <span class="n">init_val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outs</span>

<span class="k">def</span> <span class="nf">_scan_impl_block_unrolled</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span>
                              <span class="n">linear</span><span class="p">,</span> <span class="n">block_length</span><span class="p">,</span> <span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">):</span>
  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="n">num_blocks</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">block_length</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span>

  <span class="n">partition</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_partition_leading</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="n">block_length</span><span class="p">)</span>
  <span class="n">xs_block</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>

  <span class="n">prepend_aval</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_prepend_dim_to_aval</span><span class="p">,</span> <span class="n">block_length</span><span class="p">)</span>
  <span class="n">x_block_avals</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">prepend_aval</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">)</span>
  <span class="n">y_block_avals</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">prepend_aval</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">)</span>

  <span class="n">f_impl_block</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
      <span class="n">_scan_impl_unrolled</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">block_length</span><span class="p">,</span>
      <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
      <span class="n">f_impl</span><span class="o">=</span><span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="o">=</span><span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="o">=</span><span class="n">y_avals</span><span class="p">)</span>

  <span class="n">outs</span> <span class="o">=</span> <span class="n">_scan_impl_loop</span><span class="p">(</span>
      <span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="o">*</span><span class="n">xs_block</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">num_blocks</span><span class="p">,</span>
      <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
      <span class="n">f_impl</span><span class="o">=</span><span class="n">f_impl_block</span><span class="p">,</span> <span class="n">x_avals</span><span class="o">=</span><span class="n">x_block_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="o">=</span><span class="n">y_block_avals</span><span class="p">)</span>

  <span class="n">carry</span><span class="p">,</span> <span class="n">ys_blocks</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">combine</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_combine_leading</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="n">block_length</span><span class="p">)</span>
  <span class="n">ys</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">,</span> <span class="n">ys_blocks</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">ys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_scan_impl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span>
               <span class="n">unroll</span><span class="p">):</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">y_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">f_impl</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">unroll</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_scan_impl_loop</span><span class="p">(</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span>
        <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span> <span class="n">f_impl</span><span class="o">=</span><span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="o">=</span><span class="n">x_avals</span><span class="p">,</span>
        <span class="n">y_avals</span><span class="o">=</span><span class="n">y_avals</span><span class="p">)</span>

  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">num_blocks</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">unroll</span><span class="p">)</span>
  <span class="n">length_div</span> <span class="o">=</span> <span class="n">num_blocks</span> <span class="o">*</span> <span class="n">unroll</span>

  <span class="k">if</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
      <span class="n">split</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_split_leading_dim</span><span class="p">,</span> <span class="n">rem</span><span class="p">)</span>
      <span class="n">xs_rem</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">xs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">split</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_split_leading_dim</span><span class="p">,</span> <span class="n">length_div</span><span class="p">)</span>
      <span class="n">xs</span><span class="p">,</span> <span class="n">xs_rem</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">x_avals</span><span class="p">,</span> <span class="n">xs</span><span class="p">))</span>

  <span class="n">outs</span> <span class="o">=</span> <span class="n">_scan_impl_block_unrolled</span><span class="p">(</span>
      <span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length_div</span><span class="p">,</span>
      <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
      <span class="n">block_length</span><span class="o">=</span><span class="n">unroll</span><span class="p">,</span> <span class="n">f_impl</span><span class="o">=</span><span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="o">=</span><span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="o">=</span><span class="n">y_avals</span><span class="p">)</span>

  <span class="n">carry</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>

  <span class="k">if</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="n">_scan_impl_unrolled</span><span class="p">(</span>
        <span class="o">*</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">xs_rem</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">rem</span><span class="p">,</span>
        <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
        <span class="n">f_impl</span><span class="o">=</span><span class="n">f_impl</span><span class="p">,</span> <span class="n">x_avals</span><span class="o">=</span><span class="n">x_avals</span><span class="p">,</span> <span class="n">y_avals</span><span class="o">=</span><span class="n">y_avals</span><span class="p">)</span>
    <span class="n">carry</span><span class="p">,</span> <span class="n">ys_rem</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
      <span class="n">ys</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">_concatenate</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">,</span> <span class="n">ys_rem</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ys</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">_concatenate</span><span class="p">,</span> <span class="n">y_avals</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ys_rem</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">carry</span><span class="p">,</span> <span class="o">*</span><span class="n">ys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_stack</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
  <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_concatenate</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_split_leading_dim</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
          <span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">_dynamic_index_array</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">slicing</span><span class="o">.</span><span class="n">dynamic_index_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_index_array</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">slicing</span><span class="o">.</span><span class="n">index_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_empty_array</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="o">*</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_update_array</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">slicing</span><span class="o">.</span><span class="n">dynamic_update_index_in_dim</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_partition_leading</span><span class="p">(</span><span class="n">sz0</span><span class="p">,</span> <span class="n">sz1</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sz0</span> <span class="o">*</span> <span class="n">sz1</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">sz0</span><span class="p">,</span> <span class="n">sz1</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

<span class="k">def</span> <span class="nf">_combine_leading</span><span class="p">(</span><span class="n">sz0</span><span class="p">,</span> <span class="n">sz1</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sz0</span>
  <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sz1</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_prepend_dim_to_aval</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">no_axis_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_scan_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span>
                        <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="n">carry_avals</span><span class="p">,</span> <span class="n">y_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">ys_avals</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_prepend_dim_to_aval</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">y_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">carry_avals</span> <span class="o">+</span> <span class="n">ys_avals</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span>

<span class="k">def</span> <span class="nf">_scan_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span>
              <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="n">num_xs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_carry</span> <span class="o">-</span> <span class="n">num_consts</span>
  <span class="n">num_ys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_carry</span>
  <span class="n">nonzeros</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">]</span>
  <span class="n">const_nz</span><span class="p">,</span> <span class="n">init_nz</span><span class="p">,</span> <span class="n">xs_nz</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">nonzeros</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="c1"># Fixpoint computation of which carry are not ad.zero: either</span>
  <span class="c1"># non-zero from init, or the carry out is non-zero. Each iteration promotes</span>
  <span class="c1"># at least one carry to non-zero. We need at most len(carry) iterations,</span>
  <span class="c1"># but we need one last iteration to prepare the jaxpr based on the final</span>
  <span class="c1"># carry_nz.</span>
  <span class="n">carry_nz</span> <span class="o">=</span> <span class="n">init_nz</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_nz</span><span class="p">)):</span>
    <span class="n">nonzeros</span> <span class="o">=</span> <span class="n">const_nz</span> <span class="o">+</span> <span class="n">carry_nz</span> <span class="o">+</span> <span class="n">xs_nz</span>
    <span class="n">jaxpr_jvp</span><span class="p">,</span> <span class="n">nonzeros_out</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">jvp_jaxpr</span><span class="p">(</span>
        <span class="n">jaxpr</span><span class="p">,</span> <span class="n">nonzeros</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_nz</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ys</span><span class="p">)</span>
    <span class="n">carry_nz_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nonzeros_out</span><span class="p">[:</span><span class="n">num_carry</span><span class="p">],</span> <span class="n">nonzeros_out</span><span class="p">[</span><span class="n">num_carry</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">carry_nz_out</span> <span class="o">==</span> <span class="n">carry_nz</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_nz</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_nz</span><span class="p">,</span> <span class="n">carry_nz_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>

  <span class="n">tangents</span> <span class="o">=</span> <span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">nz</span> <span class="k">else</span> <span class="n">t</span>
              <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">nz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tangents</span><span class="p">,</span> <span class="n">nonzeros</span><span class="p">)]</span>

  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">all_tangents</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">tangents</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">consts_dot</span><span class="p">,</span> <span class="n">init_dot</span><span class="p">,</span> <span class="n">xs_dot</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">_prune_zeros</span><span class="p">,</span> <span class="n">all_tangents</span><span class="p">)</span>

  <span class="n">jaxpr_jvp_rearranged</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">rearrange_binders</span><span class="p">(</span>
      <span class="n">jaxpr_jvp</span><span class="p">,</span>
      <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">num_xs</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">consts_dot</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_dot</span><span class="p">)],</span>
      <span class="p">[</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">num_ys</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nonzeros_out</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">)])</span>

  <span class="n">consts_linear</span><span class="p">,</span> <span class="n">init_linear</span><span class="p">,</span> <span class="n">xs_linear</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">jaxpr_jvp_linear</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">consts_linear</span> <span class="o">+</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts_dot</span><span class="p">)</span>
                           <span class="o">+</span> <span class="n">init_linear</span> <span class="o">+</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">)</span>
                           <span class="o">+</span> <span class="n">xs_linear</span> <span class="o">+</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_dot</span><span class="p">))</span>

  <span class="n">out_flat</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="p">(</span><span class="n">consts</span> <span class="o">+</span> <span class="n">consts_dot</span> <span class="o">+</span> <span class="n">init</span> <span class="o">+</span> <span class="n">init_dot</span> <span class="o">+</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">xs_dot</span><span class="p">),</span>
      <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_jvp_rearranged</span><span class="p">,</span>
      <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts_dot</span><span class="p">),</span>
      <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">),</span>
      <span class="n">linear</span><span class="o">=</span><span class="n">jaxpr_jvp_linear</span><span class="p">,</span> <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">)</span>

  <span class="n">carry</span><span class="p">,</span> <span class="n">carry_dot</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">ys_dot</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out_flat</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">),</span> <span class="n">num_ys</span><span class="p">])</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">ys</span>
  <span class="n">tangents_out_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">carry_dot</span> <span class="o">+</span> <span class="n">ys_dot</span><span class="p">)</span>
  <span class="n">tangents_out</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">tangents_out_iter</span><span class="p">)</span> <span class="k">if</span> <span class="n">nz</span> <span class="k">else</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">nz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primals_out</span><span class="p">,</span> <span class="n">nonzeros_out</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span>

<span class="k">def</span> <span class="nf">_scan_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span>
                       <span class="n">jaxpr</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="n">num_ys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_carry</span>
  <span class="n">unknowns</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
  <span class="n">const_uk</span><span class="p">,</span> <span class="n">init_uk</span><span class="p">,</span> <span class="n">xs_uk</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">unknowns</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="c1"># Fixpoint computation of which carry elements are unknown. Each iteration</span>
  <span class="c1"># promotes at least one carry to unknown. We need at most len(carry)</span>
  <span class="c1"># iterations, but we need one last iteration to prepare the jaxpr based on the</span>
  <span class="c1"># final carry_uk.</span>
  <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">init_uk</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)):</span>
    <span class="n">unknowns</span> <span class="o">=</span> <span class="n">const_uk</span> <span class="o">+</span> <span class="n">carry_uk</span> <span class="o">+</span> <span class="n">xs_uk</span>
    <span class="n">jaxpr_known</span><span class="p">,</span> <span class="n">jaxpr_unknown</span><span class="p">,</span> <span class="n">out_uk</span><span class="p">,</span> <span class="n">res_avals</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_nounits</span><span class="p">(</span>
        <span class="n">jaxpr</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_uk</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ys</span><span class="p">)</span>
    <span class="n">carry_uk_out</span><span class="p">,</span> <span class="n">ys_uk</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out_uk</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">carry_uk_out</span> <span class="o">==</span> <span class="n">carry_uk</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">carry_uk_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>
  <span class="n">num_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_avals</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">res_avals</span><span class="p">,</span> <span class="n">carry_uk_out</span>

  <span class="c1"># Instantiate those inputs which must be treated as unknown from the fixpoint.</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">uk</span> <span class="k">else</span> <span class="n">t</span>
             <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">uk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tracers</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)]</span>

  <span class="c1"># The residual inputs and outputs of the jaxprs produced haven&#39;t yet been</span>
  <span class="c1"># adapted to the scan calling convention; in particular, jaxpr_known has its</span>
  <span class="c1"># residual outputs all at the end, meaning they&#39;re extensive outputs (which is</span>
  <span class="c1"># fully general but may be wasteful for residuals which are loop-invariant)</span>
  <span class="c1"># while jaxpr_unknown has its corresponding residual inputs at the front (just</span>
  <span class="c1"># as a convention with partial_eval_jaxpr_nounits), making them constant</span>
  <span class="c1"># inputs. To make them consistent, we move the residual inputs on</span>
  <span class="c1"># jaxpr_unknown to the end, even though we may move some back in the sequel.</span>
  <span class="n">jaxpr_unknown</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">move_binders_to_back</span><span class="p">(</span>
      <span class="n">jaxpr_unknown</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_res</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">unknowns</span><span class="p">))</span>

  <span class="c1"># At this point, all residuals are treated as extensive outputs of jaxpr_known</span>
  <span class="c1"># (and extensive inputs to jaxpr_unknown). But residuals that are loop-</span>
  <span class="c1"># invariant can be hoisted out of the scan, rather than letting them get</span>
  <span class="c1"># broadcast (as in e.g. scanning multiplication by a constant matrix; we don&#39;t</span>
  <span class="c1"># want to broadcast the matrix!). So, outside the loop we perform a partial</span>
  <span class="c1"># evaluation with known &#39;const&#39; inputs (but all other inputs unknown).</span>
  <span class="n">const_pvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">get_known</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">[:</span><span class="n">num_consts</span><span class="p">]</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()]</span>
  <span class="n">other_pvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">jaxpr_known</span><span class="o">.</span><span class="n">in_avals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">const_pvals</span><span class="p">):]]</span>
  <span class="k">with</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">reset_name_stack</span><span class="p">():</span>
    <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">invar_pvals_out</span><span class="p">,</span> <span class="n">jaxpr_known_consts</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">trace_to_jaxpr_nounits</span><span class="p">(</span>
        <span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr_known</span><span class="p">)),</span> <span class="n">const_pvals</span> <span class="o">+</span> <span class="n">other_pvals</span><span class="p">,</span>
        <span class="n">instantiate</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">out_uk</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="n">jaxpr_known</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">convert_constvars_jaxpr</span><span class="p">(</span><span class="n">jaxpr_known_</span><span class="p">),</span> <span class="p">())</span>
  <span class="c1"># The above trace_to_jaxpr_nounits call computed loop-invariant residuals</span>
  <span class="c1"># (known values in invar_pvals_out) and also computed loop-invariant values</span>
  <span class="c1"># needed by the new jaxpr_known (in jaxpr_known_consts, which replace the</span>
  <span class="c1"># previous consts). We need to collect the computed inteisive residuals, and</span>
  <span class="c1"># move corresponding intensive residual binders in jaxpr_unknown to the front.</span>
  <span class="n">res_pvals</span> <span class="o">=</span> <span class="n">invar_pvals_out</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">invar_pvals_out</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">:]</span>
  <span class="n">intensive_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">get_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">res_pvals</span> <span class="k">if</span> <span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()]</span>
  <span class="n">jaxpr_unknown</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">move_binders_to_front</span><span class="p">(</span>
      <span class="n">jaxpr_unknown</span><span class="p">,</span>
      <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">unknowns</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">res_pvals</span><span class="p">])</span>
  <span class="k">del</span> <span class="n">const_pvals</span><span class="p">,</span> <span class="n">other_pvals</span><span class="p">,</span> <span class="n">invar_pvals_out</span><span class="p">,</span> <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">res_pvals</span>
  <span class="c1"># We use `jaxpr_known_consts` when we call scan_p.bind with jaxpr_known, and</span>
  <span class="c1"># we use `intensive_res` when we build the jaxpr eqn with jaxpr_unknown.</span>

  <span class="c1"># As another optimization, for any extensive inputs that are just forwarded to</span>
  <span class="c1"># extensive outputs, to avoid a copy (which would be looping over</span>
  <span class="c1"># dynamic-update-slice) we&#39;d rather forward the input tracer/value. That means</span>
  <span class="c1"># pruning some outputs from jaxpr_known here, and updating `out_flat` below.</span>
  <span class="n">fwds_known</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">_jaxpr_forwarding</span><span class="p">(</span><span class="n">jaxpr_known</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="c1"># Prune fwds_known to include only extensive input to extensive output.</span>
  <span class="n">fwds_known</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_idx</span> <span class="k">if</span> <span class="n">out_idx</span> <span class="o">&gt;=</span> <span class="n">num_carry</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">in_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">in_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr_known_consts</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_carry</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span>
                <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">out_idx</span><span class="p">,</span> <span class="n">in_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fwds_known</span><span class="p">)]</span>
  <span class="c1"># Drop any extensive output we can instead get by forwarding an input.</span>
  <span class="c1"># TODO(mattjj): use pe.dce_jaxpr here, though need a fixpoint</span>
  <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="p">()</span> <span class="o">=</span> <span class="n">jaxpr_known</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">jaxpr_known</span><span class="o">.</span><span class="n">consts</span>
  <span class="n">jaxpr_known_</span><span class="o">.</span><span class="n">outvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jaxpr_known_</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">fwds_known</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
  <span class="n">jaxpr_known</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr_known_</span><span class="p">,</span> <span class="p">())</span>
  <span class="k">del</span> <span class="n">jaxpr_known_</span>
  <span class="c1"># We use `fwds_known` below when forming the output of scanning jaxpr_known.</span>

  <span class="c1"># Run the known part of the scan (if it has any outputs or effects).</span>
  <span class="n">known_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">jaxpr_known_consts</span><span class="p">)</span> <span class="o">+</span>
                  <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">get_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">[</span><span class="n">num_consts</span><span class="p">:]</span>
                   <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()])</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">jaxpr_known</span><span class="o">.</span><span class="n">out_avals</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">jaxpr_known</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
    <span class="n">out_known</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">linear_known</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">known_inputs</span><span class="p">)</span>  <span class="c1"># conservative!</span>
    <span class="n">out_known</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="o">*</span><span class="n">known_inputs</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_known</span><span class="p">,</span>
        <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">jaxpr_known_consts</span><span class="p">),</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">),</span>
        <span class="n">linear</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">linear_known</span><span class="p">),</span> <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">linear_known</span>
  <span class="c1"># Complete the known output by filling in forwarded values using fwds_known.</span>
  <span class="n">out_known_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">out_known</span><span class="p">)</span>
  <span class="n">out_known</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">out_known_iter</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span>
               <span class="k">else</span> <span class="n">_maybe_put</span><span class="p">(</span><span class="n">known_inputs</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fwds_known</span><span class="p">]</span>
  <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">out_known_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
  <span class="k">del</span> <span class="n">known_inputs</span><span class="p">,</span> <span class="n">out_known_iter</span>

  <span class="c1"># Split known outputs from residuals.</span>
  <span class="n">out_known</span><span class="p">,</span> <span class="n">extensive_res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out_known</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">out_uk</span><span class="p">)])</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensive_res</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">extensive_res</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_res</span>

  <span class="c1"># Create input tracers for jaxpr_unknown bind.</span>
  <span class="n">unknown_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()]</span>
  <span class="n">intensive_res</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">new_instantiated_const</span><span class="p">,</span> <span class="n">intensive_res</span><span class="p">)</span>
  <span class="n">extensive_res</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">new_instantiated_const</span><span class="p">,</span> <span class="n">extensive_res</span><span class="p">)</span>
  <span class="c1"># Create output tracers for jaxpr_unknown bind, adapting extensive shapes.</span>
  <span class="n">carry_avals</span><span class="p">,</span> <span class="n">y_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr_unknown</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)])</span>
  <span class="n">ys_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">no_axis_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_aval</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">y_aval</span> <span class="ow">in</span> <span class="n">y_avals</span><span class="p">]</span>
  <span class="n">out_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">JaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">carry_avals</span><span class="p">,</span> <span class="n">ys_avals</span><span class="p">)]</span>
  <span class="k">del</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">y_avals</span>
  <span class="c1"># Create equation.</span>
  <span class="n">linear_unknown</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensive_res</span><span class="p">)</span> <span class="o">+</span>
                         <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">uk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">)</span> <span class="k">if</span> <span class="n">uk</span><span class="p">]</span> <span class="o">+</span>
                         <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">extensive_res</span><span class="p">))</span>
  <span class="n">name_stack</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current_name_stack</span><span class="p">()[</span><span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">name_stack</span><span class="p">):]</span>
  <span class="n">source</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tracers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr_unknown</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_eqn_recipe</span><span class="p">([</span><span class="o">*</span><span class="n">intensive_res</span><span class="p">,</span> <span class="o">*</span><span class="n">unknown_inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">extensive_res</span><span class="p">],</span>
                          <span class="n">out_tracers</span><span class="p">,</span> <span class="n">scan_p</span><span class="p">,</span>
                          <span class="nb">dict</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">,</span>
                               <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_unknown</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear_unknown</span><span class="p">,</span>
                               <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">intensive_res</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">const_uk</span><span class="p">),</span>
                               <span class="n">num_carry</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)),</span>
                          <span class="n">jaxpr_unknown</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_tracers</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>

  <span class="c1"># Merge known and unknown outputs into final result.</span>
  <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">out_uk</span><span class="p">,</span> <span class="n">out_known</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_maybe_put</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">device_put</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">devices</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">_scan_transpose</span><span class="p">(</span><span class="n">reduce_axes</span><span class="p">,</span> <span class="n">cts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span>
                    <span class="n">num_carry</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="c1"># we&#39;ve only implemented transposing scans with specific lin/nonlin patterns</span>
  <span class="n">consts_lin</span><span class="p">,</span> <span class="n">init_lin</span><span class="p">,</span> <span class="n">xs_lin</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">num_ires</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts_lin</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">consts_lin</span><span class="p">)</span>
  <span class="n">num_eres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_lin</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">xs_lin</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">consts_lin</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ires</span> <span class="o">+</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">consts_lin</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_ires</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
  <span class="k">if</span> <span class="n">xs_lin</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs_lin</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_eres</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_eres</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">init_lin</span><span class="p">):</span>
    <span class="k">pass</span>  <span class="c1"># TODO(mattjj): error check https://github.com/google/jax/issues/1963</span>

  <span class="n">consts</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">ires</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">consts</span><span class="p">,</span> <span class="p">[</span><span class="n">num_ires</span><span class="p">])</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">eres</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">xs_lin</span><span class="p">)])</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ires</span><span class="p">)</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">eres</span><span class="p">)</span>

  <span class="n">carry_avals</span><span class="p">,</span> <span class="n">y_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">ys_avals</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_prepend_dim_to_aval</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">y_avals</span><span class="p">)</span>
  <span class="n">ct_carry</span><span class="p">,</span> <span class="n">ct_ys</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">ct_carry</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">ct_carry</span><span class="p">)</span>
  <span class="n">ct_ys</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">,</span> <span class="n">ys_avals</span><span class="p">,</span> <span class="n">ct_ys</span><span class="p">)</span>
  <span class="n">ct_consts</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">ad_util</span><span class="o">.</span><span class="n">zeros_like_aval</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">[</span><span class="n">num_ires</span><span class="p">:</span><span class="n">num_consts</span><span class="p">])</span>

  <span class="c1">#       jaxpr :: [ires, T d] -&gt; [T c] -&gt; [T a, eres] -&gt; ([T c], [T b])</span>
  <span class="c1"># jaxpr_trans :: [ires] -&gt; [CT d, CT c] -&gt; [CT b, eres] -&gt; ([CT d, CT c], [CT a])</span>
  <span class="n">jaxpr_trans</span> <span class="o">=</span> <span class="n">_transpose_scan_jaxpr</span><span class="p">(</span>
      <span class="n">num_ires</span><span class="p">,</span> <span class="n">num_consts</span> <span class="o">-</span> <span class="n">num_ires</span><span class="p">,</span> <span class="n">num_eres</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">reduce_axes</span><span class="p">)</span>
  <span class="n">linear_trans</span> <span class="o">=</span> <span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ires</span> <span class="o">+</span>
                  <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ct_consts</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ct_carry</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ct_ys</span><span class="p">))</span> <span class="o">+</span>
                  <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_eres</span><span class="p">)</span>

  <span class="n">outs</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="p">(</span><span class="n">ires</span> <span class="o">+</span> <span class="n">ct_consts</span> <span class="o">+</span> <span class="n">ct_carry</span> <span class="o">+</span> <span class="n">ct_ys</span> <span class="o">+</span> <span class="n">eres</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="ow">not</span> <span class="n">reverse</span><span class="p">,</span>
      <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_trans</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="n">num_ires</span><span class="p">,</span>
      <span class="n">num_carry</span><span class="o">=</span><span class="n">num_consts</span><span class="o">-</span><span class="n">num_ires</span><span class="o">+</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">linear_trans</span><span class="p">),</span>
      <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">)</span>
  <span class="n">ct_consts</span><span class="p">,</span> <span class="n">ct_init</span><span class="p">,</span> <span class="n">ct_xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span> <span class="o">-</span> <span class="n">num_ires</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ires</span> <span class="o">+</span> <span class="n">ct_consts</span> <span class="o">+</span> <span class="n">ct_init</span> <span class="o">+</span> <span class="n">ct_xs</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_eres</span>

<span class="c1"># transpose_scan_jaxpr :: ([res1, c, a, res2] -&gt; b)</span>
<span class="c1">#                         -&gt; ([res1, CT c, CT b, res2] -&gt; [CT c, CT a])</span>
<span class="k">def</span> <span class="nf">_transpose_scan_jaxpr</span><span class="p">(</span><span class="n">num_res1</span><span class="p">,</span> <span class="n">num_c</span><span class="p">,</span> <span class="n">num_res2</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">reduce_axes</span><span class="p">):</span>
  <span class="n">num_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res1</span> <span class="o">-</span> <span class="n">num_c</span> <span class="o">-</span> <span class="n">num_res2</span>
  <span class="c1"># TODO: allow input cotangent avals to be batched relative to jaxpr.in_avals</span>
  <span class="c1"># if an axis isn&#39;t reduced</span>
  <span class="n">res1_avals</span><span class="p">,</span> <span class="n">c_avals</span><span class="p">,</span> <span class="n">a_avals</span><span class="p">,</span> <span class="n">res2_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span>
      <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_res1</span><span class="p">,</span> <span class="n">num_c</span><span class="p">,</span> <span class="n">num_a</span><span class="p">])</span>
  <span class="n">num_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>
  <span class="n">b_avals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>

  <span class="nd">@lu</span><span class="o">.</span><span class="n">wrap_init</span>
  <span class="k">def</span> <span class="nf">transposed</span><span class="p">(</span><span class="o">*</span><span class="n">res1_cbar_bbar_res2</span><span class="p">):</span>
    <span class="n">res1</span><span class="p">,</span> <span class="n">c_bar</span><span class="p">,</span> <span class="n">b_bar</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span>
        <span class="n">res1_cbar_bbar_res2</span><span class="p">,</span> <span class="p">[</span><span class="n">num_res1</span><span class="p">,</span> <span class="n">num_c</span><span class="p">,</span> <span class="n">num_b</span><span class="p">])</span>
    <span class="n">primals</span> <span class="o">=</span> <span class="p">(</span><span class="n">res1</span> <span class="o">+</span> <span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">UndefinedPrimal</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">c_avals</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">UndefinedPrimal</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">a_avals</span><span class="p">]</span> <span class="o">+</span> <span class="n">res2</span><span class="p">)</span>
    <span class="n">cbar_abar</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">backward_pass</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">reduce_axes</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">,</span>
                                 <span class="n">primals</span><span class="p">,</span> <span class="n">b_bar</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_c_bar</span><span class="p">,</span> <span class="n">a_bar</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">cbar_abar</span><span class="p">,</span> <span class="p">[</span><span class="n">num_res1</span><span class="p">,</span> <span class="n">num_c</span><span class="p">,</span> <span class="n">num_a</span><span class="p">])</span>
    <span class="n">a_bar</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">,</span> <span class="n">a_avals</span><span class="p">,</span> <span class="n">a_bar</span><span class="p">)</span>
    <span class="n">c_bar</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">,</span> <span class="n">c_avals</span><span class="p">,</span>
                <span class="n">_map</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">add_tangents</span><span class="p">,</span> <span class="n">c_bar</span><span class="p">,</span> <span class="n">new_c_bar</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">c_bar</span> <span class="o">+</span> <span class="n">a_bar</span>
  <span class="k">return</span> <span class="n">_make_closed_jaxpr</span><span class="p">(</span><span class="n">transposed</span><span class="p">,</span> <span class="n">res1_avals</span> <span class="o">+</span> <span class="n">c_avals</span> <span class="o">+</span> <span class="n">b_avals</span> <span class="o">+</span> <span class="n">res2_avals</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_scan_batching_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
                        <span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="n">num_ys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_carry</span>
  <span class="n">orig_batched</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
  <span class="n">const_batched</span><span class="p">,</span> <span class="n">init_batched</span><span class="p">,</span> <span class="n">xs_batched</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">orig_batched</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>

  <span class="c1"># Fixpoint computation of which carry are batched: either</span>
  <span class="c1"># batched from init, or the carry out is batched. Each iteration promotes</span>
  <span class="c1"># at least one carry to batched. We need at most len(carry) iterations,</span>
  <span class="c1"># but we need one last iteration to prepare the jaxpr based on the final</span>
  <span class="c1"># carry_batched.</span>
  <span class="n">carry_batched</span> <span class="o">=</span> <span class="n">init_batched</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_batched</span><span class="p">)):</span>
    <span class="n">batched</span> <span class="o">=</span> <span class="n">const_batched</span> <span class="o">+</span> <span class="n">carry_batched</span> <span class="o">+</span> <span class="n">xs_batched</span>
    <span class="n">jaxpr_batched</span><span class="p">,</span> <span class="n">batched_out</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr</span><span class="p">(</span>
        <span class="n">jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">batched</span><span class="p">,</span>
        <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_batched</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ys</span><span class="p">,</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span>
        <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>
    <span class="n">carry_batched_out</span><span class="p">,</span> <span class="n">ys_batched</span> <span class="o">=</span> <span class="n">batched_out</span><span class="p">[:</span><span class="n">num_carry</span><span class="p">],</span> <span class="n">batched_out</span><span class="p">[</span><span class="n">num_carry</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">carry_batched_out</span> <span class="o">==</span> <span class="n">carry_batched</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_batched</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_batched</span><span class="p">,</span> <span class="n">carry_batched_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>

  <span class="n">consts</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">consts_bdims</span><span class="p">,</span> <span class="n">init_bdims</span><span class="p">,</span> <span class="n">xs_bdims</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">new_consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">consts</span><span class="p">,</span> <span class="n">consts_bdims</span><span class="p">)]</span>
  <span class="n">new_init</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">now_batched</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">was_batched</span>
              <span class="k">else</span> <span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">now_batched</span> <span class="k">else</span> <span class="n">x</span>
              <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">was_batched</span><span class="p">,</span> <span class="n">now_batched</span> <span class="ow">in</span>
              <span class="nb">zip</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">init_bdims</span><span class="p">,</span> <span class="n">init_batched</span><span class="p">,</span> <span class="n">carry_batched</span><span class="p">)]</span>
  <span class="n">new_xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs_bdims</span><span class="p">)]</span>
  <span class="n">new_args</span> <span class="o">=</span> <span class="n">new_consts</span> <span class="o">+</span> <span class="n">new_init</span> <span class="o">+</span> <span class="n">new_xs</span>

  <span class="n">outs</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_batched</span><span class="p">,</span>
      <span class="n">num_consts</span><span class="o">=</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="o">=</span><span class="n">unroll</span><span class="p">)</span>
  <span class="n">carry_bdims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">carry_batched</span><span class="p">]</span>
  <span class="n">ys_bdims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ys_batched</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="n">carry_bdims</span> <span class="o">+</span> <span class="n">ys_bdims</span>

<span class="k">def</span> <span class="nf">_masked_scan_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">):</span>
  <span class="n">fun</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="nd">@lu</span><span class="o">.</span><span class="n">wrap_init</span>
  <span class="k">def</span> <span class="nf">masked</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="p">[</span><span class="n">dynamic_length</span><span class="p">],</span> <span class="n">consts</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">carry</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span>
        <span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">consts</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">+</span> <span class="n">xs</span><span class="p">))</span>
    <span class="n">new_carry</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="n">new_carry</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dynamic_length</span><span class="p">,</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">new_c</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_carry</span><span class="p">,</span> <span class="n">carry</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_carry</span> <span class="o">+</span> <span class="n">ys</span>

  <span class="n">aval</span> <span class="o">=</span> <span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">const_avals</span><span class="p">,</span> <span class="n">carry_avals</span><span class="p">,</span> <span class="n">x_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">_make_closed_jaxpr</span><span class="p">(</span><span class="n">masked</span><span class="p">,</span> <span class="p">[</span><span class="n">aval</span><span class="p">]</span> <span class="o">+</span> <span class="n">const_avals</span> <span class="o">+</span> <span class="p">[</span><span class="n">aval</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry_avals</span> <span class="o">+</span> <span class="n">x_avals</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_scan_padding_rule</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">padded_jaxpr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="o">*</span><span class="n">pe</span><span class="o">.</span><span class="n">pad_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">padded_jaxpr</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_scan_dce_rule</span><span class="p">(</span><span class="n">used_outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">eqn</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">]:</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span>
  <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_carry&#39;</span><span class="p">]</span>
  <span class="n">num_xs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_consts</span> <span class="o">-</span> <span class="n">num_carry</span>
  <span class="n">used_carry_out</span><span class="p">,</span> <span class="n">used_extensive_out</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">used_outputs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_carry</span><span class="p">):</span>
    <span class="n">used_outputs</span> <span class="o">=</span> <span class="n">used_carry_out</span> <span class="o">+</span> <span class="n">used_extensive_out</span>
    <span class="n">jaxpr_dce</span><span class="p">,</span> <span class="n">used_inputs</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">dce_jaxpr</span><span class="p">(</span>
        <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">used_outputs</span><span class="p">,</span>
        <span class="n">instantiate</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_consts</span> <span class="o">+</span> <span class="n">used_carry_out</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_xs</span><span class="p">)</span>
    <span class="n">used_consts</span><span class="p">,</span> <span class="n">used_carry_in</span><span class="p">,</span> <span class="n">used_extensive_in</span> <span class="o">=</span> \
        <span class="n">split_list</span><span class="p">(</span><span class="n">used_inputs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">used_carry_in</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">used_carry_out</span><span class="p">):</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">used_carry_out</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">used_carry_out</span><span class="p">,</span> <span class="n">used_carry_in</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">check_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="n">new_linear</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">],</span> <span class="n">used_inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span><span class="p">]</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">num_consts</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">used_consts</span><span class="p">),</span>
                    <span class="n">num_carry</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">used_carry_in</span><span class="p">),</span> <span class="n">linear</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_linear</span><span class="p">),</span>
                    <span class="n">jaxpr</span><span class="o">=</span><span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr_dce</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">))</span>
  <span class="c1"># TODO(mattjj,sharadmv): don&#39;t assume effects are never DCE&#39;d?</span>
  <span class="n">new_eqn</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
      <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">used</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">used_inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">used</span><span class="p">],</span>
      <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">used</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">used_outputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">used</span><span class="p">],</span>
      <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">new_params</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_eqn</span><span class="o">.</span><span class="n">invars</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">in_avals</span> <span class="p">)</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">used_inputs</span><span class="p">,</span> <span class="n">new_eqn</span>

<span class="c1"># TODO(mattjj): de-duplicate code with _scan_partial_eval</span>
<span class="k">def</span> <span class="nf">_scan_partial_eval_custom</span><span class="p">(</span><span class="n">saveable</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">,</span> <span class="n">inst_in</span><span class="p">,</span> <span class="n">eqn</span><span class="p">):</span>
  <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span>
  <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">],</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_carry&#39;</span><span class="p">]</span>
  <span class="n">num_ys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_carry</span>

  <span class="c1"># Fixpoint (trivial on &#39;inst_in&#39;, since we might as well make all inputs</span>
  <span class="c1"># available as DCE can subsequently prune any unused ones)</span>
  <span class="n">const_uk</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">xs_uk</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)):</span>
    <span class="n">unks_in</span> <span class="o">=</span> <span class="n">const_uk</span>   <span class="o">+</span> <span class="n">carry_uk</span>   <span class="o">+</span> <span class="n">xs_uk</span>
    <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">jaxpr_staged_</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">inst_out</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> \
        <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_custom</span><span class="p">(</span>
            <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="o">=</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">in_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ensure_out_unknowns</span><span class="o">=</span><span class="n">carry_uk</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_ys</span><span class="p">,</span>
            <span class="n">ensure_out_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">saveable</span><span class="o">=</span><span class="n">saveable</span><span class="p">)</span>
    <span class="n">carry_uk_out</span><span class="p">,</span> <span class="n">ys_uk</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">carry_uk_out</span> <span class="o">==</span> <span class="n">carry_uk</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">carry_uk_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>
  <span class="n">jaxpr_known</span>  <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr_known_</span> <span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>
  <span class="n">jaxpr_staged</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr_staged_</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>

  <span class="c1"># Move all residual binders to the back of jaxpr_staged so they&#39;re extensive.</span>
  <span class="c1"># TODO(mattjj): make jaxpr_staged only take instantiated inputs</span>
  <span class="n">res_avals</span> <span class="o">=</span> <span class="n">jaxpr_staged</span><span class="o">.</span><span class="n">in_avals</span><span class="p">[:</span><span class="n">num_res</span><span class="p">]</span>
  <span class="n">jaxpr_staged</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">move_binders_to_back</span><span class="p">(</span>
      <span class="n">jaxpr_staged</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_res</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">))</span>

  <span class="c1"># Instantiate all inputs (b/c jaxpr_staged takes all inputs, corresponding to</span>
  <span class="c1"># passing in_inst argument to partial_eval_jaxpr_custom above).</span>
  <span class="n">new_inst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">inst</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">inst_in</span><span class="p">)</span>
              <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inst</span><span class="p">]</span>
  <span class="n">inst_in</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inst_in</span><span class="p">)</span>

  <span class="c1"># As an optimization, hoist loop-invariant residuals out of the loop rather</span>
  <span class="c1"># than using extensive outputs for them. See _scan_partial_eval for comments.</span>
  <span class="n">num_const_known</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">const_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">const_uk</span><span class="p">)</span>
  <span class="n">num_carry_known</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span>
  <span class="n">num_xs_known</span>    <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>   <span class="n">xs_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span>   <span class="n">xs_uk</span><span class="p">)</span>
  <span class="n">jaxpr_known_hoist</span><span class="p">,</span> <span class="n">jaxpr_known_loop</span><span class="p">,</span> <span class="n">loop_dep</span><span class="p">,</span> <span class="n">consts_known_lp_avals</span> <span class="o">=</span> \
      <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_nounits</span><span class="p">(</span>
          <span class="n">jaxpr_known</span><span class="p">,</span>
          <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_const_known</span> <span class="o">+</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_carry_known</span> <span class="o">+</span> <span class="n">num_xs_known</span><span class="p">),</span>
          <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unks_out</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">unks_out</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_res</span><span class="p">)</span>
  <span class="c1"># jaxpr_known_hoist produces intensive residuals followed by the constants for</span>
  <span class="c1"># jaxpr_known_loop. We adjust jaxpr_staged to accept intensive res as consts.</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">loop_dep_res</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">loop_dep</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">loop_dep</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_res</span><span class="p">])</span>
  <span class="n">jaxpr_staged</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">move_binders_to_front</span><span class="p">(</span>
      <span class="n">jaxpr_staged</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">inst_in</span><span class="p">)</span> <span class="o">+</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">not_</span><span class="p">,</span> <span class="n">loop_dep_res</span><span class="p">))</span>
  <span class="n">num_intensive_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_dep_res</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">loop_dep_res</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">loop_dep</span><span class="p">,</span> <span class="n">num_carry_known</span><span class="p">,</span> <span class="n">num_xs_known</span><span class="p">,</span> <span class="n">const_uk</span>

  <span class="c1"># Create residual variables.</span>
  <span class="n">intensive_avals</span><span class="p">,</span> <span class="n">ext_avals_mapped</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">loop_dep_res</span><span class="p">,</span> <span class="n">res_avals</span><span class="p">)</span>
  <span class="n">ext_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">no_axis_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ext_avals_mapped</span><span class="p">]</span>
  <span class="n">newvar</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">gensym</span><span class="p">()</span>
  <span class="n">intensive_res</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span> <span class="n">intensive_avals</span><span class="p">)</span>
  <span class="n">extensive_res</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span> <span class="n">ext_avals</span><span class="p">)</span>

  <span class="c1"># Create known eqn, which is a call_p combining evaluation of</span>
  <span class="c1"># jaxpr_known_hoist and a scan of jaxpr_known_loop.</span>
  <span class="n">ins_known</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span>
  <span class="n">out_binders_known</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>
  <span class="c1"># jaxpr_known_loop takes as input constants output as res by jaxpr_known_hoist</span>
  <span class="c1"># (corresponding to consts_known_lp_avals) followed by known carry and xs.</span>
  <span class="n">linear_known_</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">uk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">],</span> <span class="n">unks_in</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">uk</span><span class="p">]</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">linear_known_</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">linear_known_</span><span class="p">,</span> <span class="p">[</span><span class="n">num_const_known</span><span class="p">])</span>
  <span class="n">linear_known</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts_known_lp_avals</span><span class="p">)</span> <span class="o">+</span> <span class="n">linear_known_</span>
  <span class="n">params_known</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_known_loop</span><span class="p">,</span>
                      <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">consts_known_lp_avals</span><span class="p">),</span>
                      <span class="n">num_carry</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">),</span>
                      <span class="n">linear</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">linear_known</span><span class="p">))</span>

  <span class="nd">@lu</span><span class="o">.</span><span class="n">wrap_init</span>
  <span class="k">def</span> <span class="nf">known</span><span class="p">(</span><span class="o">*</span><span class="n">ins_known</span><span class="p">):</span>
    <span class="n">consts_known_hoist</span><span class="p">,</span> <span class="n">ins_known_lp</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">ins_known</span><span class="p">,</span> <span class="p">[</span><span class="n">num_const_known</span><span class="p">])</span>
    <span class="n">out_hoist</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">jaxpr_known_hoist</span><span class="p">)(</span><span class="o">*</span><span class="n">consts_known_hoist</span><span class="p">)</span>
    <span class="n">intensive_res</span><span class="p">,</span> <span class="n">consts_known_lp</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out_hoist</span><span class="p">,</span> <span class="p">[</span><span class="n">num_intensive_res</span><span class="p">])</span>
    <span class="n">out_loop</span> <span class="o">=</span> <span class="n">scan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">consts_known_lp</span><span class="p">,</span> <span class="o">*</span><span class="n">ins_known_lp</span><span class="p">,</span> <span class="o">**</span><span class="n">params_known</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">intensive_res</span><span class="p">,</span> <span class="o">*</span><span class="n">out_loop</span><span class="p">]</span>
  <span class="n">call_jaxpr_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">call_jaxpr_consts</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">trace_to_jaxpr_dynamic</span><span class="p">(</span>
      <span class="n">known</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ins_known</span><span class="p">])</span>
  <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">call_jaxpr_</span><span class="p">,</span> <span class="n">call_jaxpr_consts</span><span class="p">)</span>
  <span class="n">eqn_known</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
      <span class="n">ins_known</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">intensive_res</span><span class="p">,</span> <span class="o">*</span><span class="n">out_binders_known</span><span class="p">,</span> <span class="o">*</span><span class="n">extensive_res</span><span class="p">],</span>
      <span class="n">core</span><span class="o">.</span><span class="n">closed_call_p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">=</span><span class="n">call_jaxpr</span><span class="p">),</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
      <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>

  <span class="c1"># Create the staged eqn.</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">out_binders_staged</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">inst_out</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>
  <span class="n">linear_staged</span> <span class="o">=</span> <span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensive_res</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">])</span> <span class="o">+</span>
                   <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">extensive_res</span><span class="p">))</span>
  <span class="n">params_staged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr_staged</span><span class="p">,</span>
                       <span class="n">num_consts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">intensive_res</span><span class="p">)</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">],</span>
                       <span class="n">linear</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">linear_staged</span><span class="p">))</span>
  <span class="n">eqn_staged</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">([</span><span class="o">*</span><span class="n">intensive_res</span><span class="p">,</span> <span class="o">*</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="o">*</span><span class="n">extensive_res</span><span class="p">],</span>
                                <span class="n">out_binders_staged</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span>
                                <span class="n">params_staged</span><span class="p">,</span> <span class="n">jaxpr_staged</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
                                <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>

  <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">new_inst</span><span class="p">,</span> <span class="o">*</span><span class="n">intensive_res</span><span class="p">,</span> <span class="o">*</span><span class="n">extensive_res</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">eqn_known</span><span class="p">,</span> <span class="n">eqn_staged</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">inst_out</span><span class="p">,</span> <span class="n">new_vars</span>

<span class="k">def</span> <span class="nf">_scan_typecheck</span><span class="p">(</span><span class="n">bind_time</span><span class="p">,</span> <span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span>
                    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">unroll</span><span class="p">):</span>
  <span class="n">avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>
  <span class="n">tc</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_typecheck_param</span><span class="p">,</span> <span class="s1">&#39;scan&#39;</span><span class="p">)</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">reverse</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">reverse</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">num_consts</span><span class="p">,</span> <span class="s1">&#39;num_consts&#39;</span><span class="p">,</span> <span class="s1">&#39;non-negative int&#39;</span><span class="p">,</span>
     <span class="nb">type</span><span class="p">(</span><span class="n">num_consts</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">num_consts</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">num_carry</span><span class="p">,</span> <span class="s1">&#39;num_carry&#39;</span><span class="p">,</span> <span class="s1">&#39;non-negative int&#39;</span><span class="p">,</span>
     <span class="nb">type</span><span class="p">(</span><span class="n">num_carry</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">num_carry</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="s1">&#39;jaxpr&#39;</span><span class="p">,</span> <span class="s1">&#39;ClosedJaxpr&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">)</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">linear</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;tuple of bool&#39;</span><span class="p">,</span>
     <span class="nb">type</span><span class="p">(</span><span class="n">linear</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">linear</span><span class="p">))</span>
  <span class="n">tc</span><span class="p">(</span><span class="n">unroll</span><span class="p">,</span> <span class="s1">&#39;unroll&#39;</span><span class="p">,</span> <span class="s1">&#39;positive int&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">unroll</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">unroll</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

  <span class="n">tc</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="s1">&#39;non-negative int&#39;</span><span class="p">,</span>
     <span class="nb">type</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linear</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprTypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;scan param linear has length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">linear</span><span class="p">)</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span><span class="si">}</span><span class="s1"> operands&#39;</span><span class="p">)</span>

  <span class="n">const_avals</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="n">x_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">const_avals_jaxpr</span><span class="p">,</span> <span class="n">init_avals_jaxpr</span><span class="p">,</span> <span class="n">x_avals_jaxpr</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span>
      <span class="n">jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">])</span>
  <span class="n">carry_avals_jaxpr</span><span class="p">,</span> <span class="n">y_avals_mapped</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">x_avals_mapped</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">mapped_aval</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">x_avals</span><span class="p">)</span>
  <span class="n">y_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">no_axis_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">y_avals_mapped</span><span class="p">]</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">typematch</span><span class="p">,</span> <span class="n">init_avals_jaxpr</span><span class="p">,</span> <span class="n">carry_avals_jaxpr</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprTypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;scan input carry input and output types mismatch: &#39;</span>
      <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">init_avals_jaxpr</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">vs</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">carry_avals_jaxpr</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">typecompat</span><span class="p">,</span> <span class="n">const_avals_jaxpr</span><span class="p">,</span> <span class="n">const_avals</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprTypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;scan jaxpr takes input const types</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">const_avals_jaxpr</span><span class="p">)</span><span class="si">}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;called with consts of type</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">const_avals</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">typecompat</span><span class="p">,</span> <span class="n">init_avals_jaxpr</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprTypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;scan jaxpr takes input carry types</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">init_avals_jaxpr</span><span class="p">)</span><span class="si">}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;called with initial carry of type</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">init_avals</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">typecompat</span><span class="p">,</span> <span class="n">x_avals_jaxpr</span><span class="p">,</span> <span class="n">x_avals_mapped</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprTypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;scan jaxpr takes input sequence types</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">x_avals_jaxpr</span><span class="p">)</span><span class="si">}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;called with sequence of type</span><span class="se">\n</span><span class="si">{</span><span class="n">_avals_short</span><span class="p">(</span><span class="n">x_avals</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="o">*</span><span class="n">init_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">y_avals</span><span class="p">],</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span>

<span class="k">def</span> <span class="nf">_scan_pp_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
  <span class="n">printed_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;num_carry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;unroll&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;unroll&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;num_carry&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;num_carry&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;num_consts&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">]:</span>
    <span class="k">del</span> <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">]</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
         <span class="n">core</span><span class="o">.</span><span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">printed_params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">scan_bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span><span class="p">:</span>
    <span class="n">avals</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">in_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">avals</span><span class="p">]</span>  <span class="c1"># dummies</span>
    <span class="n">_scan_typecheck</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">core</span><span class="o">.</span><span class="n">check_jaxpr</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;jaxpr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">AxisPrimitive</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">scan_p</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="n">scan_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">AxisPrimitive</span><span class="p">(</span><span class="s2">&quot;scan&quot;</span><span class="p">)</span>
<span class="n">scan_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">scan_p</span><span class="o">.</span><span class="n">def_custom_bind</span><span class="p">(</span><span class="n">scan_bind</span><span class="p">)</span>
<span class="n">scan_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">scan_p</span><span class="p">))</span>
<span class="n">scan_p</span><span class="o">.</span><span class="n">def_effectful_abstract_eval</span><span class="p">(</span><span class="n">_scan_abstract_eval</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_jvp</span>
<span class="n">ad</span><span class="o">.</span><span class="n">reducing_transposes</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_transpose</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_partial_eval_rules</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_partial_eval</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_initial_style_primitive</span><span class="p">(</span><span class="n">scan_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">scan_p</span><span class="p">,</span>
                       <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">_scan_impl</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">batching</span><span class="o">.</span><span class="n">axis_primitive_batchers</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_batching_rule</span>
<span class="n">core</span><span class="o">.</span><span class="n">custom_typechecks</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_scan_typecheck</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_custom_rules</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_partial_eval_custom</span>
<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_padding_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">dce_rules</span><span class="p">[</span><span class="n">scan_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scan_dce_rule</span>
<span class="c1"># TODO(mattjj,frostig): un-comment this pp rule</span>
<span class="c1"># core.pp_eqn_rules[scan_p] = _scan_pp_rule</span>

<span class="c1">### while_loop</span>

<div class="viewcode-block" id="while_loop"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.while_loop.html#jax.lax.while_loop">[docs]</a><span class="nd">@api_boundary</span>
<span class="k">def</span> <span class="nf">while_loop</span><span class="p">(</span><span class="n">cond_fun</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">BooleanNumeric</span><span class="p">],</span>
               <span class="n">body_fun</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">T</span><span class="p">],</span>
               <span class="n">init_val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Call ``body_fun`` repeatedly in a loop while ``cond_fun`` is True.</span>

<span class="sd">  The `Haskell-like type signature`_ in brief is</span>

<span class="sd">  .. code-block:: haskell</span>

<span class="sd">    while_loop :: (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a</span>

<span class="sd">  The semantics of ``while_loop`` are given by this Python implementation::</span>

<span class="sd">    def while_loop(cond_fun, body_fun, init_val):</span>
<span class="sd">      val = init_val</span>
<span class="sd">      while cond_fun(val):</span>
<span class="sd">        val = body_fun(val)</span>
<span class="sd">      return val</span>

<span class="sd">  Unlike that Python version, ``while_loop`` is a JAX primitive and is lowered</span>
<span class="sd">  to a single XLA While HLO. That makes it useful for reducing compilation times</span>
<span class="sd">  for jit-compiled functions, since native Python loop constructs in an ``@jit``</span>
<span class="sd">  function are unrolled, leading to large XLA computations.</span>

<span class="sd">  Also unlike the Python analogue, the loop-carried value ``val`` must hold a</span>
<span class="sd">  fixed shape and dtype across all iterations (and not just be consistent up to</span>
<span class="sd">  NumPy rank/shape broadcasting and dtype promotion rules, for example). In</span>
<span class="sd">  other words, the type ``a`` in the type signature above represents an array</span>
<span class="sd">  with a fixed shape and dtype (or a nested tuple/list/dict container data</span>
<span class="sd">  structure with a fixed structure and arrays with fixed shape and dtype at the</span>
<span class="sd">  leaves).</span>

<span class="sd">  Another difference from using Python-native loop constructs is that</span>
<span class="sd">  ``while_loop`` is not reverse-mode differentiable because XLA computations</span>
<span class="sd">  require static bounds on memory requirements.</span>

<span class="sd">  .. note::</span>
<span class="sd">    :py:func:`while_loop` compiles ``cond_fun`` and ``body_fun``, so while it</span>
<span class="sd">    can be combined with :py:func:`jit`, it&#39;s usually unnecessary.</span>

<span class="sd">  Args:</span>
<span class="sd">    cond_fun: function of type ``a -&gt; Bool``.</span>
<span class="sd">    body_fun: function of type ``a -&gt; a``.</span>
<span class="sd">    init_val: value of type ``a``, a type that can be a scalar, array, or any</span>
<span class="sd">      pytree (nested Python tuple/list/dict) thereof, representing the initial</span>
<span class="sd">      loop carry value.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The output from the final iteration of body_fun, of type ``a``.</span>

<span class="sd">  .. _Haskell-like type signature: https://wiki.haskell.org/Type_signature</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">body_fun</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">cond_fun</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lax.while_loop: body_fun and cond_fun arguments should be callable.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_disable_jit</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">init_val</span>
      <span class="k">while</span> <span class="n">cond_fun</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">body_fun</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">val</span>
    <span class="k">except</span> <span class="n">core</span><span class="o">.</span><span class="n">ConcretizationTypeError</span><span class="p">:</span>
      <span class="c1"># Can&#39;t run this while_loop in Python (e.g. because there&#39;s a vmap</span>
      <span class="c1"># transformation on it), so we fall back to the primitive version.</span>
      <span class="k">pass</span>

  <span class="k">def</span> <span class="nf">_create_jaxpr</span><span class="p">(</span><span class="n">init_val</span><span class="p">):</span>
    <span class="n">init_vals</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">((</span><span class="n">init_val</span><span class="p">,))</span>
    <span class="n">init_avals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">_abstractify</span><span class="p">,</span> <span class="n">init_vals</span><span class="p">))</span>
    <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">cond_consts</span><span class="p">,</span> <span class="n">cond_tree</span> <span class="o">=</span> <span class="n">_initial_style_jaxpr</span><span class="p">(</span>
        <span class="n">cond_fun</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="s2">&quot;while_cond&quot;</span><span class="p">)</span>
    <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">body_consts</span><span class="p">,</span> <span class="n">body_tree</span> <span class="o">=</span> <span class="n">_initial_style_jaxpr</span><span class="p">(</span>
        <span class="n">body_fun</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="s2">&quot;while_loop&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">treedef_is_leaf</span><span class="p">(</span><span class="n">cond_tree</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;cond_fun must return a boolean scalar, but got pytree </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond_tree</span><span class="p">))</span>
    <span class="n">pred_aval</span> <span class="o">=</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pred_aval</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">pred_aval</span><span class="o">.</span><span class="n">strip_weak_type</span><span class="p">()</span><span class="o">.</span><span class="n">strip_named_shape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;cond_fun must return a boolean scalar, but got output type(s) </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">init_vals</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">cond_consts</span><span class="p">,</span> <span class="n">body_consts</span><span class="p">,</span> <span class="n">body_tree</span>

  <span class="c1"># The body input and output avals must match exactly. However, we want to account for</span>
  <span class="c1"># the case when init contains weakly-typed values (e.g. Python scalars), with avals that</span>
  <span class="c1"># may not match the output despite being compatible by virtue of their weak type.</span>
  <span class="c1"># To do this, we compute the jaxpr in two passes: first with the raw inputs, and if</span>
  <span class="c1"># necessary, a second time with modified init values.</span>
  <span class="n">init_vals</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">_create_jaxpr</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>
  <span class="n">new_init_vals</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">_promote_weak_typed_inputs</span><span class="p">(</span><span class="n">init_vals</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
    <span class="n">new_init_val</span><span class="p">,</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">new_init_vals</span><span class="p">)</span>
    <span class="n">init_vals</span><span class="p">,</span> <span class="n">init_avals</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">_create_jaxpr</span><span class="p">(</span><span class="n">new_init_val</span><span class="p">)</span>
  <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">cond_consts</span><span class="p">,</span> <span class="n">body_consts</span><span class="p">,</span> <span class="n">body_tree</span> <span class="o">=</span> <span class="n">rest</span>

  <span class="n">in_tree_children</span> <span class="o">=</span> <span class="n">in_tree</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_tree_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="n">_check_tree_and_avals</span><span class="p">(</span><span class="s2">&quot;body_fun output and input&quot;</span><span class="p">,</span>
                        <span class="n">body_tree</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span>
                        <span class="n">in_tree_children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">init_avals</span><span class="p">)</span>
  <span class="n">effects</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_effects</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="n">disallowed_effects</span> <span class="o">=</span> <span class="n">effects</span> <span class="o">-</span> <span class="n">allowed_effects</span>
  <span class="k">if</span> <span class="n">disallowed_effects</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Effects not supported in `while`: </span><span class="si">{</span><span class="n">disallowed_effects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">while_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">cond_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">body_consts</span><span class="p">,</span> <span class="o">*</span><span class="n">init_vals</span><span class="p">,</span>
                      <span class="n">cond_nconsts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cond_consts</span><span class="p">),</span> <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr</span><span class="p">,</span>
                      <span class="n">body_nconsts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">body_consts</span><span class="p">),</span> <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jaxpr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">body_tree</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_while_loop_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
  <span class="n">joined_effects</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_effects</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="n">disallowed_effects</span> <span class="o">=</span> <span class="n">joined_effects</span> <span class="o">-</span> <span class="n">allowed_effects</span>
  <span class="k">if</span> <span class="n">disallowed_effects</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Effects not supported in `while`: </span><span class="si">{</span><span class="n">disallowed_effects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_map</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">),</span> <span class="n">joined_effects</span>


<span class="k">def</span> <span class="nf">_while_loop_batching_rule</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span>
                              <span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span>
                              <span class="n">body_nconsts</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">):</span>
  <span class="n">orig_batched</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
  <span class="n">cconst_bat</span><span class="p">,</span> <span class="n">bconst_bat</span><span class="p">,</span> <span class="n">init_bat</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">orig_batched</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
  <span class="n">cconsts</span><span class="p">,</span> <span class="n">bconsts</span><span class="p">,</span> <span class="n">init</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
  <span class="n">cconst_dims</span><span class="p">,</span> <span class="n">bconst_dims</span><span class="p">,</span> <span class="n">init_dims</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>

  <span class="n">carry_bat</span> <span class="o">=</span> <span class="n">init_bat</span>
  <span class="c1"># Fixpoint computation of which carry are batched: either</span>
  <span class="c1"># batched from init, or the carry out is batched. Each iteration promotes</span>
  <span class="c1"># at least one carry to batched. We need at most len(carry) iterations to</span>
  <span class="c1"># reach a fixpoint.</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_bat</span><span class="p">)):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">carry_bat_out</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr</span><span class="p">(</span>
        <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">bconst_bat</span> <span class="o">+</span> <span class="n">carry_bat</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_bat</span><span class="p">,</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">carry_bat</span> <span class="o">==</span> <span class="n">carry_bat_out</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">carry_bat</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_bat</span><span class="p">,</span> <span class="n">carry_bat_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>

  <span class="c1"># Knowing how the carry is batched now, we can determine if the predicate is</span>
  <span class="c1"># batched.</span>
  <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">pred_bat</span><span class="p">,)</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr</span><span class="p">(</span>
      <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">cconst_bat</span> <span class="o">+</span> <span class="n">carry_bat</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
      <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">pred_bat</span><span class="p">:</span>
    <span class="c1"># If the predicate is batched, we have to batch *all* of the carry</span>
    <span class="c1"># regardless of if the body needs it.</span>
    <span class="n">carry_bat</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_bat</span><span class="p">)</span>
    <span class="n">carry_dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_bat</span><span class="p">)</span>
    <span class="n">body_jaxpr_batched</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr_axes</span><span class="p">(</span>
        <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">bconst_dims</span> <span class="o">+</span> <span class="n">carry_dims</span><span class="p">,</span>
        <span class="n">carry_dims</span><span class="p">,</span> <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>
    <span class="n">cond_jaxpr_batched</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr_axes</span><span class="p">(</span>
        <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">cconst_dims</span> <span class="o">+</span> <span class="n">carry_dims</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># If the predicate is not batched, we can look at the `cond_jaxpr`&#39;s out</span>
    <span class="c1"># shape to determine the rank of the predicate. From this rank we pick the</span>
    <span class="c1"># dims of the carry to be batched to ensure that the predicate shape is a</span>
    <span class="c1"># prefix of the carry in and out shapes. We can then batch the `body_jaxpr`</span>
    <span class="c1"># according to these new batch dims.</span>
    <span class="n">cond_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">carry_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond_rank</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">carry_bat</span><span class="p">]</span>
    <span class="n">body_jaxpr_batched</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr_axes</span><span class="p">(</span>
        <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">bconst_dims</span> <span class="o">+</span> <span class="n">carry_dims</span><span class="p">,</span> <span class="n">carry_dims</span><span class="p">,</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>
    <span class="c1"># Now we need to rebatch the `cond_jaxpr` according to the new dims of the</span>
    <span class="c1"># carry.</span>
    <span class="n">cond_jaxpr_batched</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">batch_jaxpr_axes</span><span class="p">(</span>
        <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">cconst_dims</span> <span class="o">+</span> <span class="n">carry_dims</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
        <span class="n">axis_name</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">main_type</span><span class="o">=</span><span class="n">main_type</span><span class="p">)</span>

  <span class="c1"># To prepare the `init` to the `while_p`, we broadcast values if they are</span>
  <span class="c1"># unbatched and need to have an out axis. If their current batch axis does not</span>
  <span class="c1"># match the one it needs to be for the translation rule to work, we move it</span>
  <span class="c1"># into place.</span>
  <span class="n">new_init</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">old_axis</span><span class="p">,</span> <span class="n">new_axis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">init_dims</span><span class="p">,</span> <span class="n">carry_dims</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">old_axis</span> <span class="ow">is</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="ow">and</span> <span class="n">new_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span><span class="p">:</span>
      <span class="n">new_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batching</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">,</span> <span class="n">new_axis</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">old_axis</span> <span class="ow">is</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span> <span class="ow">and</span> <span class="n">new_axis</span> <span class="ow">is</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span><span class="p">:</span>
      <span class="n">new_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">new_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span>
      <span class="n">new_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_axis</span><span class="p">,</span> <span class="n">new_axis</span><span class="p">))</span>

  <span class="n">outs</span> <span class="o">=</span> <span class="n">while_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">cconsts</span> <span class="o">+</span> <span class="n">bconsts</span> <span class="o">+</span> <span class="n">new_init</span><span class="p">),</span>
                      <span class="n">cond_nconsts</span><span class="o">=</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr_batched</span><span class="p">,</span>
                      <span class="n">body_nconsts</span><span class="o">=</span><span class="n">body_nconsts</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jaxpr_batched</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">outs</span><span class="p">,</span> <span class="n">carry_dims</span>

<span class="k">def</span> <span class="nf">_while_loop_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">,</span>
                    <span class="n">body_jaxpr</span><span class="p">):</span>
  <span class="n">nonzeros</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">]</span>
  <span class="n">cconst_nz</span><span class="p">,</span> <span class="n">bconst_nz</span><span class="p">,</span> <span class="n">init_nz</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">nonzeros</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>

  <span class="n">carry_nz</span> <span class="o">=</span> <span class="n">init_nz</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_nz</span><span class="p">)):</span>
    <span class="n">body_nonzeros</span> <span class="o">=</span> <span class="n">bconst_nz</span> <span class="o">+</span> <span class="n">carry_nz</span>
    <span class="n">body_jvp</span><span class="p">,</span> <span class="n">nonzeros_out</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">jvp_jaxpr</span><span class="p">(</span>
        <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">body_nonzeros</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_nz</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nonzeros_out</span> <span class="o">==</span> <span class="n">carry_nz</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">carry_nz</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_nz</span><span class="p">,</span> <span class="n">nonzeros_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>

  <span class="n">nonzeros</span> <span class="o">=</span> <span class="n">cconst_nz</span> <span class="o">+</span> <span class="n">body_nonzeros</span>
  <span class="n">tangents</span> <span class="o">=</span> <span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">nz</span> <span class="k">else</span> <span class="n">t</span>
              <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">nz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tangents</span><span class="p">,</span> <span class="n">nonzeros</span><span class="p">)]</span>

  <span class="n">cconst</span><span class="p">,</span> <span class="n">bconst</span><span class="p">,</span> <span class="n">init</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">bconst_dot</span><span class="p">,</span> <span class="n">init_dot</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">tangents</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
  <span class="n">bconst_dot</span> <span class="o">=</span> <span class="n">_prune_zeros</span><span class="p">(</span><span class="n">bconst_dot</span><span class="p">)</span>
  <span class="n">init_dot</span> <span class="o">=</span> <span class="n">_prune_zeros</span><span class="p">(</span><span class="n">init_dot</span><span class="p">)</span>

  <span class="n">num_carry</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span> <span class="o">-</span> <span class="n">cond_nconsts</span> <span class="o">-</span> <span class="n">body_nconsts</span>

  <span class="n">body_jvp_rearranged</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">rearrange_binders</span><span class="p">(</span>
      <span class="n">body_jvp</span><span class="p">,</span>
      <span class="p">[</span><span class="n">body_nconsts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bconst_dot</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">)],</span>
      <span class="p">[</span><span class="n">num_carry</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">init_dot</span><span class="p">)])</span>

  <span class="n">newvar</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">gensym</span><span class="p">([</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">])</span>
  <span class="n">invars_aug</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">newvar</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">init_dot</span><span class="p">])</span>
  <span class="n">cond_jaxpr_augmented</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span>
                                    <span class="n">invars_aug</span><span class="p">,</span>
                                    <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span>
                                    <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span>
                                    <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="n">cond_jaxpr_augmented</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">cond_jaxpr_augmented</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>

  <span class="n">out</span> <span class="o">=</span> <span class="n">while_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="p">(</span><span class="n">cconst</span> <span class="o">+</span> <span class="n">bconst</span> <span class="o">+</span> <span class="n">bconst_dot</span> <span class="o">+</span> <span class="n">init</span> <span class="o">+</span> <span class="n">init_dot</span><span class="p">),</span>
      <span class="n">cond_nconsts</span><span class="o">=</span><span class="n">cond_nconsts</span><span class="p">,</span>
      <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr_augmented</span><span class="p">,</span>
      <span class="n">body_nconsts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bconst</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bconst_dot</span><span class="p">),</span>
      <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jvp_rearranged</span><span class="p">)</span>

  <span class="n">out_carry</span><span class="p">,</span> <span class="n">out_carry_dot</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="n">num_carry</span><span class="p">])</span>
  <span class="n">out_tangents_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">out_carry_dot</span><span class="p">)</span>
  <span class="n">out_tangents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">out_tangents_iter</span><span class="p">)</span> <span class="k">if</span> <span class="n">nz</span> <span class="k">else</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">nz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_carry</span><span class="p">,</span> <span class="n">nonzeros_out</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">out_carry</span><span class="p">,</span> <span class="n">out_tangents</span>

<span class="k">def</span> <span class="nf">_while_partial_eval</span><span class="p">(</span><span class="n">trace</span><span class="p">:</span> <span class="n">pe</span><span class="o">.</span><span class="n">JaxprTrace</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">:</span> <span class="n">pe</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">cond_jaxpr</span><span class="p">:</span> <span class="n">pe</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">body_jaxpr</span><span class="p">:</span> <span class="n">pe</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">Tracer</span><span class="p">]:</span>
  <span class="c1"># As long as some carry (and hence output) are known and the output of</span>
  <span class="c1"># `cond_jaxpr` is known, we use a portion of the loop body to compute the</span>
  <span class="c1"># known outputs of the `while_loop`. For the unknown outputs we generate a</span>
  <span class="c1"># jaxpr to run the whole while, including recomputing the known parts,</span>
  <span class="c1"># basically like building in checkpointing/rematieralization. This means that</span>
  <span class="c1"># we don&#39;t actually save any computation by partial evaluation if there are</span>
  <span class="c1"># unknown outputs.</span>
  <span class="c1">#</span>
  <span class="c1"># What this achieves is twofold: jax.linearize works, and we can give a proper</span>
  <span class="c1"># error for reverse differentiation of `while`.</span>

  <span class="n">unknowns</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">]</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cond_nconsts</span><span class="o">=</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr</span><span class="p">,</span>
                <span class="n">body_nconsts</span><span class="o">=</span><span class="n">body_nconsts</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jaxpr</span><span class="p">)</span>

  <span class="n">cond_consts_uk</span><span class="p">,</span> <span class="n">body_consts_uk</span><span class="p">,</span> <span class="n">carry_init_uk</span> <span class="o">=</span> \
      <span class="n">split_list</span><span class="p">(</span><span class="n">unknowns</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>

  <span class="c1"># Fixpoint computation of unknown carry. Each iteration promotes at least one</span>
  <span class="c1"># carry to unknown. We need one last iteration to prepare the jaxpr.</span>
  <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">carry_init_uk</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)):</span>
    <span class="n">body_jaxpr_known</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">carry_out_uk</span><span class="p">,</span> <span class="n">body_res_avals</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_nounits</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">body_consts_uk</span> <span class="o">+</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="n">carry_uk</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">carry_out_uk</span> <span class="o">==</span> <span class="n">carry_uk</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">carry_out_uk</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>

  <span class="n">cond_jaxpr_known</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cond_uk</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_nounits</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
      <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">cond_consts_uk</span> <span class="o">+</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">instantiate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">cond_uk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">uk</span> <span class="k">for</span> <span class="n">uk</span> <span class="ow">in</span> <span class="n">unknowns</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">unknowns</span><span class="p">):</span>
    <span class="c1"># If conditional is unknown, or all inputs are known, or all are unknown,</span>
    <span class="c1"># just do the default processing.</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">while_p</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="c1"># Run the known part of the while.</span>
  <span class="n">in_consts</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">get_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">uk</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span>
               <span class="nb">zip</span><span class="p">(</span><span class="n">cond_consts_uk</span> <span class="o">+</span> <span class="n">body_consts_uk</span> <span class="o">+</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">tracers</span><span class="p">)</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">uk</span><span class="p">]</span>
  <span class="n">cond_nconsts_known</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond_consts_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cond_consts_uk</span><span class="p">)</span>
  <span class="n">body_nconsts_known</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body_consts_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">body_consts_uk</span><span class="p">)</span>
  <span class="n">num_known_outs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)</span>
  <span class="c1"># TODO(mattjj): use pe.dce_jaxpr to drop res computations and not just outputs</span>
  <span class="n">body_jaxpr_known</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span> <span class="o">=</span> <span class="n">body_jaxpr_known</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">[:</span><span class="n">num_known_outs</span><span class="p">]</span>
  <span class="n">out_known</span> <span class="o">=</span> <span class="n">while_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="n">in_consts</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="o">=</span><span class="n">cond_nconsts_known</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr_known</span><span class="p">,</span>
      <span class="n">body_nconsts</span><span class="o">=</span><span class="n">body_nconsts_known</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jaxpr_known</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">body_jaxpr_known</span>

  <span class="c1"># Run the whole while_loop to get all the outputs, then merge with known ones</span>
  <span class="n">out_tracers_</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">while_p</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">out_tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">uk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_tracers_</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">)</span> <span class="k">if</span> <span class="n">uk</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">merge_lists</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">,</span> <span class="n">out_known</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">)</span>

<span class="c1"># TODO(mattjj): de-duplicate code with _while_partial_eval</span>
<span class="k">def</span> <span class="nf">_while_partial_eval_custom</span><span class="p">(</span><span class="n">saveable</span><span class="p">,</span> <span class="n">unks_in</span><span class="p">,</span> <span class="n">inst_in</span><span class="p">,</span> <span class="n">eqn</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">saveable</span>  <span class="c1"># We can&#39;t save any residuals anyway (w/o dynamic shapes)!</span>
  <span class="n">cond_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;cond_jaxpr&#39;</span><span class="p">]</span>
  <span class="n">cond_nconsts</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;cond_nconsts&#39;</span><span class="p">]</span>
  <span class="n">body_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;body_jaxpr&#39;</span><span class="p">]</span>
  <span class="n">body_nconsts</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;body_nconsts&#39;</span><span class="p">]</span>

  <span class="n">cond_consts_uk</span><span class="p">,</span> <span class="n">body_consts_uk</span><span class="p">,</span> <span class="n">carry_init_uk</span> <span class="o">=</span> \
      <span class="n">split_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>

  <span class="c1"># Fixpoint to compute known part of the body (trivial on &#39;inst_in&#39;, since we</span>
  <span class="c1"># make all inputs available as DCE can subsequently prune any unused ones)</span>
  <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">carry_init_uk</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">)):</span>
    <span class="n">body_unks_in</span> <span class="o">=</span> <span class="n">body_consts_uk</span> <span class="o">+</span> <span class="n">carry_uk</span>
    <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">carry_uk_out</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num_res</span> <span class="o">=</span> \
        <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_custom</span><span class="p">(</span>
            <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">in_unknowns</span><span class="o">=</span><span class="n">body_unks_in</span><span class="p">,</span> <span class="n">in_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ensure_out_unknowns</span><span class="o">=</span><span class="n">carry_uk</span><span class="p">,</span> <span class="n">ensure_out_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">saveable</span><span class="o">=</span><span class="n">ad_checkpoint</span><span class="o">.</span><span class="n">nothing_saveable</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">carry_uk_out</span> <span class="o">==</span> <span class="n">carry_uk</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">carry_uk</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">carry_uk</span><span class="p">,</span> <span class="n">carry_uk_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Fixpoint not reached&quot;</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="n">num_res</span>
  <span class="n">body_jaxpr_known</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">jaxpr_known_</span><span class="p">,</span> <span class="n">carry_uk_out</span><span class="p">,</span> <span class="n">num_res</span>

  <span class="c1"># Instantiate all inputs (b/c jaxpr_staged will take all inputs).</span>
  <span class="n">new_inst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">inst</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">inst_in</span><span class="p">)</span>
              <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inst</span><span class="p">]</span>

  <span class="c1"># Compute the known part of cond_fun (basically pruning inputs on known side).</span>
  <span class="n">cond_unks_in</span> <span class="o">=</span> <span class="n">cond_consts_uk</span> <span class="o">+</span> <span class="n">carry_uk</span>
  <span class="n">cond_jaxpr_known_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_uk</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
      <span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_custom</span><span class="p">(</span>
          <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">cond_unks_in</span><span class="p">,</span> <span class="n">in_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">ensure_out_unknowns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ensure_out_inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">saveable</span><span class="o">=</span><span class="n">ad_checkpoint</span><span class="o">.</span><span class="n">nothing_saveable</span><span class="p">)</span>
  <span class="c1"># NOTE(mattjj): I think it should be impossible for the condition to be</span>
  <span class="c1"># unknown, but asserting that caused a test failure in diffrax. So</span>
  <span class="c1"># we handle it: if it is unknown, stage out the whole cond function.</span>
  <span class="k">if</span> <span class="n">cond_uk</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">eqn</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">),</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">),</span> <span class="n">new_inst</span>
  <span class="n">cond_jaxpr_known</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">cond_jaxpr_known_</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">cond_uk</span>

  <span class="c1"># Build the known eqn.</span>
  <span class="n">ins_known</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">unks_in</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span>
  <span class="n">out_binders_known</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">carry_uk</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>
  <span class="n">params_known</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">cond_jaxpr_known</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">body_jaxpr_known</span><span class="p">,</span>
                      <span class="n">cond_nconsts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cond_consts_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cond_consts_uk</span><span class="p">),</span>
                      <span class="n">body_nconsts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">body_consts_uk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">body_consts_uk</span><span class="p">))</span>
  <span class="n">effects_known</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_effects</span><span class="p">(</span><span class="n">cond_jaxpr_known</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
                                    <span class="n">body_jaxpr_known</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="n">eqn_known</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span><span class="n">ins_known</span><span class="p">,</span> <span class="n">out_binders_known</span><span class="p">,</span> <span class="n">while_p</span><span class="p">,</span>
                               <span class="n">params_known</span><span class="p">,</span> <span class="n">effects_known</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>

  <span class="c1"># Staged eqn is same as input eqn.</span>
  <span class="n">eqn_staged</span> <span class="o">=</span> <span class="n">eqn</span>

  <span class="n">unks_out</span> <span class="o">=</span> <span class="n">carry_uk</span>
  <span class="n">inst_out</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">unks_out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eqn_known</span><span class="p">,</span> <span class="n">eqn_staged</span><span class="p">,</span> <span class="n">unks_out</span><span class="p">,</span> <span class="n">inst_out</span><span class="p">,</span> <span class="n">new_inst</span>

<span class="k">def</span> <span class="nf">_while_transpose_error</span><span class="p">(</span><span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reverse-mode differentiation does not work for &quot;</span>
                   <span class="s2">&quot;lax.while_loop or lax.fori_loop. &quot;</span>
                   <span class="s2">&quot;Try using lax.scan instead.&quot;</span><span class="p">)</span>

<span class="c1"># For a while loop with ordered effects in the cond, we need a special</span>
<span class="c1"># lowering. Fundamentally, we&#39;d like to rewrite a while loop that looks like</span>
<span class="c1"># this:</span>
<span class="c1"># ```</span>
<span class="c1"># while cond(x):</span>
<span class="c1">#   x = body(x)</span>
<span class="c1"># ```</span>
<span class="c1"># into something that looks like this:</span>
<span class="c1"># ```</span>
<span class="c1"># while True:</span>
<span class="c1">#   token, pred = cond(token, x)</span>
<span class="c1">#   if not pred:</span>
<span class="c1">#     break</span>
<span class="c1">#   token, x = body(token, x)</span>
<span class="c1"># ```</span>
<span class="c1"># Unfortunately, with an MHLO while we can&#39;t (1) return multiple values</span>
<span class="c1"># from a `cond` and (2) can&#39;t break a while loop. We thus adopt the</span>
<span class="c1"># following rewrite strategy:</span>
<span class="c1"># ```</span>
<span class="c1"># def new_cond(pred, token, x):</span>
<span class="c1">#   return pred</span>
<span class="c1"># token, pred = cond(token, x)</span>
<span class="c1"># while new_cond(pred, token, x):</span>
<span class="c1">#   token, x = body(token, x)</span>
<span class="c1">#   token, pred = cond(token, x)</span>
<span class="c1"># ```</span>
<span class="k">def</span> <span class="nf">_while_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">,</span>
                    <span class="n">body_nconsts</span><span class="p">):</span>
  <span class="n">pred_aval</span> <span class="o">=</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">batched</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">cond_ordered_effects</span> <span class="o">=</span> <span class="p">[</span><span class="n">eff</span> <span class="k">for</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">effects</span> <span class="k">if</span> <span class="n">eff</span> <span class="ow">in</span>
                          <span class="n">core</span><span class="o">.</span><span class="n">ordered_effects</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">cond_ordered_effects</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">cond</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
      <span class="c1"># Pred can be batched</span>
      <span class="n">pred</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">batched</span><span class="p">:</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">_reduce_or</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))))</span>
      <span class="k">return</span> <span class="n">pred</span>
    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">body_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">new_cond</span><span class="p">(</span><span class="n">pred_args</span><span class="p">):</span>
      <span class="n">pred</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pred_args</span>
      <span class="k">return</span> <span class="n">pred</span>
    <span class="k">def</span> <span class="nf">new_body</span><span class="p">(</span><span class="n">pred_args</span><span class="p">):</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">args</span>  <span class="o">=</span> <span class="n">pred_args</span>
      <span class="n">args</span> <span class="o">=</span> <span class="n">body</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="n">pred</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">pred</span><span class="p">,</span> <span class="n">args</span>
    <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="n">pred</span> <span class="o">=</span> <span class="n">cond</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="n">_</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">while_loop</span><span class="p">(</span><span class="n">new_cond</span><span class="p">,</span> <span class="n">new_body</span><span class="p">,</span> <span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">)(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

  <span class="n">loop_carry_types</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_types</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">)</span>
  <span class="n">body_effects</span> <span class="o">=</span> <span class="p">[</span><span class="n">eff</span> <span class="k">for</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">effects</span>
                  <span class="k">if</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">core</span><span class="o">.</span><span class="n">ordered_effects</span><span class="p">]</span>
  <span class="n">num_tokens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body_effects</span><span class="p">)</span>
  <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctx</span><span class="o">.</span><span class="n">tokens_in</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eff</span><span class="p">)</span> <span class="k">for</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">body_effects</span><span class="p">]</span>
  <span class="n">token_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlir</span><span class="o">.</span><span class="n">token_type</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">]</span>
  <span class="n">loop_carry_types</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">token_types</span><span class="p">,</span> <span class="o">*</span><span class="n">loop_carry_types</span><span class="p">]</span>
  <span class="n">flat_loop_carry_types</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">loop_carry_types</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">tokens</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">]</span>

  <span class="n">flat_args</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">flatten_lowering_ir_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">while_op</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">WhileOp</span><span class="p">(</span><span class="n">flat_loop_carry_types</span><span class="p">,</span> <span class="n">flat_args</span><span class="p">)</span>

  <span class="c1"># Loop condition</span>
  <span class="n">cond_block</span> <span class="o">=</span> <span class="n">while_op</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">flat_loop_carry_types</span><span class="p">)</span>
  <span class="n">name_stack</span> <span class="o">=</span> <span class="n">extend_name_stack</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">name_stack</span><span class="p">,</span> <span class="s1">&#39;while&#39;</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">cond_block</span><span class="p">):</span>
    <span class="n">flat_cond_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">cond_block</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_loop_carry_types</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">cond_args</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_cond_args</span><span class="p">,</span> <span class="n">_map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">loop_carry_types</span><span class="p">))</span>
    <span class="c1"># Remove tokens from cond args</span>
    <span class="n">cond_args</span> <span class="o">=</span> <span class="n">cond_args</span><span class="p">[</span><span class="n">num_tokens</span><span class="p">:]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">cond_args</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
    <span class="n">cond_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">name_stack</span><span class="o">=</span><span class="n">xla</span><span class="o">.</span><span class="n">extend_name_stack</span><span class="p">(</span><span class="n">name_stack</span><span class="p">,</span> <span class="s1">&#39;cond&#39;</span><span class="p">))</span>
    <span class="p">((</span><span class="n">pred</span><span class="p">,),),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">cond_ctx</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(),</span>
                                    <span class="n">_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">),</span>
                                    <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">batched</span><span class="p">:</span>
      <span class="n">pred_ctx</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">LoweringRuleContext</span><span class="p">(</span>
          <span class="n">module_context</span><span class="o">=</span><span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="p">,</span>
          <span class="n">primitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">avals_in</span><span class="o">=</span><span class="p">[</span><span class="n">pred_aval</span><span class="p">],</span>
          <span class="n">avals_out</span><span class="o">=</span><span class="p">[</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">())],</span>
          <span class="n">tokens_in</span><span class="o">=</span><span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(),</span>
          <span class="n">tokens_out</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
      <span class="n">pred</span><span class="p">,</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">_unary_reduce_lower</span><span class="p">(</span>
          <span class="n">mhlo</span><span class="o">.</span><span class="n">OrOp</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span>
          <span class="n">pred_ctx</span><span class="p">,</span>
          <span class="n">pred</span><span class="p">,</span>
          <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))))</span>
    <span class="n">mhlo</span><span class="o">.</span><span class="n">ReturnOp</span><span class="p">([</span><span class="n">pred</span><span class="p">])</span>

  <span class="c1"># Loop body</span>
  <span class="n">body_block</span> <span class="o">=</span> <span class="n">while_op</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">flat_loop_carry_types</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">body_block</span><span class="p">):</span>
    <span class="n">flat_body_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">body_block</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_loop_carry_types</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">body_args</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_body_args</span><span class="p">,</span> <span class="n">_map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">loop_carry_types</span><span class="p">))</span>
    <span class="c1"># Tokens are at the front of the args list to the while loop</span>
    <span class="n">token_args</span><span class="p">,</span> <span class="n">body_args</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">body_args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_tokens</span><span class="p">])</span>
    <span class="n">tokens_in</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">body_effects</span><span class="p">,</span> <span class="n">token_args</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">body_args</span><span class="p">,</span> <span class="p">[</span><span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
    <span class="n">body_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">name_stack</span><span class="o">=</span><span class="n">xla</span><span class="o">.</span><span class="n">extend_name_stack</span><span class="p">(</span><span class="n">name_stack</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="p">))</span>
    <span class="n">new_z</span><span class="p">,</span> <span class="n">tokens_out</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">body_ctx</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span>
        <span class="n">tokens_in</span><span class="p">,</span> <span class="n">_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span>
    <span class="n">out_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">tokens_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eff</span><span class="p">)</span> <span class="k">for</span> <span class="n">eff</span> <span class="ow">in</span> <span class="n">body_effects</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">batched</span><span class="p">:</span>
      <span class="n">body_pred_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
          <span class="n">name_stack</span><span class="o">=</span><span class="n">xla</span><span class="o">.</span><span class="n">extend_name_stack</span><span class="p">(</span><span class="n">name_stack</span><span class="p">,</span>
                                           <span class="s1">&#39;body_pred&#39;</span><span class="p">))</span>
      <span class="p">((</span><span class="n">body_pred</span><span class="p">,),),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">jaxpr_subcomp</span><span class="p">(</span>
          <span class="n">body_pred_ctx</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(),</span>
          <span class="n">_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span>
      <span class="n">new_z</span> <span class="o">=</span> <span class="n">_map</span><span class="p">(</span>
          <span class="n">partial</span><span class="p">(</span><span class="n">_pred_bcast_select_mhlo</span><span class="p">,</span> <span class="n">pred_aval</span><span class="p">,</span> <span class="n">body_pred</span><span class="p">),</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>
          <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">)</span>

    <span class="n">mhlo</span><span class="o">.</span><span class="n">ReturnOp</span><span class="p">([</span><span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">out_tokens</span><span class="p">),</span> <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                   <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">new_z</span><span class="p">)])</span>

  <span class="n">outputs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">while_op</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">_map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">loop_carry_types</span><span class="p">))</span>
  <span class="n">tokens</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">[</span><span class="n">num_tokens</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_nconsts</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">tokens</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">set_tokens_out</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">body_effects</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">z</span>

<span class="k">def</span> <span class="nf">_while_typecheck</span><span class="p">(</span><span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">,</span>
                     <span class="n">body_nconsts</span><span class="p">):</span>
  <span class="c1"># TODO(frostig,mattjj): check cond_jaxpr, body_jaxpr types</span>
  <span class="n">joined_effects</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_effects</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">joined_effects</span> <span class="o">-</span> <span class="n">allowed_effects</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Effects not supported in `while`: </span><span class="si">{</span><span class="n">joined_effects</span> <span class="o">-</span> <span class="n">allowed_effects</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">body_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="n">joined_effects</span>

<span class="n">while_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">AxisPrimitive</span><span class="p">(</span><span class="s1">&#39;while&#39;</span><span class="p">)</span>
<span class="n">while_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">while_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">while_p</span><span class="p">))</span>
<span class="n">while_p</span><span class="o">.</span><span class="n">def_effectful_abstract_eval</span><span class="p">(</span><span class="n">_while_loop_abstract_eval</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_loop_jvp</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_partial_eval_rules</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_partial_eval</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_initial_style_primitive</span><span class="p">(</span><span class="n">while_p</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_transpose_error</span>
<span class="n">batching</span><span class="o">.</span><span class="n">axis_primitive_batchers</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_loop_batching_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">partial_eval_jaxpr_custom_rules</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_partial_eval_custom</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">while_p</span><span class="p">,</span> <span class="n">_while_lowering</span><span class="p">)</span>
<span class="n">core</span><span class="o">.</span><span class="n">custom_typechecks</span><span class="p">[</span><span class="n">while_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_while_typecheck</span>


<span class="k">def</span> <span class="nf">_pred_bcast_select_mhlo</span><span class="p">(</span>
    <span class="n">pred_aval</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">xs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">ys</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">x_y_aval</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
  <span class="k">if</span> <span class="n">x_y_aval</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">abstract_token</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">xs</span>
    <span class="n">y</span><span class="p">,</span> <span class="o">=</span> <span class="n">ys</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mhlo</span><span class="o">.</span><span class="n">AfterAllOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">x_y_aval</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">result</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_y_aval</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">),</span> <span class="n">x_y_aval</span>
    <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">xs</span>
    <span class="n">y</span><span class="p">,</span> <span class="o">=</span> <span class="n">ys</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x_y_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)]),</span> <span class="p">(</span>
            <span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x_y_aval</span><span class="p">)</span>
    <span class="n">x_y_type</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">x_y_aval</span><span class="p">)</span>
    <span class="n">bcast_pred_type</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="n">x_y_type</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dtype_to_ir_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)))</span>
    <span class="n">bcast_pred</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">BroadcastInDimOp</span><span class="p">(</span>
        <span class="n">bcast_pred_type</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)))))</span><span class="o">.</span><span class="n">result</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SelectOp</span><span class="p">(</span><span class="n">bcast_pred</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="c1">### fori_loop</span>

<span class="k">def</span> <span class="nf">_fori_cond_fun</span><span class="p">(</span><span class="n">loop_carry</span><span class="p">):</span>
  <span class="n">i</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">loop_carry</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

<span class="nd">@weakref_lru_cache</span>
<span class="k">def</span> <span class="nf">_fori_body_fun</span><span class="p">(</span><span class="n">body_fun</span><span class="p">):</span>
  <span class="n">body_fun</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">body_fun</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">while_body_fun</span><span class="p">(</span><span class="n">loop_carry</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">loop_carry</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">upper</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">()(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">while_body_fun</span>

<span class="nd">@weakref_lru_cache</span>
<span class="k">def</span> <span class="nf">_fori_scan_body_fun</span><span class="p">(</span><span class="n">body_fun</span><span class="p">):</span>
  <span class="n">body_fun</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">body_fun</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">scanned_fun</span><span class="p">(</span><span class="n">loop_carry</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">loop_carry</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">()(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">scanned_fun</span>

<div class="viewcode-block" id="fori_loop"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.fori_loop.html#jax.lax.fori_loop">[docs]</a><span class="nd">@api_boundary</span>
<span class="k">def</span> <span class="nf">fori_loop</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">,</span> <span class="n">init_val</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Loop from ``lower`` to ``upper`` by reduction to :func:`jax.lax.while_loop`.</span>

<span class="sd">  The `Haskell-like type signature`_ in brief is</span>

<span class="sd">  .. code-block:: haskell</span>

<span class="sd">    fori_loop :: Int -&gt; Int -&gt; ((Int, a) -&gt; a) -&gt; a -&gt; a</span>

<span class="sd">  The semantics of ``fori_loop`` are given by this Python implementation::</span>

<span class="sd">    def fori_loop(lower, upper, body_fun, init_val):</span>
<span class="sd">      val = init_val</span>
<span class="sd">      for i in range(lower, upper):</span>
<span class="sd">        val = body_fun(i, val)</span>
<span class="sd">      return val</span>

<span class="sd">  Unlike that Python version, ``fori_loop`` is implemented in terms of either a</span>
<span class="sd">  call to :func:`jax.lax.while_loop` or a call to :func:`jax.lax.scan`. If the</span>
<span class="sd">  trip count is static (meaning known at tracing time, perhaps because ``lower``</span>
<span class="sd">  and ``upper`` are Python integer literals) then the ``fori_loop`` is</span>
<span class="sd">  implemented in terms of ``scan`` and reverse-mode autodiff is supported;</span>
<span class="sd">  otherwise, a ``while_loop`` is used and reverse-mode autodiff is not</span>
<span class="sd">  supported.  See those functions&#39; docstrings for more information.</span>

<span class="sd">  Also unlike the Python analogue, the loop-carried value ``val`` must hold a</span>
<span class="sd">  fixed shape and dtype across all iterations (and not just be consistent up to</span>
<span class="sd">  NumPy rank/shape broadcasting and dtype promotion rules, for example). In</span>
<span class="sd">  other words, the type ``a`` in the type signature above represents an array</span>
<span class="sd">  with a fixed shape and dtype (or a nested tuple/list/dict container data</span>
<span class="sd">  structure with a fixed structure and arrays with fixed shape and dtype at the</span>
<span class="sd">  leaves).</span>

<span class="sd">  .. note::</span>
<span class="sd">    :py:func:`fori_loop` compiles ``body_fun``, so while it can be combined with</span>
<span class="sd">    :py:func:`jit`, it&#39;s usually unnecessary.</span>

<span class="sd">  Args:</span>
<span class="sd">    lower: an integer representing the loop index lower bound (inclusive)</span>
<span class="sd">    upper: an integer representing the loop index upper bound (exclusive)</span>
<span class="sd">    body_fun: function of type ``(int, a) -&gt; a``.</span>
<span class="sd">    init_val: initial loop carry value of type ``a``.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Loop value from the final iteration, of type ``a``.</span>

<span class="sd">  .. _Haskell-like type signature: https://wiki.haskell.org/Type_signature</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">body_fun</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lax.fori_loop: body_fun argument should be callable.&quot;</span><span class="p">)</span>
  <span class="c1"># TODO(phawkins): perhaps do more type checking here, better error messages.</span>
  <span class="n">lower_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">lower</span><span class="p">))</span>
  <span class="n">upper_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">lower_dtype</span> <span class="o">!=</span> <span class="n">upper_dtype</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;lower and upper arguments to fori_loop must have equal types, &quot;</span>
           <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lower_dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">upper_dtype</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

  <span class="c1"># If we can specialize on the trip count, call scan instead of a while_loop</span>
  <span class="c1"># to enable efficient reverse-mode differentiation.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span> <span class="n">ConcreteArray</span><span class="p">)</span> <span class="ow">and</span>
      <span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">upper</span><span class="p">),</span> <span class="n">ConcreteArray</span><span class="p">)):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">lower_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
      <span class="n">upper_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">use_scan</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">use_scan</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">use_scan</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">if</span> <span class="n">use_scan</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_disable_jit</span> <span class="ow">and</span> <span class="n">upper_</span> <span class="o">==</span> <span class="n">lower_</span><span class="p">:</span>
      <span class="c1"># non-jit implementation of scan does not support length=0</span>
      <span class="k">return</span> <span class="n">init_val</span>

    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">result</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scan</span><span class="p">(</span><span class="n">_fori_scan_body_fun</span><span class="p">(</span><span class="n">body_fun</span><span class="p">),</span> <span class="p">(</span><span class="n">lower_</span><span class="p">,</span> <span class="n">init_val</span><span class="p">),</span>
                          <span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">upper_</span> <span class="o">-</span> <span class="n">lower_</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">while_loop</span><span class="p">(</span><span class="n">_fori_cond_fun</span><span class="p">,</span> <span class="n">_fori_body_fun</span><span class="p">(</span><span class="n">body_fun</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">init_val</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">result</span></div>

<span class="c1">### map and miscellanous rules</span>

<div class="viewcode-block" id="map"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.map.html#jax.lax.map">[docs]</a><span class="nd">@api_boundary</span>
<span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Map a function over leading array axes.</span>

<span class="sd">  Like Python&#39;s builtin map, except inputs and outputs are in the form of</span>
<span class="sd">  stacked arrays. Consider using the ``jax.vmap`` transform instead, unless you</span>
<span class="sd">  need to apply a function element by element for reduced memory usage or</span>
<span class="sd">  heterogeneous computation with other control flow primitives.</span>

<span class="sd">  When ``xs`` is an array type, the semantics of ``map`` are given by this</span>
<span class="sd">  Python implementation::</span>

<span class="sd">    def map(f, xs):</span>
<span class="sd">      return np.stack([f(x) for x in xs])</span>

<span class="sd">  Like ``scan``, ``map`` is implemented in terms of JAX primitives so many of</span>
<span class="sd">  the same advantages over a Python loop apply: ``xs`` may be an arbitrary</span>
<span class="sd">  nested pytree type, and the mapped computation is compiled only once.</span>

<span class="sd">  Args:</span>
<span class="sd">    f: a Python function to apply element-wise over the first axis or axes of</span>
<span class="sd">      ``xs``.</span>
<span class="sd">    xs: values over which to map along the leading axis.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Mapped values.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="p">((),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">scan</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(),</span> <span class="n">xs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ys</span></div>

<span class="k">def</span> <span class="nf">_rng_bit_generator_batching_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Calls RBG in a loop and stacks the results.&quot;&quot;&quot;</span>
  <span class="n">key</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bd</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="k">if</span> <span class="n">bd</span> <span class="ow">is</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                        <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">key</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">map_body</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">)</span>
  <span class="n">stacked_keys</span><span class="p">,</span> <span class="n">stacked_bits</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">map_body</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">stacked_keys</span><span class="p">,</span> <span class="n">stacked_bits</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">rng_bit_generator_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rng_bit_generator_batching_rule</span>  <span class="c1"># type: ignore</span>

<span class="c1">### associative_scan</span>

<div class="viewcode-block" id="associative_scan"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.associative_scan.html#jax.lax.associative_scan">[docs]</a><span class="nd">@api_boundary</span>
<span class="k">def</span> <span class="nf">associative_scan</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Performs a scan with an associative binary operation, in parallel.</span>

<span class="sd">  For an introduction to associative scans, see [BLE1990]_.</span>

<span class="sd">  Args:</span>
<span class="sd">    fn: A Python callable implementing an associative binary operation with</span>
<span class="sd">      signature ``r = fn(a, b)``. Function `fn` must be associative, i.e., it</span>
<span class="sd">      must satisfy the equation</span>
<span class="sd">      ``fn(a, fn(b, c)) == fn(fn(a, b), c)``.</span>

<span class="sd">      The inputs and result are (possibly nested Python tree structures of)</span>
<span class="sd">      array(s) matching ``elems``. Each array has a dimension in place</span>
<span class="sd">      of the ``axis`` dimension. `fn` should be applied elementwise over</span>
<span class="sd">      the ``axis`` dimension (for example, by using :func:`jax.vmap` over the</span>
<span class="sd">      elementwise function.)</span>

<span class="sd">      The result ``r`` has the same shape (and structure) as the two inputs</span>
<span class="sd">      ``a`` and ``b``.</span>
<span class="sd">    elems: A (possibly nested Python tree structure of) array(s), each with</span>
<span class="sd">      an ``axis`` dimension of size ``num_elems``.</span>
<span class="sd">    reverse: A boolean stating if the scan should be reversed with respect to</span>
<span class="sd">      the ``axis`` dimension.</span>
<span class="sd">    axis: an integer identifying the axis over which the scan should occur.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A (possibly nested Python tree structure of) array(s) of the same shape</span>
<span class="sd">    and structure as ``elems``, in which the ``k``&#39;th element of ``axis`` is the</span>
<span class="sd">    result of recursively applying ``fn`` to combine the first ``k`` elements</span>
<span class="sd">    of ``elems`` along ``axis``. For example, given ``elems = [a, b, c, ...]``,</span>
<span class="sd">    the result would be ``[a, fn(a, b), fn(fn(a, b), c), ...]``.</span>

<span class="sd">  Example 1: partial sums of an array of numbers:</span>

<span class="sd">  &gt;&gt;&gt; lax.associative_scan(jnp.add, jnp.arange(0, 4))</span>
<span class="sd">  DeviceArray([0, 1, 3, 6], dtype=int32)</span>

<span class="sd">  Example 2: partial products of an array of matrices</span>

<span class="sd">  &gt;&gt;&gt; mats = jax.random.uniform(jax.random.PRNGKey(0), (4, 2, 2))</span>
<span class="sd">  &gt;&gt;&gt; partial_prods = lax.associative_scan(jnp.matmul, mats)</span>
<span class="sd">  &gt;&gt;&gt; partial_prods.shape</span>
<span class="sd">  (4, 2, 2)</span>

<span class="sd">  Example 3: reversed partial sums of an array of numbers</span>

<span class="sd">  &gt;&gt;&gt; lax.associative_scan(jnp.add, jnp.arange(0, 4), reverse=True)</span>
<span class="sd">  DeviceArray([6, 6, 5, 3], dtype=int32)</span>

<span class="sd">  .. [BLE1990] Blelloch, Guy E. 1990. &quot;Prefix Sums and Their Applications.&quot;,</span>
<span class="sd">    Technical Report CMU-CS-90-190, School of Computer Science, Carnegie Mellon</span>
<span class="sd">    University.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lax.associative_scan: fn argument should be callable.&quot;</span><span class="p">)</span>
  <span class="n">elems_flat</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
    <span class="n">elems_flat</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems_flat</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">a_flat</span><span class="p">,</span> <span class="n">b_flat</span><span class="p">):</span>
    <span class="c1"># Lower `fn` to operate on flattened sequences of elems.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">a_flat</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">b_flat</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">c_flat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_flat</span>

  <span class="c1"># Check that all inputs have a consistent leading dimension `num_elems`.</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">elems_flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="n">num_elems</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elems_flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">==</span> <span class="n">num_elems</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems_flat</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array inputs to associative_scan must have the same &#39;</span>
                     <span class="s1">&#39;first dimension. (saw: </span><span class="si">{}</span><span class="s1">)&#39;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="n">elem</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems_flat</span><span class="p">]))</span>


  <span class="c1"># Summary of algorithm:</span>
  <span class="c1">#</span>
  <span class="c1"># Consider elements of `_scan(elems)` at odd indices. That&#39;s the same as first</span>
  <span class="c1"># summing successive pairs of elements of `elems` and performing a scan on</span>
  <span class="c1"># that half sized tensor. We perform the latter scan by recursion.</span>
  <span class="c1">#</span>
  <span class="c1"># Now consider the even elements of `_scan(elems)`. These can be computed</span>
  <span class="c1"># from the odd elements of `_scan(elems)` by adding each odd element of</span>
  <span class="c1"># `_scan(elems)` to the matching even element in the original `elems`.</span>
  <span class="c1">#</span>
  <span class="c1"># We return the odd and even elements interleaved.</span>
  <span class="c1">#</span>
  <span class="c1"># For the base case of the recursion we return the first element</span>
  <span class="c1"># of `elems` followed by the sum of the first two elements computed as</span>
  <span class="c1"># a (small two-down-to-one) reduction step.</span>
  <span class="k">def</span> <span class="nf">_scan</span><span class="p">(</span><span class="n">elems</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform scan on `elems`.&quot;&quot;&quot;</span>

    <span class="n">num_elems</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">num_elems</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">elems</span>

    <span class="c1"># Combine adjacent pairs of elements.</span>
    <span class="n">reduced_elems</span> <span class="o">=</span> <span class="n">combine</span><span class="p">(</span>
      <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">],</span>
      <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>

    <span class="c1"># Recursively compute scan for partially reduced tensors.</span>
    <span class="n">odd_elems</span> <span class="o">=</span> <span class="n">_scan</span><span class="p">(</span><span class="n">reduced_elems</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_elems</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">even_elems</span> <span class="o">=</span> <span class="n">combine</span><span class="p">(</span>
        <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">odd_elems</span><span class="p">],</span>
        <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">even_elems</span> <span class="o">=</span> <span class="n">combine</span><span class="p">(</span>
        <span class="n">odd_elems</span><span class="p">,</span>
        <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span>

    <span class="c1"># The first element of a scan is the same as the first element</span>
    <span class="c1"># of the original `elems`.</span>
    <span class="n">even_elems</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">result</span><span class="p">],</span>
                      <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="n">even_elems</span><span class="p">)]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_interleave</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">even_elems</span><span class="p">,</span> <span class="n">odd_elems</span><span class="p">))</span>

  <span class="n">scans</span> <span class="o">=</span> <span class="n">_scan</span><span class="p">(</span><span class="n">elems_flat</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
    <span class="n">scans</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">scanned</span><span class="p">,</span> <span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="k">for</span> <span class="n">scanned</span> <span class="ow">in</span> <span class="n">scans</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">tree_unflatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">scans</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_interleave</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Given two Tensors of static shape, interleave them along the first axis.&quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">a_pad</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">b_pad</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">a_pad</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">b_pad</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span>
  <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">a_pad</span><span class="p">),</span>
            <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">b_pad</span><span class="p">))</span>

<span class="c1">### Cumulative reductions.</span>

<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.cumsum.html#jax.lax.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Computes a cumulative sum along `axis`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cumsum_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">reverse</span><span class="p">))</span></div>

<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.cumprod.html#jax.lax.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Computes a cumulative product along `axis`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cumprod_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">reverse</span><span class="p">))</span></div>

<div class="viewcode-block" id="cummax"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.cummax.html#jax.lax.cummax">[docs]</a><span class="k">def</span> <span class="nf">cummax</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Computes a cumulative maximum along `axis`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cummax_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">reverse</span><span class="p">))</span></div>

<div class="viewcode-block" id="cummin"><a class="viewcode-back" href="../../../../../_autosummary/jax.lax.cummin.html#jax.lax.cummin">[docs]</a><span class="k">def</span> <span class="nf">cummin</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Computes a cumulative minimum along `axis`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cummin_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">reverse</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">_cumred_shape_rule</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> is out of bounds for array of shape </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

<span class="k">def</span> <span class="nf">_cumsum_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="ow">not</span> <span class="n">reverse</span><span class="p">)]</span>



<span class="k">def</span> <span class="nf">cumred_reduce_window_impl</span><span class="p">(</span><span class="n">window_reduce</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                              <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">padding</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">strides</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">window_dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">window_dims</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">return</span> <span class="n">window_reduce</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_dims</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cumred_gpu_impl</span><span class="p">(</span><span class="n">window_reduce</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">reduce_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
  <span class="c1"># On GPU, reduce_window is executed in a single fusion and associative_scan</span>
  <span class="c1"># is split into multiple to materialize intermediate calculations.</span>
  <span class="c1"># On small inputs reduce_window is faster being a single fusion,</span>
  <span class="c1"># but on larger ones is slower because of O(n^2) complexity.</span>
  <span class="c1"># This conservative value of the threshold was obtained via benchmarking.</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">associative_scan</span><span class="p">(</span><span class="n">reduce_fn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">cumred_reduce_window_impl</span><span class="p">(</span><span class="n">window_reduce</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cumred_batch_rule</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="n">bdim</span> <span class="k">else</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">prim</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">),</span> <span class="n">bdim</span>

<span class="k">def</span> <span class="nf">_cumred_dtype_rule</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> does not accept dtype </span><span class="si">{}</span><span class="s2">. Accepted dtypes are subtypes &quot;</span>
                    <span class="s2">&quot;of number.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cumulative_reduction_primitive</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">reduce_fn</span><span class="p">,</span> <span class="n">reduce_window_fn</span><span class="p">):</span>
  <span class="n">reducer_p</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_cumred_shape_rule</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_cumred_dtype_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
    <span class="n">name</span><span class="p">)</span>
  <span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">reducer_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_cumred_batch_rule</span><span class="p">,</span>
                                                   <span class="n">reducer_p</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">register_lowering</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span>
        <span class="n">reducer_p</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">cache_lowering</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
        <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">)</span>

  <span class="c1"># Default for platforms not treated specially below.</span>
  <span class="n">register_lowering</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">associative_scan</span><span class="p">,</span> <span class="n">reduce_fn</span><span class="p">))</span>
  <span class="c1"># On GPU, we choose between window reduction and associative scan</span>
  <span class="c1"># based on the input size.</span>
  <span class="k">for</span> <span class="n">platform</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="s1">&#39;rocm&#39;</span><span class="p">]:</span>
    <span class="n">register_lowering</span><span class="p">(</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">cumred_gpu_impl</span><span class="p">,</span> <span class="n">reduce_window_fn</span><span class="p">,</span> <span class="n">reduce_fn</span><span class="p">),</span> <span class="n">platform</span><span class="p">)</span>
  <span class="c1"># On TPU, an implementation using reduce_window is handled specially by the</span>
  <span class="c1"># compiler and is efficient. On other backends, it is O(n^2).</span>
  <span class="n">register_lowering</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">cumred_reduce_window_impl</span><span class="p">,</span> <span class="n">reduce_window_fn</span><span class="p">),</span> <span class="s1">&#39;tpu&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reducer_p</span>

<span class="n">cumsum_p</span> <span class="o">=</span> <span class="n">_cumulative_reduction_primitive</span><span class="p">(</span><span class="s2">&quot;cumsum&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">windowed_reductions</span><span class="o">.</span><span class="n">_reduce_window_sum</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">cumsum_p</span><span class="p">,</span> <span class="n">_cumsum_transpose_rule</span><span class="p">)</span>
<span class="n">cumprod_p</span> <span class="o">=</span> <span class="n">_cumulative_reduction_primitive</span><span class="p">(</span><span class="s2">&quot;cumprod&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">windowed_reductions</span><span class="o">.</span><span class="n">_reduce_window_prod</span><span class="p">)</span>
<span class="n">cummax_p</span> <span class="o">=</span> <span class="n">_cumulative_reduction_primitive</span><span class="p">(</span><span class="s2">&quot;cummax&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">windowed_reductions</span><span class="o">.</span><span class="n">_reduce_window_max</span><span class="p">)</span>
<span class="n">cummin_p</span> <span class="o">=</span> <span class="n">_cumulative_reduction_primitive</span><span class="p">(</span><span class="s2">&quot;cummin&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">windowed_reductions</span><span class="o">.</span><span class="n">_reduce_window_min</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cumulative_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                         <span class="n">combine_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
  <span class="c1"># Irrespective of backend, we always use the parallel prefix scan</span>
  <span class="c1"># implementation when differentiating because reduce_window is not</span>
  <span class="c1"># arbitrarily differentiable.</span>
  <span class="k">return</span> <span class="n">api</span><span class="o">.</span><span class="n">jvp</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">associative_scan</span><span class="p">,</span> <span class="n">combine_fn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                         <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">),</span>
                 <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">cumprod_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_cumulative_jvp_rule</span><span class="p">,</span> <span class="n">combine_fn</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">cummin_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_cumulative_jvp_rule</span><span class="p">,</span> <span class="n">combine_fn</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">cummax_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_cumulative_jvp_rule</span><span class="p">,</span> <span class="n">combine_fn</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      &copy; Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>