
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax.experimental.host_callback &#8212; JAX  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/jax_logo_250px.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../installation.html">
   Installing JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/quickstart.html">
   JAX Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/Common_Gotchas_in_JAX.html">
   ðŸ”ª JAX - The Sharp Bits ðŸ”ª
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../jax-101/index.html">
   Tutorial: JAX 101
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax-101/08-pjit.html">
     Introduction to pjit
    </a>
   </li>
  </ul>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../debugging/index.html">
   Runtime value debugging in JAX
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../debugging/print_breakpoint.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.print
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.breakpoint
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       checkify
      </span>
     </code>
     transformation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../debugging/flags.html">
     JAX debugging flags
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../async_dispatch.html">
   Asynchronous dispatch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../aot.html">
   Ahead-of-time lowering and compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../jaxpr.html">
   Understanding Jaxprs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/convolutions.html">
   Convolutions in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../pytrees.html">
   Pytrees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../type_promotion.html">
   Type promotion semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../errors.html">
   JAX Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../transfer_guard.html">
   Transfer guard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../glossary.html">
   JAX Glossary of Terms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../changelog.html">
   Change log
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../api_compatibility.html">
   API compatibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../deprecation.html">
   Python and NumPy version support policy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../concurrency.html">
   Concurrency
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../gpu_memory_allocation.html">
   GPU memory allocation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../profiling.html">
   Profiling JAX programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../device_memory_profiling.html">
   Device Memory Profiling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../rank_promotion_warning.html">
   Rank promotion warning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../contributing.html">
   Contributing to JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../developer.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../jax_internal_api.html">
   Internal APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../autodidax.html">
   Autodidax: JAX core from scratch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/263-prng.html">
     263: JAX PRNG Design
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../jax.html">
   Public API: jax package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.numpy.html">
     jax.numpy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.scipy.html">
     jax.scipy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.config.html">
     JAX configuration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.debug.html">
     jax.debug package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.dlpack.html">
     jax.dlpack module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.distributed.html">
     jax.distributed module
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../jax.example_libraries.html">
     jax.example_libraries package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../jax.experimental.html">
     jax.experimental package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.flatten_util.html">
     jax.flatten_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.image.html">
     jax.image package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.lax.html">
     jax.lax package
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../jax.nn.html">
     jax.nn package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.ops.html">
     jax.ops package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.profiler.html">
     jax.profiler module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.random.html">
     jax.random package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.stages.html">
     jax.stages package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.tree_util.html">
     jax.tree_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../jax.lib.html">
     jax.lib package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/google/jax"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for jax.experimental.host_callback</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;Primitives for calling Python functions on the host from JAX accelerator code.</span>

<span class="sd">**Experimental: please give feedback, and expect changes.**</span>

<span class="sd">This module introduces the host callback functions :func:`call`,</span>
<span class="sd">:func:`id_tap`, and :func:`id_print`, that send their arguments from the device</span>
<span class="sd">to the host and invoke user-defined Python functions on the host, optionally</span>
<span class="sd">returning results back to the device computation.</span>

<span class="sd">We show below how these functions can be used. We start with :func:`call`,</span>
<span class="sd">and we discuss examples of calling from JAX to arbitrary Python functions</span>
<span class="sd">on the CPU, e.g., to use NumPy CPU custom kernels. Then we</span>
<span class="sd">show uses of :func:`id_tap` and :func:`id_print`, which have the restriction</span>
<span class="sd">that they cannot return values from the host to the device.</span>
<span class="sd">These primitives are generally faster</span>
<span class="sd">because they are executed asynchronously with the device code.</span>
<span class="sd">In particular, they can be used to tap into and to debug JAX code.</span>

<span class="sd">Using :func:`call` to call a host function and return results to device</span>
<span class="sd">-----------------------------------------------------------------------</span>

<span class="sd">Use :func:`call` to invoke a computation on the host and return</span>
<span class="sd">NumPy arrays to the device computation.</span>
<span class="sd">Host computation is useful, e.g., when a device computation needs some data</span>
<span class="sd">that requires I/O on the host, or it needs a library that is available on the</span>
<span class="sd">host and you do not want to code it in JAX.</span>
<span class="sd">For example, eigen decomposition for general matrices in JAX does not work on TPU.</span>
<span class="sd">We can call the Numpy implementation from any JAX accelerator computation,</span>
<span class="sd">using a host computation::</span>

<span class="sd">  # This function runs on the host</span>
<span class="sd">  def host_eig(m: np.ndarray) -&gt; np.ndarray:</span>
<span class="sd">    return np.linalg.eigvals(m)</span>

<span class="sd">  # This function is used in JAX</span>
<span class="sd">  def device_fun(m):</span>
<span class="sd">    # We send &quot;m&quot; to the host, asking it to call &quot;host_eig&quot; and return the result.</span>
<span class="sd">    # We have to specify the result shape and dtype, either in the form of an</span>
<span class="sd">    # example return value or any object that has `shape` and `dtype` attributes,</span>
<span class="sd">    # e.g., a NumPy array or a `jax.ShapeDtypeStruct`.</span>
<span class="sd">    return hcb.call(host_eig, m,</span>
<span class="sd">                    # Given an input of shape (..., d, d), eig output has shape (..., d)</span>
<span class="sd">                    result_shape=jax.ShapeDtypeStruct(m.shape[:-1], m.dtype))</span>


<span class="sd">The :func:`call` function and the Python host function both take a single argument</span>
<span class="sd">and return a single result, but those can be pytrees. Note that we must tell</span>
<span class="sd">the :func:`call` what shape and dtype to expect from the host invocation, using</span>
<span class="sd">the ``result_shape`` keyword argument.</span>
<span class="sd">This is important because the device code is compiled with that expectation.</span>
<span class="sd">There will be an error raised at runtime if the actual invocation produces a</span>
<span class="sd">different result shape. In general, **such errors and also exceptions raised</span>
<span class="sd">by the host computation may be difficult to debug**. See the Debugging section</span>
<span class="sd">below.</span>
<span class="sd">This is a problem for :func:`call` but not for :func:`id_tap` because for the</span>
<span class="sd">latter the decice code does not expect a returned value.</span>

<span class="sd">The :func:`call` API can be used inside a jit or pmap computation or inside</span>
<span class="sd">cond/scan/while control flow. When used inside :func:`jax.pmap`, there will be</span>
<span class="sd">separate calls to the host from each of the participating devices::</span>

<span class="sd">  def host_sin(x, *, device):</span>
<span class="sd">    # The ``device`` argument is passed due to ``call_with_device=True`` below.</span>
<span class="sd">    print(f&quot;Invoking host_sin with {x.shape} on {device}&quot;)</span>
<span class="sd">    return np.sin(x)</span>

<span class="sd">  # Use pmap to run the computation on two devices</span>
<span class="sd">  jax.pmap(lambda x: hcb.call(host_sin, x,</span>
<span class="sd">                              result_shape=x,</span>
<span class="sd">                              # Ask that the `host_sin` function be passed `device=dev`</span>
<span class="sd">                              call_with_device=True))(</span>
<span class="sd">           np.ones((2, 4), dtype=np.float32))</span>

<span class="sd">  # prints (in arbitrary order)</span>
<span class="sd">  # Invoking host_sin with (4,) on cpu:0</span>
<span class="sd">  # Invoking host_sin with (4,) on cpu:1</span>

<span class="sd">Note that :func:`call` does not support any JAX transformations, but as we</span>
<span class="sd">show below one can make use of the</span>
<span class="sd">existing support for `Custom differentiation in JAX &lt;https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html&gt;`_.</span>

<span class="sd">Using :func:`id_tap` to call a Python function on the host, with no returned values</span>
<span class="sd">-----------------------------------------------------------------------------------</span>

<span class="sd">The :func:`id_tap` and :func:`id_print` are special cases of :func:`call`, when</span>
<span class="sd">you just want the side effects of your Python callback. These functions have</span>
<span class="sd">the advantage that once the arguments have been sent to the host, the device</span>
<span class="sd">computation can proceed without waiting for the Python callback to return.</span>
<span class="sd">For :func:`id_tap` you can specify your Python callback to be called, while</span>
<span class="sd">:func:`id_print` uses a built-in callback that prints the arguments to</span>
<span class="sd">`stdout` on the host.</span>
<span class="sd">The Python function passed</span>
<span class="sd">to :func:`id_tap` takes two positional arguments (the value tapped</span>
<span class="sd">from the device computation along with a ``transforms`` tuple,</span>
<span class="sd">described below). Optionally, the function may be passed a keyword argument</span>
<span class="sd">``device`` with the Device from which the value was tapped.</span>

<span class="sd">A few examples::</span>

<span class="sd">  def host_func(arg, transforms):</span>
<span class="sd">     ...do something with arg...</span>

<span class="sd">  # calls host_func(2x, []) on host</span>
<span class="sd">  id_tap(host_func, 2 * x)</span>

<span class="sd">  # calls host_func((2x, 3x), [])</span>
<span class="sd">  id_tap(host_func, (2 * x, 3 * x))  # The argument can be a pytree</span>

<span class="sd">  # calls host_func(2x, [], device=jax.devices()[0])</span>
<span class="sd">  id_tap(host_func, 2 * x, tap_with_device=True)  # Pass the device to the tap</span>

<span class="sd">  # calls host_func(2x, [], what=&#39;activation&#39;)</span>
<span class="sd">  id_tap(functools.partial(host_func, what=&#39;activation&#39;), 2 * x)</span>

<span class="sd">  # calls host_func(dict(x=x, y=y), what=&#39;data&#39;)</span>
<span class="sd">  id_tap(lambda tap, transforms: host_func(tap, what=&#39;data&#39;), dict(x=x, y=y))</span>

<span class="sd">The above examples can all be adapted to use :func:`id_print` instead, with</span>
<span class="sd">the difference that :func:`id_print` prints on the host the positional argument,</span>
<span class="sd">along with any additional kwargs and the automatic kwarg ``transforms``.</span>

<span class="sd">Using :func:`barrier_wait` to wait until all callbacks have executed</span>
<span class="sd">--------------------------------------------------------------------</span>

<span class="sd">If your Python callbacks have side-effects you may need to wait until the</span>
<span class="sd">computation has finished to ensure that the side-effects have been observed.</span>
<span class="sd">You can use the :func:`barrier_wait` function for that purpose::</span>

<span class="sd">   accumulator = []</span>
<span class="sd">   def host_log(arg, transforms):</span>
<span class="sd">     # We just record the arguments in a list</span>
<span class="sd">     accumulator.append(arg)</span>


<span class="sd">   def device_fun(c):</span>
<span class="sd">     id_tap(host_log, x)</span>
<span class="sd">     id_tap(host_log, 2. * x)</span>

<span class="sd">   jax.jit(device_fun)(1.)</span>
<span class="sd">   jax.jit(device_fun)(1.)</span>

<span class="sd">   # At this point, we have started two computations, each with two</span>
<span class="sd">   # taps, but they may not have yet executed.</span>
<span class="sd">   barrier_wait()</span>
<span class="sd">   # Now we know that all the computations started before `barrier_wait`</span>
<span class="sd">   # on all devices, have finished, and all the callbacks have finished</span>
<span class="sd">   # executing.</span>

<span class="sd">Note that :func:`barrier_wait` will start one</span>
<span class="sd">tiny computation with one tap on each of the `jax.local_devices()` and</span>
<span class="sd">will wait for all these taps to be received.</span>

<span class="sd">An alternative to using :func:`barrier_wait` is to just wait for the end</span>
<span class="sd">of the computation, if all the callbacks are :func:`call`::</span>

<span class="sd">   accumulator = p[]</span>
<span class="sd">   def host_log(arg):</span>
<span class="sd">     # We just record the arguments in a list</span>
<span class="sd">     accumulator.append(arg)</span>
<span class="sd">     return 0.  #  return something</span>


<span class="sd">   def device_fun(c):</span>
<span class="sd">     y = call(host_log, x, result_shape=jax.ShapeDtypeStruct((), np.float32))</span>
<span class="sd">     z = call(host_log, 2. * x, result_shape=jax.ShapeDtypeStruct((), np.float32))</span>
<span class="sd">     return y + z  # return something that uses both results</span>

<span class="sd">   res1 = jax.jit(device_fun)(1.)</span>
<span class="sd">   res2 = jax.jit(device_fun)(1.)</span>
<span class="sd">   res1.block_until_ready()</span>
<span class="sd">   res2.block_until_ready()</span>

<span class="sd">Behavior under parallelization transformations</span>
<span class="sd">----------------------------------------------</span>

<span class="sd">In presence of :func:`jax.pmap` the code will run on multiple devices and</span>
<span class="sd">each device will tap its values independently.</span>
<span class="sd">It may be helpful to use the ``tap_with_device`` option for :func:`id_print`</span>
<span class="sd">or :func:`id_tap`, so that you see which device is sending which data::</span>

<span class="sd">  jax.pmap(power3, devices=jax.local_devices()[:2])(np.array([3., 4.])</span>
<span class="sd">  # device=cpu:0 what=x,x^2: (3., 9.)  # from the first device</span>
<span class="sd">  # device=cpu:1 what=x,x^2: (4., 16.)  # from the second device</span>

<span class="sd">When using :func:`jax.pmap` with multiple devices on multiple hosts, every</span>
<span class="sd">host will receive callbacks from all of its local devices, with an operand</span>
<span class="sd">that corresponds to each device slice. For a</span>
<span class="sd">:func:`call`, the callback must return to each device only the slice of the</span>
<span class="sd">result that pertains to the corresponding device.</span>

<span class="sd">When using the experimental :func:`pjit.pjit` the code will run on multiple</span>
<span class="sd">devices on different shards of the input. The current implementation of</span>
<span class="sd">host callbacks will ensure that a single device will collect and outfeed</span>
<span class="sd">the entire operand, in a single callback. The callback function is supposed</span>
<span class="sd">to return the entire array, which will then be sent in a single infeed to the</span>
<span class="sd">same device that issued the outfeed. This device is then responsible for</span>
<span class="sd">sending the required shards to the other devices::</span>

<span class="sd">  with maps.Mesh(jax.local_devices()[:2], [&quot;d&quot;]):</span>
<span class="sd">    pjit.pjit(power3, in_axis_resources=(P(&quot;d&quot;),),</span>
<span class="sd">              out_axis_resources=(P(&quot;d&quot;),))(np.array([3., 4.]))</span>

<span class="sd">  # device=TPU:0 what=x,x^2: ( [3., 4.],</span>
<span class="sd">  #                            [9., 16.] )</span>

<span class="sd">Note that the collection of the operand on one device may result in OOM if</span>
<span class="sd">the operand was sharded across devices.</span>

<span class="sd">When using :func:`pjit.pjit` with multiple devices on multiple hosts, only</span>
<span class="sd">the host for the device 0 (w.r.t. the mesh) will receive the callback, with</span>
<span class="sd">the operand collected</span>
<span class="sd">from all participating devices on all hosts. For a :func:`call`, the callback</span>
<span class="sd">must return the entire array for all devices on all hosts.</span>

<span class="sd">Behavior under JAX autodiff transformations</span>
<span class="sd">-------------------------------------------</span>

<span class="sd">When used under a JAX autodiff transformation, the host callback functions</span>
<span class="sd">operate on the primal values only. Consider the following example::</span>

<span class="sd">    def power3(x):</span>
<span class="sd">      y = x * x</span>
<span class="sd">      # Print both &#39;x&#39; and &#39;x^2&#39;. Must pack as a tuple.</span>
<span class="sd">      hcb.id_print((x, y), what=&quot;x,x^2&quot;)</span>
<span class="sd">      return y * x</span>

<span class="sd">    power3(3.)</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>

<span class="sd">(You can see these examples tested in `host_callback_test.HostCallbackTapTest.test_tap_transforms`.)</span>

<span class="sd">When used under :func:`jax.jvp` there will be one callback with the primal</span>
<span class="sd">values only::</span>

<span class="sd">    jax.jvp(power3, (3.,), (0.1,))</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>

<span class="sd">Similarly for :func:`jax.grad`, we get a callback from the forward computation</span>
<span class="sd">only::</span>

<span class="sd">    jax.grad(power3)(3.)</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>

<span class="sd">If you want to invoke the callback on the tangents during a :func:`jax.jvp`,</span>
<span class="sd">you can use a custom_jvp. For example, you can define a function that does</span>
<span class="sd">nothing interesting except that its custom_jvp will print the tangents::</span>

<span class="sd">    @jax.custom_jvp</span>
<span class="sd">    def print_tangents(arg):</span>
<span class="sd">      return None</span>

<span class="sd">    @print_tangents.defjvp</span>
<span class="sd">    def print_tangents_jvp(primals, tangents):</span>
<span class="sd">      arg_dot, = tangents</span>
<span class="sd">      hcb.id_print(arg_dot, what=&quot;tangents&quot;)</span>
<span class="sd">      return primals, tangents</span>

<span class="sd">Then you use this function in the places where you want to tap the tangents::</span>

<span class="sd">    def power3_with_tangents(x):</span>
<span class="sd">      y = x * x</span>
<span class="sd">      # Print both &#39;x&#39; and &#39;x^2&#39;. Must pack as a tuple.</span>
<span class="sd">      hcb.id_print((x, y), what=&quot;x,x^2&quot;)</span>
<span class="sd">      print_tangents((x, y))</span>
<span class="sd">      return y * x</span>

<span class="sd">    jax.jvp(power3_with_tangents, (3.,), (0.1,))</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>
<span class="sd">    # what: tangents : (0.1, 0.6)</span>

<span class="sd">You can do a similar thing for the cotangents during :func:`jax.grad`. This</span>
<span class="sd">time you must be careful to use in the rest of the computation the values whose</span>
<span class="sd">cotangents you want to tap. Hence we make the ``print_cotangents`` return</span>
<span class="sd">its argument::</span>

<span class="sd">    @jax.custom_vjp</span>
<span class="sd">    def print_cotangents(arg):</span>
<span class="sd">      # Must return the argument for which we want the cotangent.</span>
<span class="sd">      return arg</span>

<span class="sd">    # f_fwd: a -&gt; (b, residual)</span>
<span class="sd">    def print_cotangents_fwd(arg):</span>
<span class="sd">      return print_cotangents(arg), None</span>
<span class="sd">    # f_bwd: (residual, CT b) -&gt; [CT a]</span>
<span class="sd">    def print_cotangents_bwd(residual, ct_b):</span>
<span class="sd">      hcb.id_print(ct_b, what=&quot;cotangents&quot;, output_stream=testing_stream)</span>
<span class="sd">      return ct_b,</span>

<span class="sd">    print_cotangents.defvjp(print_cotangents_fwd, print_cotangents_bwd)</span>

<span class="sd">    def power3_with_cotangents(x):</span>
<span class="sd">      y = x * x</span>
<span class="sd">      # Print both &#39;x&#39; and &#39;x^2&#39;. Must pack as a tuple.</span>
<span class="sd">      hcb.id_print((x, y), what=&quot;x,x^2&quot;, output_stream=testing_stream)</span>
<span class="sd">      (x1, y1) = print_cotangents((x, y))</span>
<span class="sd">      # Must use the output of print_cotangents</span>
<span class="sd">      return y1 * x1</span>

<span class="sd">    jax.grad(power3_with_cotangents)(3.)</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>
<span class="sd">    # what: cotangents : (9., 3.)</span>

<span class="sd">If you use :func:`ad_checkpoint.checkpoint` to rematerialize the residuals</span>
<span class="sd">for the backward pass, then the callbacks from the primal computation will</span>
<span class="sd">be called twice::</span>

<span class="sd">    jax.grad(lambda x: power3(ad_checkpoint.checkpoint(power3)(x)))(3.)</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>
<span class="sd">    # what: x,x^2 : (27., 729.)</span>
<span class="sd">    # what: x,x^2 : (3., 9.)</span>

<span class="sd">The callbacks are, in order from: the primal computation of the inner ``power3``,</span>
<span class="sd">the primal computation of the outer ``power3``, and the rematerialization</span>
<span class="sd">of the residuals for the inner ``power3``.</span>


<span class="sd">Behavior under jax.vmap</span>
<span class="sd">-----------------------</span>

<span class="sd">The host callback functions :func:`id_print` and :func:`id_tap` support the</span>
<span class="sd">vectorization transformation :func:`jax.vmap`.</span>

<span class="sd">For :func:`jax.vmap` the arguments to the callback are batched,</span>
<span class="sd">and the callback function is</span>
<span class="sd">passed an additional special ``transforms`` containing a list of transformation descriptors</span>
<span class="sd">in the form ``(&quot;batch&quot;, {&quot;batch_dims&quot;: ...})``, where ``...``` denotes the</span>
<span class="sd">batched dimensions for the tapped values (one entry per argument, `</span>
<span class="sd">`None`` denotes an argument that was broadcast).</span>

<span class="sd">  jax.vmap(power3)(np.array([2., 3.]))</span>
<span class="sd">  # transforms: [(&#39;batch&#39;, {&#39;batch_dims&#39;: (0, 0)})] what: x,x^2 : ([2., 3.], [4., 9.])</span>

<span class="sd">See documentation for :func:`id_tap`, :func:`id_print`, and :func:`call`.</span>

<span class="sd">For more usage example, see tests/host_callback_test.py.</span>

<span class="sd">Using :func:`call` to call a TensorFlow function, with reverse-mode autodiff support</span>
<span class="sd">------------------------------------------------------------------------------------</span>

<span class="sd">Another possible use for host computation is to invoke a library written for</span>
<span class="sd">another framework, such as TensorFlow.</span>
<span class="sd">In this case it becomes interesting to support JAX autodiff for host callbacks</span>
<span class="sd">by deferring to the autodiff mechanism in TensorFlow,</span>
<span class="sd">using the :func:`jax.custom_vjp` mechanism.</span>

<span class="sd">This is relatively easy to do, once one understands both the JAX custom VJP</span>
<span class="sd">and the TensorFlow autodiff mechanisms.</span>
<span class="sd">The code for how this can be done is shown in the ``call_tf_full_ad``</span>
<span class="sd">function in `host_callback_to_tf_test.py &lt;https://github.com/google/jax/blob/main/tests/host_callback_to_tf_test.py&gt;`_.</span>
<span class="sd">This example supports arbitrary higher-order differentiation as well.</span>

<span class="sd">Note that if you just want to call TensorFlow functions from JAX, you can also</span>
<span class="sd">use the `jax2tf.call_tf function &lt;https://github.com/google/jax/blob/main/jax/experimental/jax2tf/call_tf.py&gt;`_.</span>

<span class="sd">Using :func:`call` to call a JAX function on another device, with reverse-mode autodiff support</span>
<span class="sd">------------------------------------------------------------------------------------------------</span>

<span class="sd">It should not be surprising that we can use host computation to invoke a JAX</span>
<span class="sd">computation on another device. The arguments are sent from the accelerator to</span>
<span class="sd">the host, and then to the outside device on which the JAX host</span>
<span class="sd">computation will run, and then the results are sent back to the original accelerator.</span>

<span class="sd">The code for how this can be done is shown in the ``call_jax_other_device function``</span>
<span class="sd">in `host_callback_test.py &lt;https://github.com/google/jax/blob/main/tests/host_callback_test.py&gt;`_.</span>

<span class="sd">Low-level details and debugging</span>
<span class="sd">-------------------------------</span>

<span class="sd">The host callback functions will be executed for each device in the order in</span>
<span class="sd">which the send operations were performed on the device.</span>

<span class="sd">The host callback functions for multiple devices may be interleaved.</span>
<span class="sd">The data from the devices is received by separate threads managed by the JAX</span>
<span class="sd">runtime (one thread per device). The runtime maintains a buffer of</span>
<span class="sd">configurable size (see the flag ``--jax_host_callback_max_queue_byte_size``).</span>
<span class="sd">When the buffer is full, all the receiving threads are paused</span>
<span class="sd">which eventually pauses the computation on devices. The runtime has one</span>
<span class="sd">additional thread for each device to invoke the Python user functions with the</span>
<span class="sd">received data. If the processing of the callbacks is slow, it may actually</span>
<span class="sd">lead to the runtime buffer filling up, and eventually pausing the computation</span>
<span class="sd">on the devices when they need to send something.</span>
<span class="sd">For more details on the outfeed receiver runtime mechanism see</span>
<span class="sd">`runtime code</span>
<span class="sd">&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_.</span>

<span class="sd">In order to pause the execution until all data from computations already</span>
<span class="sd">started on devices has arrived and has been processed, use :func:`barrier_wait`.</span>

<span class="sd">Exceptions from the user-defined callback functions are logged along with their</span>
<span class="sd">stack traces, but the receiving threads are not stopped. Instead the last</span>
<span class="sd">exception is recorded and the subsequent :func:`barrier_wait` will</span>
<span class="sd">raise :exc:`CallbackException` if any exception had occurred</span>
<span class="sd">in one of the tap functions. This exception will include the text and the</span>
<span class="sd">stack trace of the last exception encountered.</span>

<span class="sd">One further complication arises for callback functions that must return</span>
<span class="sd">results to the call origin device, such as :func:`call()`. This is handled</span>
<span class="sd">differently on CPU/GPU devices compared to TPU devices.</span>

<span class="sd">On CPU/GPU devices, in order to avoid the device computation</span>
<span class="sd">being stuck waiting for a result that will never arrive, in case of any</span>
<span class="sd">error during the processing of the callback (whether raised by the user-code</span>
<span class="sd">itself or due to a mismatch of the returned value and the expected return_shape)</span>
<span class="sd">we send the device a &quot;fake&quot; result of shape ``int8[12345]``.</span>
<span class="sd">This will make the device</span>
<span class="sd">computation abort because the received data is different than the one that</span>
<span class="sd">it expects. On CPU the runtime will crash with a distinctive error message:</span>

<span class="sd">```</span>
<span class="sd">Check failed: buffer-&gt;length() == buffer_length (12345 vs. ...)</span>
<span class="sd">```</span>

<span class="sd">On GPU, the failure is more user-friendly and will be surfaced to the Python</span>
<span class="sd">program as:</span>

<span class="sd">```</span>
<span class="sd">RET_CHECK failure ... Mismatch between infeed source buffer shape s8[12345] ...</span>
<span class="sd">```</span>

<span class="sd">To debug the underlying cause for these messages, see the Debugging section.</span>

<span class="sd">On TPU devices, there is currently no shape check for infeed, so we take the</span>
<span class="sd">safer route of not sending this fake result in case of errors. This means</span>
<span class="sd">that the computation will hang, and no exception will be raised (but any</span>
<span class="sd">exceptions in the callback functions will still appear in the logs).</span>

<span class="sd">The current implementation uses the outfeed mechanism provided by XLA. The</span>
<span class="sd">mechanism itself is quite primitive in the sense that a receiver must know</span>
<span class="sd">exactly the shape of each incoming packet, and how many packets are expected.</span>
<span class="sd">This makes it hard to use for multiple kinds of data in the same computation,</span>
<span class="sd">and it is practically impossible to use it under conditionals or in loops</span>
<span class="sd">of non-constant iteration count. Furthermore, code that uses the outfeed</span>
<span class="sd">mechanism directly cannot be transformed by JAX. All these limitations are</span>
<span class="sd">addressed by the host callback functions. The tapping API introduced here</span>
<span class="sd">makes it easy to share the outfeed mechanism for multiple purposes, while</span>
<span class="sd">supporting all transformations.</span>

<span class="sd">**Note that after you have used the host callback functions, you cannot</span>
<span class="sd">use lax.outfeed directly**. You may want to :func:`stop_outfeed_receiver`</span>
<span class="sd">if you later need to use lax.outfeed.</span>

<span class="sd">Since the actual calls to your callback functions are made from the C++</span>
<span class="sd">receiver, it may be hard to debug the calls. In particular, the stack trace</span>
<span class="sd">will not include the calling code. You can use the flag</span>
<span class="sd">``jax_host_callback_inline`` (or the environment variable</span>
<span class="sd">``JAX_HOST_CALLBACK_INLINE``) to ensure that the calls to the callbacks are</span>
<span class="sd">inlined. This works only if the calls are outside a staging context (``jit``</span>
<span class="sd">or a control-flow primitive).</span>

<span class="sd">The C++ `receiver</span>
<span class="sd">&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_</span>
<span class="sd">is started automatically on the first call to :func:`id_tap`. In order to stop</span>
<span class="sd">it properly, upon start an ``atexit`` handler is registered to call</span>
<span class="sd">:func:`barrier_wait` with the logging name &quot;at_exit&quot;.</span>

<span class="sd">There are a few environment variables that you can use to turn on logging</span>
<span class="sd">for the C++ outfeed `receiver backend</span>
<span class="sd">&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_.</span>

<span class="sd">  * ``TF_CPP_MIN_LOG_LEVEL=0``: will turn on INFO logging, needed for all below.</span>
<span class="sd">  * ``TF_CPP_MIN_VLOG_LEVEL=3``: will make all VLOG logging up to level 3 behave</span>
<span class="sd">    like INFO logs. This may be too much, but you will see which modules are</span>
<span class="sd">    logging relevant info, and then you can select which modules to log from.</span>
<span class="sd">  * ``TF_CPP_VMODULE=&lt;module_name&gt;=3`` (the module name can be either C++ or</span>
<span class="sd">    Python, without the extension).</span>

<span class="sd">You should also use the ``--verbosity=2`` flag so that you see the logs</span>
<span class="sd">from Python.</span>

<span class="sd">For example, you can try to enable logging in the ``host_callback`` module:</span>
<span class="sd">``TF_CPP_MIN_LOG_LEVEL=0 TF_CPP_VMODULE=host_callback=3 python tests/host_callback_test.py --verbosity=2 HostCallbackIdTapTest.test_tap_jit_simple``</span>

<span class="sd">If you want to enable logging in lower-level implementation modules try:</span>
<span class="sd">``TF_CPP_MIN_LOG_LEVEL=0 TF_CPP_VMODULE=outfeed_receiver=3,host_callback=3,outfeed_receiver_py=3,outfeed_thunk=3,infeed_thunk=3,cpu_transfer_manager=3,cpu_runtime=3,xfeed_manager=3,pjrt_client=3 python tests/host_callback_test.py --verbosity=2 HostCallbackIdTapTest.test_tap_jit_simple``</span>

<span class="sd">(For bazel tests use --test_arg=--vmodule=...</span>

<span class="sd">Still to do:</span>
<span class="sd">  * More performance tests.</span>
<span class="sd">  * Explore implementation with outside compilation for TPU.</span>
<span class="sd">  * Explore implementation with XLA CustomCall for CPU and GPU.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">atexit</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">Tuple</span><span class="p">,</span> <span class="n">cast</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">logging</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">custom_derivatives</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">lax</span>
<span class="kn">from</span> <span class="nn">jax.experimental</span> <span class="kn">import</span> <span class="n">pjit</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">ad</span><span class="p">,</span> <span class="n">xla</span><span class="p">,</span> <span class="n">batching</span><span class="p">,</span> <span class="n">pxla</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">partial_eval</span> <span class="k">as</span> <span class="n">pe</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">mlir</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">ad_checkpoint</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dispatch</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">pretty_printer</span> <span class="k">as</span> <span class="n">pp</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">source_info_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">lib</span> <span class="k">as</span> <span class="n">jaxlib</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">pytree</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_bridge</span> <span class="k">as</span> <span class="n">xb</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_client</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_extension</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir.dialects</span> <span class="kn">import</span> <span class="n">mhlo</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">FLAGS</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">FLAGS</span>


<span class="k">def</span> <span class="nf">_inline_host_callback</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_inline</span>


<span class="k">def</span> <span class="nf">_use_outfeed</span><span class="p">(</span><span class="n">platform</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">platform</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;tpu&quot;</span><span class="p">,</span> <span class="s2">&quot;gpu&quot;</span><span class="p">,</span> <span class="s2">&quot;cuda&quot;</span><span class="p">,</span> <span class="s2">&quot;rocm&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_outfeed</span><span class="p">)</span>

<span class="n">xops</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">_xla</span><span class="o">.</span><span class="n">ops</span>

<span class="n">XlaOp</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">XlaOp</span>
<span class="n">XlaShape</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">Shape</span>
<span class="n">XlaBuilder</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">XlaBuilder</span>
<span class="n">XlaDevice</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">Device</span>
<span class="n">XlaLocalClient</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">Client</span>
<span class="n">DType</span> <span class="o">=</span> <span class="n">Any</span>

<div class="viewcode-block" id="id_tap"><a class="viewcode-back" href="../../../_autosummary/jax.experimental.host_callback.id_tap.html#jax.experimental.host_callback.id_tap">[docs]</a><span class="k">def</span> <span class="nf">id_tap</span><span class="p">(</span><span class="n">tap_func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tap_with_device</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Host-callback tap primitive, like identity function with a call to ``tap_func``.</span>

<span class="sd">  **Experimental: please give feedback, and expect changes!**</span>

<span class="sd">  ``id_tap`` behaves semantically like the identity function but has the</span>
<span class="sd">  side-effect that a user-defined Python function is called with the runtime</span>
<span class="sd">  value of the argument.</span>

<span class="sd">  Args:</span>
<span class="sd">    tap_func: tap function to call like ``tap_func(arg, transforms)``, with</span>
<span class="sd">      ``arg`` as described below and where ``transforms`` is the sequence of</span>
<span class="sd">      applied JAX transformations in the form ``(name, params)``. If the</span>
<span class="sd">      `tap_with_device` optional argument is True, then the invocation also</span>
<span class="sd">      includes the device from which the value is tapped as a keyword argument:</span>
<span class="sd">      ``tap_func(arg, transforms, device=dev)``.</span>
<span class="sd">    arg: the argument passed to the tap function, can be a pytree of JAX</span>
<span class="sd">      types.</span>
<span class="sd">    result: if given, specifies the return value of ``id_tap``. This value is</span>
<span class="sd">      not passed to the tap function, and in fact is not sent from the device to</span>
<span class="sd">      the host. If the ``result`` parameter is not specified then the return</span>
<span class="sd">      value of ``id_tap`` is ``arg``.</span>
<span class="sd">    tap_with_device: if True then the tap function is invoked with the</span>
<span class="sd">      device from which the tap originates as a keyword argument.</span>

<span class="sd">  Returns:</span>
<span class="sd">    ``arg``, or ``result`` if given.</span>

<span class="sd">  The order of execution is by data dependency: after all the arguments and</span>
<span class="sd">  the value of ``result`` if present, are computed and before the returned</span>
<span class="sd">  value is used. At least one of the returned values of ``id_tap`` must be</span>
<span class="sd">  used in the rest of the computation, or else this operation has no effect.</span>

<span class="sd">  Tapping works even for code executed on accelerators and even for code under</span>
<span class="sd">  JAX transformations.</span>

<span class="sd">  For more details see the</span>
<span class="sd">  `module documentation</span>
<span class="sd">  &lt;jax.experimental.host_callback.html&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Support for **kwargs in ``id_tap`` has been removed. Instead, &quot;</span>
        <span class="s2">&quot;pre-apply keyword arguments, either by using a closure or by passing &quot;</span>
        <span class="s2">&quot;``functools.partial(tap_func, **kwargs)``.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The flag jax_host_callback_ad_transforms is for temporary &#39;</span>
                  <span class="s1">&#39;backwards compatibility mode. This flag, and the behavior &#39;</span>
                  <span class="s1">&#39;it enabled will be removed soon.&#39;</span><span class="p">,</span>
                  <span class="ne">FutureWarning</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">flat_results</span><span class="p">,</span> <span class="n">result_treedef</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">flat_results</span><span class="p">:</span>
      <span class="n">api</span><span class="o">.</span><span class="n">_check_arg</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

  <span class="n">call_res</span> <span class="o">=</span> <span class="n">_call</span><span class="p">(</span><span class="n">tap_func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">call_with_device</span><span class="o">=</span><span class="n">tap_with_device</span><span class="p">,</span>
                   <span class="n">result_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">identity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Return the results, but add a dependency on the call, to ensure it</span>
    <span class="c1"># is kept in the graph.</span>
    <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
      <span class="n">call_flat_results</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">call_res</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">call_flat_results</span><span class="p">:</span>
        <span class="n">call_flat_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">call_flat_results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                             <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">flat_results</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">call_flat_results</span> <span class="o">=</span> <span class="n">flat_results</span>
      <span class="k">return</span> <span class="n">result_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">call_flat_results</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">result</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">call_res</span></div>


<div class="viewcode-block" id="id_print"><a class="viewcode-back" href="../../../_autosummary/jax.experimental.host_callback.id_print.html#jax.experimental.host_callback.id_print">[docs]</a><span class="k">def</span> <span class="nf">id_print</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tap_with_device</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">output_stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Like :func:`id_tap` with a printing tap function.</span>

<span class="sd">   **Experimental: please give feedback, and expect changes!**</span>

<span class="sd">   On each invocation of the printing tap, the ``kwargs`` if present</span>
<span class="sd">   will be printed first (sorted by keys). Then arg will be printed,</span>
<span class="sd">   with the arrays stringified with ``numpy.array2string``.</span>

<span class="sd">   See the :func:`id_tap` documentation.</span>

<span class="sd">   Additional keyword arguments:</span>

<span class="sd">   * ``tap_with_device`` if True, will print also the device from which</span>
<span class="sd">     the value originates.</span>
<span class="sd">   * ``output_stream`` if given then it will be used instead of the</span>
<span class="sd">     built-in ``print``. The string will be passed as</span>
<span class="sd">     ``output_stream.write(s)``.</span>
<span class="sd">   * ``threshold`` is passed to ``numpy.array2string``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">printer</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_print_tap_func</span><span class="p">,</span>
                              <span class="n">output_stream</span><span class="o">=</span><span class="n">output_stream</span><span class="p">,</span>
                              <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">id_tap</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">tap_with_device</span><span class="o">=</span><span class="n">tap_with_device</span><span class="p">)</span></div>


<div class="viewcode-block" id="call"><a class="viewcode-back" href="../../../_autosummary/jax.experimental.host_callback.call.html#jax.experimental.host_callback.call">[docs]</a><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">callback_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
         <span class="n">result_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">call_with_device</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Make a call to the host, and expect a result.</span>

<span class="sd">  **Experimental: please give feedback, and expect changes!**</span>

<span class="sd">  Args:</span>
<span class="sd">    callback_func: The Python function to invoke on the host as</span>
<span class="sd">      ``callback_func(arg)``. If the ``call_with_device`` optional argument is True,</span>
<span class="sd">      then the invocation also includes the ``device`` kwarg with the device</span>
<span class="sd">      from which the call originates: ``callback_func(arg, device=dev)``. This function</span>
<span class="sd">      must return a pytree of numpy ndarrays.</span>

<span class="sd">    arg: the argument passed to the callback function, can be a pytree of JAX</span>
<span class="sd">      types.</span>

<span class="sd">    result_shape: a value that describes the expected shape and dtype of the</span>
<span class="sd">      result. This can be a numeric scalar, from which a shape and dtype are</span>
<span class="sd">      obtained, or an object that has ``.shape`` and ``.dtype`` attributes.</span>
<span class="sd">      If the result of the callback is a pytree, then ``result_shape`` should</span>
<span class="sd">      also be a pytree with the same structure. In particular, ``result_shape``</span>
<span class="sd">      can be `()` or `None` if the function does not have any results.</span>
<span class="sd">      The device code containing ``call`` is compiled with the expected result shape and dtype,</span>
<span class="sd">      and an error will be raised at runtime if the actual ``callback_func``</span>
<span class="sd">      invocation returns a different kind of result.</span>

<span class="sd">    call_with_device: if True then the callback function is invoked with the</span>
<span class="sd">      device from which the call originates as a keyword argument.</span>

<span class="sd">  Returns:</span>
<span class="sd">    the result of the ``callback_func`` invocation.</span>

<span class="sd">  For more details see the</span>
<span class="sd">  `module documentation</span>
<span class="sd">  &lt;jax.experimental.host_callback.html&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">_call</span><span class="p">(</span><span class="n">callback_func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">result_shape</span><span class="o">=</span><span class="n">result_shape</span><span class="p">,</span>
               <span class="n">call_with_device</span><span class="o">=</span><span class="n">call_with_device</span><span class="p">,</span> <span class="n">identity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="c1"># We need the wrapper function to have hash and equality defined since it is</span>
<span class="c1"># used as a primitive keyword argument, and we want a compilation cache hit if</span>
<span class="c1"># the user uses the same function twice.</span>
<span class="k">class</span> <span class="nc">_CallbackWrapper</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_func</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">call_with_device</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span> <span class="o">=</span> <span class="n">callback_func</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">identity</span> <span class="o">=</span> <span class="n">identity</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">call_with_device</span> <span class="o">=</span> <span class="n">call_with_device</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_with_device</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">callback_func</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">identity</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call_with_device</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">call_with_device</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">transforms</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity</span><span class="p">:</span>
      <span class="c1"># For id_tap, we pass the transforms, for backwards compatibility</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_with_device</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">transforms</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_with_device</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>


<span class="c1"># Helper function to implement both `call` and `id_tap`. The two cases are</span>
<span class="c1"># differentiated by the `identity` flag.</span>
<span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="n">callback_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
          <span class="n">result_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">call_with_device</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">identity</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="c1"># Lazy initialization</span>
  <span class="n">_initialize_outfeed_receiver</span><span class="p">(</span>
      <span class="n">max_callback_queue_size_bytes</span><span class="o">=</span><span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_max_queue_byte_size</span><span class="p">)</span>
  <span class="n">api</span><span class="o">.</span><span class="n">_check_callable</span><span class="p">(</span><span class="n">callback_func</span><span class="p">)</span>
  <span class="n">flat_args</span><span class="p">,</span> <span class="n">arg_treedef</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">flat_args</span><span class="p">:</span>
    <span class="n">api</span><span class="o">.</span><span class="n">_check_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="c1"># See definition of outside_call_p for what parameters it takes</span>
  <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="c1"># TODO: wrap function</span>
  <span class="n">params</span><span class="p">[</span><span class="s2">&quot;callback&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CallbackWrapper</span><span class="p">(</span><span class="n">callback_func</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span>
                                        <span class="n">call_with_device</span><span class="p">)</span>
  <span class="n">params</span><span class="p">[</span><span class="s2">&quot;identity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">identity</span>
  <span class="n">params</span><span class="p">[</span><span class="s2">&quot;arg_treedef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_treedef</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">identity</span><span class="p">:</span>
    <span class="c1"># Turn abstract values into ShapesDtypeStruct</span>
    <span class="n">flat_results_shape</span><span class="p">,</span> <span class="n">result_treedef</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">flat_results_aval</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">flat_results_shape</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;result_shape should be a pytree of values with structure &quot;</span>
             <span class="s2">&quot;matching the expected result of the callback function. The &quot;</span>
             <span class="s2">&quot;values must be either numeric scalars, or must have &#39;shape&#39; and &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;&#39;dtype&#39; attributes. Got </span><span class="si">{</span><span class="n">result_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;result_treedef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_treedef</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;flat_results_aval&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">)</span>
  <span class="n">flat_results</span> <span class="o">=</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">flat_args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_results</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">identity</span> <span class="k">else</span> <span class="n">arg_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_results</span><span class="p">)</span>


<span class="c1"># We need the lock for when we use the CustomCall implementation of callbacks.</span>
<span class="c1"># The outfeed implementation is driven by a single thread from C++.</span>
<span class="n">_print_tap_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_print_tap_func</span><span class="p">(</span>
    <span class="n">arg</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;The consumer for id_print.</span>

<span class="sd">  We provide this as a simple tapping function for printing.</span>
<span class="sd">  This is **experimental** and may not want to add many features to it;</span>
<span class="sd">  it should be easy for the user to roll their own printing function.</span>

<span class="sd">  Args:</span>
<span class="sd">    device: the device from which the value originates (only if</span>
<span class="sd">      ``tap_with_device`` was used for :func:`id_print`).</span>
<span class="sd">    output_stream: a function whose `write` method is called with the strings to</span>
<span class="sd">      be output.</span>
<span class="sd">    threshold: the value of numpy.array2string threshold parameter.</span>
<span class="sd">    **kwargs: all other keyword args are printed before printing `arg`.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">emit_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">output_stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">output_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">transforms</span><span class="p">:</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transforms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="n">name</span>
                            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span>
  <span class="n">kv_pairs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
  <span class="p">])</span>

  <span class="k">def</span> <span class="nf">pp_val</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;( &quot;</span><span class="p">),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span><span class="n">pp_val</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">])),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; )&quot;</span><span class="p">)</span>
      <span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;[ &quot;</span><span class="p">),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span><span class="n">pp_val</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">])),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; ]&quot;</span><span class="p">)</span>
      <span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;{ &quot;</span><span class="p">),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span>
          <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="p">])),</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; }&quot;</span><span class="p">)</span>
      <span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

  <span class="k">with</span> <span class="n">_print_tap_lock</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">kv_pairs</span><span class="p">:</span>
      <span class="n">emit_str</span><span class="p">(</span><span class="n">kv_pairs</span><span class="p">)</span>
    <span class="n">emit_str</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pp_val</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_values_to_avals</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">]:</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">)</span>

<span class="c1">### The id_tap_dep primitive</span>
<span class="c1"># The id_tap_dep_p primitive is used to create a dependency of the result of</span>
<span class="c1"># id_tap on the actual tap operation. This is only needed when the</span>
<span class="c1"># id_tap function is used with the `result` parameter. This primitive acts</span>
<span class="c1"># as the identity operator on the first argument.</span>
<span class="c1">#</span>
<span class="c1"># For example, given `id_tap(f, (a, b), result=(r, s)`, we convert this to</span>
<span class="c1">#</span>
<span class="c1">#    a1, b1 = outside_call_p(f, a, b)</span>
<span class="c1">#    r1 = id_tap_dep_p(r, a1)</span>
<span class="c1">#    s1 = id_tap_dep_p(s, a1)</span>
<span class="c1">#</span>
<span class="c1"># There are always two arguments and the result is equal to the first.</span>
<span class="n">id_tap_dep_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;id_tap_dep&quot;</span><span class="p">)</span>
<span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">r</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">id_tap_dep_p</span><span class="p">,</span>
                         <span class="k">lambda</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span> <span class="n">a_res</span><span class="p">,</span> <span class="n">a_tap</span><span class="p">:</span> <span class="p">[</span><span class="n">a_res</span><span class="p">])</span>
<span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r_a</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">r_a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_id_tap_dep_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>
  <span class="n">tangents_instantiated</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_instantiate_zeros</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">primals</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">primals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">primals</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
          <span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">tangents_instantiated</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tangents_instantiated</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">id_tap_dep_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_id_tap_dep_jvp_rule</span>

<span class="k">def</span> <span class="nf">_id_tap_dep_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">arg_res</span><span class="p">,</span> <span class="n">arg_tap</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">arg_res</span><span class="p">):</span>
    <span class="n">ct_res</span> <span class="o">=</span> <span class="n">_instantiate_zeros</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">arg_res</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ct_res</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">arg_tap</span><span class="p">):</span>
    <span class="n">ct_tap</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">arg_tap</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ct_tap</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ct_res</span><span class="p">,</span> <span class="n">ct_tap</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">id_tap_dep_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_id_tap_dep_transpose_rule</span>


<span class="k">def</span> <span class="nf">_id_tap_dep_batching_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>
  <span class="n">arg_res</span><span class="p">,</span> <span class="n">arg_tap</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="k">return</span> <span class="n">id_tap_dep_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">arg_res</span><span class="p">,</span> <span class="n">arg_tap</span><span class="p">),</span> <span class="n">batch_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">id_tap_dep_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_id_tap_dep_batching_rule</span>

<span class="c1">### The outside_call primitive</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This primitive is used to implement the `call` and `id_tap` functions.</span>
<span class="sd">It takes several positional arguments that are the flattened</span>
<span class="sd">according to `arg_treedef`.</span>
<span class="sd">The result of the primitive is computed based on the `identity` parameter,</span>
<span class="sd">as follows:</span>

<span class="sd">  * if `identity` is True, then the results are the same as the</span>
<span class="sd">  positional arguments of the primitive (except perhaps the last couple of</span>
<span class="sd">  arguments, see `has_token`). In this case, `result_treedef` and</span>
<span class="sd">  `flat_results_aval` are ignored, and `args_treedef` describes the result also.</span>
<span class="sd">  * if `identity` is False, then the results are those from</span>
<span class="sd">  the call to the outside computation:</span>

<span class="sd">     flatten(callback(arg_treedef.unflatten(args), device=...))</span>

<span class="sd">   In this case, the callback results must match `result_treedef`</span>
<span class="sd">   and `flat_results_aval`.</span>

<span class="sd">It takes the following parameters:</span>

<span class="sd">  * callback: the function to invoke with the unflattened arguments,</span>
<span class="sd">    the device and the transforms: `callback(arrays, device, transforms)`</span>
<span class="sd">  * arg_treedef: the treedef for the argument.</span>
<span class="sd">  * identity: see description above.</span>
<span class="sd">  * result_treedef, flat_results_aval: describes the expected result of the</span>
<span class="sd">    callback. Only used when not `identity`.</span>
<span class="sd">  * transforms: a tuple of the transformations that have been applied. Each</span>
<span class="sd">    element of the tuple is itself a tuple with the first element the name</span>
<span class="sd">    of the transform. The remaining elements depend on the transform. For</span>
<span class="sd">    example, for `batch`, the parameters are the dimensions that have been</span>
<span class="sd">    batched, and for `mask` the logical shapes. These are unpacked by</span>
<span class="sd">    _outside_call_run_callback before passing to the user function.</span>
<span class="sd">  * has_token: a boolean, when True it means that the last positional argument</span>
<span class="sd">    is the current token. In this case, the result of the primitive is</span>
<span class="sd">    going to be the non-token positional arguments, along with the updated</span>
<span class="sd">    token. The tokens and this parameter are added after all the JAX</span>
<span class="sd">    transformations, just before staging XLA.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">outside_call_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;outside_call&quot;</span><span class="p">)</span>
<span class="n">outside_call_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">core</span><span class="o">.</span><span class="n">outfeed_primitives</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_outside_call_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args_a</span><span class="p">:</span> <span class="n">pe</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">,</span>
                                <span class="n">identity</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">]:</span>
  <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
    <span class="c1"># Do some validation here</span>
    <span class="k">assert</span> <span class="s2">&quot;result_treedef&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
    <span class="k">assert</span> <span class="s2">&quot;flat_results_aval&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
    <span class="k">return</span> <span class="n">args_a</span>

  <span class="k">assert</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;result_treedef&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="k">assert</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;flat_results_aval&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="n">flat_results_aval</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;flat_results_aval&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;has_token&quot;</span><span class="p">]:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">flat_results_aval</span> <span class="o">+</span> <span class="n">args_a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">flat_results_aval</span>


<span class="n">outside_call_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_outside_call_abstract_eval</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_outside_call_impl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">in</span> <span class="n">params</span>
  <span class="k">if</span> <span class="n">_inline_host_callback</span><span class="p">():</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">devices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">_outside_call_run_callback</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">send_infeed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># We use the jitted-version of the primitive even for eager execution, both</span>
    <span class="c1"># so that we do not duplicate logic, but also so that all outfeed is received</span>
    <span class="c1"># by the outfeed_listeners, in the same thread from a given device. If we were</span>
    <span class="c1"># to process the tap here, it would be coming from the main thread. Also,</span>
    <span class="c1"># even in eager execution some primitives, such as while, are compiled.</span>
    <span class="c1"># It would be confusing to process a sequence &quot;id_tap; while&quot; in two</span>
    <span class="c1"># different threads.</span>
    <span class="k">return</span> <span class="n">dispatch</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>


<span class="n">outside_call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">_outside_call_impl</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_outside_call_translation_rule</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span>
                                   <span class="o">*</span><span class="n">args_op</span><span class="p">:</span> <span class="n">XlaOp</span><span class="p">,</span>
                                   <span class="n">has_token</span><span class="p">,</span>
                                   <span class="n">identity</span><span class="p">,</span>
                                   <span class="n">flat_results_aval</span><span class="o">=</span><span class="p">(),</span>
                                   <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="c1"># We expect the current tokens at the end, inserted by _rewrite_jaxpr.</span>
  <span class="k">assert</span> <span class="n">has_token</span>
  <span class="n">current_token</span> <span class="o">=</span> <span class="n">args_op</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">current_itoken</span> <span class="o">=</span> <span class="n">args_op</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">comp</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">builder</span>
  <span class="k">assert</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">current_token</span><span class="p">)</span><span class="o">.</span><span class="n">is_token</span><span class="p">()</span> <span class="ow">and</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">current_itoken</span><span class="p">)</span><span class="o">.</span><span class="n">is_token</span><span class="p">(),</span> <span class="p">(</span>
      <span class="s2">&quot;The last two arguments must be tokens&quot;</span><span class="p">)</span>

  <span class="n">args_to_outfeed</span> <span class="o">=</span> <span class="n">args_op</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
  <span class="c1"># Some platforms refuse to infeed empty arrays. We generate constants</span>
  <span class="c1"># instead.</span>
  <span class="n">non_empty_flat_results_aval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">aval</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_aval_is_empty</span><span class="p">(</span><span class="n">aval</span><span class="p">)),</span>
                                            <span class="n">flat_results_aval</span><span class="p">))</span>
  <span class="n">need_callback_results_on_device</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">identity</span> <span class="ow">and</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="n">non_empty_flat_results_aval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">use_outfeed</span> <span class="o">=</span> <span class="n">_use_outfeed</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">platform</span><span class="p">)</span>
  <span class="c1"># TODO(sharadmv): Delete non-outfeed path when jaxlib minimum version is</span>
  <span class="c1"># bumped past 0.3.8.</span>
  <span class="k">assert</span> <span class="n">use_outfeed</span><span class="p">,</span> <span class="s1">&#39;Should be using MLIR path for `CustomCall` lowering&#39;</span>
  <span class="n">send_infeed</span> <span class="o">=</span> <span class="n">use_outfeed</span> <span class="ow">and</span> <span class="n">need_callback_results_on_device</span>
  <span class="n">generated_infeed</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Keep track if we emitted an infeed op</span>
  <span class="k">if</span> <span class="n">use_outfeed</span><span class="p">:</span>
    <span class="n">callback_id</span> <span class="o">=</span> <span class="n">_register_callback</span><span class="p">(</span>
        <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">_outside_call_run_callback</span><span class="p">,</span>
            <span class="n">send_infeed</span><span class="o">=</span><span class="n">send_infeed</span><span class="p">,</span>
            <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
            <span class="n">flat_results_aval</span><span class="o">=</span><span class="n">flat_results_aval</span><span class="p">,</span>
            <span class="o">**</span><span class="n">params</span><span class="p">))</span>
    <span class="n">next_token</span> <span class="o">=</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">receiver</span><span class="o">.</span><span class="n">add_outfeed</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">current_token</span><span class="p">,</span>
                                                        <span class="n">callback_id</span><span class="p">,</span>
                                                        <span class="n">args_to_outfeed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
      <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args_to_outfeed</span><span class="p">)</span>
      <span class="n">next_itoken</span> <span class="o">=</span> <span class="n">current_itoken</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">empty_results</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">xops</span><span class="o">.</span><span class="n">ConstantLiteral</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">flat_results_aval</span>
          <span class="k">if</span> <span class="n">_aval_is_empty</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
      <span class="p">]</span>
      <span class="k">if</span> <span class="n">non_empty_flat_results_aval</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">need_callback_results_on_device</span>
        <span class="n">after_outfeed_itoken</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">AfterAll</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="p">[</span><span class="n">current_itoken</span><span class="p">,</span> <span class="n">next_token</span><span class="p">])</span>
        <span class="c1"># We shard the infeed as AssignedDevice(0). This must match the</span>
        <span class="c1"># outfeed (from outfeed_receiver.cc). Since `lax.infeed` does not support</span>
        <span class="c1"># this kind of sharding, we use a custom translation for infeed.</span>
        <span class="n">array_sharding_proto</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="p">()</span>
        <span class="n">array_sharding_proto</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">MAXIMAL</span>
        <span class="n">array_sharding_proto</span><span class="o">.</span><span class="n">tile_assignment_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">array_sharding_proto</span><span class="o">.</span><span class="n">tile_assignment_devices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">token_sharding_proto</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="p">()</span>
        <span class="n">token_sharding_proto</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">REPLICATED</span>
        <span class="n">infeed_sharding_proto</span> <span class="o">=</span> <span class="n">xla</span><span class="o">.</span><span class="n">tuple_sharding_proto</span><span class="p">(</span>
            <span class="p">[</span><span class="n">array_sharding_proto</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_empty_flat_results_aval</span><span class="p">)</span> <span class="o">+</span>
            <span class="p">[</span><span class="n">token_sharding_proto</span><span class="p">])</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">with_major_to_minor_layout_if_absent</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">non_empty_flat_results_aval</span>
            <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">xla</span><span class="o">.</span><span class="n">aval_to_xla_shapes</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">build_infeed</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">InfeedWithToken</span><span class="p">,</span>
                                         <span class="n">after_outfeed_itoken</span><span class="p">,</span>
                                         <span class="n">xla_client</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">tuple_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">outs_and_token</span> <span class="o">=</span> <span class="n">xla</span><span class="o">.</span><span class="n">with_sharding_proto</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">infeed_sharding_proto</span><span class="p">,</span>
                                                 <span class="n">build_infeed</span><span class="p">)</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">GetTupleElement</span><span class="p">(</span><span class="n">outs_and_token</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">next_itoken</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">GetTupleElement</span><span class="p">(</span><span class="n">outs_and_token</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">non_empty_results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">xops</span><span class="o">.</span><span class="n">GetTupleElement</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_empty_flat_results_aval</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">generated_infeed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">empty_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_aval_is_empty</span><span class="p">(</span><span class="n">result_aval</span><span class="p">)</span> <span class="k">else</span> <span class="n">non_empty_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">result_aval</span> <span class="ow">in</span> <span class="n">flat_results_aval</span>
        <span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">empty_results</span>
        <span class="n">next_itoken</span> <span class="o">=</span> <span class="n">current_itoken</span>

  <span class="k">else</span><span class="p">:</span>  <span class="c1"># !use_outfeed : CustomCall implementation</span>
    <span class="c1"># TODO(necula): this is a weak attempt to get the device. This works</span>
    <span class="c1"># inside pmap, but does not work when we just execute on a single device,</span>
    <span class="c1"># because in such executions we always get replica_id == 0.</span>
    <span class="n">replica_id</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">ReplicaId</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
    <span class="n">callback_operands</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_token</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">)</span> <span class="o">+</span> <span class="n">args_to_outfeed</span>
    <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
      <span class="n">callback_flat_results_aval</span> <span class="o">=</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">abstract_token</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">callback_flat_results_aval</span> <span class="o">=</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">abstract_token</span><span class="p">,)</span> <span class="o">+</span> <span class="n">flat_results_aval</span>

    <span class="k">def</span> <span class="nf">wrapped_callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="n">token</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">args</span>
      <span class="n">result_arrays</span> <span class="o">=</span> <span class="n">_outside_call_run_callback</span><span class="p">(</span>
          <span class="n">arrays</span><span class="p">,</span>
          <span class="n">xb</span><span class="o">.</span><span class="n">local_devices</span><span class="p">()[</span><span class="n">replica_id</span><span class="p">],</span>
          <span class="n">send_infeed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="c1"># The same parameters as outside_call_p</span>
          <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
          <span class="n">flat_results_aval</span><span class="o">=</span><span class="n">flat_results_aval</span><span class="p">,</span>
          <span class="o">**</span><span class="n">params</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
        <span class="c1"># For identity, we do not pass the any results back to the device</span>
        <span class="n">result_arrays</span> <span class="o">=</span> <span class="p">()</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">token</span><span class="p">,)</span> <span class="o">+</span> <span class="n">result_arrays</span>

    <span class="n">result_shapes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">xla</span><span class="o">.</span><span class="n">aval_to_xla_shapes</span><span class="p">(</span><span class="n">res_aval</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">res_aval</span> <span class="ow">in</span> <span class="n">callback_flat_results_aval</span>
    <span class="p">]</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">backend</span>
    <span class="n">token_and_results_op</span><span class="p">,</span> <span class="n">keep_alive</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">emit_python_callback</span><span class="p">(</span>
        <span class="n">wrapped_callback</span><span class="p">,</span>
        <span class="n">comp</span><span class="p">,</span>
        <span class="n">callback_operands</span><span class="p">,</span>
        <span class="n">result_shapes</span><span class="p">,</span>
        <span class="n">operand_layouts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">has_side_effects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">keep_alives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_alive</span><span class="p">)</span>
    <span class="n">next_token</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">xops</span><span class="o">.</span><span class="n">GetTupleElement</span><span class="p">(</span><span class="n">token_and_results_op</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">callback_flat_results_aval</span><span class="p">)))</span>
    <span class="c1"># We must put the two tokens at the end</span>
    <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
      <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args_to_outfeed</span><span class="p">)</span>
    <span class="n">next_itoken</span> <span class="o">=</span> <span class="n">current_itoken</span>

  <span class="k">assert</span> <span class="n">generated_infeed</span> <span class="o">==</span> <span class="n">send_infeed</span><span class="p">,</span> <span class="p">(</span>
      <span class="sa">f</span><span class="s2">&quot;generated_infeed (</span><span class="si">{</span><span class="n">generated_infeed</span><span class="si">}</span><span class="s2">) != send_infeed (</span><span class="si">{</span><span class="n">send_infeed</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">identity</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">),</span> <span class="p">(</span>
      <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="si">}</span><span class="s2"> but expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;identity = </span><span class="si">{</span><span class="n">identity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">results</span> <span class="o">+</span> <span class="p">[</span><span class="n">next_token</span><span class="p">,</span> <span class="n">next_itoken</span><span class="p">]</span>


<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">_outside_call_translation_rule</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_outside_call_lowering</span><span class="p">(</span>
    <span class="n">ctx</span><span class="p">:</span> <span class="n">mlir</span><span class="o">.</span><span class="n">LoweringRuleContext</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">has_token</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">identity</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">flat_results_aval</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;MLIR Lowering for `CustomCall`-based HCB.&quot;&quot;&quot;</span>
  <span class="n">platform</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">platform</span>
  <span class="n">use_outfeed</span> <span class="o">=</span> <span class="n">_use_outfeed</span><span class="p">(</span><span class="n">platform</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">use_outfeed</span><span class="p">:</span>
    <span class="c1"># Fall back to XLA path if we are using the outfeed</span>
    <span class="c1"># TODO(sharadmv): update to use MLIR for this path as well and delete</span>
    <span class="c1">#                 XLA lowering</span>
    <span class="k">return</span> <span class="n">mlir</span><span class="o">.</span><span class="n">xla_fallback_lowering</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">)(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">has_token</span><span class="o">=</span><span class="n">has_token</span><span class="p">,</span> <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">flat_results_aval</span><span class="o">=</span><span class="n">flat_results_aval</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="c1"># We expect the current tokens at the end, inserted by _rewrite_jaxpr.</span>
  <span class="k">assert</span> <span class="n">has_token</span>
  <span class="n">current_token</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">current_itoken</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">assert</span> <span class="n">current_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">TokenType</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="s2">&quot;The last two arguments must be tokens&quot;</span>
  <span class="k">assert</span> <span class="n">current_itoken</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">TokenType</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="s2">&quot;The last two arguments must be tokens&quot;</span>

  <span class="n">args_to_outfeed</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
  <span class="c1"># TODO(necula): this is a weak attempt to get the device. This works</span>
  <span class="c1"># inside pmap, but does not work when we just execute on a single device,</span>
  <span class="c1"># because in such executions we always get replica_id == 0.</span>
  <span class="n">replica_id</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReplicaIdOp</span><span class="p">()</span>
  <span class="n">callback_operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">replica_id</span><span class="p">,</span> <span class="o">*</span><span class="n">args_to_outfeed</span><span class="p">]</span>
  <span class="n">callback_operand_avals</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
  <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
    <span class="n">callback_flat_results_aval</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">callback_flat_results_aval</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">flat_results_aval</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">wrapped_callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">replica_id</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">result_arrays</span> <span class="o">=</span> <span class="n">_outside_call_run_callback</span><span class="p">(</span>
        <span class="n">arrays</span><span class="p">,</span>
        <span class="n">xb</span><span class="o">.</span><span class="n">local_devices</span><span class="p">()[</span><span class="n">replica_id</span><span class="p">],</span>
        <span class="n">send_infeed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="c1"># The same parameters as outside_call_p</span>
        <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">flat_results_aval</span><span class="o">=</span><span class="n">flat_results_aval</span><span class="p">,</span>
        <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
      <span class="c1"># For identity, we do not pass the any results back to the device</span>
      <span class="n">result_arrays</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">return</span> <span class="n">result_arrays</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">axis_context</span><span class="p">,</span>
                <span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">SPMDAxisContext</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">ShardingContext</span><span class="p">)):</span>
    <span class="c1"># Apply maximal sharding so pjit only executes the callback on device 0.</span>
    <span class="n">sharding</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="p">()</span>
    <span class="n">sharding</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">OpSharding</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">MAXIMAL</span>
    <span class="n">sharding</span><span class="o">.</span><span class="n">tile_assignment_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sharding</span><span class="o">.</span><span class="n">tile_assignment_devices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">sharding</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">results</span><span class="p">,</span> <span class="n">next_token</span><span class="p">,</span> <span class="n">keep_alive</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">emit_python_callback</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="n">wrapped_callback</span><span class="p">,</span> <span class="n">current_token</span><span class="p">,</span> <span class="n">callback_operands</span><span class="p">,</span>
      <span class="n">callback_operand_avals</span><span class="p">,</span> <span class="n">callback_flat_results_aval</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
      <span class="n">has_side_effect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharding</span><span class="o">=</span><span class="n">sharding</span><span class="p">)</span>
  <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">keep_alives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_alive</span><span class="p">)</span>
  <span class="c1"># We must put the two tokens at the end</span>
  <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args_to_outfeed</span><span class="p">)</span>
  <span class="n">next_itoken</span> <span class="o">=</span> <span class="n">current_itoken</span>

  <span class="k">assert</span> <span class="n">identity</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">),</span> <span class="p">(</span>
      <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="si">}</span><span class="s2"> but expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;identity = </span><span class="si">{</span><span class="n">identity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">results</span> <span class="o">+</span> <span class="p">[</span><span class="n">next_token</span><span class="p">,</span> <span class="n">next_itoken</span><span class="p">]</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">_outside_call_lowering</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_outside_call_run_callback</span><span class="p">(</span>
    <span class="n">arrays</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
    <span class="n">send_infeed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># The same parameters as outside_call_p</span>
    <span class="n">callback</span><span class="p">,</span> <span class="n">arg_treedef</span><span class="p">,</span>
    <span class="n">identity</span><span class="p">,</span> <span class="n">result_treedef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat_results_aval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">transforms</span><span class="o">=</span><span class="p">(),</span> <span class="n">has_token</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Performs the callback:</span>
<span class="sd">       callback(arg, device, transforms)</span>

<span class="sd">  Called during the device computation once we have the argument, either from</span>
<span class="sd">  an inlined callback or from an XLA computation outfeed.</span>

<span class="sd">  Returns the flat list of result arrays. If `send_infeed` then it will also send</span>
<span class="sd">  the flat list of results to the device.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">_unpack_transforms</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="o">...</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">_unpack_transform</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;batch&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">batch_dims</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;mask&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">logical_shapes</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">params</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_unpack_transform</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">tree_unflatten</span><span class="p">(</span><span class="n">arg_treedef</span><span class="p">,</span> <span class="n">arrays</span><span class="p">)</span>
    <span class="n">unpacked_transforms</span> <span class="o">=</span> <span class="n">_unpack_transforms</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
                   <span class="sa">f</span><span class="s2">&quot;Outside call invoking call_func </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2">, device=</span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2">, transforms=</span><span class="si">{</span><span class="n">unpacked_transforms</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">unpacked_transforms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">identity</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Check the type of the callback results</span>
      <span class="k">assert</span> <span class="n">result_treedef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
      <span class="k">assert</span> <span class="n">flat_results_aval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
      <span class="n">actual_flat_results</span><span class="p">,</span> <span class="n">actual_result_treedef</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">actual_result_treedef</span> <span class="o">!=</span> <span class="n">result_treedef</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Callback func </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2"> should have returned a result &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;with pytree </span><span class="si">{</span><span class="n">result_treedef</span><span class="si">}</span><span class="s2"> but returned &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">actual_result_treedef</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

      <span class="n">canonical_flat_results</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">safe_map</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">,</span> <span class="n">actual_flat_results</span><span class="p">))</span>
      <span class="n">actual_flat_results_aval</span> <span class="o">=</span> <span class="n">_values_to_avals</span><span class="p">(</span><span class="n">canonical_flat_results</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Outside call </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2"> result </span><span class="si">{</span><span class="n">flat_results_aval</span><span class="si">}</span><span class="s2">. Sending to infeed for device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ea</span><span class="o">.</span><span class="n">strip_weak_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">ra</span><span class="o">.</span><span class="n">strip_weak_type</span><span class="p">()</span>
                 <span class="k">for</span> <span class="n">ea</span><span class="p">,</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_zip</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">,</span>
                                             <span class="n">actual_flat_results_aval</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Callback func </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2"> should have returned a result &quot;</span>
               <span class="s2">&quot;with abstract values &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">result_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_results_aval</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;but returned </span><span class="si">{</span><span class="n">actual_result_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">actual_flat_results_aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">send_infeed</span><span class="p">:</span>
        <span class="c1"># Do not send the 0-sized arrays</span>
        <span class="n">non_empty_canonical_flat_results</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="ow">not</span> <span class="n">_aval_is_empty</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                                        <span class="n">canonical_flat_results</span><span class="p">))</span>
        <span class="n">device</span><span class="o">.</span><span class="n">transfer_to_infeed</span><span class="p">(</span><span class="n">non_empty_canonical_flat_results</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">canonical_flat_results</span>

  <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Outside call </span><span class="si">%s</span><span class="s2"> threw exception </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">send_infeed</span><span class="p">:</span>
      <span class="c1"># Prepare some results to send in case of error. We are sending something</span>
      <span class="c1"># with a distinctive shape (int8[12345]), one that is unlikely to be what the device</span>
      <span class="c1"># expects. This should have the effect to abort the device computation,</span>
      <span class="c1"># with an error message that we recognize. On TPU there seem to be no</span>
      <span class="c1"># such check, and if we send anything at all the device computation will</span>
      <span class="c1"># use some garbage data. So, on TPU we prefer to not send anything and let</span>
      <span class="c1"># the computation hang.</span>
      <span class="c1"># TODO: implement a proper error handling for TPU</span>
      <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;tpu&quot;</span><span class="p">:</span>
        <span class="n">canonical_flat_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">xla</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Outside call consumer </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2"> exception </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Sending to infeed the error result.&quot;</span><span class="p">)</span>
        <span class="n">device</span><span class="o">.</span><span class="n">transfer_to_infeed</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">canonical_flat_results</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Outside call consumer </span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2"> exception </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. On TPU we do not send infeed.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">e</span>  <span class="c1"># Let the exception propagate</span>


<span class="k">def</span> <span class="nf">_add_transform</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">transform_params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Adds the `transform` to the params[&quot;transforms&quot;].</span>

<span class="sd">  Uses a tuple representation internally, will be unpacked before the</span>
<span class="sd">  callback by _ConsumerCallable.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">new_transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">transform_params</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
      <span class="n">params</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transforms&quot;</span><span class="p">,</span> <span class="p">())</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_transform</span><span class="p">,)))</span>


<span class="k">def</span> <span class="nf">_aval_is_empty</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">_instantiate_zeros</span><span class="p">(</span><span class="n">tan</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Turn special ad.zero tangents into arrays of 0s for sending to host.</span>
<span class="sd">  Args:</span>
<span class="sd">    tan: the tangent.</span>
<span class="sd">    arg: the argument for which we need to instantiate the tangent</span>

<span class="sd">  Returns: tan if is is not ad.Zero, otherwise a 0 array of appropriate type</span>
<span class="sd">    and shape</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tan</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ad</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">tan</span>
  <span class="k">if</span> <span class="n">tan</span><span class="o">.</span><span class="n">aval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">abstract_unit</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">(</span><span class="n">tan</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">tan</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">aval</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">ad</span><span class="o">.</span><span class="n">instantiate_zeros_aval</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">tan</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_outside_call_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">assert</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;identity&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;JVP rule is implemented only for id_tap, not for call.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="n">tangents_instantiated</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_instantiate_zeros</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">primals</span><span class="p">))</span>

    <span class="n">arg_treedef</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;arg_treedef&quot;</span><span class="p">]</span>
    <span class="c1"># The argument to the jvp tap is a pair of the tapped primals and tangents</span>
    <span class="n">jvp_flat_args</span><span class="p">,</span> <span class="n">jvp_arg_treedef</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span>
        <span class="p">(</span><span class="n">arg_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">primals</span><span class="p">),</span>
         <span class="n">arg_treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">tangents_instantiated</span><span class="p">)))</span>
    <span class="n">out_all</span> <span class="o">=</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="o">*</span><span class="n">jvp_flat_args</span><span class="p">,</span>
        <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">_add_transform</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;jvp&quot;</span><span class="p">),</span>
               <span class="n">arg_treedef</span><span class="o">=</span><span class="n">jvp_arg_treedef</span><span class="p">,</span>
               <span class="p">))</span>
    <span class="n">out_primals_tapped</span><span class="p">,</span> <span class="n">out_tangents_tapped</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">out_all</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">primals</span><span class="p">)])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_primals_tapped</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_tangents_tapped</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">out_primals_tapped</span> <span class="o">=</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">primals</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_primals_tapped</span><span class="p">),</span> <span class="n">tangents</span>


<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">outside_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_outside_call_jvp_rule</span>


<span class="k">def</span> <span class="nf">_outside_call_partial_eval_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="c1"># partial eval is used after jvp and before transpose.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="c1"># TODO: just remote the partial eval rule</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">transforms</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transforms&quot;</span><span class="p">,</span> <span class="p">())</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">transforms</span> <span class="ow">or</span> <span class="n">transforms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;jvp&quot;</span><span class="p">,):</span>
    <span class="c1"># We are not in the process of computing VJP</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="c1"># The args have been prepared by the id_tap_jvp_rule: primals, tangents. The</span>
  <span class="c1"># result is a pair of the primal outputs and output tangents.</span>
  <span class="c1"># One invariant that JAX requires is that if the primals arguments are known</span>
  <span class="c1"># then the primal outputs must be known. So, if the primal arguments are known</span>
  <span class="c1"># and some of the tangents are unknown, then we must split the tap into</span>
  <span class="c1"># one for the primals (thus the output will be considered known), and a</span>
  <span class="c1"># separate tap for the tangents.</span>
  <span class="k">assert</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;identity&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;differentiation rules are implemented only for id_tap, not for call.&quot;</span><span class="p">)</span>

  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">nr_primals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[</span><span class="n">nr_primals</span><span class="p">])</span>
  <span class="n">all_primals_known</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">primals</span><span class="p">)</span>
  <span class="n">some_tangents_unknown</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">all_primals_known</span> <span class="ow">and</span> <span class="n">some_tangents_unknown</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="n">prims</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;arg_treedef&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">primals_treedef</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">prims</span><span class="p">)</span>

  <span class="n">outs_known</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span>
      <span class="n">outside_call_p</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span>
      <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
           <span class="n">arg_treedef</span><span class="o">=</span><span class="n">primals_treedef</span><span class="p">,</span>
           <span class="n">transforms</span><span class="o">=</span><span class="n">transforms</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
  <span class="c1"># Now compute the unknowns using the whole tap, and merge them with the tapped ones</span>
  <span class="n">outs_all_unknown</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">outside_call_p</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">outs_primals_unknown</span><span class="p">,</span> <span class="n">outs_tangents_unknown</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span>
      <span class="n">outs_all_unknown</span><span class="p">,</span> <span class="p">[</span><span class="n">nr_primals</span><span class="p">])</span>
  <span class="n">outs_combined</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">JaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">known</span><span class="p">(</span><span class="n">primal_known</span><span class="p">),</span>
                      <span class="n">primal_unknown</span><span class="o">.</span><span class="n">recipe</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">primal_known</span><span class="p">,</span> <span class="n">primal_unknown</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_zip</span><span class="p">(</span><span class="n">outs_known</span><span class="p">,</span> <span class="n">outs_primals_unknown</span><span class="p">)]</span> <span class="o">+</span>
      <span class="n">outs_tangents_unknown</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outs_combined</span><span class="p">)</span>


<span class="n">pe</span><span class="o">.</span><span class="n">custom_partial_eval_rules</span><span class="p">[</span><span class="n">outside_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_outside_call_partial_eval_rule</span>


<span class="k">def</span> <span class="nf">_outside_call_transpose_rule</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;identity&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;differentiation rules are implemented only for id_tap, not for call.&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">cts_instantiated</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_instantiate_zeros</span><span class="p">,</span> <span class="n">cts</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>

  <span class="c1"># The args have been prepared by the id_tap_jvp_rule: tapped_primals, tapped_tangents, rest_primals, rest_tangents</span>
  <span class="n">transforms</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transforms&quot;</span><span class="p">,</span> <span class="p">())</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">transforms</span> <span class="ow">or</span> <span class="n">transforms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;jvp&quot;</span><span class="p">,):</span>
    <span class="c1"># TODO: I should understand better when can this happen. It seems to arise</span>
    <span class="c1"># in scan.</span>
    <span class="k">return</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="o">*</span><span class="n">cts_instantiated</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_add_transform</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">))</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_host_callback_ad_transforms</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>

  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">nr_primals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

  <span class="n">args_unflat</span><span class="p">,</span> <span class="n">tan_unflat</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;arg_treedef&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">vjp_arg_treedef</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">args_unflat</span><span class="p">)</span>
  <span class="c1"># We want to tap the cts_tapped_tangents</span>
  <span class="n">cts_primals</span><span class="p">,</span> <span class="n">cts_tangents</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">cts_instantiated</span><span class="p">,</span> <span class="p">[</span><span class="n">nr_primals</span><span class="p">])</span>
  <span class="n">cts_tangents_through_tap</span> <span class="o">=</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="o">*</span><span class="n">cts_tangents</span><span class="p">,</span>
      <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">_add_transform</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">),</span>
             <span class="n">arg_treedef</span><span class="o">=</span><span class="n">vjp_arg_treedef</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">cts_primals</span> <span class="o">+</span> <span class="n">cts_tangents_through_tap</span>


<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">outside_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_outside_call_transpose_rule</span>


<span class="k">def</span> <span class="nf">_outside_call_batching_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;identity&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;batching rules are implemented only for id_tap, not for call.&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="n">_add_transform</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;batch&quot;</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">outside_call_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">batched_args</span><span class="p">,</span> <span class="o">**</span><span class="n">new_params</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">batch_dims</span>


<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">outside_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_outside_call_batching_rule</span>

<span class="c1">####</span>
<span class="c1">#### Jaxpr rewriting logic to thread the tokens through stateful primitives.</span>
<span class="c1">####</span>


<span class="k">def</span> <span class="nf">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">cjaxpr</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">has_input_token</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                          <span class="n">has_output_token</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Rewrites a ClosedJaxpr to thread the token, if needed.&quot;&quot;&quot;</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">cjaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">has_input_token</span><span class="p">,</span> <span class="n">has_output_token</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">cjaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rewrite_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">has_input_token</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                   <span class="n">has_output_token</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Rewrite a Jaxpr to thread the token, if needed.&quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">has_input_token</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">has_output_token</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">has_input_token</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jaxpr</span>

  <span class="n">mk_new_var</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">gensym</span><span class="p">([</span><span class="n">jaxpr</span><span class="p">])</span>

  <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># store the incoming tokens</span>
  <span class="n">last_token_var</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">abstract_token</span><span class="p">)</span>
  <span class="n">last_itoken_var</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">abstract_token</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">has_input_token</span><span class="p">:</span>
    <span class="n">invars</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">last_token_var</span><span class="p">,</span> <span class="n">last_itoken_var</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">invars</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span>
    <span class="c1"># We need tokens but none is given in input; make one depending on all invars</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="p">[</span><span class="n">last_token_var</span><span class="p">],</span>
                           <span class="n">lax</span><span class="o">.</span><span class="n">create_token_p</span><span class="p">,</span> <span class="p">{},</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span><span class="p">,</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current</span><span class="p">()))</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="p">[</span><span class="n">last_itoken_var</span><span class="p">],</span>
                           <span class="n">lax</span><span class="o">.</span><span class="n">create_token_p</span><span class="p">,</span> <span class="p">{},</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span><span class="p">,</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current</span><span class="p">()))</span>

  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">primitive_uses_outfeed</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
      <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">output_token_var</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">last_token_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
      <span class="n">output_itoken_var</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">last_itoken_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
      <span class="n">_rewrite_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">last_token_var</span><span class="p">,</span> <span class="n">output_token_var</span><span class="p">,</span>
                   <span class="n">last_itoken_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">,</span> <span class="n">mk_new_var</span><span class="p">)</span>
      <span class="n">last_token_var</span> <span class="o">=</span> <span class="n">output_token_var</span>
      <span class="n">last_itoken_var</span> <span class="o">=</span> <span class="n">output_itoken_var</span>

  <span class="n">outvars</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">([</span><span class="n">last_token_var</span><span class="p">,</span> <span class="n">last_itoken_var</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_output_token</span> <span class="k">else</span> <span class="p">[])</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span>


<span class="k">def</span> <span class="nf">_rewrite_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">],</span>
                 <span class="n">input_token_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span> <span class="n">output_token_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                 <span class="n">input_itoken_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                 <span class="n">mk_new_var</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">core</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">]):</span>
  <span class="sd">&quot;&quot;&quot;Rewrite an `eqn` and append equations to `eqns`.</span>

<span class="sd">  This is only called if the current primitive uses outfeed.</span>
<span class="sd">  Assume that the current token is in `input_token_var` and the resulting</span>
<span class="sd">  token must end in `output_token_var`.</span>

<span class="sd">  Append the result of rewriting to `eqns`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">outside_call_p</span><span class="p">:</span>
    <span class="k">assert</span> <span class="s2">&quot;has_token&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
                            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
                            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">has_token</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">lax</span><span class="o">.</span><span class="n">while_p</span><span class="p">:</span>
    <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_dict</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;cond_jaxpr&quot;</span><span class="p">,</span> <span class="s2">&quot;cond_nconsts&quot;</span><span class="p">,</span> <span class="s2">&quot;body_jaxpr&quot;</span><span class="p">,</span> <span class="s2">&quot;body_nconsts&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">):</span>
      <span class="n">_rewrite_while_outfeed_cond</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">input_token_var</span><span class="p">,</span> <span class="n">output_token_var</span><span class="p">,</span>
                                  <span class="n">input_itoken_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">,</span>
                                  <span class="n">mk_new_var</span><span class="p">)</span>
      <span class="k">return</span>

    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">body_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">))))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">lax</span><span class="o">.</span><span class="n">cond_p</span><span class="p">:</span>
    <span class="n">branches</span><span class="p">,</span> <span class="n">linear</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_dict</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">])</span>
    <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span>
    <span class="n">new_invars</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">]</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">new_invars</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">branches</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">jaxpr</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">),</span>
                <span class="n">linear</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">linear</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">lax</span><span class="o">.</span><span class="n">scan_p</span><span class="p">:</span>
    <span class="n">num_consts</span><span class="p">,</span> <span class="n">num_carry</span><span class="p">,</span> <span class="n">carry_jaxpr</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_dict</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;num_consts&quot;</span><span class="p">,</span> <span class="s2">&quot;num_carry&quot;</span><span class="p">,</span> <span class="s2">&quot;jaxpr&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;reverse&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span>
         <span class="s2">&quot;unroll&quot;</span><span class="p">])</span>
    <span class="c1"># We add the tokens right at the end of carry</span>
    <span class="n">nr_const_and_carry</span> <span class="o">=</span> <span class="n">num_consts</span> <span class="o">+</span> <span class="n">num_carry</span>
    <span class="n">new_invars</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nr_const_and_carry</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">]</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="n">nr_const_and_carry</span><span class="p">:]</span>
    <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">carry_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="c1"># The rewrite has put the token at end, it has to be at end of carry</span>
    <span class="n">new_jaxpr_invars</span> <span class="o">=</span> <span class="n">new_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span>
    <span class="n">new_jaxpr_invars</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">new_jaxpr_invars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nr_const_and_carry</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_jaxpr_invars</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span>
        <span class="n">new_jaxpr_invars</span><span class="p">[</span><span class="n">nr_const_and_carry</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">new_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span> <span class="o">=</span> <span class="n">new_jaxpr_invars</span>

    <span class="n">new_jaxpr_outvars</span> <span class="o">=</span> <span class="n">new_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span>
    <span class="n">new_jaxpr_outvars</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">new_jaxpr_outvars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_carry</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_jaxpr_outvars</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span>
        <span class="n">new_jaxpr_outvars</span><span class="p">[</span><span class="n">num_carry</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">new_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span> <span class="o">=</span> <span class="n">new_jaxpr_outvars</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">new_invars</span><span class="p">,</span>
            <span class="c1"># Output token is at the end of carry result</span>
            <span class="n">outvars</span><span class="o">=</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_carry</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">]</span> <span class="o">+</span>
                     <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">[</span><span class="n">num_carry</span><span class="p">:]),</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">jaxpr</span><span class="o">=</span><span class="n">new_jaxpr</span><span class="p">,</span>
                <span class="n">num_carry</span><span class="o">=</span><span class="n">num_carry</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nr_const_and_carry</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">linear</span><span class="p">[</span><span class="n">nr_const_and_carry</span><span class="p">:])))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">xla</span><span class="o">.</span><span class="n">xla_call_p</span><span class="p">:</span>
    <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">])</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">donated_invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;donated_invars&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">pxla</span><span class="o">.</span><span class="n">xla_pmap_p</span><span class="p">:</span>
    <span class="c1"># We broadcast the input token into an array of tokens</span>
    <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">])</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">donated_invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;donated_invars&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="c1"># Sharding/unsharding of tokens in pmap_translation are special</span>
                <span class="c1"># cased to just pass-through the token</span>
                <span class="n">in_axes</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;in_axes&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">out_axes</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;out_axes&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">custom_derivatives</span><span class="o">.</span><span class="n">custom_jvp_call_p</span><span class="p">:</span>
    <span class="n">fun_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">unreachable_thunk</span><span class="p">():</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Should not be reached&quot;</span>

    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">fun_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">jvp_jaxpr_thunk</span><span class="o">=</span><span class="n">unreachable_thunk</span>
            <span class="p">)))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">custom_derivatives</span><span class="o">.</span><span class="n">custom_vjp_call_jaxpr_p</span><span class="p">:</span>
    <span class="n">fun_jaxpr</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;fun_jaxpr&quot;</span><span class="p">]</span>
    <span class="n">new_invars</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">unreachable_thunk</span><span class="p">():</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Should not be reached&quot;</span>

    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">new_invars</span><span class="p">,</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">fun_jaxpr</span><span class="o">=</span><span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">fun_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">fwd_jaxpr_thunk</span><span class="o">=</span><span class="n">unreachable_thunk</span><span class="p">,</span>
                <span class="c1"># The following are illegal values for the parameters, they</span>
                <span class="c1"># should not be needed because this rewrite is just before</span>
                <span class="c1"># compilation to XLA, which does not use those parameters.</span>
                <span class="n">bwd</span><span class="o">=</span><span class="s2">&quot;illegal param&quot;</span><span class="p">,</span>
                <span class="n">out_trees</span><span class="o">=</span><span class="s2">&quot;illegal param&quot;</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">named_call_p</span><span class="p">:</span>
    <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">])</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="p">)))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">pjit</span><span class="o">.</span><span class="n">pjit_p</span><span class="p">:</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;jaxpr&quot;</span><span class="p">])</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">jaxpr</span><span class="o">=</span><span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">donated_invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;donated_invars&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="n">in_axis_resources</span><span class="o">=</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;in_axis_resources&quot;</span><span class="p">]</span> <span class="o">+</span>
                                   <span class="p">(</span><span class="n">pjit</span><span class="o">.</span><span class="n">REPLICATED</span><span class="p">,</span> <span class="n">pjit</span><span class="o">.</span><span class="n">REPLICATED</span><span class="p">)),</span>
                <span class="n">out_axis_resources</span><span class="o">=</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;out_axis_resources&quot;</span><span class="p">]</span> <span class="o">+</span>
                                    <span class="p">(</span><span class="n">pjit</span><span class="o">.</span><span class="n">REPLICATED</span><span class="p">,</span> <span class="n">pjit</span><span class="o">.</span><span class="n">REPLICATED</span><span class="p">)),</span>
            <span class="p">)))</span>
  <span class="k">elif</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span> <span class="ow">is</span> <span class="n">ad_checkpoint</span><span class="o">.</span><span class="n">remat_p</span><span class="p">:</span>
    <span class="n">jaxpr_</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;jaxpr&quot;</span><span class="p">])</span>
    <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">invars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
            <span class="n">outvars</span><span class="o">=</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">],</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">jaxpr</span><span class="o">=</span><span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">jaxpr_</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;outfeed rewrite </span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rewrite_while_outfeed_cond</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">JaxprEqn</span><span class="p">],</span>
                                <span class="n">input_token_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                                <span class="n">output_token_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                                <span class="n">input_itoken_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                                <span class="n">output_itoken_var</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span>
                                <span class="n">mk_new_var</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Rewrite a while whose cond has outfeed&quot;&quot;&quot;</span>
  <span class="n">cond_jaxpr</span><span class="p">,</span> <span class="n">cond_nconsts</span><span class="p">,</span> <span class="n">body_jaxpr</span><span class="p">,</span> <span class="n">body_nconsts</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_dict</span><span class="p">(</span>
      <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;cond_jaxpr&quot;</span><span class="p">,</span> <span class="s2">&quot;cond_nconsts&quot;</span><span class="p">,</span> <span class="s2">&quot;body_jaxpr&quot;</span><span class="p">,</span> <span class="s2">&quot;body_nconsts&quot;</span><span class="p">])</span>
  <span class="n">transformed_cond_jaxpr</span> <span class="o">=</span> <span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">carry_invars</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="n">cond_nconsts</span> <span class="o">+</span> <span class="n">body_nconsts</span><span class="p">:]</span>
  <span class="c1"># pred1, token1, itoken1 = rewrite(COND)(cond_consts, carry_invars, input_token, input_itoken)</span>
  <span class="n">pred1_and_token1</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">mk_new_var</span><span class="p">(</span><span class="n">ov</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">ov</span> <span class="ow">in</span> <span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span>
  <span class="p">]</span>
  <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
          <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cond_nconsts</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry_invars</span> <span class="o">+</span> <span class="p">[</span><span class="n">input_token_var</span><span class="p">,</span> <span class="n">input_itoken_var</span><span class="p">],</span>
          <span class="n">pred1_and_token1</span><span class="p">,</span> <span class="n">xla</span><span class="o">.</span><span class="n">xla_call_p</span><span class="p">,</span>
          <span class="nb">dict</span><span class="p">(</span>
              <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cond_before&quot;</span><span class="p">,</span>
              <span class="n">donated_invars</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">),</span>
              <span class="n">inline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
          <span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
          <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">))</span>
  <span class="c1"># Make a new cond &quot;lambda pred, carry, token, itoken: pred&quot;</span>
  <span class="n">new_cond_pred_invar</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">new_cond_invars</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">[</span><span class="n">new_cond_pred_invar</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mk_new_var</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">carry_invars</span><span class="p">]</span> <span class="o">+</span>
      <span class="p">[</span><span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_token_var</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span>
       <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_itoken_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)])</span>
  <span class="n">new_cond_jaxpr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">([],</span> <span class="n">new_cond_invars</span><span class="p">,</span> <span class="p">[</span><span class="n">new_cond_pred_invar</span><span class="p">],</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()),</span> <span class="p">[])</span>
  <span class="c1"># Make a new body:</span>
  <span class="c1">#   &quot;lambda cond_constvars, body_constvars, pred, carry, token, itoken:</span>
  <span class="c1">#        carry2, token2, itoken2 = rewrite(BODY)(body_constvars, carry, token, itoken)</span>
  <span class="c1">#        pred2, token3, itoken3 = rewrite(COND)(cond_constvars, carry2, token2, itoken2)</span>
  <span class="c1">#        (pred2, carry2, token3, itoken3)</span>
  <span class="n">transformed_body_jaxpr</span> <span class="o">=</span> <span class="n">_rewrite_closed_jaxpr</span><span class="p">(</span><span class="n">body_jaxpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">new_body_invars_cond_constvars</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">mk_new_var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cond_nconsts</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">new_body_invars_body_constvars</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">mk_new_var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="n">cond_nconsts</span><span class="p">:</span><span class="n">cond_nconsts</span> <span class="o">+</span> <span class="n">body_nconsts</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">new_body_invars_pred</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">new_body_invars_carry</span> <span class="o">=</span> <span class="p">[</span><span class="n">mk_new_var</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">carry_invars</span><span class="p">]</span>
  <span class="n">new_body_invars_token</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_token_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="n">new_body_invars_itoken</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_itoken_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="n">new_body_carry2</span> <span class="o">=</span> <span class="p">[</span><span class="n">mk_new_var</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">carry_invars</span><span class="p">]</span>
  <span class="n">new_body_token2</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_token_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="n">new_body_itoken2</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_itoken_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="n">new_body_pred2</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">new_body_token3</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_token_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="n">new_body_itoken3</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">input_itoken_var</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="n">new_body_eqns</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
          <span class="n">new_body_invars_body_constvars</span> <span class="o">+</span> <span class="n">new_body_invars_carry</span> <span class="o">+</span>
          <span class="p">[</span><span class="n">new_body_invars_token</span><span class="p">,</span> <span class="n">new_body_invars_itoken</span><span class="p">],</span>
          <span class="n">new_body_carry2</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_body_token2</span><span class="p">,</span> <span class="n">new_body_itoken2</span><span class="p">],</span>
          <span class="n">xla</span><span class="o">.</span><span class="n">xla_call_p</span><span class="p">,</span>
          <span class="nb">dict</span><span class="p">(</span>
              <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">transformed_body_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;body&quot;</span><span class="p">,</span>
              <span class="n">donated_invars</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformed_body_jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">),</span>
              <span class="n">inline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
          <span class="n">transformed_body_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
          <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">),</span>
      <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
          <span class="n">new_body_invars_cond_constvars</span> <span class="o">+</span> <span class="n">new_body_carry2</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_body_token2</span><span class="p">,</span> <span class="n">new_body_itoken2</span><span class="p">],</span>
          <span class="p">[</span><span class="n">new_body_pred2</span><span class="p">,</span> <span class="n">new_body_token3</span><span class="p">,</span> <span class="n">new_body_itoken3</span><span class="p">],</span> <span class="n">xla</span><span class="o">.</span><span class="n">xla_call_p</span><span class="p">,</span>
          <span class="nb">dict</span><span class="p">(</span>
              <span class="n">call_jaxpr</span><span class="o">=</span><span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cond_body&quot;</span><span class="p">,</span>
              <span class="n">donated_invars</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">),</span>
              <span class="n">inline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
          <span class="n">transformed_cond_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
          <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
  <span class="p">]</span>
  <span class="n">effects</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_effects</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">effects</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">new_body_eqns</span><span class="p">))</span>
  <span class="n">new_body_jaxpr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">Jaxpr</span><span class="p">([],</span> <span class="p">(</span><span class="n">new_body_invars_cond_constvars</span> <span class="o">+</span>
                      <span class="n">new_body_invars_body_constvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_body_invars_pred</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">new_body_invars_carry</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_body_invars_token</span><span class="p">,</span> <span class="n">new_body_invars_itoken</span><span class="p">]),</span>
                 <span class="p">([</span><span class="n">new_body_pred2</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_body_carry2</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_body_token3</span><span class="p">,</span> <span class="n">new_body_itoken3</span><span class="p">]),</span>
                 <span class="n">new_body_eqns</span><span class="p">,</span> <span class="n">effects</span><span class="p">),</span> <span class="p">[])</span>

  <span class="n">pred_out</span> <span class="o">=</span> <span class="n">mk_new_var</span><span class="p">(</span><span class="n">cond_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">(</span>
          <span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cond_nconsts</span> <span class="o">+</span> <span class="n">body_nconsts</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">pred1_and_token1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span>
           <span class="n">carry_invars</span> <span class="o">+</span> <span class="n">pred1_and_token1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
          <span class="p">([</span><span class="n">pred_out</span><span class="p">]</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_token_var</span><span class="p">,</span> <span class="n">output_itoken_var</span><span class="p">]),</span>
          <span class="n">lax</span><span class="o">.</span><span class="n">while_p</span><span class="p">,</span>
          <span class="nb">dict</span><span class="p">(</span>
              <span class="n">cond_jaxpr</span><span class="o">=</span><span class="n">new_cond_jaxpr</span><span class="p">,</span>
              <span class="n">cond_nconsts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">body_jaxpr</span><span class="o">=</span><span class="n">new_body_jaxpr</span><span class="p">,</span>
              <span class="n">body_nconsts</span><span class="o">=</span><span class="n">cond_nconsts</span> <span class="o">+</span> <span class="n">body_nconsts</span><span class="p">),</span>
          <span class="n">new_body_jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">,</span>
          <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">))</span>


<span class="c1"># We need an identity primitive to simplify rewriting</span>
<span class="n">id_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>
<span class="n">id_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">id_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">args</span><span class="p">)</span>
<span class="n">id_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">args</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">id_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">args</span><span class="p">)</span>

<span class="n">dispatch</span><span class="o">.</span><span class="n">outfeed_rewriter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">_rewrite_jaxpr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<div class="viewcode-block" id="CallbackException"><a class="viewcode-back" href="../../../_autosummary/jax.experimental.host_callback.CallbackException.html#jax.experimental.host_callback.CallbackException">[docs]</a><span class="k">class</span> <span class="nc">CallbackException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Signals that some callback function had exceptions.</span>

<span class="sd">  Raised by :func:`barrier_wait`.</span>
<span class="sd">  See module documentation for details.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">pass</span></div>

<span class="n">TapFunctionException</span> <span class="o">=</span> <span class="n">CallbackException</span>  <span class="c1"># For backwards compatibility</span>

<span class="k">class</span> <span class="nc">_CallbackHandlerData</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Keep track of the outfeed receiver data.&quot;&quot;&quot;</span>
  <span class="n">receiver</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">initialized</span><span class="p">:</span> <span class="nb">bool</span>
  <span class="n">on_exit</span><span class="p">:</span> <span class="nb">bool</span>
  <span class="n">lock</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span>
  <span class="n">last_callback_exception</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="ne">Exception</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
  <span class="n">clients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">XlaLocalClient</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">devices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">XlaDevice</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">consumer_registry</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
  <span class="n">consumer_registry_by_id</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">receiver</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Initialize lazily, when first needed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">on_exit</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">last_callback_exception</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">clients</span> <span class="o">=</span> <span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">devices</span> <span class="o">=</span> <span class="p">()</span>
    <span class="c1"># The consumer registries must be live for the lifetime of the program,</span>
    <span class="c1"># because we may have cached compilations that embed consumer ids, and we</span>
    <span class="c1"># do not want the id reused for other shapes.</span>
    <span class="c1"># Used only for the outfeed mechanism.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">callback_registry</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">callback_registry_by_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># For now we keep here the keep_alives for the emit_python_callback. This is</span>
    <span class="c1"># a leak. We ought to attach these to the executable.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">keep_alives</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wait for all pending outfeeds and stop the receiver.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">receiver</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># GC will trigger the destructor</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">clients</span> <span class="o">=</span> <span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">devices</span> <span class="o">=</span> <span class="p">()</span>
    <span class="c1"># Do not clear the consumer registries.</span>


<span class="n">_callback_handler_data</span> <span class="o">=</span> <span class="n">_CallbackHandlerData</span><span class="p">()</span>


<span class="c1"># This function is called from C++; it must not allow exceptions through.</span>
<span class="k">def</span> <span class="nf">_callback_input_received</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">consumer_id</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
  <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span>
      <span class="mi">2</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;Callback input received on device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> for consumer </span><span class="si">{</span><span class="n">consumer_id</span><span class="si">}</span><span class="s2"> &quot;</span>
      <span class="o">+</span> <span class="s2">&quot;arrays: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="si">}{</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">])))</span>
  <span class="n">callback</span> <span class="o">=</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">callback_registry_by_id</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">consumer_id</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;We should have crashed in the runtime&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">formatted_e</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Postponing exception raised in callback function: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">formatted_e</span><span class="p">)</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">last_callback_exception</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">formatted_e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_register_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Registers a callback function, cache by hash of callback.</span>

<span class="sd">  The callback is a function to be invoked as `callback(arrays, device)`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">callback_id</span> <span class="o">=</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">callback_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">callback_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">callback_id</span>
  <span class="n">callback_id</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFC</span>  <span class="c1"># pybind11 has trouble here with large ints</span>
  <span class="n">callback_id</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Reserve the consumer ID 0</span>
  <span class="k">assert</span> <span class="n">callback_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">callback_registry</span><span class="p">,</span> <span class="p">(</span>
      <span class="s2">&quot;callback id collision&quot;</span><span class="p">)</span>
  <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">callback_registry</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback_id</span>
  <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">callback_registry_by_id</span><span class="p">[</span><span class="n">callback_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>
  <span class="k">return</span> <span class="n">callback_id</span>


<span class="k">def</span> <span class="nf">_initialize_outfeed_receiver</span><span class="p">(</span>
    <span class="n">max_callback_queue_size_bytes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)):</span>
  <span class="sd">&quot;&quot;&quot;Creates and starts the outfeed_receiver.</span>

<span class="sd">  This function is called lazily only when we compile an id_tap.</span>

<span class="sd">  Args:</span>
<span class="sd">    * clients: the list of clients (backends) on whose devices to listen on.</span>
<span class="sd">    * max_callback_queue_size_bytes: an optional integer to bound the maximum</span>
<span class="sd">      size of arrays in the callback queue. When this limit is reached the</span>
<span class="sd">      device listener pauses.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">outfeed_receiver_module</span> <span class="o">=</span> <span class="n">xla_extension</span><span class="o">.</span><span class="n">outfeed_receiver</span>

  <span class="k">with</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">initialized</span><span class="p">:</span>
      <span class="k">return</span>

    <span class="c1"># By default, all devices on all supported backends.</span>
    <span class="n">clients</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">backend</span> <span class="ow">in</span> <span class="n">xb</span><span class="o">.</span><span class="n">backends</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="s2">&quot;cuda&quot;</span><span class="p">,</span> <span class="s2">&quot;rocm&quot;</span><span class="p">,</span> <span class="s2">&quot;tpu&quot;</span><span class="p">)]</span>
    <span class="n">devices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">local_devices</span><span class="p">()</span> <span class="k">for</span> <span class="n">backend</span> <span class="ow">in</span> <span class="n">clients</span><span class="p">]))</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">clients</span> <span class="o">=</span> <span class="n">clients</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">devices</span> <span class="o">=</span> <span class="n">devices</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="n">clients_with_outfeed</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clients</span> <span class="k">if</span> <span class="n">_use_outfeed</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">platform</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">clients_with_outfeed</span><span class="p">:</span>
      <span class="n">devices_with_outfeed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">local_devices</span><span class="p">()</span> <span class="k">for</span> <span class="n">backend</span> <span class="ow">in</span> <span class="n">clients_with_outfeed</span><span class="p">]))</span>
      <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Starting outfeed_receiver for </span><span class="si">{</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">devices_with_outfeed</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;max_callback_queue_size_bytes=</span><span class="si">{</span><span class="n">max_callback_queue_size_bytes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">receiver</span> <span class="o">=</span> <span class="n">outfeed_receiver_module</span><span class="o">.</span><span class="n">start</span><span class="p">(</span>
          <span class="n">_callback_input_received</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">clients_with_outfeed</span><span class="p">),</span>
          <span class="n">max_callback_queue_size_bytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exit_handler</span><span class="p">():</span>
      <span class="c1"># Prevent logging usage during compilation, gives errors under pytest</span>
      <span class="n">dispatch</span><span class="o">.</span><span class="n">_on_exit</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># type: ignore[protected-access]</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">on_exit</span><span class="p">:</span>
        <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">on_exit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">barrier_wait</span><span class="p">(</span><span class="s2">&quot;at_exit&quot;</span><span class="p">)</span>

    <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">exit_handler</span><span class="p">)</span>  <span class="c1"># We wait as long as we have callbacks</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="barrier_wait"><a class="viewcode-back" href="../../../_autosummary/jax.experimental.host_callback.barrier_wait.html#jax.experimental.host_callback.barrier_wait">[docs]</a><span class="k">def</span> <span class="nf">barrier_wait</span><span class="p">(</span><span class="n">logging_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Blocks the calling thread until all current outfeed is processed.</span>

<span class="sd">  Waits until all callbacks from computations already running on all devices</span>
<span class="sd">  have been received and processed by the Python callbacks. Raises</span>
<span class="sd">  CallbackException if there were exceptions while processing the callbacks.</span>

<span class="sd">  This works by enqueueing a special tap computation to all devices to which</span>
<span class="sd">  we are listening for outfeed. Once all those tap computations are done, we</span>
<span class="sd">  return from barrier_wait.</span>

<span class="sd">  Note: If any of the devices are busy and cannot accept new computations,</span>
<span class="sd">  this will deadlock.</span>

<span class="sd">  Args:</span>
<span class="sd">    logging_name: an optional string that will be used in the logging statements</span>
<span class="sd">      for this invocation. See `Debugging` in the module documentation.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">logging_name</span> <span class="o">=</span> <span class="n">logging_name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
  <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: start&quot;</span><span class="p">)</span>

  <span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
  <span class="n">cv</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">(</span><span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">devices_at_barrier</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Protected by lock</span>
  <span class="k">def</span> <span class="nf">barrier_tap_received</span><span class="p">(</span><span class="n">dev_idx</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">devices</span><span class="p">[</span><span class="n">dev_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span>
          <span class="mi">2</span><span class="p">,</span>
          <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: at barrier_tap for device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;. Thread </span><span class="si">{</span><span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
      <span class="n">devices_at_barrier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">waiting_for_devices</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">devices</span>
                               <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">devices_at_barrier</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
                     <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: still waiting &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">waiting_for_devices</span><span class="p">)</span><span class="si">}</span><span class="s2"> devices at &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;barrier (</span><span class="si">{</span><span class="n">waiting_for_devices</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
      <span class="n">cv</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">d_idx</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">devices</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
                   <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: enqueueing barrier on device </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">x_on_dev</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">device_put</span><span class="p">(</span><span class="n">d_idx</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="n">api</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">id_tap</span><span class="p">(</span><span class="n">barrier_tap_received</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">d</span><span class="p">)(</span><span class="n">x_on_dev</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
                 <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: waiting for callbacks&quot;</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">devices_at_barrier</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">devices</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">logging</span><span class="o">.</span><span class="n">vlog_is_on</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">vlog</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;barrier_wait[</span><span class="si">{</span><span class="n">logging_name</span><span class="si">}</span><span class="s2">]: done&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">last_callback_exception</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">last_exception</span><span class="p">,</span> <span class="n">formatted_last_exception</span> <span class="o">=</span> <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">last_callback_exception</span>
    <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">last_callback_exception</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">raise</span> <span class="n">CallbackException</span><span class="p">(</span>
        <span class="s2">&quot;There were exceptions during callback processing. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;Last one was: </span><span class="si">{</span><span class="n">formatted_last_exception</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">last_exception</span></div>


<span class="k">def</span> <span class="nf">stop_outfeed_receiver</span><span class="p">():</span>
  <span class="sd">&quot;&quot;&quot;Stops the outfeed receiver runtime.</span>

<span class="sd">  This waits for all outfeeds from computations already running on all devices,</span>
<span class="sd">  and then stops the outfeed receiver runtime. The runtime will be restarted</span>
<span class="sd">  next time you use a tap function.</span>

<span class="sd">  It should not be necessary to use this function, unless you want to start</span>
<span class="sd">  using lax.outfeed directly after having used host callbacks.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">_callback_handler_data</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      &copy; Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>