
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax.core &#8212; JAX  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/jax_logo_250px.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../installation.html">
   Installing JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/quickstart.html">
   JAX Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/Common_Gotchas_in_JAX.html">
   ðŸ”ª JAX - The Sharp Bits ðŸ”ª
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../jax-101/index.html">
   Tutorial: JAX 101
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax-101/08-pjit.html">
     Introduction to pjit
    </a>
   </li>
  </ul>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../debugging/index.html">
   Runtime value debugging in JAX
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../debugging/print_breakpoint.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.print
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.breakpoint
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       checkify
      </span>
     </code>
     transformation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../debugging/flags.html">
     JAX debugging flags
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../async_dispatch.html">
   Asynchronous dispatch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../aot.html">
   Ahead-of-time lowering and compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../jaxpr.html">
   Understanding Jaxprs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/convolutions.html">
   Convolutions in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../pytrees.html">
   Pytrees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../type_promotion.html">
   Type promotion semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../errors.html">
   JAX Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../transfer_guard.html">
   Transfer guard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../glossary.html">
   JAX Glossary of Terms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../changelog.html">
   Change log
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../api_compatibility.html">
   API compatibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../deprecation.html">
   Python and NumPy version support policy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../concurrency.html">
   Concurrency
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../gpu_memory_allocation.html">
   GPU memory allocation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../profiling.html">
   Profiling JAX programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../device_memory_profiling.html">
   Device Memory Profiling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../rank_promotion_warning.html">
   Rank promotion warning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../contributing.html">
   Contributing to JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../developer.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../jax_internal_api.html">
   Internal APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../autodidax.html">
   Autodidax: JAX core from scratch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/263-prng.html">
     263: JAX PRNG Design
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../jax.html">
   Public API: jax package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.numpy.html">
     jax.numpy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.scipy.html">
     jax.scipy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.config.html">
     JAX configuration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.debug.html">
     jax.debug package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.dlpack.html">
     jax.dlpack module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.distributed.html">
     jax.distributed module
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../jax.example_libraries.html">
     jax.example_libraries package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../jax.experimental.html">
     jax.experimental package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.flatten_util.html">
     jax.flatten_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.image.html">
     jax.image package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.lax.html">
     jax.lax package
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../jax.nn.html">
     jax.nn package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.ops.html">
     jax.ops package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.profiler.html">
     jax.profiler module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.random.html">
     jax.random package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.stages.html">
     jax.stages package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.tree_util.html">
     jax.tree_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../jax.lib.html">
     jax.lib package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/google/jax"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for jax.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">partialmethod</span><span class="p">,</span> <span class="n">total_ordering</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">DefaultDict</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span>
                    <span class="n">Generator</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span>
                    <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span>
                    <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">ref</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">config</span> <span class="k">as</span> <span class="n">jax_config</span>
<span class="kn">from</span> <span class="nn">jax._src.config</span> <span class="kn">import</span> <span class="n">FLAGS</span><span class="p">,</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax.errors</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ConcretizationTypeError</span><span class="p">,</span> <span class="n">TracerArrayConversionError</span><span class="p">,</span>
                        <span class="n">TracerIntegerConversionError</span><span class="p">,</span> <span class="n">UnexpectedTracerError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">linear_util</span> <span class="k">as</span> <span class="n">lu</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">source_info_util</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">safe_zip</span><span class="p">,</span> <span class="n">safe_map</span><span class="p">,</span> <span class="n">curry</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">tuple_insert</span><span class="p">,</span>
                           <span class="n">tuple_delete</span><span class="p">,</span> <span class="n">as_hashable_function</span><span class="p">,</span>
                           <span class="n">HashableFunction</span><span class="p">,</span> <span class="n">HashableWrapper</span><span class="p">,</span> <span class="n">weakref_lru_cache</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">jax._src.pretty_printer</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">jax_jit</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">traceback_util</span>
<span class="kn">from</span> <span class="nn">jax._src.typing</span> <span class="kn">import</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">typing</span>
<span class="n">traceback_util</span><span class="o">.</span><span class="n">register_exclusion</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>

<span class="nb">zip</span><span class="p">,</span> <span class="n">unsafe_zip</span> <span class="o">=</span> <span class="n">safe_zip</span><span class="p">,</span> <span class="nb">zip</span>
<span class="nb">map</span><span class="p">,</span> <span class="n">unsafe_map</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">,</span> <span class="nb">map</span>


<span class="c1"># -------------------- jaxprs --------------------</span>

<span class="n">Effect</span> <span class="o">=</span> <span class="n">Hashable</span>
<span class="n">Effects</span> <span class="o">=</span> <span class="n">Set</span><span class="p">[</span><span class="n">Effect</span><span class="p">]</span>
<span class="n">no_effects</span><span class="p">:</span> <span class="n">Effects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">ordered_effects</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Effect</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<div class="viewcode-block" id="Jaxpr"><a class="viewcode-back" href="../../_autosummary/jax.core.Jaxpr.html#jax.core.Jaxpr">[docs]</a><span class="k">class</span> <span class="nc">Jaxpr</span><span class="p">:</span>
  <span class="n">constvars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">invars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">outvars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">eqns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">]</span>
  <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span>

<div class="viewcode-block" id="Jaxpr.__init__"><a class="viewcode-back" href="../../_autosummary/jax.core.Jaxpr.html#jax.core.Jaxpr.__init__">[docs]</a>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constvars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span> <span class="n">invars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
               <span class="n">outvars</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Atom</span><span class="p">],</span> <span class="n">eqns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">JaxprEqn</span><span class="p">],</span>
               <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span> <span class="o">=</span> <span class="n">no_effects</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">      constvars: list of variables introduced for constants. Array constants are</span>
<span class="sd">        replaced with such variables while scalar constants are kept inline.</span>
<span class="sd">      invars: list of input variables. Together, `constvars` and `invars` are</span>
<span class="sd">        the inputs to the Jaxpr.</span>
<span class="sd">      outvars: list of output variables.</span>
<span class="sd">      eqns: list of equations.</span>
<span class="sd">      effects: set of effects. The effects on a jaxpr are a superset of the</span>
<span class="sd">        union of the effects for each equation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constvars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">invars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">invars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">outvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outvars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eqns</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">effects</span> <span class="o">=</span> <span class="n">effects</span></div>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">(),</span> <span class="n">JaxprPpSettings</span><span class="p">()))</span>
  <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

  <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name_stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">(),</span>
                   <span class="n">JaxprPpSettings</span><span class="p">(</span><span class="n">source_info</span><span class="o">=</span><span class="n">source_info</span><span class="p">,</span>
                                   <span class="n">print_shapes</span><span class="o">=</span><span class="n">print_shapes</span><span class="p">,</span>
                                   <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="n">custom_pp_eqn_rules</span><span class="p">,</span>
                                   <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">use_color</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">constvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eqns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">effects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">constvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constvars</span> <span class="k">if</span> <span class="n">constvars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constvars</span>
    <span class="n">invars</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">invars</span> <span class="k">if</span> <span class="n">invars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">invars</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outvars</span> <span class="k">if</span> <span class="n">outvars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">outvars</span>
    <span class="n">eqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqns</span> <span class="k">if</span> <span class="n">eqns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">eqns</span>
    <span class="n">effects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">effects</span> <span class="k">if</span> <span class="n">effects</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">effects</span>
    <span class="k">return</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">constvars</span><span class="o">=</span><span class="n">constvars</span><span class="p">,</span> <span class="n">invars</span><span class="o">=</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="n">outvars</span><span class="p">,</span> <span class="n">eqns</span><span class="o">=</span><span class="n">eqns</span><span class="p">,</span>
                 <span class="n">effects</span><span class="o">=</span><span class="n">effects</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">join_effects</span><span class="p">(</span><span class="o">*</span><span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">effects</span><span class="p">)</span> <span class="k">if</span> <span class="n">effects</span> <span class="k">else</span> <span class="n">no_effects</span>

<span class="k">def</span> <span class="nf">jaxprs_in_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">v</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">v</span><span class="o">.</span><span class="n">jaxpr</span>


<span class="k">def</span> <span class="nf">subjaxprs</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Generator for all subjaxprs found in the params of jaxpr.eqns.</span>

<span class="sd">  Does not descend recursively into the found subjaxprs.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="k">yield from</span> <span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>


<div class="viewcode-block" id="ClosedJaxpr"><a class="viewcode-back" href="../../_autosummary/jax.core.ClosedJaxpr.html#jax.core.ClosedJaxpr">[docs]</a><span class="k">class</span> <span class="nc">ClosedJaxpr</span><span class="p">:</span>
  <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span>
  <span class="n">consts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>

<div class="viewcode-block" id="ClosedJaxpr.__init__"><a class="viewcode-back" href="../../_autosummary/jax.core.ClosedJaxpr.html#jax.core.ClosedJaxpr.__init__">[docs]</a>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span> <span class="o">=</span> <span class="n">jaxpr</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">consts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span></div>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">in_avals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">out_avals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">literals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span>  <span class="c1"># backwards compatible alias</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">eqns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">effects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Effects</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span>

  <span class="k">def</span> <span class="nf">map_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">consts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span> <span class="k">if</span> <span class="n">jaxpr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jaxpr</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span> <span class="k">if</span> <span class="n">consts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">consts</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">name_stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">JaxprPpSettings</span><span class="p">(</span><span class="n">source_info</span><span class="o">=</span><span class="n">source_info</span><span class="p">,</span>
                               <span class="n">print_shapes</span><span class="o">=</span><span class="n">print_shapes</span><span class="p">,</span> <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">,</span>
                               <span class="n">custom_pp_eqn_rules</span><span class="o">=</span><span class="n">custom_pp_eqn_rules</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">(),</span> <span class="n">settings</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>


  <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">use_color</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

<span class="nd">@curry</span>
<span class="k">def</span> <span class="nf">jaxpr_as_fun</span><span class="p">(</span><span class="n">closed_jaxpr</span><span class="p">:</span> <span class="n">ClosedJaxpr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">eval_jaxpr</span><span class="p">(</span><span class="n">closed_jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">closed_jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">JaxprEqn</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">invars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span>
  <span class="n">outvars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span>
  <span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span>
  <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
  <span class="n">effects</span><span class="p">:</span> <span class="n">Effects</span>
  <span class="n">source_info</span><span class="p">:</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">SourceInfo</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_eqn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">(),</span> <span class="n">JaxprPpSettings</span><span class="p">()))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># TODO(mattjj): call typecheck rules here, so we don&#39;t form bad eqns</span>
<span class="k">def</span> <span class="nf">new_jaxpr_eqn</span><span class="p">(</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">effects</span><span class="p">,</span> <span class="n">source_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">source_info</span> <span class="o">=</span> <span class="n">source_info</span> <span class="ow">or</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">new_source_info</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Var</span><span class="p">,</span> <span class="n">Literal</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>  <span class="n">invars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span>  <span class="n">Var</span><span class="p">)</span>           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">outvars</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">JaxprEqn</span><span class="p">(</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">effects</span><span class="p">,</span> <span class="n">source_info</span><span class="p">)</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Var</span><span class="p">:</span>
  <span class="n">count</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">suffix</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_encode_digits_alphabetic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span>

<span class="k">def</span> <span class="nf">_encode_digits_alphabetic</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;*&#39;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">26</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">26</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">97</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span>
  <span class="k">return</span> <span class="n">s</span>

<span class="k">def</span> <span class="nf">_jaxpr_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
      <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span>
      <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">gensym</span><span class="p">(</span><span class="n">jaxprs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AbstractValue</span><span class="p">],</span> <span class="n">Var</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Produce distinct variables, printed with the optional suffix.</span>

<span class="sd">  If `jaxprs` is provided, the variables produced will be distinct from those in</span>
<span class="sd">  any of the given jaxprs.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">jaxprs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">all_vars</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_jaxpr_vars</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jaxprs</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">count</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">),</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">counter</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">:</span> <span class="n">Var</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">),</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>

<span class="c1"># In a jaxpr, `dropvar` can appear in place of a bound variable to indicate that</span>
<span class="c1"># the assignment is dropped, i.e. that an expression&#39;s output value will never</span>
<span class="c1"># be read. In that sense, `dropvar` is not a variable, but it is convenient to</span>
<span class="c1"># treat it as a special case of one. Its `aval` is similarly inexact.</span>
<span class="k">class</span> <span class="nc">DropVar</span><span class="p">(</span><span class="n">Var</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;_&#39;</span>

<span class="k">class</span> <span class="nc">Literal</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="s2">&quot;aval&quot;</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">]</span>

  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>
  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span>
  <span class="nb">hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">literalable_types</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="n">val</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">):</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Literal(val=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">)&#39;</span>

<span class="n">literalable_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="n">Atom</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Literal</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Primitive</span><span class="p">:</span>
  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
  <span class="c1"># set for multi-output primitives.</span>
  <span class="n">multiple_results</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="c1"># set for call primitives processed in final style.</span>
  <span class="n">call_primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="c1"># set for map primitives processed in final style.</span>
  <span class="n">map_primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span> <span class="ow">or</span>
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">valid_jaxtype</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)),</span> <span class="n">args</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_with_trace</span><span class="p">(</span><span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">bind_with_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiple_results</span> <span class="k">else</span> <span class="n">full_lower</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">def_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impl</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">=</span> <span class="n">impl</span>
    <span class="k">return</span> <span class="n">impl</span>

  <span class="k">def</span> <span class="nf">def_abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abstract_eval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">abstract_eval</span> <span class="o">=</span> <span class="n">_effect_free_abstract_eval</span><span class="p">(</span><span class="n">abstract_eval</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="k">return</span> <span class="n">abstract_eval</span>

  <span class="k">def</span> <span class="nf">def_effectful_abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">effectful_abstract_eval</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">abstract_eval</span> <span class="o">=</span> <span class="n">effectful_abstract_eval</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="k">return</span> <span class="n">effectful_abstract_eval</span>

  <span class="k">def</span> <span class="nf">def_custom_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">bind</span>
    <span class="k">return</span> <span class="n">bind</span>

  <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Evaluation rule for &#39;</span><span class="si">{}</span><span class="s2">&#39; not implemented&quot;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">abstract_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Abstract evaluation for &#39;</span><span class="si">{}</span><span class="s2">&#39; not implemented&quot;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[],</span> <span class="n">params</span>


<span class="k">def</span> <span class="nf">_effect_free_abstract_eval</span><span class="p">(</span><span class="n">abstract_eval</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">abstract_eval_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">no_effects</span>
  <span class="k">return</span> <span class="n">abstract_eval_</span>

<span class="c1"># -------------------- lifting --------------------</span>

<span class="c1"># TODO(mattjj): replace this approach with a primitive-keyed table of rules</span>
<span class="k">def</span> <span class="nf">traverse_jaxpr_params</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Applies f to each jaxpr parameter and returns a tuple of returned values.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
          <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">param</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">param</span><span class="p">])</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)}</span>


<span class="k">def</span> <span class="nf">eval_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">typecheck</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

  <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">:</span>
    <span class="n">subfuns</span><span class="p">,</span> <span class="n">bind_params</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">get_bind_params</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">name_stack</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current_name_stack</span><span class="p">()</span> <span class="o">+</span> <span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">name_stack</span>
    <span class="k">with</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">user_context</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">traceback</span><span class="p">,</span> <span class="n">name_stack</span><span class="o">=</span><span class="n">name_stack</span><span class="p">):</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">subfuns</span><span class="p">,</span> <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">),</span> <span class="o">**</span><span class="n">bind_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">multiple_results</span><span class="p">:</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">write</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ans</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>


<span class="c1"># -------------------- tracing --------------------</span>


<span class="k">class</span> <span class="nc">Trace</span><span class="p">:</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="s1">&#39;sublevel&#39;</span><span class="p">]</span>

  <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">sublevel</span><span class="p">:</span> <span class="n">Sublevel</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">,</span> <span class="n">sublevel</span><span class="p">:</span> <span class="n">Sublevel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">main</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">main</span><span class="o">.</span><span class="n">level</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">=</span> <span class="n">sublevel</span>

  <span class="k">def</span> <span class="nf">full_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tracer</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pure</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="o">.</span><span class="n">_assert_live</span><span class="p">()</span>
    <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>
    <span class="n">sublevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span>
    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">==</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
      <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">&lt;</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t lift sublevels </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">sublevel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">sublevel</span> <span class="o">&gt;</span> <span class="n">sublevel</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Incompatible sublevel: </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">sublevel</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
          <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t lift level </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># val._trace.level == self.level:</span>
      <span class="k">raise</span> <span class="n">escaped_tracer_error</span><span class="p">(</span>
          <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Different traces at same level: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">lift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sublift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(level=</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sublevel</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_call to handle call-like &quot;</span>
           <span class="s2">&quot;primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_map to handle map-like &quot;</span>
           <span class="s2">&quot;primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_jvp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">jvp</span><span class="p">,</span> <span class="n">tracers</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_jvp_call &quot;</span>
           <span class="s2">&quot;to handle custom_jvp primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_transpose &quot;</span>
           <span class="s2">&quot;to handle custom_transpose_call primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_vjp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">out_trees</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> must override process_custom_vjp_call &quot;</span>
           <span class="s2">&quot;to handle custom_vjp primitives&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">raise_as_much_as_possible</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tracer</span><span class="p">:</span>
  <span class="c1"># Find effective bottom of trace stack (highest dynamic Trace on the stack).</span>
  <span class="n">trace_stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">stack</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace_stack</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span>
             <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="c1"># Only pay attention to effective part of trace stack.</span>
  <span class="n">trace_stack</span> <span class="o">=</span> <span class="n">trace_stack</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>

  <span class="c1"># Lift tracer into everything in the effective stack higher than its level</span>
  <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">trace_stack</span><span class="p">:</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tracer</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">trace</span><span class="o">.</span><span class="n">level</span><span class="p">):</span>
      <span class="n">tracer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">tracer</span>


<span class="k">def</span> <span class="nf">escaped_tracer_error</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">num_frames</span> <span class="o">=</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_tracer_error_num_traceback_frames</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Encountered an unexpected tracer. A function transformed by JAX &#39;</span>
         <span class="s1">&#39;had a side effect, allowing for a reference to an intermediate value &#39;</span>
         <span class="sa">f</span><span class="s1">&#39;with type </span><span class="si">{</span><span class="n">tracer</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">str_short</span><span class="p">()</span><span class="si">}</span><span class="s1"> wrapped in a &#39;</span>
         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tracer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> to escape the scope of the transformation.</span><span class="se">\n</span><span class="s1">&#39;</span>
         <span class="s1">&#39;JAX transformations require that functions explicitly return their &#39;</span>
         <span class="s1">&#39;outputs, and disallow saving intermediate values to global state.&#39;</span><span class="p">)</span>
  <span class="n">dbg</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="s1">&#39;_debug_info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dbg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The function being traced when the value leaked was &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dbg</span><span class="o">.</span><span class="n">func_src_info</span><span class="si">}</span><span class="s1"> traced for </span><span class="si">{</span><span class="n">dbg</span><span class="o">.</span><span class="n">traced_for</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
  <span class="n">line_info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="s1">&#39;_line_info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">line_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">30</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;The leaked intermediate value was created on line &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">line_info</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span>
    <span class="k">if</span> <span class="n">num_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;When the value was created, the final </span><span class="si">{</span><span class="n">num_frames</span><span class="si">}</span><span class="s1"> stack &#39;</span>
              <span class="s1">&#39;frames (most recent last) excluding JAX-internal frames were:&#39;</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="n">divider</span> <span class="o">+</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span>
          <span class="n">line_info</span><span class="p">,</span> <span class="n">num_frames</span><span class="o">=</span><span class="n">num_frames</span><span class="p">)</span> <span class="o">+</span> <span class="n">divider</span>
  <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">To catch the leak earlier, try setting the environment variable &#39;</span>
          <span class="s1">&#39;JAX_CHECK_TRACER_LEAKS or using the `jax.checking_leaks` context &#39;</span>
          <span class="s1">&#39;manager.&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">detail</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Detail: </span><span class="si">{</span><span class="n">detail</span><span class="si">}</span><span class="s1">&#39;</span>
  <span class="k">return</span> <span class="n">UnexpectedTracerError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Tracer</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
  <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1000</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_trace&#39;</span><span class="p">,</span> <span class="s1">&#39;_line_info&#39;</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">TracerArrayConversionError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__dlpack__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
      <span class="sa">f</span><span class="s2">&quot;The __dlpack__() method was called on the JAX Tracer object </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">TracerIntegerConversionError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="n">Trace</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>

  <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

  <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">at</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">aval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">_assert_live</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Override for liveness checking</span>

  <span class="k">def</span> <span class="nf">get_referent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># Override for object equivalence checking</span>

  <span class="c1"># Python looks up special methods only on classes, not instances. This means</span>
  <span class="c1"># these methods needs to be defined explicitly rather than relying on</span>
  <span class="c1"># __getattr__.</span>
  <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_ne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_radd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rdiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_truediv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rtruediv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_floordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rfloordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_divmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rdivmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rpow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rmatmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_ror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rxor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_lshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rlshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_rrshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_int</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__long__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_long</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__hex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_hex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__oct__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_oct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">)</span>

  <span class="c1"># raises a useful error on attempts to pickle a Tracer.</span>
  <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;The error occurred in the __reduce__ method, which may &quot;</span>
             <span class="s2">&quot;indicate an attempt to serialize/pickle a traced value.&quot;</span><span class="p">))</span>

  <span class="c1"># raises the better error message from ShapedArray</span>
  <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

  <span class="c1"># NumPy also only looks up special methods on classes.</span>
  <span class="k">def</span> <span class="nf">__array_module__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">_array_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># if the aval property raises an AttributeError, gets caught here</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;aval&quot;</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">aval_property</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">aval_method</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attr</span>

  <span class="k">def</span> <span class="nf">_pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Traced&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s1">&gt;with&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace</span><span class="si">}</span><span class="s1">&gt;&#39;</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">_pretty_print</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span>
                 <span class="k">else</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">attr</span><span class="p">)))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contents</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">contents</span><span class="p">:</span>
      <span class="n">base</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39; with&#39;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span>
          <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> = &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_payload</span>
          <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pp_payload</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">])</span>
      <span class="p">])))</span>
    <span class="k">return</span> <span class="n">base</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pretty_print</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">_contents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">()</span>

  <span class="k">def</span> <span class="nf">_origin_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="c1"># these can be used to set up forwarding of properties and instance methods from</span>
<span class="c1"># Tracer instances to the underlying avals</span>
<span class="n">aval_property</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;aval_property&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fget&quot;</span><span class="p">])</span>
<span class="n">aval_method</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;aval_method&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">EvalTrace</span><span class="p">(</span><span class="n">Trace</span><span class="p">):</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="k">def</span> <span class="nf">pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
  <span class="n">lift</span> <span class="o">=</span> <span class="n">sublift</span> <span class="o">=</span> <span class="n">pure</span>

  <span class="k">def</span> <span class="nf">process_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">primitive</span><span class="o">.</span><span class="n">impl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="n">process_map</span> <span class="o">=</span> <span class="n">process_call</span>

  <span class="k">def</span> <span class="nf">process_custom_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">primitive</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">call</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_jvp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">jvp</span><span class="p">,</span> <span class="n">tracers</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">jvp</span>  <span class="c1"># Unused.</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">fun</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process_custom_vjp_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">bwd</span>  <span class="c1"># Unused.</span>
    <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
      <span class="k">return</span> <span class="n">fun</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">tracers</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MainTrace</span><span class="p">:</span>
  <span class="n">level</span><span class="p">:</span> <span class="nb">int</span>
  <span class="n">trace_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Trace</span><span class="p">]</span>
  <span class="n">payload</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span> <span class="o">=</span> <span class="n">trace_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MainTrace(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">trace_type</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">payload</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">with_cur_sublevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_sublevel</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TraceStack</span><span class="p">:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">]</span>
  <span class="n">dynamic</span><span class="p">:</span> <span class="n">MainTrace</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">eval_trace</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_trace</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">eval_trace</span>

  <span class="k">def</span> <span class="nf">next_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_trace</span><span class="p">:</span> <span class="n">MainTrace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main_trace</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">stack_str</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Trace stack</span><span class="se">\n</span><span class="si">{</span><span class="n">stack_str</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">TraceStack</span><span class="p">)</span>
    <span class="n">new</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[:]</span>
    <span class="n">new</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Sublevel</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Sublevel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span>

  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Sublevel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span>


<span class="n">AxisEnvFrame</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;AxisEnvFrame&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;main_trace&#39;</span><span class="p">])</span>
<span class="n">AxisName</span> <span class="o">=</span> <span class="n">Hashable</span>

<span class="n">no_axis_name</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">TraceState</span><span class="p">:</span>
  <span class="n">trace_stack</span><span class="p">:</span> <span class="n">TraceStack</span>
  <span class="n">substack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Sublevel</span><span class="p">]</span>
  <span class="n">axis_env</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AxisEnvFrame</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_stack</span> <span class="o">=</span> <span class="n">TraceStack</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">substack</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sublevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">TraceState</span><span class="p">)</span>
    <span class="n">new</span><span class="o">.</span><span class="n">trace_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new</span><span class="o">.</span><span class="n">substack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substack</span><span class="p">[:]</span>
    <span class="n">new</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_env</span><span class="p">[:]</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">dynamic</span><span class="p">):</span>
  <span class="c1"># Copies the MainTrace instance, removing any .debug_info or .jaxpr_stack</span>
  <span class="c1"># fields that should not be kept alive as part of a cache key.</span>
  <span class="c1"># TODO(mattjj): split debug_info and jaxpr_stack out of MainTrace.</span>
  <span class="c1"># TODO(mattjj): add a test that verifies that JIT-ted functions are not kept</span>
  <span class="c1"># alive by the JIT cache, particularly for nested JIT-ted functions.</span>
  <span class="n">copy</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">dynamic</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">dynamic</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span><span class="n">dynamic_trace_state</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="c1"># The global state of the tracer is accessed by a thread-local object.</span>
<span class="c1"># This allows concurrent tracing in separate threads; passing traced objects</span>
<span class="c1"># between threads is forbidden.</span>
<span class="k">class</span> <span class="nc">ThreadLocalState</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trace_state</span> <span class="o">=</span> <span class="n">TraceState</span><span class="p">()</span>

<span class="n">thread_local_state</span> <span class="o">=</span> <span class="n">ThreadLocalState</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_initialize_jax_jit_thread_local_state</span><span class="p">():</span>
  <span class="sd">&quot;&quot;&quot;Initializes the C++ thread-local context.</span>

<span class="sd">  When the user spawns threads, the C++ `jax_jit.thread_local_state` is None.</span>
<span class="sd">  The C++ accessor calls this function if it realizes the thread_local_state</span>
<span class="sd">  is None (which means it&#39;s not yet initialized for this thread).</span>

<span class="sd">  This function does not live in `config.py`, to prevent circular imports.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">tls</span> <span class="o">=</span> <span class="n">jax_jit</span><span class="o">.</span><span class="n">thread_local_state</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">tls</span><span class="o">.</span><span class="n">extra_jit_context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">dynamic</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">dynamic</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">tls</span><span class="o">.</span><span class="n">extra_jit_context</span> <span class="o">=</span> <span class="n">jax_config</span><span class="o">.</span><span class="n">_ThreadLocalExtraJitContext</span><span class="p">(</span>
        <span class="n">dynamic_trace_state</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="n">jax_jit</span><span class="o">.</span><span class="n">set_thread_local_state_initialization_callback</span><span class="p">(</span>
    <span class="n">_initialize_jax_jit_thread_local_state</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">trace_state_clean</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="n">trace_state</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span> <span class="o">==</span> <span class="p">[</span><span class="n">Sublevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">stack</span> <span class="o">==</span> <span class="p">[</span><span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">)]</span> <span class="ow">and</span>
          <span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">==</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EvalTrace</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">reset_trace_state</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Resets the global trace state and returns True if it was already clean.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">trace_state_clean</span><span class="p">():</span>
    <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">cur_sublevel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Sublevel</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">TRACER_LEAK_DEBUGGER_WARNING</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">JAX check_tracer_leaks behavior can trigger false positives when used with a debugger.</span>
<span class="s2">To avoid false positives and silence this warning, you can disable thread tracing using</span>
<span class="s2">the following:</span>

<span class="s2">  import threading</span>
<span class="s2">  threading.current_thread().pydev_do_not_trace = True</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">,</span> <span class="n">Sublevel</span><span class="p">]]</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tracer</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Find the leaked tracers holding a reference to the MainTrace or SubLevel.</span>

<span class="sd">  It&#39;s possible there&#39;s none! eg. there&#39;s some cases where JAX itself holds a</span>
<span class="sd">  reference to `x` inside of a lambda closure, and no tracers were leaked</span>
<span class="sd">  by the user. In this case an empty list is returned.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">(),</span> <span class="s1">&#39;pydev_do_not_trace&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">TRACER_LEAK_DEBUGGER_WARNING</span><span class="p">)</span>
  <span class="c1"># Trigger garbage collection to filter out cyclical dependency false positives</span>
  <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
  <span class="n">traces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Trace</span><span class="p">),</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">),</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="o">*</span><span class="n">traces</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">tracers</span>

<span class="k">def</span> <span class="nf">leaked_tracer_error</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tracers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tracer</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="ne">Exception</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">tracers</span>
  <span class="n">msgs</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tracer</span><span class="si">}{</span><span class="n">tracer</span><span class="o">.</span><span class="n">_origin_msg</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">tracer</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">)</span>
  <span class="k">return</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Leaked </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">. Leaked tracer(s):</span><span class="se">\n\n</span><span class="si">{</span><span class="n">msgs</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Trace</span><span class="p">],</span>
             <span class="n">dynamic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span>
  <span class="n">level</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">next_level</span><span class="p">()</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dynamic</span><span class="p">:</span>
    <span class="n">prev_dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">main</span>
    <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dynamic</span><span class="p">:</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">prev_dynamic</span>
      <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_check_tracer_leaks</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">main</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span> <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_base_main</span><span class="p">(</span><span class="n">trace_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Trace</span><span class="p">],</span>
                  <span class="o">**</span><span class="n">payload</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">MainTrace</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="c1"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="n">stack</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span>
  <span class="n">main</span> <span class="o">=</span> <span class="n">MainTrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace_type</span><span class="p">,</span> <span class="o">**</span><span class="n">payload</span><span class="p">)</span>
  <span class="n">prev_dynamic</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">main</span>
  <span class="n">prev_base</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main</span>
  <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">main</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="n">prev_dynamic</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_base</span>
    <span class="n">_update_thread_local_jit_state</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">dynamic</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_check_tracer_leaks</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">main</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span> <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<div class="viewcode-block" id="ensure_compile_time_eval"><a class="viewcode-back" href="../../_autosummary/jax.ensure_compile_time_eval.html#jax.core.ensure_compile_time_eval">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">ensure_compile_time_eval</span><span class="p">():</span>
  <span class="sd">&quot;&quot;&quot;Context manager to ensure evaluation at trace/compile time (or error).</span>

<span class="sd">  Some JAX APIs like ``jax.jit`` and ``jax.lax.scan`` involve staging, i.e.</span>
<span class="sd">  delaying the evaluation of numerical expressions (like jax.numpy function</span>
<span class="sd">  applications) so that instead of performing those computations eagerly while</span>
<span class="sd">  evaluating the corresponding Python expressions, their computation is carried</span>
<span class="sd">  out separately, e.g. after optimized compilation. But this delay can be</span>
<span class="sd">  undesirable. For example, numerical values might be needed to evaluate Python</span>
<span class="sd">  control flow and so their evaluation cannot be delayed. As another example, it</span>
<span class="sd">  may be beneficial to ensure compile time evaluation (or &quot;constant folding&quot;)</span>
<span class="sd">  for performance reasons.</span>

<span class="sd">  This context manager ensures that JAX computations are evaluated eagerly. If</span>
<span class="sd">  eager evaluation is not possible, a ``ConcretizationError`` is raised.</span>

<span class="sd">  Here&#39;s a contrived example::</span>

<span class="sd">    import jax</span>
<span class="sd">    import jax.numpy as jnp</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def f(x):</span>
<span class="sd">      with jax.ensure_compile_time_eval():</span>
<span class="sd">        y = jnp.sin(3.0)</span>
<span class="sd">        z = jnp.sin(y)</span>
<span class="sd">        z_positive = z &gt; 0</span>
<span class="sd">      if z_positive:  # z_positive is usable in Python control flow</span>
<span class="sd">        return jnp.sin(x)</span>
<span class="sd">      else:</span>
<span class="sd">        return jnp.cos(x)</span>

<span class="sd">  Here&#39;s a real-world example from https://github.com/google/jax/issues/3974::</span>

<span class="sd">    import jax</span>
<span class="sd">    import jax.numpy as jnp</span>
<span class="sd">    from jax import random</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def jax_fn(x):</span>
<span class="sd">      with jax.ensure_compile_time_eval():</span>
<span class="sd">        y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100)</span>
<span class="sd">      y2 = y @ y</span>
<span class="sd">      x2 = jnp.sum(y2) * x</span>
<span class="sd">      return x2</span>

<span class="sd">  A similar behavior can often be achieved simply by &#39;hoisting&#39; the constant</span>
<span class="sd">  expression out of the corresponding staging API::</span>

<span class="sd">    y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100)</span>

<span class="sd">    @jax.jit</span>
<span class="sd">    def jax_fn(x):</span>
<span class="sd">      y2 = y @ y</span>
<span class="sd">      x2 = jnp.sum(y2)*x</span>
<span class="sd">      return x2</span>

<span class="sd">  But in some cases it can be more convenient to use this context manager.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">new_base_main</span><span class="p">(</span><span class="n">EvalTrace</span><span class="p">):</span>
    <span class="k">yield</span></div>
<span class="n">eval_context</span> <span class="o">=</span> <span class="n">ensure_compile_time_eval</span>  <span class="c1"># alias, backward compatibility</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">new_sublevel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
  <span class="n">sublevel</span> <span class="o">=</span> <span class="n">Sublevel</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="p">))</span>
  <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sublevel</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">substack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_check_tracer_leaks</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">sublevel</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">sublevel</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">leaked_tracers</span> <span class="o">=</span> <span class="n">maybe_find_leaked_tracers</span><span class="p">(</span><span class="n">t</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">leaked_tracers</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">leaked_tracer_error</span><span class="p">(</span><span class="s2">&quot;sublevel&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">(),</span> <span class="n">leaked_tracers</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">full_lower</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">full_lower</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">def</span> <span class="nf">find_top_trace</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trace</span><span class="p">:</span>
  <span class="n">top_tracer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)),</span>
                    <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;_trace.level&#39;</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">top_tracer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">top_tracer</span><span class="o">.</span><span class="n">_assert_live</span><span class="p">()</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="n">top_tracer</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">top_main</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
  <span class="n">dynamic</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">trace_stack</span><span class="o">.</span><span class="n">dynamic</span>
  <span class="n">top_main</span> <span class="o">=</span> <span class="p">(</span><span class="n">dynamic</span> <span class="k">if</span> <span class="n">top_main</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">top_main</span><span class="o">.</span><span class="n">level</span>
              <span class="k">else</span> <span class="n">top_main</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">top_main</span> <span class="ow">and</span> <span class="n">top_main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>  <span class="c1"># type: ignore</span>

<span class="k">def</span> <span class="nf">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">get_referent</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">same_referent</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dedup_referents</span><span class="p">(</span><span class="n">itr</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
  <span class="k">return</span> <span class="nb">list</span><span class="p">({</span><span class="n">HashableWrapper</span><span class="p">(</span><span class="n">get_referent</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itr</span><span class="p">}</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="c1"># -------------------- abstract values --------------------</span>

<span class="k">class</span> <span class="nc">AbstractValue</span><span class="p">:</span>
  <span class="vm">__slots__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">kv_pairs</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
      <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kv_pairs</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

  <span class="k">def</span> <span class="nf">strip_weak_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>

  <span class="k">def</span> <span class="nf">strip_named_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must override&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="c1"># For type signatures involving dynamic shapes, we use lists of abstract values</span>
<span class="c1"># which may contain (reverse) de Bruijn indices in their shapes.</span>
<span class="k">class</span> <span class="nc">DBIdx</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">InDBIdx</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">OutDBIdx</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># For annotating input types of callables (i.e. linear_util.WrappedFuns), we use</span>
<span class="c1"># a sequence of pairs where the first element of each pair is an AbstractValue</span>
<span class="c1"># (possibly containing DBIdx instances in its shape) and the second is a boolean</span>
<span class="c1"># indicating whether that argument is explicit (i.e. passed to the callable).</span>
<span class="n">InputType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># DBIdx in shapes</span>

<span class="c1"># For annotating jaxpr output types, we use a sequence of pairs where the first</span>
<span class="c1"># element of each pair is an AbstractValue (possibly containing InDBIdx and/or</span>
<span class="c1"># OutDBIdx instances in its shape) and the second is a boolean indicating</span>
<span class="c1"># whether that argument is explicit (i.e. returned by the callable).</span>
<span class="n">OutputType</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># InDBIdx / OutDBIdx shapes</span>


<span class="k">def</span> <span class="nf">_jaxpr_type_to_callable_annotation</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputType</span><span class="p">:</span>
  <span class="n">idxs</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">DBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="o">*</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">))}</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
          <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bot</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span> <span class="k">pass</span>
<span class="n">bot</span> <span class="o">=</span> <span class="n">Bot</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">lattice_join</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">],</span>
                 <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="c1"># TODO(mattjj): remove this special case after dynamic shapes are integrated</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># For use in typing annotations to denote either a Tracer or a `valid_jaxtype`.</span>
<span class="n">Value</span> <span class="o">=</span> <span class="n">Any</span>

<span class="k">def</span> <span class="nf">valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">check_valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_jaxtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s2">&quot;Value </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not a valid JAX type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">pytype_aval_mappings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">handler</span><span class="p">:</span> <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">())</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> with type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not a valid JAX &quot;</span>
                   <span class="s2">&quot;type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concrete_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concretization_function_error</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">suggest_astype</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="n">fname_context</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The problem arose with the `</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">` function. &quot;</span>
  <span class="k">if</span> <span class="n">suggest_astype</span><span class="p">:</span>
    <span class="n">fname_context</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;If trying to convert the data type of a value, &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;try using `x.astype(</span><span class="si">{</span><span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)` &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;or `jnp.array(x, </span><span class="si">{</span><span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)` instead.&quot;</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fname_context</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">error</span>

<span class="k">def</span> <span class="nf">concrete_or_error</span><span class="p">(</span><span class="n">force</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Like force(val), but gives the context in the error message.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">force</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ConcreteArray</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">force</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">ConcretizationTypeError</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">force</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="c1"># TODO(frostig,mattjj): achieve this w/ a protocol instead of registry?</span>

<span class="n">opaque_dtypes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># TODO(frostig): update inliners of the four functions below to call them</span>
<span class="k">def</span> <span class="nf">has_opaque_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_opaque_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="n">opaque_dtypes</span>

<span class="k">def</span> <span class="nf">_short_dtype_name</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="n">opaque_dtypes</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;uint&#39;</span>   <span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">)</span>
                      <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;int&#39;</span>  <span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtype</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="n">opaque_dtypes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UnshapedArray</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;weak_type&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">4</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="c1"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="c1"># the unique character code via hash(self.dtype.char)</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">str_short</span><span class="p">(),</span>
                             <span class="s2">&quot;, weak_type=True&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

  <span class="n">_bool</span> <span class="o">=</span> <span class="n">_nonzero</span> <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
  <span class="n">_float</span>   <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_int</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_complex</span> <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_hex</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>
  <span class="n">_oct</span>     <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">oct</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>

  <span class="k">def</span> <span class="nf">strip_weak_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a copy of the aval with weak_type=False.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;UnshapedArray has no shape. Please open an issue at &quot;</span>
           <span class="s2">&quot;https://github.com/google/jax/issues because it&#39;s unexpected for &quot;</span>
           <span class="s2">&quot;UnshapedArray instances to ever be produced.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ShapedArray</span><span class="p">(</span><span class="n">UnshapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;named_shape&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">2</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">named_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">if</span> <span class="n">named_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="p">)</span>

  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

  <span class="n">broadcast</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">aval_method</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">transpose</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">aval_method</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">reshape</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">aval_method</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">_iter</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">staticmethod</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="c1"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="c1"># the unique character code via hash(self.dtype.char)</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span>
                 <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="n">join_named_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">dt_str</span> <span class="o">=</span>  <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="n">shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">:</span>
      <span class="n">named_shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">;</span><span class="si">{</span><span class="n">named_shapestr</span><span class="si">}</span><span class="s1">]&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">]&#39;</span>

  <span class="k">def</span> <span class="nf">strip_named_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="p">{})</span>

  <span class="k">def</span> <span class="nf">_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignored_tracer</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;len() of unsized object&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>  <span class="c1"># same as numpy error</span>


<span class="k">def</span> <span class="nf">_forward_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">ignored_tracer</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ConcreteArray</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span>
        <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weak_type</span><span class="p">)</span>
    <span class="c1"># Note: canonicalized self.dtype doesn&#39;t necessarily match self.val</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">),</span> <span class="n">val</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span>
    <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">ConcreteArray</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span>
        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">):</span>
      <span class="k">with</span> <span class="n">eval_context</span><span class="p">():</span>  <span class="c1"># in case self.val is a DeviceArray</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="n">named_shape</span> <span class="o">=</span> <span class="n">join_named_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">,</span> <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">weak_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">dt_str</span> <span class="o">=</span>  <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">short_dtypes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s1">, dtype=</span><span class="si">{</span><span class="n">dt_str</span><span class="si">}</span><span class="s1">&#39;</span>

  <span class="n">_bool</span> <span class="o">=</span> <span class="n">_nonzero</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="n">_int</span>             <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">_hex</span>             <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">hex</span><span class="p">)</span>
  <span class="n">_oct</span>             <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">_forward_to_value</span><span class="p">,</span> <span class="nb">oct</span><span class="p">)</span>

  <span class="n">_float</span>           <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">_complex</span>         <span class="o">=</span> <span class="n">concretization_function_error</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">):</span>
  <span class="c1"># TODO(frostig,mattjj): determines that all opaque dtypes have</span>
  <span class="c1"># float0 tangent type, which works fine for all our current opaque</span>
  <span class="c1"># dtype applications. We may some day want to delegate this</span>
  <span class="c1"># decision to the dtype rules.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">)</span> <span class="ow">or</span>
      <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">primal_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_dtype</span>


<span class="c1"># Dynamic shape stuff below here! We keep the abstract values distinct just so</span>
<span class="c1"># as not to interfere with any static shape machinery.</span>

<span class="c1"># We have a convention of reusing AbsractValues as types, even though we could</span>
<span class="c1"># make a distinction and use abstract values during tracing only. This reuse</span>
<span class="c1"># becomes a bit more extreme with DShapedArrays. A DShapedArray&#39;s shape</span>
<span class="c1"># attribute is a tuple which can contain several different types: int, BInt,</span>
<span class="c1"># Tracer (while tracing), Var (when used as jaxpr type annotations), or</span>
<span class="c1"># DBIdx/InDBIdx/OutDBIdx (when used in InputType or OutputType). We could reduce</span>
<span class="c1"># this polymorphism if it seems cleaner, though it&#39;s kind of convenient!</span>
<span class="n">AxisSize</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;BInt&#39;</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">DBIdx</span><span class="p">,</span> <span class="n">InDBIdx</span><span class="p">,</span> <span class="n">OutDBIdx</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">DShapedArray</span><span class="p">(</span><span class="n">UnshapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
  <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">AxisSize</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># noqa: F821</span>
  <span class="n">array_abstraction_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">=</span> <span class="n">weak_type</span>

  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">short_dtypes</span>  <span class="c1"># ignored</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">]&#39;</span>
  <span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">str_short</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span>
    <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
      <span class="n">weak_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">weak_type</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">UnshapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DConcreteArray</span><span class="p">(</span><span class="n">DShapedArray</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="n">array_abstraction_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>


<span class="n">pytype_aval_mappings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">AbstractValue</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># TODO(mattjj): remove this, replace with arrays of bints</span>
<span class="k">class</span> <span class="nc">AbstractBInt</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bound&#39;</span><span class="p">]</span>
  <span class="n">bound</span><span class="p">:</span> <span class="nb">int</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;bint</span><span class="se">{{</span><span class="s1">â‰¤</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="si">}</span><span class="se">}}</span><span class="s1">[]&#39;</span>
  <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">str_short</span>
  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">AbstractBInt</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span>
  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">))</span>
  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># should return float0 array</span>
  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">BInt</span><span class="p">:</span>
  <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>  <span class="c1"># Union[int, Array]</span>
  <span class="n">bound</span><span class="p">:</span> <span class="nb">int</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bound</span><span class="p">):</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">bound</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="se">{{</span><span class="s1">â‰¤</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span>
  <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BInt</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">))</span>
  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">))</span>
<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">BInt</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">AbstractBInt</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>


<span class="c1"># DShapedArray w/ BInt in shapes =&gt; PaddedArray runtime representation</span>
<span class="k">class</span> <span class="nc">PaddedArray</span><span class="p">:</span>
  <span class="n">_aval</span><span class="p">:</span> <span class="n">DShapedArray</span>
  <span class="n">_data</span><span class="p">:</span> <span class="n">Any</span>  <span class="c1"># standard array type</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">padded_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">bound</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">BInt</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">padded_shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">dtypestr</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">shapestr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">BInt</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtypestr</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">shapestr</span><span class="si">}</span><span class="s1">] with value:</span><span class="se">\n</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">PaddedArray</span><span class="p">]</span> <span class="o">=</span> \
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">DConcreteArray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span>
                             <span class="n">x</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AbstractToken</span><span class="p">(</span><span class="n">AbstractValue</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractToken</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Cannot join </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">def</span> <span class="nf">str_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short_dtypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;Tok&#39;</span>
  <span class="k">def</span> <span class="nf">at_least_vspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
<span class="n">abstract_token</span><span class="p">:</span> <span class="n">AbstractToken</span> <span class="o">=</span> <span class="n">AbstractToken</span><span class="p">()</span>

<span class="c1"># Concrete token object</span>
<span class="k">class</span> <span class="nc">Token</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">token</span><span class="p">:</span> <span class="n">Token</span> <span class="o">=</span> <span class="n">Token</span><span class="p">()</span>
<span class="n">pytype_aval_mappings</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">abstract_token</span>


<span class="k">def</span> <span class="nf">raise_to_shaped</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">aval_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">aval_type</span> <span class="ow">is</span> <span class="n">ShapedArray</span> <span class="ow">and</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">if</span> <span class="n">weak_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weak_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;weak_type&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">aval_type</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">raise_to_shaped_mappings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">handler</span><span class="p">:</span> <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">))</span>

<span class="n">raise_to_shaped_mappings</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">AbstractBInt</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">AbstractToken</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">Bot</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">UnshapedArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">aval</span><span class="p">,</span>
  <span class="n">ShapedArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">(</span>
      <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">),</span>
  <span class="n">DConcreteArray</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">aval</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">(</span>
      <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1">### Operations on shapes and dimension sizes.</span>

<span class="k">class</span> <span class="nc">InconclusiveDimensionOperation</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Raised when we cannot conclusively compute with symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="k">pass</span>

<span class="k">class</span> <span class="nc">DimensionHandler</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Operations on dimension sizes.</span>

<span class="sd">  Dimension sizes are normally integer constants, but can also be symbolic,</span>
<span class="sd">  e.g., masking.Poly or jax2tf.shape_poly.DimVar.</span>

<span class="sd">  The base class works for integers only. Subclasses are invoked when at least</span>
<span class="sd">  one of the operands has a type registered in _SPECIAL_DIMENSION_HANDLERS. In</span>
<span class="sd">  that case, all operands are guaranteed to be either the special dimension</span>
<span class="sd">  type, or Python integer scalars.</span>

<span class="sd">  Subclasses should raise InconclusiveDimensionOperation if the result cannot</span>
<span class="sd">  be computed in some contexts.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The dimension is a constant.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">symbolic_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;True iff the dimension sizes are equal in all contexts; False otherwise.</span>
<span class="sd">    Unlike `d1 == d2` this never raises InconclusiveDimensionOperation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span>

  <span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes `d1 &gt;= d2`.</span>
<span class="sd">    Raise InconclusiveDimensionOperation if the result is different in</span>
<span class="sd">    different contexts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">d1</span> <span class="o">&gt;=</span> <span class="n">d2</span>

  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ds</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sum of dimensions.</span>
<span class="sd">    Raises InconclusiveDimensionOperation if the result cannot be represented</span>
<span class="sd">    by the same DimSize in all contexts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Difference of dimensions.</span>
<span class="sd">    Raises InconclusiveDimensionOperation if the result cannot be represented</span>
<span class="sd">    by the same DimSize in all contexts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>

  <span class="k">def</span> <span class="nf">divide_shape_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes integer &quot;i&quot; such that i  * size(s2) == size(s1).</span>

<span class="sd">    Raise InconclusiveDimensionOperation if there is no such integer for all</span>
<span class="sd">    contexts,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sz1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
    <span class="n">sz2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">sz1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sz2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">sz1</span> <span class="o">%</span> <span class="n">sz2</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">InconclusiveDimensionOperation</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot divide evenly the sizes of shapes </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sz1</span> <span class="o">//</span> <span class="n">sz2</span>

  <span class="k">def</span> <span class="nf">stride</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;(d - window_size) // window_stride + 1.</span>

<span class="sd">    If d == 0 or window_size &gt; d, returns 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">window_size</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">window_stride</span> <span class="o">+</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="nf">dilate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Implements `0 if d == 0 else 1 + dilation * (d - 1))`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dilation</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">as_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turns a dimension size into a JAX value that we can compute with.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">d</span>

<span class="n">_dimension_handler_int</span> <span class="o">=</span> <span class="n">DimensionHandler</span><span class="p">()</span>
<span class="n">_SPECIAL_DIMENSION_HANDLERS</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">DimensionHandler</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">_get_special_dim_handler</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DimensionHandler</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">_SPECIAL_DIMENSION_HANDLERS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_dim_handler_and_canonical</span><span class="p">(</span><span class="o">*</span><span class="n">dlist</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DimensionHandler</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DimSize</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
  <span class="sd">&quot;&quot;&quot;Finds the handler for the given dimensions; also returns the canonical dimensions.</span>

<span class="sd">  A dimension is canonical if it is a Python integer scalar, or has a type</span>
<span class="sd">  registered in _SPECIAL_DIMENSION_HANDLERS.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">special_handlers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="n">canonical</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlist</span><span class="p">:</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">_get_special_dim_handler</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">handler</span><span class="p">:</span>
      <span class="n">special_handlers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
      <span class="n">canonical</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">canonical</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
      <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">_invalid_shape_error</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">special_handlers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension size operation involves multiple special dimension types </span><span class="si">{</span><span class="n">dlist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">special_handlers</span><span class="p">),</span> <span class="n">_dimension_handler_int</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">canonical</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_special_dim_size</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Checks if a value is a special DimSize.&quot;&quot;&quot;</span>
  <span class="n">handler</span> <span class="o">=</span> <span class="n">_get_special_dim_handler</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">symbolic_equal_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">d1</span> <span class="ow">is</span> <span class="n">d2</span> <span class="ow">or</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">get_referent</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">symbolic_equal</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">symbolic_equal_one_of_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dlist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DimSize</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d1</span> <span class="ow">is</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlist</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># identical always implies equal</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="o">*</span><span class="n">dlist</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">handler</span><span class="o">.</span><span class="n">symbolic_equal</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

<span class="k">def</span> <span class="nf">symbolic_equal_shape</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">all</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">symbolic_equal_dim</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">greater_equal_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">symbolic_equal</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span> <span class="ow">or</span> <span class="n">handler</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">greater_equal_shape</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">greater_equal_dim</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sum_dim</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sum_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sum_dim</span><span class="p">,</span> <span class="o">*</span><span class="n">ss</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">diff_dim</span><span class="p">(</span><span class="n">d1</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">diff_shape</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">diff_dim</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">divide_shape_sizes</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Returns an integer &quot;i&quot; s.t., i * size(s2) == size(s1).</span>
<span class="sd">  Raises if there is no such integer.&quot;&quot;&quot;</span>
  <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
  <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">divide_shape_sizes</span><span class="p">(</span><span class="n">ds</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)],</span> <span class="n">ds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">):])</span>

<span class="k">def</span> <span class="nf">same_shape_sizes</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">divide_shape_sizes</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_empty_shape</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dilate_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dilation</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Implements `0 if d == 0 else 1 + dilation * (d - 1))`&quot;&quot;&quot;</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dilation</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dilate_shape</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">dilations</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dilate_dim</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">dilations</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">stride_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">stride</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">stride_shape</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;(s - window_size) // window_stride + 1&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">stride_dim</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">window_stride</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">dimension_as_value</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Turns a dimension size into a JAX value that we can compute with.</span>
<span class="sd">     This is the identity function for constant dimensions.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">):</span> <span class="k">return</span> <span class="n">d</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">_dim_handler_and_canonical</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">handler</span><span class="o">.</span><span class="n">as_value</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_canonicalize_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dim</span>
  <span class="k">elif</span> <span class="n">is_special_dim_size</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dim</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape value.</span>

<span class="sd">  Args:</span>
<span class="sd">    shape: a Python value that represents a shape.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A tuple of canonical dimension values.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">_canonicalize_dimension</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">pass</span>
  <span class="k">raise</span> <span class="n">_invalid_shape_error</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">canonicalize_dim</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DimSize</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape dimension value.</span>

<span class="sd">  Args:</span>
<span class="sd">    f: a Python value that represents a dimension.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A canonical dimension value.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">canonicalize_shape</span><span class="p">((</span><span class="n">d</span><span class="p">,),</span> <span class="n">context</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_invalid_shape_error</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Shapes must be 1D sequences of concrete values of integer type, &quot;</span>
         <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">.&quot;</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ShapedArray</span><span class="p">)</span>
         <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ConcreteArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">If using `jit`, try using `static_argnums` or applying `jit` to &quot;</span>
            <span class="s2">&quot;smaller subfunctions.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BIntDimensionHandler</span><span class="p">(</span><span class="n">DimensionHandler</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">symbolic_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">BInt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d1</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">d2</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">d1</span><span class="o">.</span><span class="n">bound</span> <span class="o">==</span> <span class="n">d2</span><span class="o">.</span><span class="n">bound</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BInt</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">BInt</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">InconclusiveDimensionOperation</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">d</span><span class="o">.</span><span class="n">bound</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="n">InconclusiveDimensionOperation</span>
    <span class="k">return</span> <span class="n">BInt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">),</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">fail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span> <span class="k">raise</span> <span class="n">InconclusiveDimensionOperation</span>
  <span class="n">great_equal</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">divide_shape_sizes</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">dilate</span> <span class="o">=</span> <span class="n">as_value</span> <span class="o">=</span> <span class="n">fail</span>
<span class="n">_SPECIAL_DIMENSION_HANDLERS</span><span class="p">[</span><span class="n">BInt</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIntDimensionHandler</span><span class="p">()</span>



<span class="c1"># ------------------- Named shapes -------------------</span>


<span class="k">class</span> <span class="nc">NamedShape</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># TODO: Assert that kwargs match axis env?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__named</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">positional_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">named_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">:</span> <span class="n">total</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">values</span><span class="p">():</span> <span class="n">total</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">total</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># TODO(mattjj,frostig): revise not to miss commas</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">))</span><span class="si">}{</span><span class="s1">&#39;, &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NamedShape</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__named</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__named</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__positional</span> <span class="o">==</span> <span class="n">other</span>
    <span class="k">return</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">named</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__named</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__positional</span><span class="p">,</span> <span class="n">named</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">join_named_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">named_shapes</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">named_shape</span> <span class="ow">in</span> <span class="n">named_shapes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">named_shape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axis name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> used with inconsistent sizes: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="c1"># TODO: Make canonicalize_shape return named shapes?</span>
<span class="k">def</span> <span class="nf">as_named_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedShape</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">NamedShape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">shape</span>
  <span class="k">return</span> <span class="n">NamedShape</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>


<span class="c1"># ------------------- Call -------------------</span>

<span class="k">class</span> <span class="nc">CallPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">call_primitive</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">call_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">hashable_partial</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">),</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
      <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">subfun</span><span class="p">,</span> <span class="n">_jaxpr_type_to_callable_annotation</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>

<span class="k">def</span> <span class="nf">call_bind</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">CallPrimitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">fun_</span><span class="p">,</span> <span class="n">env_trace_todo</span> <span class="o">=</span> <span class="n">process_env_traces_call</span><span class="p">(</span>
      <span class="n">fun</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">top_trace</span> <span class="ow">and</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">top_trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">fun_</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">fun_</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="n">in_type</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">process_call</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">fun_</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">apply_todos</span><span class="p">(</span><span class="n">env_trace_todo</span><span class="p">(),</span> <span class="n">outs</span><span class="p">))</span>

<span class="nd">@lu</span><span class="o">.</span><span class="n">transformation_with_aux</span>
<span class="k">def</span> <span class="nf">process_env_traces_call</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">CallPrimitive</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                            <span class="n">params_tuple</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">args</span><span class="p">,</span> <span class="p">{}</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params_tuple</span><span class="p">)</span>
  <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span>
               <span class="ow">and</span> <span class="p">(</span><span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">tracers</span><span class="p">:</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tracers</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">,</span> <span class="n">cur_todo</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">post_process_call</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_todo</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">outs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span>  <span class="c1"># Ensure the aux output is immutable</span>

<span class="k">def</span> <span class="nf">apply_todos</span><span class="p">(</span><span class="n">todos</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
  <span class="n">todos_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">todos</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">todos_list</span><span class="p">:</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">todos_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()(</span><span class="n">outs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">outs</span>


<span class="k">def</span> <span class="nf">call_impl</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">lu</span><span class="o">.</span><span class="n">WrappedFun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">params</span>  <span class="c1"># params parameterize the call primitive, not the function</span>
  <span class="k">with</span> <span class="n">new_sublevel</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">call_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">call_p</span><span class="p">:</span> <span class="n">CallPrimitive</span> <span class="o">=</span> <span class="n">CallPrimitive</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">call_p</span><span class="o">.</span><span class="n">bind</span>
<span class="n">call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">call_impl</span><span class="p">)</span>

<span class="n">named_call_p</span><span class="p">:</span> <span class="n">CallPrimitive</span> <span class="o">=</span> <span class="n">CallPrimitive</span><span class="p">(</span><span class="s1">&#39;named_call&#39;</span><span class="p">)</span>
<span class="n">named_call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">call_impl</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ClosedCallPrimitive</span><span class="p">(</span><span class="n">CallPrimitive</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>

<span class="n">closed_call_p</span><span class="p">:</span> <span class="n">ClosedCallPrimitive</span> <span class="o">=</span> <span class="n">ClosedCallPrimitive</span><span class="p">(</span><span class="s1">&#39;closed_call&#39;</span><span class="p">)</span>
<span class="n">closed_call_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">call_impl</span><span class="p">)</span>


<span class="n">outfeed_primitives</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Primitive</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Finds if there are outfeed primitives anywhere inside a Jaxpr.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">primitive_uses_outfeed</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_param_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Jaxpr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ClosedJaxpr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">jaxpr_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">primitive_uses_outfeed</span><span class="p">(</span><span class="n">prim</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">outfeed_primitives</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">unsafe_map</span><span class="p">(</span><span class="n">_param_uses_outfeed</span><span class="p">,</span> <span class="n">param</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">_param_uses_outfeed</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># ------------------- Map -------------------</span>

<span class="k">class</span> <span class="nc">MapPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">map_primitive</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;in_axes&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">map_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">post_process_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">get_bind_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call_jaxpr&#39;</span><span class="p">)</span>
    <span class="n">subfun</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">hashable_partial</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">eval_jaxpr</span><span class="p">),</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="p">())</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;out_axes&#39;</span><span class="p">)</span>
    <span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;out_axes_thunk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HashableFunction</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">axes</span><span class="p">,</span> <span class="n">closure</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">subfun</span><span class="p">],</span> <span class="n">new_params</span>

<span class="k">def</span> <span class="nf">map_bind</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">MapPrimitive</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">out_axes_thunk</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="c1"># The new thunk depends deterministically on the old thunk and the wrapped</span>
  <span class="c1"># function. Any caching already has to include the wrapped function as part</span>
  <span class="c1"># of the key, so we only use the previous thunk for equality checks.</span>
  <span class="nd">@as_hashable_function</span><span class="p">(</span><span class="n">closure</span><span class="o">=</span><span class="n">out_axes_thunk</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">new_out_axes_thunk</span><span class="p">():</span>
    <span class="n">out_axes</span> <span class="o">=</span> <span class="n">out_axes_thunk</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">out_axes_transforms</span> <span class="o">=</span> <span class="n">todo_and_xforms</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_axes_transforms</span><span class="p">:</span>
      <span class="n">out_axes</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">out_axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_axes</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">out_axes_thunk</span><span class="o">=</span><span class="n">new_out_axes_thunk</span><span class="p">)</span>
  <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">fun</span><span class="p">,</span> <span class="n">todo_and_xforms</span> <span class="o">=</span> <span class="n">process_env_traces_map</span><span class="p">(</span>
      <span class="n">fun</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">top_trace</span> <span class="ow">and</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
  <span class="n">tracers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">top_trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">primitive</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">tracers</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">env_trace_todo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">todo_and_xforms</span><span class="p">()</span>
  <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">full_lower</span><span class="p">,</span> <span class="n">apply_todos</span><span class="p">(</span><span class="n">env_trace_todo</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>

<span class="nd">@lu</span><span class="o">.</span><span class="n">transformation_with_aux</span>
<span class="k">def</span> <span class="nf">process_env_traces_map</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">MapPrimitive</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">params_tuple</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">args</span><span class="p">,</span> <span class="p">{}</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params_tuple</span><span class="p">)</span>
  <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">out_axes_transforms</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">tracers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tracer</span><span class="p">)</span>
               <span class="ow">and</span> <span class="p">(</span><span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">tracers</span><span class="p">:</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tracers</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="n">_trace</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">()</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">full_raise</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">,</span> <span class="p">(</span><span class="n">cur_todo</span><span class="p">,</span> <span class="n">cur_xform</span><span class="p">)</span> <span class="o">=</span> <span class="n">primitive</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_todo</span><span class="p">)</span>
    <span class="n">out_axes_transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_xform</span><span class="p">)</span>
  <span class="k">yield</span> <span class="n">outs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">todo</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_axes_transforms</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">mapped_aval</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="n">handler</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aval_mapping_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no mapping handler for </span><span class="si">{</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unmapped_aval</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                  <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractValue</span><span class="p">:</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">aval_mapping_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no unmapping handler for </span><span class="si">{</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_map_shaped_array</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">size</span>
  <span class="c1"># TODO: Extend the named shape</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">tuple_delete</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                     <span class="n">named_shape</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unmap_shaped_array</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                        <span class="n">aval</span><span class="p">:</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapedArray</span><span class="p">:</span>
  <span class="n">named_shape</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="c1"># TODO: Make this mandatory</span>
  <span class="n">named_shape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">tuple_insert</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                     <span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_map_dshaped_array</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                       <span class="n">aval</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">tuple_delete</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                      <span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unmap_dshaped_array</span><span class="p">(</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">AxisSize</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">aval</span><span class="p">:</span> <span class="n">DShapedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DShapedArray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">aval</span>
  <span class="k">return</span> <span class="n">DShapedArray</span><span class="p">(</span><span class="n">tuple_insert</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                      <span class="n">weak_type</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="n">AvalMapHandlerPair</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>
<span class="n">aval_mapping_handlers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">AvalMapHandlerPair</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">DShapedArray</span><span class="p">:</span>   <span class="p">(</span><span class="n">_map_dshaped_array</span><span class="p">,</span> <span class="n">_unmap_dshaped_array</span><span class="p">),</span>
    <span class="n">ShapedArray</span><span class="p">:</span>   <span class="p">(</span><span class="n">_map_shaped_array</span><span class="p">,</span> <span class="n">_unmap_shaped_array</span><span class="p">),</span>
    <span class="n">ConcreteArray</span><span class="p">:</span> <span class="p">(</span><span class="n">_map_shaped_array</span><span class="p">,</span> <span class="n">_unmap_shaped_array</span><span class="p">),</span>
    <span class="n">AbstractToken</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">___</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">extend_axis_env</span><span class="p">(</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">AxisName</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
  <span class="n">frame</span> <span class="o">=</span> <span class="n">AxisEnvFrame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
  <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
      <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                           <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">extend_axis_env_nd</span><span class="p">(</span><span class="n">axes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">AxisName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]):</span>
  <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">AxisEnvFrame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
  <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
      <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                           <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">stash_axis_env</span><span class="p">():</span>
  <span class="s2">&quot;Promise that a function or with-suite does not depend implicitly on axis env&quot;</span>
  <span class="c1"># If the promise is broken, then a NameError about an unbound axis name will</span>
  <span class="c1"># be raised.</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span>
  <span class="n">prev_axis_env</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span><span class="p">,</span> <span class="p">[]</span>
  <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span><span class="n">axis_env_state</span><span class="o">=</span><span class="p">())</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">yield</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span> <span class="o">=</span> <span class="n">prev_axis_env</span>
    <span class="n">jax_config</span><span class="o">.</span><span class="n">update_thread_local_jit_state</span><span class="p">(</span>
        <span class="n">axis_env_state</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">axis_env</span>
                             <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_axis_name</span><span class="p">))</span>


<span class="c1"># When a mapped function is given no axis name, we generate a name object based</span>
<span class="c1"># on the id of the function object. Collisions aren&#39;t important because this</span>
<span class="c1"># name can&#39;t be used in collectives, as user code never gets a ref to this</span>
<span class="c1"># object. We don&#39;t want to use the function object itself because that might</span>
<span class="c1"># persist references to the function object.</span>
<span class="c1"># TODO(mattjj): revisit this unique axis name strategy</span>
<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">_TempAxisName</span><span class="p">:</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;axis </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt;&#39;</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">_TempAxisName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>

  <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">_TempAxisName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>


<span class="k">def</span> <span class="nf">axis_frame</span><span class="p">(</span><span class="n">axis_name</span><span class="p">):</span>
  <span class="n">frames</span> <span class="o">=</span> <span class="n">thread_local_state</span><span class="o">.</span><span class="n">trace_state</span><span class="o">.</span><span class="n">axis_env</span>
  <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">axis_name</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">frame</span>
  <span class="n">named_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_TempAxisName</span><span class="p">)]</span>
  <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
      <span class="sa">f</span><span class="s1">&#39;unbound axis name: </span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s1">. The following axis names (e.g. defined &#39;</span>
      <span class="sa">f</span><span class="s1">&#39;by pmap) are available to collective operations: </span><span class="si">{</span><span class="n">named_axes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="n">ParamDict</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="n">AxisSubst</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AxisName</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">AxisName</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>

<span class="k">class</span> <span class="nc">NameGatheringSubst</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">axis_name</span><span class="p">,)</span>

<span class="k">def</span> <span class="nf">used_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">ParamDict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">AxisName</span><span class="p">]:</span>
  <span class="n">subst</span> <span class="o">=</span> <span class="n">NameGatheringSubst</span><span class="p">()</span>
  <span class="n">subst_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">subst</span><span class="o">.</span><span class="n">axis_names</span>

<span class="k">def</span> <span class="nf">subst_axis_names</span><span class="p">(</span><span class="n">primitive</span><span class="p">:</span> <span class="n">Primitive</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">ParamDict</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">traverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDict</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">primitive</span> <span class="ow">in</span> <span class="n">axis_substitution_rules</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">axis_substitution_rules</span><span class="p">[</span><span class="n">primitive</span><span class="p">](</span><span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">traverse</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">traverse</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">params</span>
  <span class="c1"># Default implementation: substitute names in all jaxpr parameters</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primitive</span><span class="p">,</span> <span class="n">MapPrimitive</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">shadowed_subst</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;axis_name&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">subst</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shadowed_subst</span> <span class="o">=</span> <span class="n">subst</span>
  <span class="n">jaxpr_params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">jaxpr_params</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">params</span>
  <span class="n">new_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">jaxpr</span> <span class="ow">in</span> <span class="n">jaxpr_params</span><span class="p">:</span>
    <span class="n">new_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">shadowed_subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_params</span>

<span class="k">class</span> <span class="nc">DuplicateAxisNameError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">var</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eqn</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Var</span><span class="p">:</span>
  <span class="c1"># Var identity is load-bearing, so we can&#39;t have duplicates!</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">):</span> <span class="k">return</span> <span class="n">v</span>
  <span class="k">assert</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_map</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="s1">&#39;named_shape&#39;</span><span class="p">):</span>
    <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">v</span>
  <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">subst</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">named_shape</span><span class="p">))</span>
  <span class="n">named_shape</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">axis_frame</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">named_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">DuplicateAxisNameError</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">new_v</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">suffix</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_shape</span><span class="o">=</span><span class="n">named_shape</span><span class="p">))</span>
  <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v</span>
  <span class="k">return</span> <span class="n">new_v</span>

<span class="k">def</span> <span class="nf">subst_axis_names_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">:</span> <span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">JaxprEqn</span><span class="p">:</span>
  <span class="n">invars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">outvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="k">except</span> <span class="n">DuplicateAxisNameError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">e</span><span class="o">.</span><span class="n">eqn</span> <span class="o">=</span> <span class="n">eqn</span>
    <span class="k">raise</span>
  <span class="n">params</span> <span class="o">=</span> <span class="n">subst_axis_names</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eqn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">invars</span><span class="o">=</span><span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="o">=</span><span class="n">outvars</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">do_subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">],</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">):</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
    <span class="n">consts</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">consts</span>
    <span class="n">jaxpr</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">jaxpr</span>
  <span class="n">var_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">invars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">]</span>
  <span class="n">constvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">]</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">subst_axis_names_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">subst</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span> <span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">]</span>
  <span class="n">outvars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Literal</span><span class="p">)</span> <span class="k">else</span> <span class="n">var_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="n">new_jaxpr</span> <span class="o">=</span> <span class="n">Jaxpr</span><span class="p">(</span><span class="n">constvars</span><span class="p">,</span> <span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span><span class="p">,</span> <span class="n">eqns</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">consts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">new_jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_jaxpr</span>

<span class="nd">@weakref_lru_cache</span>
<span class="k">def</span> <span class="nf">used_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">]):</span>
  <span class="n">subst</span> <span class="o">=</span> <span class="n">NameGatheringSubst</span><span class="p">()</span>
  <span class="n">do_subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">subst</span><span class="o">.</span><span class="n">axis_names</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">],</span> <span class="n">subst</span><span class="p">:</span> <span class="n">AxisSubst</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subst</span><span class="p">,</span> <span class="n">NameGatheringSubst</span><span class="p">):</span>  <span class="c1"># This is a common case, so we optimize it!</span>
    <span class="n">subst</span><span class="o">.</span><span class="n">axis_names</span> <span class="o">|=</span> <span class="n">used_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jaxpr</span>
  <span class="k">return</span> <span class="n">do_subst_axis_names_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>


<span class="n">axis_substitution_rules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParamDict</span><span class="p">,</span> <span class="n">AxisSubst</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">ParamDict</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># ------------------- AxisPrimitive -------------------</span>
<span class="c1"># Primitives that store axis names in params and want those axis names to</span>
<span class="c1"># participate in dispatch should subclass AxisPrimitive.</span>

<span class="k">class</span> <span class="nc">AxisPrimitive</span><span class="p">(</span><span class="n">Primitive</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
    <span class="n">top_trace</span> <span class="o">=</span> <span class="n">find_top_trace</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">axis_main</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">axis_frame</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">main_trace</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">used_axis_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)),</span>
                    <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">top_trace</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_trace</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">axis_main</span> <span class="ow">or</span> <span class="n">axis_main</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">top_trace</span><span class="o">.</span><span class="n">level</span>
                 <span class="k">else</span> <span class="n">axis_main</span><span class="o">.</span><span class="n">with_cur_sublevel</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_with_trace</span><span class="p">(</span><span class="n">top_trace</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="c1"># ------------------- Jaxpr checking -------------------</span>

<span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">typecompat</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Determine whether `aval` conforms to `aval_ref`.</span>

<span class="sd">  Ignores weak_type and named_shape, other than to check that an axis name isn&#39;t</span>
<span class="sd">  used with different sizes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">typematch</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">,</span> <span class="n">lattice_join</span><span class="p">(</span><span class="n">aval_ref</span><span class="p">,</span> <span class="n">aval</span><span class="p">))</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">typematch</span><span class="p">(</span><span class="n">aval1</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">aval2</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Determine whether `aval1` and `aval2` are equivalent.</span>

<span class="sd">  Ignores weak_type and named_shape, other than to check that an axis name isn&#39;t</span>
<span class="sd">  used with different sizes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">aval1</span> <span class="o">==</span> <span class="n">aval2</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="c1"># unequal avals may still represent the same type, because type is represented</span>
  <span class="c1"># by avals at the shaped level, and because weak type tags and (for now) named</span>
  <span class="c1"># shape components aren&#39;t considered part of the type</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval1</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval2</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
    <span class="c1"># a bonus check for whether any named axes have inconsistent sizes</span>
    <span class="n">join_named_shapes</span><span class="p">(</span><span class="n">aval1</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">aval2</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval1</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">strip_named_shape</span><span class="p">()</span> <span class="o">==</span>
          <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">aval2</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">strip_named_shape</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">JaxprTypeError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">custom_typechecks</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">_check_closed_call</span><span class="p">(</span><span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">):</span>
  <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_avals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">in_avals</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Closed call in_avals mismatch&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">out_avals</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span>
<span class="n">custom_typechecks</span><span class="p">[</span><span class="n">closed_call_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_closed_call</span>

<span class="k">def</span> <span class="nf">check_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checks well-formedness of a jaxpr.</span>

<span class="sd">  Specifically, check that:</span>
<span class="sd">  - variables that are read are bound beforehand</span>
<span class="sd">  - variables are typed equally throughout a jaxpr</span>
<span class="sd">  - variable type annotations are compatible with their binding expression</span>

<span class="sd">  Raises `JaxprTypeError` if `jaxpr` is determined invalid. Returns `None`</span>
<span class="sd">  otherwise.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">ctx_factory</span><span class="p">():</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">JaxprPpContext</span><span class="p">()</span>
    <span class="n">pp_settings</span> <span class="o">=</span> <span class="n">JaxprPpSettings</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span><span class="p">)</span>  <span class="c1"># side-effect on ctx, build variable names</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">return</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">)</span>
  <span class="k">except</span> <span class="n">JaxprTypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">msg</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">jaxpr_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span> <span class="n">eqnidx</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span>
                                         <span class="n">pp_settings</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span><span class="p">,</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">jaxpr_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pp_settings</span><span class="p">))</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;while checking jaxpr:&quot;</span><span class="p">,</span> <span class="n">jaxpr_str</span><span class="p">])</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">_check_jaxpr</span><span class="p">(</span>
    <span class="n">ctx_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">]],</span>
    <span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="c1"># Use set of variables to types to check that variables are in scope.</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
    <span class="c1"># Check the type annotation is itself well-typed.</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
      <span class="c1"># Check the variable is in-scope and consistently typed.</span>
      <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; not defined&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
      <span class="c1"># Check that the literal matches its type annotation.</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">typecheck</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Literal value </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> does not match its type annotation &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;syntactically invalid jaxpr&quot;</span>

  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Var</span><span class="p">),</span> <span class="s2">&quot;syntactically invalid jaxpr&quot;</span>
    <span class="c1"># Check the type annotation of the binder is itself well-typed.</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="c1"># Check that the variable is not already bound.</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; already bound&quot;</span><span class="p">)</span>
    <span class="c1"># Check that the computed type is consistent with the binder annotation.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typematch</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;Value for variable &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; inconsistently typed &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;as </span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2"> for let-binder of type </span><span class="si">{</span><span class="n">pp_aval</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># If the variable is not a DropVar, add it to the environment.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">):</span>
      <span class="n">env</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

  <span class="c1"># Check type annotations on lambda binders.</span>
  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">):</span>
    <span class="n">check_type</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
    <span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>

  <span class="c1"># Check each eqn.</span>
  <span class="k">for</span> <span class="n">eqn_idx</span><span class="p">,</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">):</span>
    <span class="n">prim</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">in_atoms</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span>
      <span class="n">in_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>  <span class="c1"># use in_atoms for dyn shapes</span>

      <span class="c1"># Compute the type of the primitive application.</span>
      <span class="k">if</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">custom_typechecks</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">custom_typechecks</span><span class="p">[</span><span class="n">prim</span><span class="p">](</span><span class="o">*</span><span class="n">in_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">prim</span><span class="o">.</span><span class="n">call_primitive</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">_check_call</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">prim</span><span class="o">.</span><span class="n">map_primitive</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">_check_map</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">out_type</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">check_eqn</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

      <span class="c1"># Check the computed effect type matches the eqn&#39;s annotation, and is</span>
      <span class="c1"># included in the jaxpr&#39;s annotation.</span>
      <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">effects</span> <span class="o">!=</span> <span class="n">effects</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Inferred effects do not match equation effects. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Equation effects: </span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Jaxpr effects: </span><span class="si">{</span><span class="n">effects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="s2">&quot;Equation effects are not subset of Jaxpr effects. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Equation effects: </span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Jaxpr effects: </span><span class="si">{</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

      <span class="c1"># Check out_type matches the let-binders&#39; annotation (after substitution).</span>
      <span class="n">out_type</span> <span class="o">=</span> <span class="n">substitute_vars_in_output_ty</span><span class="p">(</span><span class="n">out_type</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>
      <span class="nb">map</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">out_type</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">JaxprTypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="n">ctx</span><span class="p">,</span> <span class="n">settings</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
      <span class="n">msg</span><span class="p">,</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
      <span class="n">src</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;in equation:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">settings</span><span class="p">))),</span>
                         <span class="sa">f</span><span class="s2">&quot;from source: </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">eqn_idx</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

  <span class="c1"># TODO(mattjj): include output type annotation on jaxpr and check it here</span>
  <span class="nb">map</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">check_type</span><span class="p">(</span>
    <span class="n">ctx_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">]],</span>
    <span class="n">env</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
    <span class="n">ty</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ty</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
    <span class="c1"># Check all elements in the shape tuple are well-typed.</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ty</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">BInt</span><span class="p">)):</span>
        <span class="k">continue</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
          <span class="n">ctx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ctx_factory</span><span class="p">()</span>
          <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unbound axis size: &#39;</span><span class="si">{</span><span class="n">pp_var</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="n">AbstractBInt</span><span class="p">)):</span>
          <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size with unexpected type annotation: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
          <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span>
          <span class="k">if</span> <span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size nonscalar: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis size with non-integer dtype: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected type in shape: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span>  <span class="c1"># Except in above case(s), all syntactic forms are valid</span>

<span class="k">def</span> <span class="nf">substitute_vars_in_output_ty</span><span class="p">(</span>
    <span class="n">out_type</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">],</span>  <span class="c1"># shapes may contain InDBIdx / OutDBIdx</span>
    <span class="n">in_atoms</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Atom</span><span class="p">],</span>
    <span class="n">out_binders</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Var</span><span class="p">],</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractValue</span><span class="p">]:</span>  <span class="c1"># shapes may contain Vars</span>
  <span class="n">in_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Literal</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">in_atoms</span><span class="p">]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">out_type</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_atoms</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">InDBIdx</span> <span class="k">else</span>  <span class="c1"># type: ignore</span>
               <span class="n">out_binders</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">OutDBIdx</span> <span class="k">else</span>  <span class="c1"># type: ignore</span>
               <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
      <span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">check_eqn</span><span class="p">(</span><span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">jaxpr</span> <span class="ow">in</span> <span class="n">jaxprs_in_params</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">check_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">)</span>

  <span class="n">out_avals</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">prim</span><span class="o">.</span><span class="n">abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">in_avals</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">prim</span><span class="o">.</span><span class="n">multiple_results</span><span class="p">:</span>
    <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_avals</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">effects</span>

<span class="k">def</span> <span class="nf">_check_call</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="s2">&quot;call_jaxpr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;call_jaxpr&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">]</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">in_atoms</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;operands cannot call jaxpr with &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs&quot;</span><span class="p">)</span>

  <span class="c1"># Check `call_jaxpr` can be applied to in_atoms.</span>
  <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
      <span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([</span><span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">]))</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">aval</span>
  <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">in_atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">substitute</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">):</span>
      <span class="c1"># TODO(mattjj): vars in error message are confusing b/c of Var.__repr__</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> passes operand </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> of type &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="si">}</span><span class="s2"> to jaxpr expecting type &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">substitute</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">env</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span>

  <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">)</span>

  <span class="n">invars</span><span class="p">,</span> <span class="n">outvars</span> <span class="o">=</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span>
  <span class="n">in_map</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span>  <span class="n">InDBIdx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span>  <span class="n">InDBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">invars</span><span class="p">)}</span>
  <span class="n">out_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="n">OutDBIdx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">OutDBIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outvars</span><span class="p">)</span>
                                  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span><span class="p">}</span>
  <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="n">out_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">in_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">out_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                                   <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
              <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DShapedArray</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">out_avals</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span>

<span class="k">def</span> <span class="nf">_check_map</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
  <span class="k">if</span> <span class="s2">&quot;call_jaxpr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;call_jaxpr&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">call_jaxpr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;call_jaxpr&quot;</span><span class="p">]</span>
  <span class="n">ordered_effects_</span> <span class="o">=</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span> <span class="o">&amp;</span> <span class="n">ordered_effects</span>
  <span class="k">if</span> <span class="n">ordered_effects_</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> mapping ordered effects: </span><span class="si">{</span><span class="n">ordered_effects_</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="s2">&quot;axis_size&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;axis_size&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">axis_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axis_size&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;axis_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;axis_name&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">axis_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axis_name&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;in_axes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;in_axes&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">in_axes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;in_axes&quot;</span><span class="p">]</span>
  <span class="k">if</span> <span class="s2">&quot;out_axes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> missing &#39;out_axes&#39; parameter&quot;</span><span class="p">)</span>
  <span class="n">out_axes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;out_axes&quot;</span><span class="p">]</span>

  <span class="n">binder_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">in_axis</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">in_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span>
                  <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_axis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">call_jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">in_axes</span><span class="p">)]</span>
  <span class="k">for</span> <span class="n">binder_aval</span><span class="p">,</span> <span class="n">in_aval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binder_avals</span><span class="p">,</span> <span class="n">in_avals</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typecompat</span><span class="p">(</span><span class="n">binder_aval</span><span class="p">,</span> <span class="n">in_aval</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">JaxprTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call primitive </span><span class="si">{</span><span class="n">prim</span><span class="si">}</span><span class="s2"> passes operand </span><span class="si">{</span><span class="n">in_aval</span><span class="si">}</span><span class="s2"> &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;to jaxpr expecting </span><span class="si">{</span><span class="n">binder_aval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">with</span> <span class="n">extend_axis_env</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;axis_name&#39;</span><span class="p">],</span> <span class="n">axis_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">_check_jaxpr</span><span class="p">(</span><span class="n">ctx_factory</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="p">)</span>

  <span class="n">mapped_out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">]</span>
  <span class="n">out_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">unmapped_aval</span><span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">out_axis</span><span class="p">,</span> <span class="n">aval</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">out_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">aval</span>
               <span class="k">for</span> <span class="n">aval</span><span class="p">,</span> <span class="n">out_axis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mapped_out_avals</span><span class="p">,</span> <span class="n">out_axes</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">call_jaxpr</span><span class="o">.</span><span class="n">effects</span>


<span class="c1"># ------------------- Jaxpr printed representation -------------------</span>


<span class="k">class</span> <span class="nc">JaxprPpSettings</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">print_shapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">source_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="n">name_stack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="n">custom_pp_eqn_rules</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># A JaxprPpContext allows us to globally uniquify variable names within nested</span>
<span class="c1"># Jaxprs.</span>
<span class="k">class</span> <span class="nc">JaxprPpContext</span><span class="p">:</span>
  <span class="n">var_ids</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="n">Var</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">var_ids</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="fm">__next__</span><span class="p">,</span> <span class="p">{})</span>


<span class="k">def</span> <span class="nf">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Var</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="n">DropVar</span><span class="p">)):</span> <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_encode_digits_alphabetic</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">var_ids</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">pp_aval</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AbstractValue</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">DShapedArray</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp_var</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Var</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_short_dtype_name</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">str_short</span><span class="p">(</span><span class="n">short_dtypes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_vars</span><span class="p">(</span><span class="n">vs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">print_shapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">print_shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()),</span> <span class="p">[</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span> <span class="o">+</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">type_annotation</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">pp_aval</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">context</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span>
      <span class="p">])</span>
    <span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()),</span>
              <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pp_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">])</span>
    <span class="p">))</span>

<span class="k">def</span> <span class="nf">pp_kv_pair</span><span class="p">(</span><span class="n">k</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxprs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Jaxpr</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">):</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">pp_v</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_v</span>

<span class="k">def</span> <span class="nf">pp_kv_pairs</span><span class="p">(</span><span class="n">kv_pairs</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">kv_pairs</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">nil</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">),</span>  <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="p">[</span><span class="n">pp_kv_pair</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kv_pairs</span><span class="p">])</span>
    <span class="p">]))</span>
    <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
  <span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">rule</span> <span class="o">=</span> <span class="n">pp_eqn_rules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="p">)</span>
  <span class="n">name_stack_annotation</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="o">.</span><span class="n">name_stack</span><span class="si">}</span><span class="s1">]&#39;</span> <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">name_stack</span> <span class="k">else</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">rule</span> <span class="ow">and</span> <span class="n">settings</span><span class="o">.</span><span class="n">custom_pp_eqn_rules</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">))</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">name_stack_annotation</span><span class="p">),</span>
         <span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">])</span>
<span class="n">CustomPpEqnRule</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">JaxprEqn</span><span class="p">,</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">JaxprPpSettings</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">]]</span>
<span class="n">pp_eqn_rules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">CustomPpEqnRule</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">pp_eqns</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span>
    <span class="p">[</span><span class="n">pp_eqn</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eqns</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_compact_eqn_should_include</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;branches&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)):</span> <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
      <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Jaxpr</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">str_eqn_compact</span><span class="p">(</span><span class="n">primitive_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="s2">&quot;Compact equation to string conversion used in HLO metadata.&quot;</span>
  <span class="n">kvs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="n">_compact_eqn_should_include</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">primitive_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">kvs</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kvs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">primitive_name</span>

<span class="k">def</span> <span class="nf">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
                      <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">constvars</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">constvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">invars</span> <span class="o">=</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">eqns_fn</span><span class="p">()</span>
  <span class="n">outvars</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">),</span> <span class="n">pp_vars</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;)&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">outvars</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;,)&quot;</span><span class="p">)])</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;{ &quot;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;lambda &quot;</span><span class="p">)),</span>
    <span class="n">constvars</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span> <span class="n">invars</span><span class="p">,</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;. &quot;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;let&quot;</span><span class="p">)),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">()</span> <span class="o">+</span> <span class="n">eqns</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">keyword</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;in &quot;</span><span class="p">)),</span> <span class="n">outvars</span>
  <span class="p">]))</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; }&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pp_jaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">eqns_fn</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">pp_eqns</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pp_jaxprs</span><span class="p">(</span><span class="n">jaxprs</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">jaxprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="o">.</span><span class="n">jaxpr</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">ClosedJaxpr</span><span class="p">)</span> <span class="k">else</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jaxprs</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">),</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
      <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(),</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pp_jaxpr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span> <span class="n">jaxprs</span><span class="p">))]</span>
    <span class="p">))</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
  <span class="p">)</span>


<span class="k">def</span> <span class="nf">pp_jaxpr_eqn_range</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">:</span> <span class="n">Jaxpr</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">JaxprPpContext</span><span class="p">,</span>
                       <span class="n">settings</span><span class="p">:</span> <span class="n">JaxprPpSettings</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Doc</span><span class="p">:</span>
  <span class="n">lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">hi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)))</span>
  <span class="n">eqns</span> <span class="o">=</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">eqns_fn</span><span class="p">():</span>
    <span class="n">pps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">lo</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
      <span class="n">pps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">map</span><span class="p">((</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">pp_eqn</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)),</span> <span class="n">eqns</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">hi</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jaxpr</span><span class="o">.</span><span class="n">eqns</span><span class="p">):</span>
        <span class="n">pps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">brk</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">),</span> <span class="n">pps</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pp_jaxpr_skeleton</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">eqns_fn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>


<span class="c1"># TODO(mattjj,frostig): remove these stubs, which are a temporary hack for</span>
<span class="c1"># google-internal type checking</span>
<span class="n">extract_call_jaxpr</span><span class="p">:</span> <span class="n">Callable</span>
<span class="n">eval_jaxpr_eqn</span><span class="p">:</span> <span class="n">Callable</span>
<span class="n">initial_to_final_param_rules</span><span class="p">:</span> <span class="n">Dict</span>
<span class="n">unit</span><span class="p">:</span> <span class="n">Any</span>
<span class="n">abstract_unit</span><span class="p">:</span> <span class="n">AbstractValue</span>
<span class="n">unitvar</span><span class="p">:</span> <span class="n">Var</span>
<span class="n">UnitVar</span><span class="p">:</span> <span class="n">Type</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      &copy; Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>