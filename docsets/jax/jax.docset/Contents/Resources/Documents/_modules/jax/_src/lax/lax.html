
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jax._src.lax.lax &#8212; JAX  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" href="../../../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../../_static/jax_logo_250px.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../installation.html">
   Installing JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/quickstart.html">
   JAX Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/thinking_in_jax.html">
   How to Think in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Common_Gotchas_in_JAX.html">
   ðŸ”ª JAX - The Sharp Bits ðŸ”ª
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jax-101/index.html">
   Tutorial: JAX 101
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/01-jax-basics.html">
     JAX As Accelerated NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/02-jitting.html">
     Just In Time Compilation with JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/03-vectorization.html">
     Automatic Vectorization in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/04-advanced-autodiff.html">
     Advanced Automatic Differentiation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/05-random-numbers.html">
     Pseudo Random Numbers in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/05.1-pytrees.html">
     Working with Pytrees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/06-parallelism.html">
     Parallel Evaluation in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/07-state.html">
     Stateful Computations in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax-101/08-pjit.html">
     Introduction to pjit
    </a>
   </li>
  </ul>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../debugging/index.html">
   Runtime value debugging in JAX
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/print_breakpoint.html">
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.print
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       jax.debug.breakpoint
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/checkify_guide.html">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       checkify
      </span>
     </code>
     transformation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../debugging/flags.html">
     JAX debugging flags
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../faq.html">
   JAX Frequently Asked Questions (FAQ)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../async_dispatch.html">
   Asynchronous dispatch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../aot.html">
   Ahead-of-time lowering and compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../jaxpr.html">
   Understanding Jaxprs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/convolutions.html">
   Convolutions in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../pytrees.html">
   Pytrees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../type_promotion.html">
   Type promotion semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../errors.html">
   JAX Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../transfer_guard.html">
   Transfer guard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../glossary.html">
   JAX Glossary of Terms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../changelog.html">
   Change log
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced JAX Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/autodiff_cookbook.html">
   The Autodiff Cookbook
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/vmapped_log_probs.html">
   Autobatching log-densities example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/neural_network_with_tfds_data.html">
   Training a Simple Neural Network, with tensorflow/datasets Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Custom_derivative_rules_for_Python_code.html">
   Custom derivative rules for JAX-transformable Python functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/How_JAX_primitives_work.html">
   How JAX primitives work
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Writing_custom_interpreters_in_Jax.html">
   Writing custom Jaxpr interpreters in JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/Neural_Network_and_Data_Loading.html">
   Training a Simple Neural Network, with PyTorch Data Loading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../notebooks/xmap_tutorial.html">
   Named axes and easy-to-revise parallelism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../multi_process.html">
   Using JAX in multi-host and multi-process environments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../api_compatibility.html">
   API compatibility
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../deprecation.html">
   Python and NumPy version support policy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../concurrency.html">
   Concurrency
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../gpu_memory_allocation.html">
   GPU memory allocation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../profiling.html">
   Profiling JAX programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../device_memory_profiling.html">
   Device Memory Profiling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../rank_promotion_warning.html">
   Rank promotion warning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Developer documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../contributing.html">
   Contributing to JAX
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../developer.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../jax_internal_api.html">
   Internal APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../../autodidax.html">
   Autodidax: JAX core from scratch
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jep/index.html">
   JAX Enhancement Proposals (JEPs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/263-prng.html">
     263: JAX PRNG Design
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/2026-custom-derivatives.html">
     2026: Custom JVP/VJP rules for JAX-transformable functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/4008-custom-vjp-update.html">
     4008: Custom VJP and `nondiff_argnums` update
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/4410-omnistaging.html">
     4410: Omnistaging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/9407-type-promotion.html">
     9407: Design of Type Promotion Semantics for JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/9419-jax-versioning.html">
     9419: Jax and Jaxlib versioning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/10657-sequencing-effects.html">
     10657: Sequencing side-effects in JAX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/11830-new-remat-checkpoint.html">
     11830: `jax.remat` / `jax.checkpoint` new implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jep/12049-type-annotations.html">
     12049: Type Annotation Roadmap for JAX
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../../jax.html">
   Public API: jax package
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.numpy.html">
     jax.numpy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.scipy.html">
     jax.scipy package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.config.html">
     JAX configuration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.debug.html">
     jax.debug package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.dlpack.html">
     jax.dlpack module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.distributed.html">
     jax.distributed module
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.example_libraries.html">
     jax.example_libraries package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.example_libraries.optimizers.html">
       jax.example_libraries.optimizers module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.example_libraries.stax.html">
       jax.example_libraries.stax module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.experimental.html">
     jax.experimental package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.checkify.html">
       jax.experimental.checkify module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.global_device_array.html">
       jax.experimental.global_device_array module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.host_callback.html">
       jax.experimental.host_callback module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.maps.html">
       jax.experimental.maps module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.pjit.html">
       jax.experimental.pjit module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.sparse.html">
       jax.experimental.sparse module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.experimental.jet.html">
       jax.experimental.jet module
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.flatten_util.html">
     jax.flatten_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.image.html">
     jax.image package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.lax.html">
     jax.lax package
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../../jax.nn.html">
     jax.nn package
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../../jax.nn.initializers.html">
       jax.nn.initializers package
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.ops.html">
     jax.ops package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.profiler.html">
     jax.profiler module
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.random.html">
     jax.random package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.stages.html">
     jax.stages package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.tree_util.html">
     jax.tree_util package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../../jax.lib.html">
     jax.lib package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/google/jax"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for jax._src.lax.lax</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span>
                    <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span> <span class="k">as</span> <span class="n">type_cast</span><span class="p">,</span> <span class="n">overload</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">ad_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">device_array</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dispatch</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">linear_util</span> <span class="k">as</span> <span class="n">lu</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">tree_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">source_info_util</span>
<span class="kn">from</span> <span class="nn">jax._src.config</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Primitive</span><span class="p">,</span> <span class="n">UnshapedArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">ConcreteArray</span><span class="p">,</span>
                      <span class="n">raise_to_shaped</span><span class="p">,</span> <span class="n">abstract_token</span><span class="p">,</span> <span class="n">canonicalize_shape</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.abstract_arrays</span> <span class="kn">import</span> <span class="n">array_types</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">partial_eval</span> <span class="k">as</span> <span class="n">pe</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">mlir</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">xla</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">pxla</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">ad</span>
<span class="kn">from</span> <span class="nn">jax.interpreters</span> <span class="kn">import</span> <span class="n">batching</span>
<span class="kn">import</span> <span class="nn">jax._src.pretty_printer</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">safe_zip</span><span class="p">,</span> <span class="n">safe_map</span><span class="p">,</span> <span class="n">canonicalize_axis</span><span class="p">,</span>
                           <span class="n">split_list</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax.tree_util</span> <span class="kn">import</span> <span class="n">tree_map</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">mlir_api_version</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">pytree</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_bridge</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_client</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir</span> <span class="kn">import</span> <span class="n">ir</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir.dialects</span> <span class="kn">import</span> <span class="n">chlo</span>
<span class="kn">from</span> <span class="nn">jax._src.lib.mlir.dialects</span> <span class="kn">import</span> <span class="n">mhlo</span>
<span class="kn">from</span> <span class="nn">jax._src.lax.utils</span> <span class="kn">import</span> <span class="p">(</span>
  <span class="n">_input_dtype</span><span class="p">,</span>
  <span class="n">standard_abstract_eval</span><span class="p">,</span>
  <span class="n">standard_multi_result_abstract_eval</span><span class="p">,</span>
  <span class="n">standard_named_shape_rule</span><span class="p">,</span>
  <span class="n">standard_primitive</span><span class="p">,</span>
  <span class="n">standard_translate</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">slicing</span>
<span class="kn">from</span> <span class="nn">jax._src.typing</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">Shape</span>

<span class="n">xb</span> <span class="o">=</span> <span class="n">xla_bridge</span>
<span class="n">xc</span> <span class="o">=</span> <span class="n">xla_client</span>
<span class="n">xops</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">ops</span>
<span class="n">xe</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">_xla</span>

<span class="n">_max</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">max</span>
<span class="n">_min</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">min</span>
<span class="n">_reduce</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="nb">map</span><span class="p">,</span> <span class="n">unsafe_map</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">,</span> <span class="nb">map</span>
<span class="nb">zip</span><span class="p">,</span> <span class="n">unsafe_zip</span> <span class="o">=</span> <span class="n">safe_zip</span><span class="p">,</span> <span class="nb">zip</span>

<span class="c1"># TODO(jakevdp): replace this with an isinstance() check when JEP 12049 is complete.</span>
<span class="k">def</span> <span class="nf">_is_array_or_tracer</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_array</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">array</span>  <span class="c1"># pylint: disable=g-import-not-at-top</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">ArrayImpl</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">device_array</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_validate_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Shape</span><span class="p">]):</span>
  <span class="k">def</span> <span class="nf">_check_static_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">):</span>
    <span class="n">checked</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">checked</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Only non-negative indices are allowed when broadcasting&quot;</span> \
            <span class="sa">f</span><span class="s2">&quot; static shapes, but got shape </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">assert</span> <span class="n">shapes</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="c1"># pass dynamic shapes through unchecked</span>
    <span class="k">return</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">_check_static_shape</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_try_broadcast_shapes</span><span class="p">(</span>
    <span class="n">shapes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">rank</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span> <span class="o">=</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">others</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># must have consistent rank</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">rank</span><span class="p">:</span> <span class="k">return</span> <span class="p">()</span>  <span class="c1"># scalar case</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">unsafe_zip</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">same_referent</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="c1"># if all axes are identical objects, the resulting size is the object</span>
      <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># if all dims are equal (or 1), the result is the non-1 size (or 1)</span>
      <span class="n">non_1s</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">non_1s</span><span class="p">:</span>
        <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">non_1s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_1s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_1s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns the shape that results from NumPy broadcasting of `shapes`.&quot;&quot;&quot;</span>
  <span class="c1"># NOTE: We have both cached and uncached versions to handle Tracers in shapes.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_broadcast_shapes_cached</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
  <span class="k">except</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_broadcast_shapes_uncached</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>

<span class="nd">@cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_broadcast_shapes_cached</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">_broadcast_shapes_uncached</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_broadcast_shapes_uncached</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
  <span class="n">_validate_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
  <span class="n">fst</span><span class="p">,</span> <span class="o">*</span><span class="n">rst</span> <span class="o">=</span> <span class="n">shapes</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">rst</span><span class="p">:</span> <span class="k">return</span> <span class="n">fst</span>

  <span class="c1"># First check if we need only rank promotion (and not singleton-broadcasting).</span>
  <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="n">_broadcast_ranks</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">fst</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">pass</span>

  <span class="c1"># Next try singleton-broadcasting, padding out ranks using singletons.</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">)</span>
  <span class="n">shape_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">]</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="n">_try_broadcast_shapes</span><span class="p">(</span><span class="n">shape_list</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">result_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incompatible shapes for broadcasting: shapes=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result_shape</span>

<span class="k">def</span> <span class="nf">_broadcast_ranks</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
    <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s1</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
  <span class="n">s1_</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">):]</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">s1_</span><span class="p">,</span> <span class="n">s1</span><span class="p">):</span> <span class="k">return</span> <span class="n">s2</span>
  <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span>

<span class="k">def</span> <span class="nf">_identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">_extract_tracers_dyn_shape</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">]]</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
  <span class="c1"># Given a sequence representing a shape, pull out Tracers, replacing with None</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="c1"># We must gate this behavior under a flag because otherwise the errors</span>
    <span class="c1"># raised are different (and have worse source provenance information).</span>
    <span class="n">dyn_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)]</span>
    <span class="n">static_shape</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">static_shape</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[],</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

<span class="k">def</span> <span class="nf">_merge_dyn_shape</span><span class="p">(</span>
    <span class="n">static_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">dyn_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
  <span class="c1"># Replace Nones in static_shape with elements of dyn_shape, in order</span>
  <span class="n">dyn_shape_it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">dyn_shape</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">dyn_shape_it</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">static_shape</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">dyn_shape_it</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">shape</span>

<span class="k">def</span> <span class="nf">_dyn_shape_staging_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">out_aval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">source_info</span> <span class="o">=</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current</span><span class="p">()</span>
  <span class="n">out_tracer</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">DynamicJaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">out_aval</span><span class="p">,</span> <span class="n">source_info</span><span class="p">)</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_jaxpr_eqn</span><span class="p">([</span><span class="n">trace</span><span class="o">.</span><span class="n">getvar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">makevar</span><span class="p">(</span><span class="n">out_tracer</span><span class="p">)],</span>
                         <span class="n">prim</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span><span class="p">,</span> <span class="n">source_info</span><span class="p">)</span>
  <span class="n">trace</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">add_eqn</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out_tracer</span>


<span class="c1">### traceables</span>

<div class="viewcode-block" id="neg"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.neg.html#jax.lax.neg">[docs]</a><span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise negation: :math:`-x`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">neg_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sign.html#jax.lax.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise sign.</span>

<span class="sd">  For floating-point inputs, returns</span>
<span class="sd">  :math:`\mathrm{sign}(x) = \begin{cases}</span>
<span class="sd">  -1 &amp; x &lt; 0\\</span>
<span class="sd">  -0 &amp; x = -0\\</span>
<span class="sd">  \mathit{NaN} &amp; x = \mathit{NaN}\\</span>
<span class="sd">  +0 &amp; x = +0\\</span>
<span class="sd">  1 &amp; x &gt; 0</span>
<span class="sd">  \end{cases}`</span>

<span class="sd">  For signed integer inputs, returns</span>
<span class="sd">  :math:`\mathrm{sign}(x) = \begin{cases}</span>
<span class="sd">  -1 &amp; x &lt; 0\\</span>
<span class="sd">  0 &amp; x = 0\\</span>
<span class="sd">  1 &amp; x &gt; 0</span>
<span class="sd">  \end{cases}`</span>

<span class="sd">  For complex inputs, returns the complex phase, i.e.</span>
<span class="sd">  :math:`\mathrm{sign}(x) = \frac{x}{|x|}`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">sign_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="nextafter"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.nextafter.html#jax.lax.nextafter">[docs]</a><span class="k">def</span> <span class="nf">nextafter</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the next representable value after `x1` in the direction of `x2`.</span>

<span class="sd">  Note that in some environments flush-denormal-to-zero semantics is used.</span>
<span class="sd">  This means that, around zero, this function returns strictly non-zero</span>
<span class="sd">  values which appear as zero in any operations. Consider this example::</span>

<span class="sd">    &gt;&gt;&gt; jnp.nextafter(0, 1)  # denormal numbers are representable</span>
<span class="sd">    DeviceArray(1.e-45, dtype=float32, weak_type=True)</span>
<span class="sd">    &gt;&gt;&gt; jnp.nextafter(0, 1) * 1  # but are flushed to zero</span>
<span class="sd">    DeviceArray(0., dtype=float32, weak_type=True)</span>

<span class="sd">  For the smallest usable (i.e. normal) float, use ``tiny`` of ``jnp.finfo``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">nextafter_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.floor.html#jax.lax.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise floor: :math:`\left\lfloor x \right\rfloor`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">floor_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.ceil.html#jax.lax.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise ceiling: :math:`\left\lceil x \right\rceil`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">ceil_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="RoundingMethod"><a class="viewcode-back" href="../../../../jax.lax.html#jax.lax.RoundingMethod">[docs]</a><span class="k">class</span> <span class="nc">RoundingMethod</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">IntEnum</span><span class="p">):</span>
  <span class="n">AWAY_FROM_ZERO</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">TO_NEAREST_EVEN</span> <span class="o">=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.round.html#jax.lax.round">[docs]</a><span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
          <span class="n">rounding_method</span><span class="p">:</span> <span class="n">RoundingMethod</span> <span class="o">=</span> <span class="n">RoundingMethod</span><span class="o">.</span><span class="n">AWAY_FROM_ZERO</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise round.</span>

<span class="sd">  Rounds values to the nearest integer.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: an array or scalar value to round.</span>
<span class="sd">    rounding_method: the method to use when rounding halfway values</span>
<span class="sd">      (e.g., `0.5`). See ``lax.RoundingMethod`` for the list of possible</span>
<span class="sd">      values.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the elementwise rounding of x.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">rounding_method</span> <span class="o">=</span> <span class="n">RoundingMethod</span><span class="p">(</span><span class="n">rounding_method</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">round_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rounding_method</span><span class="o">=</span><span class="n">rounding_method</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_finite"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.is_finite.html#jax.lax.is_finite">[docs]</a><span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise :math:`\mathrm{isfinite}`.</span>

<span class="sd">  For each element x returns `True` if and only if x is not :math:`\pm\infty` or</span>
<span class="sd">  :math:`\mathit{NaN}`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">is_finite_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.exp.html#jax.lax.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise exponential: :math:`e^x`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">exp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.expm1.html#jax.lax.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise :math:`e^{x} - 1`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">expm1_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.log.html#jax.lax.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise natural logarithm: :math:`\mathrm{log}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">log_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.log1p.html#jax.lax.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise :math:`\mathrm{log}(1 + x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">log1p_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise hyperbolic tangent: :math:`\mathrm{tanh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">tanh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="logistic"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.logistic.html#jax.lax.logistic">[docs]</a><span class="k">def</span> <span class="nf">logistic</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise logistic (sigmoid) function: :math:`\frac{1}{1 + e^{-x}}`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">logistic_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sin.html#jax.lax.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise sine: :math:`\mathrm{sin}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">sin_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.cos.html#jax.lax.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise cosine: :math:`\mathrm{cos}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cos_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="atan2"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.atan2.html#jax.lax.atan2">[docs]</a><span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise arc tangent of two variables:</span>
<span class="sd">    :math:`\mathrm{atan}({x \over y})`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">atan2_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="betainc"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.betainc.html#jax.lax.betainc">[docs]</a><span class="k">def</span> <span class="nf">betainc</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise regularized incomplete beta integral.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">regularized_incomplete_beta_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="lgamma"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.lgamma.html#jax.lax.lgamma">[docs]</a><span class="k">def</span> <span class="nf">lgamma</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise log gamma: :math:`\mathrm{log}(\Gamma(x))`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">lgamma_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="digamma"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.digamma.html#jax.lax.digamma">[docs]</a><span class="k">def</span> <span class="nf">digamma</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise digamma: :math:`\psi(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">digamma_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="igamma"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.igamma.html#jax.lax.igamma">[docs]</a><span class="k">def</span> <span class="nf">igamma</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise regularized incomplete gamma function.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">igamma_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="igammac"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.igammac.html#jax.lax.igammac">[docs]</a><span class="k">def</span> <span class="nf">igammac</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise complementary regularized incomplete gamma function.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">igammac_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">igamma_grad_a</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise derivative of the regularized incomplete gamma function.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">igamma_grad_a_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_gamma_grad</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise derivative of samples from `Gamma(a, 1)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">random_gamma_grad_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="bessel_i0e"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bessel_i0e.html#jax.lax.bessel_i0e">[docs]</a><span class="k">def</span> <span class="nf">bessel_i0e</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exponentially scaled modified Bessel function of order 0:</span>
<span class="sd">  :math:`\mathrm{i0e}(x) = e^{-|x|} \mathrm{i0}(x)`</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">bessel_i0e_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="bessel_i1e"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bessel_i1e.html#jax.lax.bessel_i1e">[docs]</a><span class="k">def</span> <span class="nf">bessel_i1e</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Exponentially scaled modified Bessel function of order 1:</span>
<span class="sd">  :math:`\mathrm{i1e}(x) = e^{-|x|} \mathrm{i1}(x)`</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">bessel_i1e_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="erf"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.erf.html#jax.lax.erf">[docs]</a><span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise error function: :math:`\mathrm{erf}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">erf_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="erfc"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.erfc.html#jax.lax.erfc">[docs]</a><span class="k">def</span> <span class="nf">erfc</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise complementary error function:</span>
<span class="sd">    :math:`\mathrm{erfc}(x) = 1 - \mathrm{erf}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">erfc_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="erf_inv"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.erf_inv.html#jax.lax.erf_inv">[docs]</a><span class="k">def</span> <span class="nf">erf_inv</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise inverse error function: :math:`\mathrm{erf}^{-1}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">erf_inv_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="real"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.real.html#jax.lax.real">[docs]</a><span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise extract real part: :math:`\mathrm{Re}(x)`.</span>

<span class="sd">  Returns the real part of a complex number.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">real_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="imag"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.imag.html#jax.lax.imag">[docs]</a><span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise extract imaginary part: :math:`\mathrm{Im}(x)`.</span>

<span class="sd">  Returns the imaginary part of a complex number.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">imag_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="complex"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.complex.html#jax.lax.complex">[docs]</a><span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise make complex number: :math:`x + jy`.</span>

<span class="sd">  Builds a complex number from real and imaginary parts.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">complex_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="conj"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.conj.html#jax.lax.conj">[docs]</a><span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise complex conjugate function: :math:`\overline{x}`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">conj_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">input_dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>

<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.abs.html#jax.lax.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise absolute value: :math:`|x|`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">abs_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="pow"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.pow.html#jax.lax.pow">[docs]</a><span class="k">def</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise power: :math:`x^y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">pow_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise power: :math:`x^y`, where :math:`y` is a fixed integer.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">integer_pow_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sqrt.html#jax.lax.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise square root: :math:`\sqrt{x}`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">sqrt_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="rsqrt"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.rsqrt.html#jax.lax.rsqrt">[docs]</a><span class="k">def</span> <span class="nf">rsqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise reciprocal square root:  :math:`1 \over \sqrt{x}`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">rsqrt_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="cbrt"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.cbrt.html#jax.lax.cbrt">[docs]</a><span class="k">def</span> <span class="nf">cbrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise cube root: :math:`\sqrt[3]{x}`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cbrt_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="bitwise_not"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bitwise_not.html#jax.lax.bitwise_not">[docs]</a><span class="k">def</span> <span class="nf">bitwise_not</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise NOT: :math:`\neg x`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">not_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bitwise_and.html#jax.lax.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise AND: :math:`x \wedge y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">and_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bitwise_or.html#jax.lax.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise OR: :math:`x \vee y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">or_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bitwise_xor.html#jax.lax.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise exclusive OR: :math:`x \oplus y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">xor_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_count"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.population_count.html#jax.lax.population_count">[docs]</a><span class="k">def</span> <span class="nf">population_count</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise popcount, count the number of set bits in each element.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">population_count_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">clz</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise count-leading-zeros.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">clz_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.add.html#jax.lax.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise addition: :math:`x + y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">add_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="sub"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sub.html#jax.lax.sub">[docs]</a><span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise subtraction: :math:`x - y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">sub_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="mul"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.mul.html#jax.lax.mul">[docs]</a><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise multiplication: :math:`x \times y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">mul_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="div"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.div.html#jax.lax.div">[docs]</a><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise division: :math:`x \over y`.</span>

<span class="sd">  Integer division overflow</span>
<span class="sd">  (division by zero or signed division of INT_SMIN with -1)</span>
<span class="sd">  produces an implementation defined value.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">div_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="rem"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.rem.html#jax.lax.rem">[docs]</a><span class="k">def</span> <span class="nf">rem</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise remainder: :math:`x \bmod y`.</span>

<span class="sd">  The sign of the result is taken from the dividend,</span>
<span class="sd">  and the absolute value of the result is always</span>
<span class="sd">  less than the divisor&#39;s absolute value.</span>

<span class="sd">  Integer division overflow</span>
<span class="sd">  (remainder by zero or remainder of INT_SMIN with -1)</span>
<span class="sd">  produces an implementation defined value.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">rem_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.max.html#jax.lax.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise maximum: :math:`\mathrm{max}(x, y)`</span>

<span class="sd">  For complex numbers, uses a lexicographic comparison on the</span>
<span class="sd">  `(real, imaginary)` pairs.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">max_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.min.html#jax.lax.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise minimum:  :math:`\mathrm{min}(x, y)`</span>

<span class="sd">  For complex numbers, uses a lexicographic comparison on the</span>
<span class="sd">  `(real, imaginary)` pairs.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">min_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="shift_left"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.shift_left.html#jax.lax.shift_left">[docs]</a><span class="k">def</span> <span class="nf">shift_left</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise left shift: :math:`x \ll y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">shift_left_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="shift_right_arithmetic"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.shift_right_arithmetic.html#jax.lax.shift_right_arithmetic">[docs]</a><span class="k">def</span> <span class="nf">shift_right_arithmetic</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise arithmetic right shift: :math:`x \gg y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">shift_right_arithmetic_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="shift_right_logical"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.shift_right_logical.html#jax.lax.shift_right_logical">[docs]</a><span class="k">def</span> <span class="nf">shift_right_logical</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise logical right shift: :math:`x \gg y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">shift_right_logical_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="eq"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.eq.html#jax.lax.eq">[docs]</a><span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise equals: :math:`x = y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">eq_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="ne"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.ne.html#jax.lax.ne">[docs]</a><span class="k">def</span> <span class="nf">ne</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise not-equals: :math:`x \neq y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">ne_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="ge"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.ge.html#jax.lax.ge">[docs]</a><span class="k">def</span> <span class="nf">ge</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise greater-than-or-equals: :math:`x \geq y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">ge_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="gt"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.gt.html#jax.lax.gt">[docs]</a><span class="k">def</span> <span class="nf">gt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise greater-than: :math:`x &gt; y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">gt_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="le"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.le.html#jax.lax.le">[docs]</a><span class="k">def</span> <span class="nf">le</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise less-than-or-equals: :math:`x \leq y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">le_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="lt"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.lt.html#jax.lax.lt">[docs]</a><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise less-than: :math:`x &lt; y`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">lt_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="convert_element_type"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.convert_element_type.html#jax.lax.convert_element_type">[docs]</a><span class="k">def</span> <span class="nf">convert_element_type</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Elementwise cast.</span>

<span class="sd">  Wraps XLA&#39;s `ConvertElementType</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#convertelementtype&gt;`_</span>
<span class="sd">  operator, which performs an elementwise conversion from one type to another.</span>
<span class="sd">  Similar to a C++ `static_cast`.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an array or scalar value to be cast</span>
<span class="sd">    new_dtype: a NumPy dtype representing the target type.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array with the same shape as `operand`, cast elementwise to `new_dtype`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
  <span class="k">return</span> <span class="n">_convert_element_type</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_convert_element_type</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">weak_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
  <span class="c1"># Don&#39;t canonicalize old_dtype because x64 context might cause</span>
  <span class="c1"># un-canonicalized operands to be passed in.</span>
  <span class="n">old_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">old_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">new_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">old_dtype</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
  <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">new_weak_type</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">weak_type</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">old_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">and</span>
      <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Casting complex values to real discards the imaginary part&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ComplexWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

  <span class="c1"># Python has big integers, but convert_element_type(2 ** 100, np.float32) need</span>
  <span class="c1"># not be an error since the target dtype fits the value. Handle this case by</span>
  <span class="c1"># converting to a NumPy array before calling bind. Without this step, we&#39;d</span>
  <span class="c1"># first canonicalize the input to a value of dtype int32 or int64, leading to</span>
  <span class="c1"># an overflow error.</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">)</span>
    <span class="n">old_weak_type</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">old_dtype</span><span class="p">,</span> <span class="n">old_weak_type</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">new_weak_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">,</span>
                                       <span class="n">weak_type</span><span class="o">=</span><span class="n">new_weak_type</span><span class="p">)</span>

<div class="viewcode-block" id="bitcast_convert_type"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.bitcast_convert_type.html#jax.lax.bitcast_convert_type">[docs]</a><span class="k">def</span> <span class="nf">bitcast_convert_type</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Elementwise bitcast.</span>

<span class="sd">  Wraps XLA&#39;s `BitcastConvertType</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#bitcastconverttype&gt;`_</span>
<span class="sd">  operator, which performs a bit cast from one type to another. The bitwidth</span>
<span class="sd">  of the source and destination types must match.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an array or scalar value to be cast</span>
<span class="sd">    new_dtype: the new type. Should be a NumPy type.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array with the same shape as `operand`, bitcast elementwise to</span>
<span class="sd">    `new_dtype`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">bitcast_convert_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="clamp"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.clamp.html#jax.lax.clamp">[docs]</a><span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="nb">min</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise clamp.</span>

<span class="sd">  Returns :math:`\mathrm{clamp}(x) = \begin{cases}</span>
<span class="sd">  \mathit{min} &amp; \text{if } x &lt; \mathit{min},\\</span>
<span class="sd">  \mathit{max} &amp; \text{if } x &gt; \mathit{max},\\</span>
<span class="sd">  x &amp; \text{otherwise}</span>
<span class="sd">  \end{cases}`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span></div>

<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.concatenate.html#jax.lax.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">operands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Concatenates a sequence of arrays along `dimension`.</span>

<span class="sd">  Wraps XLA&#39;s `Concatenate</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#concatenate&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  Args:</span>
<span class="sd">    operands: a sequence of arrays to concatenate. The arrays must have equal</span>
<span class="sd">      shapes, except in the `dimension` axis.</span>
<span class="sd">    dimension: the dimension along which to concatenate the arrays.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the concatenation.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;concatenate requires a non-empty sequences of arrays&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">op</span><span class="p">,</span> <span class="o">=</span> <span class="n">operands</span>
    <span class="k">if</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">concatenate_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_enum_descriptor</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
  <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">owner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>


<div class="viewcode-block" id="Precision"><a class="viewcode-back" href="../../../../jax.lax.html#jax.lax.Precision">[docs]</a><span class="k">class</span> <span class="nc">Precision</span><span class="p">(</span><span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
  <span class="sd">&quot;&quot;&quot;Precision enum for lax functions</span>

<span class="sd">  The `precision` argument to JAX functions generally controls the tradeoff</span>
<span class="sd">  between speed and accuracy for array computations on accelerator backends,</span>
<span class="sd">  (i.e. TPU and GPU). Members are:</span>

<span class="sd">  DEFAULT:</span>
<span class="sd">    Fastest mode, but least accurate. Performs computations in bfloat16.</span>
<span class="sd">    Aliases: ``&#39;default&#39;``, ``&#39;fastest&#39;``, ``&#39;bfloat16&#39;``.</span>
<span class="sd">  HIGH:</span>
<span class="sd">    Slower but more accurate. Performs float32 computations in 3 bfloat16</span>
<span class="sd">    passes, or using tensorfloat32 where available. Aliases: ``&#39;high&#39;``,</span>
<span class="sd">    ``&#39;bfloat16_3x&#39;``, ``&#39;tensorfloat32&#39;``.</span>
<span class="sd">  HIGHEST:</span>
<span class="sd">    Slowest but most accurate. Performs computations in float32 or float64</span>
<span class="sd">    as applicable. Aliases: ``&#39;highest&#39;``, ``&#39;float32&#39;``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Wrap enum values with this class.</span>
  <span class="n">DEFAULT</span> <span class="o">=</span> <span class="n">_enum_descriptor</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
  <span class="n">HIGH</span> <span class="o">=</span> <span class="n">_enum_descriptor</span><span class="p">(</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
  <span class="n">HIGHEST</span> <span class="o">=</span> <span class="n">_enum_descriptor</span><span class="p">(</span><span class="s1">&#39;highest&#39;</span><span class="p">)</span>

  <span class="n">_strings</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;highest&#39;</span><span class="p">:</span>       <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">HIGHEST</span><span class="p">,</span>
      <span class="s1">&#39;float32&#39;</span><span class="p">:</span>       <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">HIGHEST</span><span class="p">,</span>
      <span class="s1">&#39;high&#39;</span><span class="p">:</span>          <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">HIGH</span><span class="p">,</span>
      <span class="s1">&#39;bfloat16_3x&#39;</span><span class="p">:</span>   <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">HIGH</span><span class="p">,</span>
      <span class="s1">&#39;tensorfloat32&#39;</span><span class="p">:</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">HIGH</span><span class="p">,</span>
      <span class="s1">&#39;default&#39;</span><span class="p">:</span>       <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span>
      <span class="s1">&#39;bfloat16&#39;</span><span class="p">:</span>      <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span>
      <span class="s1">&#39;fastest&#39;</span><span class="p">:</span>       <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span>
      <span class="kc">None</span><span class="p">:</span>            <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg0</span><span class="p">):</span>
    <span class="n">arg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg0</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="n">PrecisionType</span> <span class="o">=</span> <span class="n">Precision</span>
<span class="n">PrecisionLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                      <span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">]]</span>

<div class="viewcode-block" id="dot"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.dot.html#jax.lax.dot">[docs]</a><span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Vector/vector, matrix/vector, and matrix/matrix multiplication.</span>

<span class="sd">  Wraps XLA&#39;s `Dot</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#dot&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  For more general contraction, see the `dot_general` operator.</span>

<span class="sd">  Args:</span>
<span class="sd">    lhs: an array of dimension 1 or 2.</span>
<span class="sd">    rhs: an array of dimension 1 or 2.</span>
<span class="sd">    precision: Optional. Either ``None``, which means the default precision for</span>
<span class="sd">      the backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,</span>
<span class="sd">      ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two</span>
<span class="sd">      :class:`~jax.lax.Precision` enums indicating precision of ``lhs``` and ``rhs``.</span>
<span class="sd">    preferred_element_type: Optional. Either ``None``, which means the default</span>
<span class="sd">      accumulation type for the input types, or a datatype, indicating to</span>
<span class="sd">      accumulate results to and return a result with that datatype.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the product.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">return</span> <span class="n">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">(((</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)),</span> <span class="p">((),</span> <span class="p">())),</span>
                       <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                       <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for dot: got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span></div>


<span class="n">DotDimensionNumbers</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                            <span class="n">Tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span>

<div class="viewcode-block" id="dot_general"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.dot_general.html#jax.lax.dot_general">[docs]</a><span class="k">def</span> <span class="nf">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">:</span> <span class="n">DotDimensionNumbers</span><span class="p">,</span>
                <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;More general contraction operator.</span>

<span class="sd">  Wraps XLA&#39;s `DotGeneral</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#dotgeneral&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  Args:</span>
<span class="sd">    lhs: an array</span>
<span class="sd">    rhs: an array</span>
<span class="sd">    dimension_numbers: a tuple of tuples of the form</span>
<span class="sd">      `((lhs_contracting_dims, rhs_contracting_dims),</span>
<span class="sd">      (lhs_batch_dims, rhs_batch_dims))`</span>
<span class="sd">    precision: Optional. Either ``None``, which means the default precision for</span>
<span class="sd">      the backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,</span>
<span class="sd">      ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two</span>
<span class="sd">      :class:`~jax.lax.Precision` enums indicating precision of ``lhs``` and ``rhs``.</span>
<span class="sd">    preferred_element_type: Optional. Either ``None``, which means the default</span>
<span class="sd">      accumulation type for the input types, or a datatype, indicating to</span>
<span class="sd">      accumulate results to and return a result with that datatype.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the result.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="p">(</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">rhs_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="n">cdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">api_util</span><span class="o">.</span><span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">lhs_contract</span><span class="p">),</span>
           <span class="n">api_util</span><span class="o">.</span><span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">rhs_contract</span><span class="p">))</span>
  <span class="n">bdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">api_util</span><span class="o">.</span><span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">),</span>
           <span class="n">api_util</span><span class="o">.</span><span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">))</span>
  <span class="n">preferred_element_type</span> <span class="o">=</span> <span class="p">(</span>
      <span class="kc">None</span> <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
      <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">dot_general_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span>
                            <span class="n">dimension_numbers</span><span class="o">=</span><span class="p">(</span><span class="n">cdims</span><span class="p">,</span> <span class="n">bdims</span><span class="p">),</span>
                            <span class="n">precision</span><span class="o">=</span><span class="n">canonicalize_precision</span><span class="p">(</span><span class="n">precision</span><span class="p">),</span>
                            <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="broadcast"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.broadcast.html#jax.lax.broadcast">[docs]</a><span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">sizes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Broadcasts an array, adding new leading dimensions</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an array</span>
<span class="sd">    sizes: a sequence of integers, giving the sizes of new leading dimensions</span>
<span class="sd">      to add to the front of the array.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the result.</span>

<span class="sd">  See Also:</span>
<span class="sd">    jax.lax.broadcast_in_dim : add new dimensions at any location in the array shape.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">dims</span><span class="p">)</span></div>

<div class="viewcode-block" id="broadcast_in_dim"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.broadcast_in_dim.html#jax.lax.broadcast_in_dim">[docs]</a><span class="k">def</span> <span class="nf">broadcast_in_dim</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
                     <span class="n">broadcast_dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `BroadcastInDim</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#broadcastindim&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an array</span>
<span class="sd">    shape: the shape of the target array</span>
<span class="sd">    broadcast_dimensions: to which dimension in the target shape each dimension</span>
<span class="sd">      of the operand shape corresponds to</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array containing the result.</span>

<span class="sd">  See Also:</span>
<span class="sd">    jax.lax.broadcast : simpler interface to add new leading dimensions.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="c1"># We must gate this behavior under a flag because otherwise the errors</span>
    <span class="c1"># raised are different (and have worse source provenance information).</span>
    <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">static_shape</span> <span class="o">=</span> <span class="n">_extract_tracers_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">static_shape</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">shape</span>  <span class="c1"># type: ignore</span>
  <span class="k">return</span> <span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">static_shape</span><span class="p">),</span>
      <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">broadcast_to_rank</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Adds leading dimensions of ``1`` to give ``x`` rank ``rank``.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.reshape.html#jax.lax.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Reshape</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#reshape&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  For inserting/removing dimensions of size 1, prefer using ``lax.squeeze`` /</span>
<span class="sd">  ``lax.expand_dims``. These preserve information about axis identity that may</span>
<span class="sd">  be useful for advanced transformation rules.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: array to be reshaped.</span>
<span class="sd">    new_sizes: sequence of integers specifying the resulting shape. The size</span>
<span class="sd">      of the final array must match the size of the input.</span>
<span class="sd">    dimensions: optional sequence of integers specifying the permutation order of</span>
<span class="sd">      the input shape. If specified, the length must match ``operand.shape``.</span>

<span class="sd">  Returns:</span>
<span class="sd">    out: reshaped array.</span>

<span class="sd">  Examples:</span>
<span class="sd">    Simple reshaping from one to two dimensions:</span>

<span class="sd">    &gt;&gt;&gt; x = jnp.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; y = reshape(x, (2, 3))</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    DeviceArray([[0, 1, 2],</span>
<span class="sd">                 [3, 4, 5]], dtype=int32)</span>

<span class="sd">    Reshaping back to one dimension:</span>

<span class="sd">    &gt;&gt;&gt; reshape(y, (6,))</span>
<span class="sd">    DeviceArray([0, 1, 2, 3, 4, 5], dtype=int32)</span>

<span class="sd">    Reshaping to one dimension with permutation of dimensions:</span>

<span class="sd">    &gt;&gt;&gt; reshape(y, (6,), (1, 0))</span>
<span class="sd">    DeviceArray([0, 3, 1, 4, 2, 5], dtype=int32)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">new_sizes</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">)</span>  <span class="c1"># TODO</span>
  <span class="n">new_sizes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">)</span>
  <span class="n">same_shape</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">new_sizes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">same_dims</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">api_util</span><span class="o">.</span><span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">same_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="ow">and</span> <span class="n">same_shape</span> <span class="ow">and</span> <span class="n">same_dims</span> <span class="ow">and</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">static_new_sizes</span> <span class="o">=</span> <span class="n">_extract_tracers_dyn_shape</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reshape_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
      <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">new_sizes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">static_new_sizes</span><span class="p">),</span>
      <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">same_dims</span> <span class="k">else</span> <span class="n">dims</span><span class="p">)</span></div>

<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.pad.html#jax.lax.pad">[docs]</a><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">padding_config</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Applies low, high, and/or interior padding to an array.</span>

<span class="sd">  Wraps XLA&#39;s `Pad</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#pad&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an array to be padded.</span>
<span class="sd">    padding_value: the value to be inserted as padding. Must have the same dtype</span>
<span class="sd">      as ``operand``.</span>
<span class="sd">    padding_config: a sequence of ``(low, high, interior)`` tuples of integers,</span>
<span class="sd">      giving the amount of low, high, and interior (dilation) padding to insert</span>
<span class="sd">      in each dimension.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The ``operand`` array with padding value ``padding_value`` inserted in each</span>
<span class="sd">    dimension according to the ``padding_config``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">pad_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="n">padding_config</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">padding_config</span><span class="p">))</span></div>

<div class="viewcode-block" id="rev"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.rev.html#jax.lax.rev">[docs]</a><span class="k">def</span> <span class="nf">rev</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Rev</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#rev_reverse&gt;`_</span>
<span class="sd">  operator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">rev_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span></div>

<div class="viewcode-block" id="select"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.select.html#jax.lax.select">[docs]</a><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">pred</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">on_true</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">on_false</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Select</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#select&gt;`_</span>
<span class="sd">  operator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Caution! The select_n_p primitive has the *opposite* order of arguments to</span>
  <span class="c1"># select(). This is because it implements `select_n`.</span>
  <span class="k">return</span> <span class="n">select_n_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">on_false</span><span class="p">,</span> <span class="n">on_true</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Selects array values from multiple cases.</span>

<span class="sd">  Generalizes XLA&#39;s `Select</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#select&gt;`_</span>
<span class="sd">  operator. Unlike XLA&#39;s version, the operator is variadic and can select</span>
<span class="sd">  from many cases using an integer `pred`.</span>

<span class="sd">  Args:</span>
<span class="sd">    which: determines which case should be returned. Must be an array containing</span>
<span class="sd">      either a boolean or integer values. May either be a scalar or have</span>
<span class="sd">      shape matching ``cases``. For each array element, the value of ``which``</span>
<span class="sd">      determines which of ``cases`` is taken. ``which`` must be in the range</span>
<span class="sd">      ``[0 .. len(cases))``; for values outside that range the behavior is</span>
<span class="sd">      implementation-defined.</span>
<span class="sd">    *cases: a non-empty list of array cases. All must have equal dtypes and</span>
<span class="sd">      equal shapes.</span>
<span class="sd">  Returns:</span>
<span class="sd">    An array with shape and dtype equal to the cases, whose values are chosen</span>
<span class="sd">    according to ``which``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;select_n() must have at least one case&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">select_n_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">)</span>


<div class="viewcode-block" id="transpose"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.transpose.html#jax.lax.transpose">[docs]</a><span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">permutation</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Transpose</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#transpose&gt;`_</span>
<span class="sd">  operator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">permutation</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">permutation</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span> <span class="ow">and</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">transpose_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">permutation</span><span class="o">=</span><span class="n">permutation</span><span class="p">)</span></div>

<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.argmin.html#jax.lax.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
           <span class="n">index_dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Computes the index of the minimum element along ``axis``.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">argmin_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span><span class="p">,),</span>
                       <span class="n">index_dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.argmax.html#jax.lax.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
           <span class="n">index_dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Computes the index of the maximum element along ``axis``.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">argmax_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span><span class="p">,),</span>
                       <span class="n">index_dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="reduce"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.reduce.html#jax.lax.reduce">[docs]</a><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">operands</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
           <span class="n">init_values</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
           <span class="n">computation</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
           <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Reduce</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#reduce&gt;`_</span>
<span class="sd">  operator.</span>

<span class="sd">  ``init_values`` and ``computation`` together must form a `monoid</span>
<span class="sd">  &lt;https://en.wikipedia.org/wiki/Monoid&gt;`_</span>
<span class="sd">  for correctness. That is ``init_values`` must be an identity of</span>
<span class="sd">  ``computation``, and ``computation`` must be associative. XLA may exploit both</span>
<span class="sd">  of these properties during code generation; if either is violated the result</span>
<span class="sd">  is undefined.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">flat_operands</span><span class="p">,</span> <span class="n">operand_tree</span> <span class="o">=</span> <span class="n">tree_util</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
  <span class="n">flat_init_values</span><span class="p">,</span> <span class="n">init_value_tree</span> <span class="o">=</span> <span class="n">tree_util</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">init_values</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">operand_tree</span> <span class="o">!=</span> <span class="n">init_value_tree</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Operands must have the same tree structure as init_values:&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">operand_tree</span><span class="si">}</span><span class="s1"> vs. </span><span class="si">{</span><span class="n">init_value_tree</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_operands</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_init_values</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have same total number of operands as init_values: &#39;</span>
                     <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_operands</span><span class="p">)</span><span class="si">}</span><span class="s1"> vs. </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_init_values</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">monoid_reducer</span> <span class="o">=</span> <span class="n">_get_monoid_reducer</span><span class="p">(</span><span class="n">computation</span><span class="p">,</span> <span class="n">flat_init_values</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">monoid_reducer</span><span class="p">:</span>
    <span class="c1"># monoid reducers bypass the weak_type_rule, so we set it explicitly.</span>
    <span class="n">weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="o">*</span><span class="n">flat_operands</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="o">*</span><span class="n">flat_init_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_convert_element_type</span><span class="p">(</span><span class="n">monoid_reducer</span><span class="p">(</span><span class="o">*</span><span class="n">flat_operands</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">),</span>
                                 <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">flat_init_avals</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">(</span><span class="n">_abstractify</span><span class="p">,</span> <span class="n">flat_init_values</span><span class="p">)</span>
    <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">_variadic_reduction_jaxpr</span><span class="p">(</span>
        <span class="n">computation</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flat_init_avals</span><span class="p">),</span> <span class="n">init_value_tree</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reduce_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">flat_operands</span> <span class="o">+</span> <span class="n">flat_init_values</span><span class="p">),</span> <span class="n">computation</span><span class="o">=</span><span class="n">computation</span><span class="p">,</span>
                         <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="o">=</span><span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tree_util</span><span class="o">.</span><span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out_tree</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<span class="nd">@cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_reduction_jaxpr</span><span class="p">(</span><span class="n">computation</span><span class="p">,</span> <span class="n">aval</span><span class="p">):</span>
  <span class="nd">@lu</span><span class="o">.</span><span class="n">wrap_init</span>
  <span class="k">def</span> <span class="nf">comp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">computation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">core</span><span class="o">.</span><span class="n">valid_jaxtype</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;Invalid return type from reduction function: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
          <span class="sa">f</span><span class="s2">&quot;Reduction functions should only return an array.</span><span class="se">\n</span><span class="s2">&quot;</span>
          <span class="sa">f</span><span class="s2">&quot;Full return value: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,)</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">trace_to_jaxpr_dynamic</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">aval</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;Reduction computations can&#39;t close over Tracers. Please open an issue &quot;</span>
        <span class="s2">&quot;at https://github.com/google/jax.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">consts</span><span class="p">)</span>

<span class="nd">@cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_variadic_reduction_jaxpr</span><span class="p">(</span><span class="n">computation</span><span class="p">,</span> <span class="n">flat_avals</span><span class="p">,</span> <span class="n">aval_tree</span><span class="p">):</span>
  <span class="n">avals</span> <span class="o">=</span> <span class="n">tree_util</span><span class="o">.</span><span class="n">tree_unflatten</span><span class="p">(</span><span class="n">aval_tree</span><span class="p">,</span> <span class="n">flat_avals</span><span class="p">)</span>
  <span class="n">flat_in_avals</span><span class="p">,</span> <span class="n">in_tree</span> <span class="o">=</span> <span class="n">tree_util</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">((</span><span class="n">avals</span><span class="p">,</span> <span class="n">avals</span><span class="p">))</span>
  <span class="n">comp</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">wrap_init</span><span class="p">(</span><span class="n">computation</span><span class="p">)</span>
  <span class="n">flat_comp</span><span class="p">,</span> <span class="n">out_tree</span> <span class="o">=</span> <span class="n">api_util</span><span class="o">.</span><span class="n">flatten_fun_nokwargs</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">in_tree</span><span class="p">)</span>
  <span class="n">jaxpr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">consts</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">trace_to_jaxpr_dynamic</span><span class="p">(</span><span class="n">flat_comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flat_in_avals</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consts</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;Reduction computations can&#39;t close over Tracers. Please open an issue &quot;</span>
        <span class="s2">&quot;at https://github.com/google/jax.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">consts</span><span class="p">),</span> <span class="n">out_tree</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_get_monoid_reducer</span><span class="p">(</span><span class="n">monoid_op</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                        <span class="n">xs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Array</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ConcreteArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
    <span class="c1"># allow bitwise reductions for boolean and integer types</span>
    <span class="n">_is_intlike</span> <span class="o">=</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">or</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="n">add</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_sum</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="n">mul</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_prod</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="n">bitwise_or</span> <span class="ow">and</span> <span class="n">_is_intlike</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_or</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_get_bitwise_or_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="n">bitwise_and</span> <span class="ow">and</span> <span class="n">_is_intlike</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_and</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_get_bitwise_and_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="n">bitwise_xor</span> <span class="ow">and</span> <span class="n">_is_intlike</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_xor</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_get_bitwise_or_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="nb">max</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_max</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_get_max_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">monoid_op</span> <span class="ow">is</span> <span class="nb">min</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_reduce_min</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">_get_min_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">_get_bitwise_and_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_bitwise_or_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_max_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported dtype for max: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_min_identity</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported dtype for min: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_sum</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_sum_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_prod</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_prod_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_max</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_max_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_min</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_min_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_or</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_or_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_and</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_and_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_xor</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">reduce_xor_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Array</span><span class="p">],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">is_stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">is_stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sort.html#jax.lax.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Array</span><span class="p">]],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">is_stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Sort</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#sort&gt;`_ operator.</span>

<span class="sd">  For floating point inputs, -0.0 and 0.0 are treated as equivalent, and NaN values</span>
<span class="sd">  are sorted to the end of the array. For complex inputs, the sort order is</span>
<span class="sd">  lexicographic over the real and imaginary parts, with the real part primary.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand : Array or sequence of arrays</span>
<span class="sd">    dimension : integer dimension along which to sort. Default: -1.</span>
<span class="sd">    is_stable : boolean specifying whether to use a stable sort. Default: True.</span>
<span class="sd">    num_keys : number of operands to treat as sort keys. Default: 1.</span>
<span class="sd">      For num_keys &gt; 1, the sort order will be determined lexicographically using</span>
<span class="sd">      the first `num_keys` arrays, with the first key being primary.</span>
<span class="sd">      The remaining operands will be returned with the same permutation.</span>

<span class="sd">  Returns:</span>
<span class="sd">    operand : sorted version of the input or inputs.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sort requires at least one operand&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">num_keys</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num_keys=</span><span class="si">{</span><span class="n">num_keys</span><span class="si">}</span><span class="s2"> must be between 1 and len(operand)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sort_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                             <span class="n">is_stable</span><span class="o">=</span><span class="n">is_stable</span><span class="p">,</span>
                             <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">num_keys</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num_keys=</span><span class="si">{</span><span class="n">num_keys</span><span class="si">}</span><span class="s2"> must equal 1 for a single operand.&quot;</span><span class="p">)</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sort_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="o">=</span><span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="sort_key_val"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sort_key_val.html#jax.lax.sort_key_val">[docs]</a><span class="k">def</span> <span class="nf">sort_key_val</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">is_stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Sorts ``keys`` along ``dimension`` and applies the same permutation to ``values``.&quot;&quot;&quot;</span>
  <span class="n">dimension</span> <span class="o">=</span> <span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">sort_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="o">=</span><span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span></div>

<div class="viewcode-block" id="top_k"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.top_k.html#jax.lax.top_k">[docs]</a><span class="k">def</span> <span class="nf">top_k</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Returns top ``k`` values and their indices along the last axis of ``operand``.&quot;&quot;&quot;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;k argument to top_k must be nonnegative, got </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">top_k_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="tie_in"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.tie_in.html#jax.lax.tie_in">[docs]</a><span class="k">def</span> <span class="nf">tie_in</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Deprecated. Ignores ``x`` and returns ``y``.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="full"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.full.html#jax.lax.full">[docs]</a><span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Returns an array of `shape` filled with `fill_value`.</span>

<span class="sd">  Args:</span>
<span class="sd">    shape: sequence of integers, describing the shape of the output array.</span>
<span class="sd">    fill_value: the value to fill the new array with.</span>
<span class="sd">    dtype: the type of the output array, or `None`. If not `None`, `fill_value`</span>
<span class="sd">      will be cast to `dtype`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;full must be called with scalar fill_value, got fill_value.shape </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)))</span>
  <span class="n">weak_type</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
  <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_convert_element_type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">zeros_like_shaped_array</span><span class="p">(</span><span class="n">aval</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">:</span>
    <span class="n">scalar_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">scalar_zero</span> <span class="o">=</span> <span class="n">_convert_element_type</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">scalar_zero</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">ad_util</span><span class="o">.</span><span class="n">aval_zeros_likers</span><span class="p">[</span><span class="n">ShapedArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros_like_shaped_array</span>

<div class="viewcode-block" id="iota"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.iota.html#jax.lax.iota">[docs]</a><span class="k">def</span> <span class="nf">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `Iota</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#iota&gt;`_</span>
<span class="sd">  operator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,),</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="broadcasted_iota"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.broadcasted_iota.html#jax.lax.broadcasted_iota">[docs]</a><span class="k">def</span> <span class="nf">broadcasted_iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Convenience wrapper around ``iota``.&quot;&quot;&quot;</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dynamic_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)]</span>
  <span class="n">static_shape</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]</span>
  <span class="n">dimension</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
      <span class="nb">int</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="s2">&quot;dimension argument of lax.broadcasted_iota&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">iota_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">dynamic_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">static_shape</span><span class="p">),</span>
                     <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_eye</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Like numpy.eye, create a 2D array with ones on a diagonal.&quot;&quot;&quot;</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">bool_eye</span> <span class="o">=</span> <span class="n">eq</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">offset</span><span class="p">)),</span>
                <span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">bool_eye</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_delta</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;This utility function exists for creating Kronecker delta arrays.&quot;&quot;&quot;</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">base_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="n">iotas</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">base_shape</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base_shape</span><span class="p">))]</span>
  <span class="n">eyes</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iotas</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">iotas</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">_reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">eyes</span><span class="p">),</span>
                                       <span class="n">new_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_tri</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Like numpy.tri, create a 2D array with ones below a diagonal.&quot;&quot;&quot;</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">bool_tri</span> <span class="o">=</span> <span class="n">ge</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">offset</span><span class="p">)),</span>
                <span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">bool_tri</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.stop_gradient.html#jax.lax.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Stops gradient computation.</span>

<span class="sd">  Operationally ``stop_gradient`` is the identity function, that is, it returns</span>
<span class="sd">  argument `x` unchanged. However, ``stop_gradient`` prevents the flow of</span>
<span class="sd">  gradients during forward or reverse-mode automatic differentiation. If there</span>
<span class="sd">  are multiple nested gradient computations, ``stop_gradient`` stops gradients</span>
<span class="sd">  for all of them.</span>

<span class="sd">  For example:</span>

<span class="sd">  &gt;&gt;&gt; jax.grad(lambda x: x**2)(3.)</span>
<span class="sd">  DeviceArray(6., dtype=float32, weak_type=True)</span>
<span class="sd">  &gt;&gt;&gt; jax.grad(lambda x: jax.lax.stop_gradient(x)**2)(3.)</span>
<span class="sd">  DeviceArray(0., dtype=float32, weak_type=True)</span>
<span class="sd">  &gt;&gt;&gt; jax.grad(jax.grad(lambda x: x**2))(3.)</span>
<span class="sd">  DeviceArray(2., dtype=float32, weak_type=True)</span>
<span class="sd">  &gt;&gt;&gt; jax.grad(jax.grad(lambda x: jax.lax.stop_gradient(x)**2))(3.)</span>
<span class="sd">  DeviceArray(0., dtype=float32, weak_type=True)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># only bind primitive on inexact dtypes, to avoid some staging</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">has_opaque_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">or</span>
        <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
      <span class="k">return</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">stop_gradient_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="reduce_precision"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.reduce_precision.html#jax.lax.reduce_precision">[docs]</a><span class="k">def</span> <span class="nf">reduce_precision</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
                     <span class="n">exponent_bits</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">mantissa_bits</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Wraps XLA&#39;s `ReducePrecision</span>
<span class="sd">  &lt;https://www.tensorflow.org/xla/operation_semantics#reduceprecision&gt;`_</span>
<span class="sd">  operator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">exponent_bits</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">exponent_bits</span><span class="p">,</span> <span class="s2">&quot;exponent_bits argument of lax.reduce_precision&quot;</span><span class="p">)</span>
  <span class="n">mantissa_bits</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">mantissa_bits</span><span class="p">,</span> <span class="s2">&quot;mantissa_bits argument of lax.reduce_precision&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reduce_precision_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">exponent_bits</span><span class="o">=</span><span class="n">exponent_bits</span><span class="p">,</span> <span class="n">mantissa_bits</span><span class="o">=</span><span class="n">mantissa_bits</span><span class="p">)</span></div>

<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.squeeze.html#jax.lax.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Squeeze any number of size 1 dimensions from an array.&quot;&quot;&quot;</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">_is_array_or_tracer</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">squeeze_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">)</span></div>

<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.expand_dims.html#jax.lax.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Insert any number of size 1 dimensions into an array.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;repeated axis in lax.expand_dims: </span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">ndim_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim_out</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>  <span class="c1"># check again after canonicalizing</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;repeated axis in lax.expand_dims: </span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">dims_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dims_set</span><span class="p">):</span>
    <span class="n">result_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">broadcast_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim_out</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims_set</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">result_shape</span><span class="p">,</span> <span class="n">broadcast_dims</span><span class="p">)</span></div>


<span class="c1">### convenience wrappers around traceables</span>

<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.full_like.html#jax.lax.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Create a full array like np.full based on the example array `x`.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: example array-like, used for shape and dtype information.</span>
<span class="sd">    fill_value: a scalar value to fill the entries of the output array.</span>
<span class="sd">    dtype: optional, a dtype parameter for the output ndarray.</span>
<span class="sd">    shape: optional, a shape parameter for the output ndarray.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An ndarray with the same shape as `x` with its entries set equal to</span>
<span class="sd">    `fill_value`, similar to the output of np.full.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">array</span>
  <span class="kn">from</span> <span class="nn">jax._src.sharding</span> <span class="kn">import</span> <span class="n">PmapSharding</span>

  <span class="n">fill_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">weak_type</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">full</span><span class="p">(</span><span class="n">fill_shape</span><span class="p">,</span> <span class="n">_convert_element_type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">))</span>
  <span class="c1"># If the sharding is SingleDeviceSharding then don&#39;t take the `if` branch</span>
  <span class="c1"># because `val` is already an array with SingleDeviceSharding making this an</span>
  <span class="c1"># optimization.</span>
  <span class="c1"># TODO(yashkatariya,mattjj): `x` and `val` should have the same sharding,</span>
  <span class="c1"># probably in the form of a primitive like `val = match_sharding_p.bind(x, val)`</span>
  <span class="c1"># (so it works in staged-out code as well as &#39;eager&#39; code). Related to</span>
  <span class="c1"># equi-sharding.</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_array</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;sharding&#39;</span><span class="p">):</span>
    <span class="n">sharding</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sharding</span>  <span class="c1"># type: ignore[union-attr]</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dispatch</span><span class="o">.</span><span class="n">is_single_device_sharding</span><span class="p">(</span><span class="n">sharding</span><span class="p">)</span> <span class="ow">and</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sharding</span><span class="p">,</span> <span class="n">PmapSharding</span><span class="p">)):</span>
      <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">make_array_from_callback</span><span class="p">(</span>
        <span class="n">type_cast</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">fill_shape</span><span class="p">),</span> <span class="n">sharding</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">idx</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="collapse"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.collapse.html#jax.lax.collapse">[docs]</a><span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">operand</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">start_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">stop_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Collapses dimensions of an array into a single dimension.</span>

<span class="sd">  For example, if ``operand`` is an array with shape ``[2, 3, 4]``,</span>
<span class="sd">  ``collapse(operand, 0, 2).shape == [6, 4]``. The elements of the collapsed</span>
<span class="sd">  dimension are laid out major-to-minor, i.e., with the lowest-numbered</span>
<span class="sd">  dimension as the slowest varying dimension.</span>

<span class="sd">  Args:</span>
<span class="sd">    operand: an input array.</span>
<span class="sd">    start_dimension: the start of the dimensions to collapse (inclusive).</span>
<span class="sd">    stop_dimension: the end of the dimensions to collapse (exclusive).</span>

<span class="sd">  Returns:</span>
<span class="sd">    An array where dimensions ``[start_dimension, stop_dimension)`` have been</span>
<span class="sd">    collapsed (raveled) into a single dimension.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">start_dimension</span><span class="p">,</span> <span class="n">stop_dimension</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">hi</span><span class="p">])</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">lo</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hi</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="batch_matmul"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.batch_matmul.html#jax.lax.batch_matmul">[docs]</a><span class="k">def</span> <span class="nf">batch_matmul</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span>
                 <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Batch matrix multiplication.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">_min</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments to batch_matmul must be at least 2D, got </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments to batch_matmul must have same ndim, got </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="n">lhs_contract</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,)</span>
  <span class="n">rhs_contract</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,)</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">((</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">rhs_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch</span><span class="p">)),</span>
                     <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>


<span class="c1"># These functions also exist in the XLA client library, but we treat them</span>
<span class="c1"># as non-primitive to maintain a smaller set of autodiff primitives.</span>

<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.square.html#jax.lax.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise square: :math:`x^2`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="reciprocal"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.reciprocal.html#jax.lax.reciprocal">[docs]</a><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise reciprocal: :math:`1 \over x`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_upcast_fp16_for_computation</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f_wrapped</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">convert_element_type</span><span class="p">(</span>
        <span class="n">f</span><span class="p">(</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)),</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">f_wrapped</span>

<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.tan.html#jax.lax.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise tangent: :math:`\mathrm{tan}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">tan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="asin"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.asin.html#jax.lax.asin">[docs]</a><span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise arc sine: :math:`\mathrm{asin}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">asin_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="acos"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.acos.html#jax.lax.acos">[docs]</a><span class="k">def</span> <span class="nf">acos</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise arc cosine: :math:`\mathrm{acos}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">acos_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="atan"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.atan.html#jax.lax.atan">[docs]</a><span class="k">def</span> <span class="nf">atan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise arc tangent: :math:`\mathrm{atan}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">atan_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.sinh.html#jax.lax.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise hyperbolic sine: :math:`\mathrm{sinh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">sinh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../../_autosummary/jax.lax.cosh.html#jax.lax.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise hyperbolic cosine: :math:`\mathrm{cosh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">cosh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise inverse hyperbolic sine: :math:`\mathrm{asinh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">asinh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise inverse hyperbolic cosine: :math:`\mathrm{acosh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">acosh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elementwise inverse hyperbolic tangent: :math:`\mathrm{atanh}(x)`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">atanh_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># Add some methods to ShapedArray that rely on lax primitives</span>

<span class="n">ShapedArray</span><span class="o">.</span><span class="n">broadcast</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span>
<span class="n">ShapedArray</span><span class="o">.</span><span class="n">transpose</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>  <span class="c1"># clobbered by lax_numpy</span>
<span class="n">ShapedArray</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">reshape</span><span class="p">)</span>      <span class="c1"># clobbered by lax_numpy</span>

<span class="k">def</span> <span class="nf">_iter</span><span class="p">(</span><span class="n">tracer</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">tracer</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;iteration over a 0-d array&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tracer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tracer</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">slicing</span><span class="o">.</span><span class="n">dynamic_index_in_dim</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">slicing</span><span class="o">.</span><span class="n">index_in_dim</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="n">ShapedArray</span><span class="o">.</span><span class="n">_iter</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
<span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="o">.</span><span class="n">_iter</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>

<span class="c1"># Add some ad handlers that use (or could use) lax primitives</span>

<span class="k">def</span> <span class="nf">zeros_like_array</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
    <span class="n">dtypes</span><span class="o">.</span><span class="n">python_scalar_dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">array_types</span><span class="p">,</span>
    <span class="n">device_array</span><span class="o">.</span><span class="n">device_array_types</span><span class="p">,</span>
    <span class="p">[</span><span class="n">pxla</span><span class="o">.</span><span class="n">ShardedDeviceArray</span><span class="p">,</span> <span class="n">pxla</span><span class="o">.</span><span class="n">_ShardedDeviceArray</span><span class="p">,</span>
     <span class="n">pxla</span><span class="o">.</span><span class="n">pmap_lib</span><span class="o">.</span><span class="n">ShardedDeviceArray</span><span class="p">]):</span>
  <span class="n">ad_util</span><span class="o">.</span><span class="n">jaxval_adders</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">add</span>
<span class="n">ad_util</span><span class="o">.</span><span class="n">jaxval_zeros_likers</span><span class="p">[</span><span class="n">device_array</span><span class="o">.</span><span class="n">_DeviceArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros_like_array</span>
<span class="n">ad_util</span><span class="o">.</span><span class="n">jaxval_zeros_likers</span><span class="p">[</span><span class="n">device_array</span><span class="o">.</span><span class="n">Buffer</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros_like_array</span>
<span class="n">ad_util</span><span class="o">.</span><span class="n">jaxval_zeros_likers</span><span class="p">[</span><span class="n">pxla</span><span class="o">.</span><span class="n">ShardedDeviceArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros_like_array</span>
<span class="n">ad_util</span><span class="o">.</span><span class="n">jaxval_zeros_likers</span><span class="p">[</span><span class="n">pxla</span><span class="o">.</span><span class="n">pmap_lib</span><span class="o">.</span><span class="n">ShardedDeviceArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros_like_array</span>


<span class="c1">### primitives</span>


<span class="n">_fixed_dtype</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">_complex_basetype</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>

<span class="n">_strip_weak_type</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">:</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">unop_dtype_rule</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">accepted_dtypes</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> does not accept dtype </span><span class="si">{}</span><span class="s1">. Accepted dtypes are subtypes of </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">accepted_typenames</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">accepted_dtypes</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">accepted_typenames</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">result_dtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unop</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="n">dtype_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">unop_dtype_rule</span><span class="p">,</span> <span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">weak_type_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_naryop_weak_type_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">prim</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_attrgetter</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">),</span> <span class="n">dtype_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                            <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">weak_type_rule</span><span class="p">)</span>
  <span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">prim</span><span class="p">)</span>
  <span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">prim</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">prim</span>
<span class="n">standard_unop</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">unop</span><span class="p">,</span> <span class="n">_identity</span><span class="p">)</span>
<span class="n">_attrgetter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">naryop_dtype_rule</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">aval_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">aval_dtype</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">aval_dtypes</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">)):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval_dtype</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">aval_dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Called </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with a float0 at position </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;float0s do not support any operations by design, because they &quot;</span>
            <span class="s2">&quot;are not compatible with non-trivial vector spaces. No implicit dtype &quot;</span>
            <span class="s2">&quot;conversion is done. You can use np.zeros_like(arr, dtype=np.float) &quot;</span>
            <span class="s2">&quot;to cast a float0 array to a regular zeros array. </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;If you didn&#39;t expect to get a float0 you might have accidentally &quot;</span>
            <span class="s2">&quot;taken a gradient with respect to an integer argument.&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> does not accept dtype </span><span class="si">{}</span><span class="s1"> at position </span><span class="si">{}</span><span class="s1">. &#39;</span>
               <span class="s1">&#39;Accepted dtypes at position </span><span class="si">{}</span><span class="s1"> are subtypes of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">aval_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">typenames</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">typenames</span><span class="p">))</span>
  <span class="n">_check_same_dtypes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">aval_dtypes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result_dtype</span><span class="p">(</span><span class="o">*</span><span class="n">avals</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">broadcasting_shape_rule</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">avals</span><span class="p">):</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals</span> <span class="k">if</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">()</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: arrays must have same number of dimensions, got </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)))))</span>
  <span class="c1"># TODO(mattjj): de-duplicate with _try_broadcast_shapes</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">same_referent</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="c1"># if all axes are identical objects, the resulting size is the object</span>
      <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># if all dims are equal (or 1), the result is the non-1 size</span>
      <span class="n">non_1s</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">non_1s</span><span class="p">:</span>
        <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">non_1s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_1s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">result_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_1s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> got incompatible shapes for broadcasting: &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)))</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_naryop_weak_type_rule</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">aval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="k">if</span> <span class="n">aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Called </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with a float0 at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">. &quot;</span>
        <span class="s2">&quot;float0s do not support any operations by design, because they &quot;</span>
        <span class="s2">&quot;are not compatible with non-trivial vector spaces. No implicit dtype &quot;</span>
        <span class="s2">&quot;conversion is done. You can use np.zeros_like(arr, dtype=np.float) &quot;</span>
        <span class="s2">&quot;to cast a float0 array to a regular zeros array. </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;If you didn&#39;t expect to get a float0 you might have accidentally &quot;</span>
        <span class="s2">&quot;taken a gradient with respect to an integer argument.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">avals</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">naryop</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="n">dtype_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">naryop_dtype_rule</span><span class="p">,</span> <span class="n">result_dtype</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">shape_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">broadcasting_shape_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">weak_type_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_naryop_weak_type_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">prim</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">shape_rule</span><span class="p">,</span> <span class="n">dtype_rule</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                            <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">weak_type_rule</span><span class="p">)</span>
  <span class="n">batching</span><span class="o">.</span><span class="n">defbroadcasting</span><span class="p">(</span><span class="n">prim</span><span class="p">)</span>
  <span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">prim</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">prim</span>
<span class="n">standard_naryop</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">naryop</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_broadcast_translate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Variant of _standard_translate that performs explicit broadcasting.</span>

<span class="sd">  Not all XLA library functions perform their own broadcasting.&quot;&quot;&quot;</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">avals_out</span>
  <span class="n">broadcasted_args</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">aval_in</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avals_in</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">aval_in</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="n">bcast_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval_in</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                               <span class="nb">len</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
      <span class="n">arg</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">BroadcastInDim</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcast_dims</span><span class="p">)</span>
    <span class="n">broadcasted_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">broadcasted_args</span><span class="p">)]</span>


<span class="c1"># Like autograd.numpy.numpy_vjps.unbroadcast, this utility handles transposition</span>
<span class="c1"># involving linear primitives with implicit broadcasting.</span>
<span class="k">def</span> <span class="nf">_unbroadcast</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;transpose with implicit broadcasting of unshaped values&quot;</span><span class="p">)</span>
  <span class="n">x_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">))))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_enable_checks</span><span class="p">:</span> <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">_reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dims</span><span class="p">),</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_maybe_broadcast</span><span class="p">(</span><span class="n">target_shape</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">x_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="n">x_shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">,</span> <span class="p">())</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
    <span class="n">squeeze_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">squeeze_shape</span><span class="p">),</span> <span class="n">target_shape</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">broadcast_mhlo</span><span class="p">(</span>
    <span class="n">aval_out</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="n">avals</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">],</span>
    <span class="n">args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]:</span>
  <span class="sd">&quot;&quot;&quot;Broadcasts MHLO values with broadcast-compatible shapes to the same shape.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">aval</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">aval_out</span><span class="p">)</span>
      <span class="n">dims</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span>
          <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
      <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DynamicBroadcastInDimOp</span><span class="p">(</span>
            <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">arg</span><span class="p">,</span>
            <span class="n">mlir</span><span class="o">.</span><span class="n">shape_tensor</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">BroadcastInDimOp</span><span class="p">(</span>
            <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="n">arg</span><span class="p">,</span>
            <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">_nary_lower_mhlo</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span>
                     <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">]],</span>
                     <span class="n">explicit_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Lowers an elementwise operator to its MHLO/CHLO equivalent.</span>

<span class="sd">  Args:</span>
<span class="sd">    explicit_type: does the MHLO/CHLO operator require its output type to be</span>
<span class="sd">      provided?</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">del</span> <span class="n">params</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="p">(</span><span class="n">aval_out</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="n">substitute</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_substitute_axis_sizes_in_aval</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">axis_size_env</span><span class="p">)</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">substitute</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">)</span>
    <span class="n">aval_out</span> <span class="o">=</span> <span class="n">substitute</span><span class="p">(</span><span class="n">aval_out</span><span class="p">)</span>
  <span class="n">broadcasted_args</span> <span class="o">=</span> <span class="n">broadcast_mhlo</span><span class="p">(</span><span class="n">aval_out</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">explicit_type</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="o">*</span><span class="n">broadcasted_args</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">broadcasted_args</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="k">def</span> <span class="nf">_substitute_axis_sizes_in_aval</span><span class="p">(</span>
    <span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Var</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">a</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractValue</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
  <span class="k">return</span> <span class="n">a</span>


<span class="n">_float</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">}</span>
<span class="n">_complex</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">}</span>
<span class="n">_complex_elem_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">}</span>
<span class="n">_int</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">}</span>
<span class="n">_bool</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">}</span>

<span class="n">_num</span> <span class="o">=</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span>
<span class="n">_any</span> <span class="o">=</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span> <span class="o">|</span> <span class="n">_bool</span>
<span class="n">_bool_or_int</span> <span class="o">=</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_bool</span>
<span class="n">_ordered</span> <span class="o">=</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_bool</span>

<span class="n">neg_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_num</span><span class="p">,</span> <span class="s1">&#39;neg&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">neg_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="p">:</span> <span class="p">[</span><span class="n">neg</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">neg_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">NegOp</span><span class="p">))</span>

<span class="n">sign_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_num</span><span class="p">,</span> <span class="s1">&#39;sign&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">sign_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_sign_lower_mhlo</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">x_aval</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SelectOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">compare_mhlo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">full_like_aval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_aval</span><span class="p">),</span> <span class="s1">&#39;EQ&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;UNSIGNED&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">full_like_aval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_aval</span><span class="p">),</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">full_like_aval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_aval</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SignOp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sign_p</span><span class="p">,</span> <span class="n">_sign_lower_mhlo</span><span class="p">)</span>

<span class="n">nextafter_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;nextafter&#39;</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">nextafter_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">NextAfterOp</span><span class="p">))</span>

<span class="n">floor_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">floor_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">floor_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">FloorOp</span><span class="p">))</span>

<span class="n">ceil_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">ceil_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">ceil_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">CeilOp</span><span class="p">))</span>

<span class="n">round_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;round&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">round_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_round_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rounding_method</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">rounding_method</span> <span class="ow">is</span> <span class="n">RoundingMethod</span><span class="o">.</span><span class="n">AWAY_FROM_ZERO</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RoundOp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">rounding_method</span> <span class="ow">is</span> <span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RoundNearestEvenOp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">round_p</span><span class="p">,</span> <span class="n">_round_lower</span><span class="p">)</span>

<span class="n">is_finite_p</span> <span class="o">=</span> <span class="n">unop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;is_finite&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">is_finite_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">is_finite_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">IsFiniteOp</span><span class="p">))</span>

<span class="n">exp_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">exp_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">))</span>
<span class="c1"># For exp_p it is more efficient to use the reconstructed output for the vjp</span>
<span class="c1"># rule instead of computing it again from the input.</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">exp_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ExpOp</span><span class="p">))</span>

<span class="n">log_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">log_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">div</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">log_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">LogOp</span><span class="p">))</span>

<span class="n">expm1_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;expm1&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">expm1_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">_one</span><span class="p">(</span><span class="n">ans</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">expm1_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">Expm1Op</span><span class="p">))</span>

<span class="n">log1p_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;log1p&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">log1p_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">div</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">log1p_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">Log1pOp</span><span class="p">))</span>

<span class="n">tanh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">tanh_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">)),</span>
                                         <span class="n">sub</span><span class="p">(</span><span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ans</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">tanh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">TanhOp</span><span class="p">))</span>

<span class="n">logistic_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;logistic&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">logistic_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">sub</span><span class="p">(</span><span class="n">_one</span><span class="p">(</span><span class="n">ans</span><span class="p">),</span> <span class="n">ans</span><span class="p">))))</span>
<span class="c1"># TODO(phawkins): switch to mhlo.logistic lowering; debug numerical problems.</span>
<span class="c1"># mlir.register_lowering(logistic_p, partial(_nary_lower_mhlo, mhlo.LogisticOp))</span>

<span class="k">def</span> <span class="nf">logistic_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">one</span> <span class="o">=</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">logistic_p</span><span class="p">,</span>
                       <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">logistic_impl</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

<span class="n">sin_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">sin_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sin_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SineOp</span><span class="p">))</span>

<span class="n">cos_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">cos_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">neg</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">cos_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">CosineOp</span><span class="p">))</span>

<span class="nd">@_upcast_fp16_for_computation</span>
<span class="k">def</span> <span class="nf">_tan_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="n">tan_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">tan_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">ans</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">tan_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">TanOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">asin_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="n">asinh</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="n">x</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
               <span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))))))</span>

<span class="n">asin_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">asin_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">rsqrt</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
<span class="k">if</span> <span class="n">mlir_api_version</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">asin_p</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">asin_impl</span><span class="p">,</span>
                                                <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">asin_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">AsinOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">acos_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="n">acosh</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="c1"># By convention, numpy chooses the branch with positive real part.</span>
    <span class="n">rpart</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">select</span><span class="p">(</span>
      <span class="n">gt</span><span class="p">(</span><span class="n">rpart</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">rpart</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
      <span class="n">result</span><span class="p">,</span>
      <span class="n">neg</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">select</span><span class="p">(</span>
        <span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)),</span>
        <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">atan2</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">add</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">))),</span>
        <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

<span class="n">acos_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;acos&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">acos_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">-</span><span class="n">rsqrt</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">acos_p</span><span class="p">,</span>
                       <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">acos_impl</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">atan_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">atan_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">atan_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">div</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="k">if</span> <span class="n">mlir_api_version</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">atan_p</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">atan_impl</span><span class="p">,</span>
                                                <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">atan_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">AtanOp</span><span class="p">))</span>

<span class="n">atan2_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">],</span> <span class="s1">&#39;atan2&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">atan2_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">g</span> <span class="o">*</span> <span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">atan2_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">Atan2Op</span><span class="p">))</span>

<span class="n">sinh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">sinh_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sinh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">SinhOp</span><span class="p">))</span>

<span class="n">cosh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">cosh_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">cosh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">CoshOp</span><span class="p">))</span>

<span class="n">asinh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">asinh_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">rsqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">asinh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">AsinhOp</span><span class="p">))</span>

<span class="n">acosh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">acosh_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">rsqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">)))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">acosh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">AcoshOp</span><span class="p">))</span>

<span class="n">atanh_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">atanh_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">),</span> <span class="n">div</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">atanh_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">AtanhOp</span><span class="p">))</span>

<span class="n">regularized_incomplete_beta_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">(</span>
    <span class="p">[</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;regularized_incomplete_beta&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span>
    <span class="n">regularized_incomplete_beta_p</span><span class="p">,</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">_broadcast_translate</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">RegularizedIncompleteBeta</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">betainc_gradx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">lbeta</span> <span class="o">=</span> <span class="n">lgamma</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">lgamma</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">lgamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">partial_x</span> <span class="o">=</span> <span class="n">exp</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">lbeta</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">partial_x</span> <span class="o">*</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">betainc_grad_not_implemented</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Betainc gradient with respect to a and b not supported.&quot;</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">regularized_incomplete_beta_p</span><span class="p">,</span>
  <span class="n">betainc_grad_not_implemented</span><span class="p">,</span>
  <span class="n">betainc_grad_not_implemented</span><span class="p">,</span>
  <span class="n">betainc_gradx</span><span class="p">)</span>

<span class="n">lgamma_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;lgamma&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">lgamma_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">digamma</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">lgamma_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">LgammaOp</span><span class="p">))</span>

<span class="n">digamma_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;digamma&#39;</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">digamma_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">DigammaOp</span><span class="p">))</span>

<span class="n">igamma_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;igamma&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">igamma_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_broadcast_translate</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Igamma</span><span class="p">))</span>
<span class="n">igamma_grad_a_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;igamma_grad_a&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">igamma_grad_a_p</span><span class="p">,</span>
                         <span class="n">partial</span><span class="p">(</span><span class="n">_broadcast_translate</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">IgammaGradA</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">igamma_gradx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">g</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">_ones</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">lgamma</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">igamma_grada</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">g</span> <span class="o">*</span> <span class="n">igamma_grad_a</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">igamma_p</span><span class="p">,</span> <span class="n">igamma_grada</span><span class="p">,</span> <span class="n">igamma_gradx</span><span class="p">)</span>

<span class="n">igammac_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;igammac&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">igammac_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_broadcast_translate</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">Igammac</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">igammac_gradx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">igamma_gradx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">igammac_grada</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">igamma_grada</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">igammac_p</span><span class="p">,</span> <span class="n">igammac_grada</span><span class="p">,</span> <span class="n">igammac_gradx</span><span class="p">)</span>

<span class="n">random_gamma_grad_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span><span class="p">,</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;random_gamma_grad&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">random_gamma_grad_p</span><span class="p">,</span>
                         <span class="n">partial</span><span class="p">(</span><span class="n">_broadcast_translate</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">RandomGammaGrad</span><span class="p">))</span>
<span class="n">bessel_i0e_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;bessel_i0e&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">bessel_i0e_p</span><span class="p">,</span> <span class="n">standard_translate</span><span class="p">(</span><span class="n">bessel_i0e_p</span><span class="p">))</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">bessel_i0e_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_i1e</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">))</span>

<span class="n">bessel_i1e_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;bessel_i1e&#39;</span><span class="p">)</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">,</span> <span class="n">standard_translate</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">))</span>
<span class="k">if</span> <span class="n">mlir_api_version</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">:</span>
  <span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">,</span> <span class="n">standard_translate</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">,</span>
                         <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">BesselI1eOp</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_bessel_i1e_jvp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">eps</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">eps</span>
  <span class="n">x_is_not_tiny</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span>
  <span class="n">safe_x</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">x_is_not_tiny</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
  <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">bessel_i0e</span><span class="p">(</span><span class="n">safe_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">safe_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">reciprocal</span><span class="p">(</span><span class="n">safe_x</span><span class="p">))</span>
  <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">x_is_not_tiny</span><span class="p">,</span> <span class="n">dy_dx</span><span class="p">,</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">g</span> <span class="o">*</span> <span class="n">dy_dx</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">bessel_i1e_p</span><span class="p">,</span> <span class="n">_bessel_i1e_jvp</span><span class="p">)</span>

<span class="n">erf_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;erf&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">erf_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)),</span>
                                  <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">erf_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">ErfOp</span><span class="p">))</span>

<span class="n">erfc_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;erfc&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">erfc_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)),</span>
                                   <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">erfc_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">chlo</span><span class="o">.</span><span class="n">ErfcOp</span><span class="p">))</span>

<span class="n">erf_inv_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;erf_inv&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">erf_inv_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">),</span>
                                            <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">ans</span><span class="p">)))))</span>
<span class="n">xla</span><span class="o">.</span><span class="n">register_translation</span><span class="p">(</span><span class="n">erf_inv_p</span><span class="p">,</span> <span class="n">standard_translate</span><span class="p">(</span><span class="n">erf_inv_p</span><span class="p">))</span>

<span class="n">real_p</span> <span class="o">=</span> <span class="n">unop</span><span class="p">(</span><span class="n">_complex_basetype</span><span class="p">,</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">real_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)))])</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">real_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RealOp</span><span class="p">))</span>

<span class="n">imag_p</span> <span class="o">=</span> <span class="n">unop</span><span class="p">(</span><span class="n">_complex_basetype</span><span class="p">,</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">imag_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">neg</span><span class="p">(</span><span class="n">t</span><span class="p">))])</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">imag_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ImagOp</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_complex_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">_unbroadcast</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">imag</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">t</span><span class="p">)))]</span>
  <span class="k">elif</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="kc">None</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">_unbroadcast</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">imag</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">t</span><span class="p">)))]</span>

<span class="n">_complex_dtype</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">complex_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_complex_dtype</span><span class="p">,</span> <span class="p">[</span><span class="n">_complex_elem_types</span><span class="p">,</span> <span class="n">_complex_elem_types</span><span class="p">],</span>
                  <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">complex_p</span><span class="p">,</span> <span class="n">_complex_transpose_rule</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">complex_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ComplexOp</span><span class="p">))</span>

<span class="n">conj_p</span> <span class="o">=</span> <span class="n">unop</span><span class="p">(</span><span class="n">_complex_dtype</span><span class="p">,</span> <span class="n">_complex_elem_types</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;conj&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_conj_impl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">conj_p</span><span class="p">,</span>
                       <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">_conj_impl</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_conj_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">input_dtype</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">real</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>

<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">conj_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">linear_jvp</span><span class="p">,</span> <span class="n">conj_p</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">conj_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_conj_transpose_rule</span>

<span class="n">abs_p</span> <span class="o">=</span> <span class="n">unop</span><span class="p">(</span><span class="n">_complex_basetype</span><span class="p">,</span> <span class="n">_num</span><span class="p">,</span> <span class="s1">&#39;abs&#39;</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">abs_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AbsOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_abs_jvp_rule</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">_iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_maybe_real</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">_maybe_conj</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
           <span class="n">_replace_zero</span><span class="p">(</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))))))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">g</span><span class="p">,</span> <span class="n">neg</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">abs_p</span><span class="p">,</span> <span class="n">_abs_jvp_rule</span><span class="p">)</span>
<span class="n">_maybe_conj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">_iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
<span class="n">_maybe_real</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">_iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>

<span class="n">sqrt_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">sqrt_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">ans</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sqrt_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SqrtOp</span><span class="p">))</span>

<span class="n">rsqrt_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;rsqrt&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">rsqrt_p</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span>
           <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">div</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">rsqrt_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RsqrtOp</span><span class="p">))</span>

<span class="n">cbrt_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;cbrt&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">cbrt_p</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">),</span> <span class="n">integer_pow</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">cbrt_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">CbrtOp</span><span class="p">))</span>

<span class="n">pow_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">],</span> <span class="s1">&#39;pow&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_pow_jvp_lhs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sub</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">_ones</span><span class="p">(</span><span class="n">y</span><span class="p">)))))</span>

<span class="k">def</span> <span class="nf">_pow_jvp_rhs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">_replace_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">ans</span><span class="p">))</span>

<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">pow_p</span><span class="p">,</span> <span class="n">_pow_jvp_lhs</span><span class="p">,</span> <span class="n">_pow_jvp_rhs</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">pow_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">PowOp</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_integer_pow_dtype_rule</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">unop_dtype_rule</span><span class="p">(</span><span class="n">_identity</span><span class="p">,</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span> <span class="o">|</span> <span class="n">_complex</span><span class="p">,</span> <span class="s1">&#39;integer_pow&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Integers cannot be raised to negative powers, got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;integer_pow(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_integer_pow_jvp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>

<span class="n">integer_pow_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
  <span class="n">_attrgetter</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">),</span> <span class="n">_integer_pow_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;integer_pow&#39;</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">integer_pow_p</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">integer_pow_p</span><span class="p">,</span> <span class="n">_integer_pow_jvp</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">integer_pow_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="c1"># This should be kept in sync with the jax2tf translation rule.</span>
  <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">is_reciprocal</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="n">is_reciprocal</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span>
  <span class="n">acc</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">while</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">acc</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">acc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mul</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># We don&#39;t call square because it calls integer_pow.</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">full_like</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">acc</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_reciprocal</span> <span class="k">else</span> <span class="n">acc</span>


<span class="k">def</span> <span class="nf">_integer_pow_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">lowering</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">_integer_pow</span><span class="p">,</span> <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="c1"># TODO(b/217551391): emitting an out-of-line call leads to a large</span>
  <span class="c1"># expansion when the MHLO is lowered to HLO, because the HLO lowering</span>
  <span class="c1"># clones the callee. Consider unconditionally caching when the MHLO-&gt;HLO</span>
  <span class="c1"># lowering doesn&#39;t expand the program.</span>
  <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">lowering</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">cache_lowering</span><span class="p">(</span><span class="n">lowering</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">integer_pow_p</span><span class="p">,</span> <span class="n">_integer_pow_lowering</span><span class="p">)</span>

<span class="n">_replace_zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">select</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">_ones</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>

<span class="n">not_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_bool_or_int</span><span class="p">,</span> <span class="s1">&#39;not&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">not_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">not_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">NotOp</span><span class="p">))</span>

<span class="n">and_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_bool_or_int</span><span class="p">,</span> <span class="n">_bool_or_int</span><span class="p">],</span> <span class="s1">&#39;and&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">and_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">and_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AndOp</span><span class="p">))</span>

<span class="n">or_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_bool_or_int</span><span class="p">,</span> <span class="n">_bool_or_int</span><span class="p">],</span> <span class="s1">&#39;or&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">or_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">or_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">OrOp</span><span class="p">))</span>

<span class="n">xor_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_bool_or_int</span><span class="p">,</span> <span class="n">_bool_or_int</span><span class="p">],</span> <span class="s1">&#39;xor&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">xor_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">xor_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">XorOp</span><span class="p">))</span>

<span class="n">population_count_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_int</span><span class="p">,</span> <span class="s1">&#39;population_count&#39;</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">population_count_p</span><span class="p">,</span>
                       <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">PopulationCountOp</span><span class="p">))</span>

<span class="n">clz_p</span> <span class="o">=</span> <span class="n">standard_unop</span><span class="p">(</span><span class="n">_int</span><span class="p">,</span> <span class="s1">&#39;clz&#39;</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">clz_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ClzOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_add_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">xdot</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">primal_out</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xdot</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">primal_out</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xdot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">primal_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ydot</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">primal_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">xdot</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">xdot</span><span class="p">,</span> <span class="n">ydot</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_add_transpose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="c1"># Morally the following assertion is true, but because we instantiate zeros in</span>
  <span class="c1"># some places (e.g. in custom_jvp) it may not always hold. For example, see</span>
  <span class="c1"># api_test.py&#39;s CustomJVPTest.test_jaxpr_zeros.</span>
  <span class="c1"># assert ad.is_undefined_primal(x) and ad.is_undefined_primal(y)</span>
  <span class="n">x_aval</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">_abstractify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">y_aval</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">aval</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">_abstractify</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x_aval</span><span class="p">),</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">y_aval</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x_aval</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">_unbroadcast</span><span class="p">(</span><span class="n">y_aval</span><span class="p">,</span> <span class="n">t</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_add_inverse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">xr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">y</span>
  <span class="n">yr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span>

<span class="c1"># TODO(slebedev): Why does mypy fail to infer the type here?</span>
<span class="n">add_p</span><span class="p">:</span> <span class="n">Primitive</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_num</span><span class="p">,</span> <span class="n">_num</span><span class="p">],</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_add_jvp</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">add_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_add_transpose</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">add_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AddOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_sub_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">xdot</span><span class="p">,</span> <span class="n">ydot</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">primal_out</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xdot</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">primal_out</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xdot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">primal_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">neg</span><span class="p">(</span><span class="n">ydot</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">ydot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">primal_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">xdot</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">sub</span><span class="p">(</span><span class="n">xdot</span><span class="p">,</span> <span class="n">ydot</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_sub_transpose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="c1"># Morally the following assertion is true, but see the comment in add_p&#39;s</span>
  <span class="c1"># transpose rule.</span>
  <span class="c1"># assert ad.is_undefined_primal(x) and ad.is_undefined_primal(y)</span>
  <span class="n">x_aval</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">aval</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">_abstractify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">y_aval</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">aval</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">_abstractify</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x_aval</span><span class="p">),</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">y_aval</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x_aval</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">_unbroadcast</span><span class="p">(</span><span class="n">y_aval</span><span class="p">,</span> <span class="n">neg</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>

<span class="n">sub_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_num</span><span class="p">,</span> <span class="n">_num</span><span class="p">],</span> <span class="s1">&#39;sub&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">sub_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sub_jvp</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">sub_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sub_transpose</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sub_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SubtractOp</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_mul_transpose</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">^</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="kc">None</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">_unbroadcast</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ct</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">_mul_inverse</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">xr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">y</span>
  <span class="n">yr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span>

<span class="n">mul_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_num</span><span class="p">,</span> <span class="n">_num</span><span class="p">],</span> <span class="s1">&#39;mul&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">mul_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">xdot</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">xdot</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
          <span class="k">lambda</span> <span class="n">ydot</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ydot</span><span class="p">))</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">mul_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_mul_transpose</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">mul_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">MulOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_div_transpose_rule</span><span class="p">(</span><span class="n">cotangent</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cotangent</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_unbroadcast</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">cotangent</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">div_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_num</span><span class="p">,</span> <span class="n">_num</span><span class="p">],</span> <span class="s1">&#39;div&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">div_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">div</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">integer_pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">div_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_div_transpose_rule</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">div_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DivOp</span><span class="p">))</span>

<span class="n">rem_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span><span class="p">,</span> <span class="n">_int</span> <span class="o">|</span> <span class="n">_float</span><span class="p">],</span> <span class="s1">&#39;rem&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span>
    <span class="n">rem_p</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">g</span><span class="p">),</span>
    <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">mul</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">floor</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))))))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">rem_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RemOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_minmax_complex_lowering</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lax_cmp_pick_x</span><span class="p">):</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">_maybe_broadcast</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">rx</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">ry</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="n">pick_x</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">),</span> <span class="n">lax_cmp_pick_x</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
                  <span class="n">lax_cmp_pick_x</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">pick_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">max_p</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span> <span class="s1">&#39;max&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">max_p</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_balanced_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_balanced_eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">max_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">max_mhlo</span><span class="p">))</span>

<span class="n">min_p</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span> <span class="s1">&#39;min&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">min_p</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_balanced_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
           <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_balanced_eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">min_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">min_mhlo</span><span class="p">))</span>

<span class="n">shift_left_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_int</span><span class="p">,</span> <span class="n">_int</span><span class="p">],</span> <span class="s1">&#39;shift_left&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">shift_left_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">shift_left_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ShiftLeftOp</span><span class="p">))</span>

<span class="n">shift_right_arithmetic_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_int</span><span class="p">,</span> <span class="n">_int</span><span class="p">],</span> <span class="s1">&#39;shift_right_arithmetic&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">shift_right_arithmetic_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">shift_right_arithmetic_p</span><span class="p">,</span>
                       <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ShiftRightArithmeticOp</span><span class="p">))</span>

<span class="n">shift_right_logical_p</span> <span class="o">=</span> <span class="n">standard_naryop</span><span class="p">([</span><span class="n">_int</span><span class="p">,</span> <span class="n">_int</span><span class="p">],</span> <span class="s1">&#39;shift_right_logical&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">shift_right_logical_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">shift_right_logical_p</span><span class="p">,</span>
                       <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ShiftRightLogicalOp</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_compare_lower_mhlo</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">avals_in</span><span class="p">,</span> <span class="p">(</span><span class="n">aval_out</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="n">substitute</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_substitute_axis_sizes_in_aval</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">axis_size_env</span><span class="p">)</span>
    <span class="n">avals_in</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">substitute</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">)</span>
    <span class="n">aval_out</span> <span class="o">=</span> <span class="n">substitute</span><span class="p">(</span><span class="n">aval_out</span><span class="p">)</span>
  <span class="n">x_aval</span><span class="p">,</span> <span class="n">y_aval</span> <span class="o">=</span> <span class="n">avals_in</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">broadcast_mhlo</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="s2">&quot;FLOAT&quot;</span>
  <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">):</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="s2">&quot;SIGNED&quot;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="s2">&quot;UNSIGNED&quot;</span>
  <span class="k">return</span> <span class="n">mlir</span><span class="o">.</span><span class="n">compare_mhlo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">compare_type</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="n">eq_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span> <span class="s1">&#39;eq&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">eq_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">eq_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;EQ&quot;</span><span class="p">))</span>

<span class="n">ne_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span> <span class="s1">&#39;ne&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">ne_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">ne_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;NE&quot;</span><span class="p">))</span>

<span class="n">ge_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_ordered</span><span class="p">,</span> <span class="n">_ordered</span><span class="p">],</span> <span class="s1">&#39;ge&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">ge_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">ge_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;GE&quot;</span><span class="p">))</span>

<span class="n">gt_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_ordered</span><span class="p">,</span> <span class="n">_ordered</span><span class="p">],</span> <span class="s1">&#39;gt&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">gt_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">gt_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;GT&quot;</span><span class="p">))</span>

<span class="n">le_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_ordered</span><span class="p">,</span> <span class="n">_ordered</span><span class="p">],</span> <span class="s1">&#39;le&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">le_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">le_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;LE&quot;</span><span class="p">))</span>

<span class="n">lt_p</span> <span class="o">=</span> <span class="n">naryop</span><span class="p">(</span><span class="n">_fixed_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="p">[</span><span class="n">_ordered</span><span class="p">,</span> <span class="n">_ordered</span><span class="p">],</span> <span class="s1">&#39;lt&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">lt_p</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">lt_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_compare_lower_mhlo</span><span class="p">,</span> <span class="s2">&quot;LT&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_convert_element_type_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span>

<span class="k">def</span> <span class="nf">_convert_element_type_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">new_dtype</span>

<span class="k">def</span> <span class="nf">_convert_element_type_weak_type_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">weak_type</span>

<span class="k">def</span> <span class="nf">_convert_element_type_transpose_rule</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="n">old_dtype</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span>
  <span class="n">old_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="n">old_dtype</span><span class="p">)</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">old_dtype</span><span class="p">,</span>
                                        <span class="n">weak_type</span><span class="o">=</span><span class="n">old_weak_type</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_convert_element_type_jvp_rule</span><span class="p">(</span><span class="n">tangent</span><span class="p">,</span> <span class="n">operand</span> <span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">primal_dtype_to_tangent_dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">tangent</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">tangent</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">,</span>
                                       <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_convert_elt_type_folding_rule</span><span class="p">(</span><span class="n">consts</span><span class="p">,</span> <span class="n">eqn</span><span class="p">):</span>
  <span class="c1"># We constant-fold convert_element_types applied to constants if those</span>
  <span class="c1"># constants are Python builtin numeric types or numpy.ndarrays (so as not</span>
  <span class="c1"># to perform any device operations when constant-folding) and if the output</span>
  <span class="c1"># type can be faithfully represented by a Python builtin numeric type or</span>
  <span class="c1"># numpy.ndarray. If those conditions are met, we output a numpy.ndarray</span>
  <span class="c1"># constant if the output type is not weak, and if the output type is weak then</span>
  <span class="c1"># we output a Python builtin numeric type.</span>
  <span class="c1"># TODO(mattjj): allow constant-folding CPU-backed JAX arrays</span>
  <span class="n">c</span><span class="p">,</span> <span class="o">=</span> <span class="n">consts</span>
  <span class="n">o</span><span class="p">,</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">dtypes</span><span class="o">.</span><span class="n">python_scalar_dtypes</span><span class="p">}</span> <span class="ow">and</span>
      <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">UnshapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;new_dtype&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="kc">None</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">out</span><span class="p">],</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">eqn</span>

<span class="k">def</span> <span class="nf">_convert_elt_type_fwd_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">):</span>
  <span class="n">v</span><span class="p">,</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;new_dtype&#39;</span><span class="p">]</span> <span class="ow">and</span>
      <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span> <span class="o">==</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;weak_type&#39;</span><span class="p">]):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="kc">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">eqn</span>

<span class="k">def</span> <span class="nf">_convert_elt_type_pp_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
  <span class="c1"># don&#39;t print new_dtype because the output binder shows it, don&#39;t print</span>
  <span class="c1"># weak_type when false</span>
  <span class="n">printed_params</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;weak_type&#39;</span><span class="p">]:</span>
    <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;weak_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
         <span class="n">core</span><span class="o">.</span><span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">printed_params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">]</span>


<span class="n">convert_element_type_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;convert_element_type&#39;</span><span class="p">)</span>
<span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">convert_element_type_p</span><span class="p">))</span>
<span class="n">convert_element_type_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">standard_abstract_eval</span><span class="p">,</span> <span class="n">convert_element_type_p</span><span class="p">,</span>
            <span class="n">_convert_element_type_shape_rule</span><span class="p">,</span> <span class="n">_convert_element_type_dtype_rule</span><span class="p">,</span>
            <span class="n">_convert_element_type_weak_type_rule</span><span class="p">,</span> <span class="n">standard_named_shape_rule</span><span class="p">))</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">convert_element_type_p</span><span class="p">,</span> <span class="n">_convert_element_type_jvp_rule</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">convert_element_type_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_element_type_transpose_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">convert_element_type_p</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">const_fold_rules</span><span class="p">[</span><span class="n">convert_element_type_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_elt_type_folding_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">forwarding_rules</span><span class="p">[</span><span class="n">convert_element_type_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_elt_type_fwd_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">convert_element_type_p</span><span class="p">)</span>
<span class="c1"># TODO(mattjj): un-comment the next line (see #9456)</span>
<span class="c1"># core.pp_eqn_rules[convert_element_type_p] = _convert_elt_type_pp_rule</span>

<span class="k">def</span> <span class="nf">_real_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_convert_element_type_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="p">):</span>
  <span class="n">aval_in</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">and</span>
      <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RealOp</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
    <span class="n">aval_in</span> <span class="o">=</span> <span class="n">aval_in</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">_real_dtype</span><span class="p">(</span><span class="n">aval_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">mlir</span><span class="o">.</span><span class="n">convert_mhlo</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">aval_in</span><span class="p">,</span> <span class="n">aval_out</span><span class="p">)]</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">convert_element_type_p</span><span class="p">,</span> <span class="n">_convert_element_type_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_bitcast_convert_type_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span>

<span class="k">def</span> <span class="nf">_bitcast_convert_type_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">):</span>
  <span class="n">old_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">old_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">old_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">old_dtype</span> <span class="o">!=</span> <span class="n">new_dtype</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`bitcast_convert_type` for operand type (</span><span class="si">{</span><span class="n">old_dtype</span><span class="si">}</span><span class="s2">) cannot have different destination type (</span><span class="si">{</span><span class="n">new_dtype</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">old_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`bitcast_convert_type` for operand type (</span><span class="si">{</span><span class="n">old_dtype</span><span class="si">}</span><span class="s2">) must have destination type (</span><span class="si">{</span><span class="n">new_dtype</span><span class="si">}</span><span class="s2">) of same size.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_dtype</span>

<span class="n">bitcast_convert_type_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_bitcast_convert_type_shape_rule</span><span class="p">,</span> <span class="n">_bitcast_convert_type_dtype_rule</span><span class="p">,</span>
    <span class="s1">&#39;bitcast_convert_type&#39;</span><span class="p">,</span> <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">bitcast_convert_type_p</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">bitcast_convert_type_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_bitcast_convert_type_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">BitcastConvertOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">operand</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">bitcast_convert_type_p</span><span class="p">,</span> <span class="n">_bitcast_convert_type_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_preferred_element_type</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">):</span>

  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
    <span class="c1"># Special-case integer-&gt;float multiply. This is allowed, and also allows</span>
    <span class="c1"># different signedness between input and output.</span>
    <span class="k">pass</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">allowed_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">allowed_types</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input type is incompatible with `preferred_element_type`. The compatible combinations of &quot;</span>
                      <span class="s2">&quot;(input_type, preferred_element_type) are (integral, integral), (integral, floating), &quot;</span>
                      <span class="s2">&quot;(floating, floating), (complex, complex.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`preferred_element_type` must have the same signedness as the original type.&quot;</span><span class="p">)</span>
  <span class="n">input_bitwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="n">preferred_bitwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="k">if</span> <span class="n">preferred_bitwidth</span> <span class="o">&lt;</span> <span class="n">input_bitwidth</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`preferred_element_type` must not be narrower than the original type.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_precision_config</span><span class="p">(</span><span class="n">precision</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="n">config</span><span class="o">.</span><span class="n">operand_precision</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">config</span><span class="o">.</span><span class="n">operand_precision</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">precision</span><span class="p">,</span> <span class="n">precision</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">config</span>
  <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">_masked</span><span class="p">(</span><span class="n">padded_value</span><span class="p">,</span> <span class="n">logical_shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Sets all padding to the given value (default is 0) in the given dimensions.</span>
<span class="sd">  All values outside the logical shape are considered padding.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">padded_value</span>

  <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">padded_value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">logical_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
           <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
  <span class="n">mask_intersection</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">mask_intersection</span> <span class="o">&amp;=</span> <span class="n">mask</span>
  <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">mask_intersection</span><span class="p">,</span> <span class="n">padded_value</span><span class="p">,</span> <span class="n">full_like</span><span class="p">(</span><span class="n">padded_value</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_dot_general_shape_rule</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                            <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]):</span>
  <span class="p">(</span><span class="n">lhs_contracting</span><span class="p">,</span> <span class="n">rhs_contracting</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">lhs_contracting</span><span class="p">,</span> <span class="n">lhs_batch</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires lhs dimension numbers to be nonnegative and &quot;</span>
           <span class="s2">&quot;less than the number of axes of the lhs value, got &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;lhs_batch of </span><span class="si">{</span><span class="n">lhs_batch</span><span class="si">}</span><span class="s2"> and lhs_contracting of </span><span class="si">{</span><span class="n">lhs_contracting</span><span class="si">}</span><span class="s2"> &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;for lhs of rank </span><span class="si">{</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">rhs_contracting</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires rhs dimension numbers to be nonnegative and &quot;</span>
           <span class="s2">&quot;less than the number of axes of the rhs value, got &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;rhs_batch of </span><span class="si">{</span><span class="n">rhs_batch</span><span class="si">}</span><span class="s2"> and rhs_contracting of </span><span class="si">{</span><span class="n">rhs_contracting</span><span class="si">}</span><span class="s2"> &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;for rhs of rank </span><span class="si">{</span><span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires equal numbers of lhs_batch and rhs_batch &quot;</span>
           <span class="s2">&quot;dimensions, got lhs_batch </span><span class="si">{}</span><span class="s2"> and rhs_batch </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">))</span>
  <span class="n">lhs_contracting_set</span><span class="p">,</span> <span class="n">lhs_batch_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_contracting</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">)</span>
  <span class="n">rhs_contracting_set</span><span class="p">,</span> <span class="n">rhs_batch_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_contracting</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_batch_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires lhs batch dimensions to be distinct, got &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;lhs_batch </span><span class="si">{</span><span class="n">lhs_batch</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_batch_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires rhs batch dimensions to be distinct, got &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;rhs_batch </span><span class="si">{</span><span class="n">rhs_batch</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_contracting_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_contracting</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires lhs contracting dimensions to be distinct, &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;got lhs_contracting </span><span class="si">{</span><span class="n">lhs_contracting</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_contracting_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_contracting</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires rhs contracting dimensions to be distinct, &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;got rhs_contracting </span><span class="si">{</span><span class="n">rhs_contracting</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">lhs_contracting_set</span> <span class="o">&amp;</span> <span class="n">lhs_batch_set</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires lhs batch dimensions to be disjoint from &quot;</span>
           <span class="s2">&quot;contracting dimensions, got lhs_batch </span><span class="si">{}</span><span class="s2"> and lhs_contracting </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">lhs_contracting</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">rhs_contracting_set</span> <span class="o">&amp;</span> <span class="n">rhs_batch_set</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires rhs batch dimensions to be disjoint from &quot;</span>
           <span class="s2">&quot;contracting dimensions, got rhs_batch </span><span class="si">{}</span><span class="s2"> and rhs_contracting </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">,</span> <span class="n">rhs_contracting</span><span class="p">))</span>
  <span class="n">lhs_batch_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs_batch</span><span class="p">)</span>
  <span class="n">rhs_batch_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rhs_batch</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">lhs_batch_shape</span><span class="p">,</span> <span class="n">rhs_batch_shape</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires lhs batch dimensions and rhs batch dimensions &quot;</span>
           <span class="s2">&quot;to have the same shape, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs_batch_shape</span><span class="p">,</span> <span class="n">rhs_batch_shape</span><span class="p">))</span>
  <span class="n">lhs_contracting_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs_contracting</span><span class="p">)</span>
  <span class="n">rhs_contracting_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rhs_contracting</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">lhs_contracting_shape</span><span class="p">,</span> <span class="n">rhs_contracting_shape</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dot_general requires contracting dimensions to have the same &quot;</span>
           <span class="s2">&quot;shape, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lhs_contracting_shape</span><span class="p">,</span> <span class="n">rhs_contracting_shape</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">_dot_general_shape_computation</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_dot_general_shape_computation</span><span class="p">(</span><span class="n">lhs_shape</span><span class="p">,</span> <span class="n">rhs_shape</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">):</span>
  <span class="p">(</span><span class="n">lhs_contracting</span><span class="p">,</span> <span class="n">rhs_contracting</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="n">batch_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lhs_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs_batch</span><span class="p">)</span>
  <span class="n">lhs_contract_or_batch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lhs_contracting</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">)))</span>
  <span class="n">lhs_tensored_shape</span> <span class="o">=</span> <span class="n">tuple_delete</span><span class="p">(</span><span class="n">lhs_shape</span><span class="p">,</span> <span class="n">lhs_contract_or_batch</span><span class="p">)</span>
  <span class="n">rhs_contract_or_batch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">rhs_contracting</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">)))</span>
  <span class="n">rhs_tensored_shape</span> <span class="o">=</span> <span class="n">tuple_delete</span><span class="p">(</span><span class="n">rhs_shape</span><span class="p">,</span> <span class="n">rhs_contract_or_batch</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">batch_shape</span> <span class="o">+</span> <span class="n">lhs_tensored_shape</span> <span class="o">+</span> <span class="n">rhs_tensored_shape</span>

<span class="k">def</span> <span class="nf">tuple_delete</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
  <span class="n">idx_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idx_</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dot_general_dtype_rule</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                            <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]):</span>
  <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">naryop_dtype_rule</span><span class="p">(</span><span class="n">_input_dtype</span><span class="p">,</span> <span class="p">[</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span> <span class="s1">&#39;dot_general&#39;</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">input_dtype</span>
  <span class="n">_validate_preferred_element_type</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">preferred_element_type</span>

<span class="k">def</span> <span class="nf">_dot_general_transpose_lhs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                               <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">],</span>
                               <span class="n">swap_ans</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x_contract</span><span class="p">,</span> <span class="n">y_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="n">x_ndim</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_batch</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_contract</span><span class="p">)</span>
  <span class="n">x_kept</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x_ndim</span><span class="p">),</span> <span class="n">x_contract</span><span class="p">,</span> <span class="n">x_batch</span><span class="p">)</span>
  <span class="n">y_kept</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">y_contract</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">swap_ans</span><span class="p">:</span>
    <span class="n">ans_batch</span><span class="p">,</span> <span class="n">ans_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ranges_like</span><span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_kept</span><span class="p">,</span> <span class="n">x_kept</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ans_batch</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ans_y</span> <span class="o">=</span> <span class="n">ranges_like</span><span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">x_kept</span><span class="p">,</span> <span class="n">y_kept</span><span class="p">)</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">ans_y</span><span class="p">,</span> <span class="n">y_kept</span><span class="p">),</span> <span class="p">(</span><span class="n">ans_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">))</span>
  <span class="n">x_contract_sorted_by_y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">x_contract</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_contract</span><span class="p">)))</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="n">out_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x_batch</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_kept</span> <span class="o">+</span> <span class="n">x_contract_sorted_by_y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">dot_general</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">),</span>
                   <span class="nb">tuple</span><span class="p">(</span><span class="n">out_axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_dot_general_transpose_rhs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                               <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]):</span>
  <span class="p">(</span><span class="n">x_contract</span><span class="p">,</span> <span class="n">y_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="n">swapped_dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">y_contract</span><span class="p">,</span> <span class="n">x_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">y_batch</span><span class="p">,</span> <span class="n">x_batch</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">_dot_general_transpose_lhs</span><span class="p">(</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">swapped_dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">,</span>
    <span class="n">swap_ans</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dot_general_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span>
                            <span class="n">precision</span><span class="p">,</span>
                            <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">]):</span>
  <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">new_dimension_numbers</span><span class="p">,</span> <span class="n">result_batch_dim</span> <span class="o">=</span> <span class="n">_dot_general_batch_dim_nums</span><span class="p">(</span>
      <span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">)</span>
  <span class="n">batched_out</span> <span class="o">=</span> <span class="n">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">new_dimension_numbers</span><span class="p">,</span>
                            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                            <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">batched_out</span><span class="p">,</span> <span class="n">result_batch_dim</span>

<span class="k">def</span> <span class="nf">_dot_general_batch_dim_nums</span><span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">):</span>
  <span class="c1"># there are three kinds of dimensions in a dot_general:</span>
  <span class="c1"># - contraction dimensions appear in lhs and rhs but not the result</span>
  <span class="c1"># - batch dimensions appear in lhs, rhs, and result</span>
  <span class="c1"># - tensor product dimensions appear in the result and one of lhs or rhs</span>
  <span class="n">lhs_ndim</span><span class="p">,</span> <span class="n">rhs_ndim</span> <span class="o">=</span> <span class="n">ndims</span>
  <span class="n">lbd</span><span class="p">,</span> <span class="n">rbd</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="k">assert</span> <span class="n">lbd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rbd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="p">(</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">rhs_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>

  <span class="k">def</span> <span class="nf">bump_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">b</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">lbd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rbd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># adding a batch dimension</span>
    <span class="n">lhs_batch</span> <span class="o">=</span> <span class="p">(</span><span class="n">lbd</span><span class="p">,)</span> <span class="o">+</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">lbd</span><span class="p">)</span>
    <span class="n">rhs_batch</span> <span class="o">=</span> <span class="p">(</span><span class="n">rbd</span><span class="p">,)</span> <span class="o">+</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">,</span> <span class="n">rbd</span><span class="p">)</span>
    <span class="n">lhs_contract</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">lbd</span><span class="p">)</span>
    <span class="n">rhs_contract</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">rhs_contract</span><span class="p">,</span> <span class="n">rbd</span><span class="p">)</span>
    <span class="n">result_batch_dim</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># adding a tensor product dimension</span>
    <span class="k">if</span> <span class="n">lbd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">other</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lhs_ndim</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs_batch</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs_contract</span><span class="p">)</span>
      <span class="n">result_batch_dim</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">lbd</span><span class="p">)))</span>
      <span class="n">lhs_batch</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">lbd</span><span class="p">)</span>
      <span class="n">lhs_contract</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">lbd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">other</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs_ndim</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rhs_batch</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rhs_contract</span><span class="p">)</span>
      <span class="n">result_batch_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_contract</span><span class="p">)</span> <span class="o">+</span>
                          <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">rbd</span><span class="p">)))</span>
      <span class="n">rhs_batch</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">,</span> <span class="n">rbd</span><span class="p">)</span>
      <span class="n">rhs_contract</span> <span class="o">=</span> <span class="n">bump_dims</span><span class="p">(</span><span class="n">rhs_contract</span><span class="p">,</span> <span class="n">rbd</span><span class="p">)</span>

  <span class="n">new_dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">rhs_contract</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">new_dimension_numbers</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">result_batch_dim</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_dot_general_padding_rule</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                              <span class="n">dimension_numbers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="n">lhs_aval</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">in_avals</span>
  <span class="p">(</span><span class="n">lhs_contract</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dimension_numbers</span>
  <span class="n">padded_axes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">lhs_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs_contract</span>
                 <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pe</span><span class="o">.</span><span class="n">BoundedAxisSize</span><span class="p">)]</span>
  <span class="n">lhs_</span> <span class="o">=</span> <span class="n">_replace_masked_values</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padded_axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">dot_general</span><span class="p">(</span><span class="n">lhs_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dimension_numbers</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_dot_general_pp_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
  <span class="c1"># suppress printing precision or preferred_element_type when None.</span>
  <span class="c1"># print dimension_numbers as list-of-lists to be shorter.</span>
  <span class="n">printed_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
  <span class="p">(</span><span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dimension_numbers&#39;</span><span class="p">]</span>
  <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;dimension_numbers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_cont</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">rhs_cont</span><span class="p">)),</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">)))</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
         <span class="n">core</span><span class="o">.</span><span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">printed_params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">]</span>


<span class="n">dot_general_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_dot_general_shape_rule</span><span class="p">,</span>
                                   <span class="n">_dot_general_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;dot_general&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defbilinear</span><span class="p">(</span><span class="n">dot_general_p</span><span class="p">,</span>
               <span class="n">_dot_general_transpose_lhs</span><span class="p">,</span> <span class="n">_dot_general_transpose_rhs</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">dot_general_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_dot_general_batch_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">dot_general_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_dot_general_padding_rule</span>
<span class="c1"># TODO(mattjj): un-comment the next line</span>
<span class="c1"># core.pp_eqn_rules[dot_general_p] = _dot_general_pp_rule</span>

<span class="k">def</span> <span class="nf">precision_attr</span><span class="p">(</span><span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ir</span><span class="o">.</span><span class="n">ArrayAttr</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">full_precision</span> <span class="o">=</span> <span class="p">(</span><span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">Precision</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">)</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="n">full_precision</span> <span class="o">=</span> <span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">full_precision</span> <span class="o">=</span> <span class="n">precision</span>
  <span class="k">return</span> <span class="n">ir</span><span class="o">.</span><span class="n">ArrayAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
      <span class="p">[</span><span class="n">mhlo</span><span class="o">.</span><span class="n">PrecisionAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">full_precision</span><span class="p">])</span>



<span class="k">def</span> <span class="nf">_dot_general_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span>
                       <span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">]):</span>
  <span class="k">del</span> <span class="n">preferred_element_type</span>  <span class="c1"># Implied by the output aval</span>
  <span class="n">lhs_aval</span><span class="p">,</span> <span class="n">rhs_aval</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="p">(</span><span class="n">lhs_contracting</span><span class="p">,</span> <span class="n">rhs_contracting</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">dimension_numbers</span>

  <span class="c1"># TODO(b/195364460): Work around slow XLA/CPU implementation of float16 matmul</span>
  <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">lhs_aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span>
      <span class="n">f32</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dtype_to_ir_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
      <span class="n">lhs</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ConvertOp</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">f32</span><span class="p">),</span>
                           <span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
    <span class="k">if</span> <span class="n">rhs_aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">:</span>
      <span class="n">f32</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dtype_to_ir_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
      <span class="n">rhs</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ConvertOp</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rhs_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">f32</span><span class="p">),</span>
                           <span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
  <span class="n">dot_dnums</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DotDimensionNumbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
      <span class="n">lhs_batching_dimensions</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_batch</span><span class="p">),</span>
      <span class="n">rhs_batching_dimensions</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">rhs_batch</span><span class="p">),</span>
      <span class="n">lhs_contracting_dimensions</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lhs_contracting</span><span class="p">),</span>
      <span class="n">rhs_contracting_dimensions</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">rhs_contracting</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span>
      <span class="n">mhlo</span><span class="o">.</span><span class="n">DotGeneralOp</span><span class="p">(</span>
          <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span>
          <span class="n">lhs</span><span class="p">,</span>
          <span class="n">rhs</span><span class="p">,</span>
          <span class="n">dot_dnums</span><span class="p">,</span>
          <span class="n">precision_config</span><span class="o">=</span><span class="n">precision_attr</span><span class="p">(</span><span class="n">precision</span><span class="p">))</span><span class="o">.</span><span class="n">result</span>
  <span class="p">]</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">dot_general_p</span><span class="p">,</span> <span class="n">_dot_general_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_broadcast_in_dim_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="n">_check_shapelike</span><span class="p">(</span><span class="s1">&#39;broadcast_in_dim&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
  <span class="n">_check_shapelike</span><span class="p">(</span><span class="s1">&#39;broadcast_in_dim&#39;</span><span class="p">,</span> <span class="s1">&#39;broadcast_dimensions&#39;</span><span class="p">,</span>
                   <span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="n">operand_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">operand_ndim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;broadcast_in_dim broadcast_dimensions must have length equal to &#39;</span>
           <span class="s1">&#39;operand ndim; got broadcast_dimensions </span><span class="si">{}</span><span class="s1"> for operand ndim </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">,</span> <span class="n">operand_ndim</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">operand_ndim</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;broadcast_in_dim target broadcast shape must have equal or higher rank &#39;</span>
           <span class="s1">&#39;to the operand shape; got operand ndim </span><span class="si">{}</span><span class="s1"> and target broadcast ndim </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operand_ndim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;broadcast_in_dim broadcast_dimensions must be a subset of output &#39;</span>
           <span class="s1">&#39;dimensions, got </span><span class="si">{}</span><span class="s1"> for operand ndim </span><span class="si">{}</span><span class="s1"> and shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">,</span> <span class="n">operand_ndim</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_one_of_dim</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">broadcast_dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">operand_ndim</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;broadcast_in_dim operand dimension sizes must either be 1, or be &quot;</span>
        <span class="s2">&quot;equal to their corresponding dimensions in the target broadcast &quot;</span>
        <span class="s2">&quot;shape; got operand of shape </span><span class="si">{}</span><span class="s2">, target broadcast shape </span><span class="si">{}</span><span class="s2">, &quot;</span>
        <span class="s2">&quot;broadcast_dimensions </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">))</span> <span class="ow">or</span>
      <span class="nb">tuple</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">))):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;broadcast_in_dim broadcast_dimensions must be strictly increasing; &quot;</span>
           <span class="s2">&quot;got broadcast_dimensions </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">shape</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_typecheck_rule</span><span class="p">(</span>
    <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">out_aval</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">abstract_eval</span><span class="p">(</span>
        <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">effects</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># TODO(mattjj): perform more checks like _broadcast_in_dim_shape_rule</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">Literal</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
    <span class="n">out_aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                 <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_transpose_rule</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="p">)]</span>
  <span class="n">unit_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>  <span class="mi">1</span><span class="p">)]</span>
  <span class="n">bdims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">,</span> <span class="n">unit_dims</span><span class="p">))</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">bdims</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">([</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">_reduce_sum</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">axes</span><span class="p">),</span> <span class="n">unit_dims</span><span class="p">)]</span> <span class="o">+</span>
          <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn_shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                 <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># TODO(mattjj)</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">new_operand</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">bdim</span><span class="p">],)</span> <span class="o">+</span> <span class="n">shape</span>
  <span class="n">new_broadcast_dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">new_operand</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">new_broadcast_dimensions</span><span class="p">),</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_fwd_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">):</span>
  <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">invars</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn</span> <span class="ow">and</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_shape</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="kc">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">eqn</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_staging_rule</span><span class="p">(</span>
    <span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">broadcast_in_dim_p</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_dyn_shape_staging_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">broadcast_in_dim_p</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_padding_rule</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span>
                                   <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">in_avals</span><span class="p">,</span> <span class="n">dyn_shape</span>
  <span class="n">out_aval</span><span class="p">,</span> <span class="o">=</span> <span class="n">out_avals</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">new_dyn_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">pe</span><span class="o">.</span><span class="n">BoundedAxisSize</span><span class="p">:</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
      <span class="n">new_dyn_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">new_dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span>
                                  <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">operand_dot</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                              <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">operand_dot</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="n">y_dot</span> <span class="o">=</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">y_dot</span> <span class="o">=</span> <span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">operand_dot</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                    <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">y_dot</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_partial_eval</span><span class="p">(</span>
    <span class="n">trace</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span>
        <span class="n">broadcast_in_dim_p</span><span class="p">,</span> <span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">),</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">))</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pval</span><span class="o">.</span><span class="n">is_known</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dyn_shape</span><span class="p">)</span>
  <span class="n">operand_tracer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="n">dyn_shape_tracers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">instantiate_const</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
  <span class="n">dyn_shape_tracers_</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">dyn_shape_tracers</span><span class="p">)</span>
  <span class="n">shape_</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">dyn_shape_tracers_</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]</span>
  <span class="n">out_aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape_</span><span class="p">),</span> <span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="n">out_tracer</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">JaxprTracer</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">PartialVal</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="n">out_aval</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">eqn</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">new_eqn_recipe</span><span class="p">(</span>
      <span class="p">[</span><span class="n">operand_tracer</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape_tracers</span><span class="p">],</span> <span class="p">[</span><span class="n">out_tracer</span><span class="p">],</span> <span class="n">broadcast_in_dim_p</span><span class="p">,</span>
      <span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">),</span>
      <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span><span class="p">,</span> <span class="n">source_info_util</span><span class="o">.</span><span class="n">current</span><span class="p">())</span>
  <span class="n">out_tracer</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="n">eqn</span>
  <span class="k">return</span> <span class="n">out_tracer</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">broadcast_in_dim_mlir</span><span class="p">(</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DynamicBroadcastInDimOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">shape_tensor</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">BroadcastInDimOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_pp_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
  <span class="c1"># Don&#39;t print shape or trivial broadcast_dimensions in params, since it can be</span>
  <span class="c1"># inferred from the let-binder&#39;s type annotation.</span>
  <span class="n">printed_params</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">if</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;broadcast_dimensions&#39;</span><span class="p">]:</span>
    <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;broadcast_dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;broadcast_dimensions&#39;</span><span class="p">]</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
         <span class="n">core</span><span class="o">.</span><span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">printed_params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">context</span><span class="p">)]</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_broadcast_in_dim_abstract_eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span>
  <span class="k">del</span> <span class="n">dyn_shape</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">BInt</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_shape_rule</span><span class="p">(</span>  <span class="c1"># error checking</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="n">broadcast_dimensions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">named_shape</span><span class="p">)</span>
  <span class="c1"># If any BInts in shape, produce a DShapedArray (even if x is a ShapedArray)</span>
  <span class="c1"># TODO(mattjj): unify DShapedArray with ShapedArray, and remove this code</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>

<span class="n">broadcast_in_dim_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_broadcast_in_dim_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="s1">&#39;broadcast_in_dim&#39;</span><span class="p">)</span>
<span class="n">broadcast_in_dim_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_broadcast_in_dim_abstract_eval</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_jvp_rule</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_transpose_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_batch_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">forwarding_rules</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_fwd_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_partial_eval_rules</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_partial_eval</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_staging_rules</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_staging_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_padding_rule</span>
<span class="n">core</span><span class="o">.</span><span class="n">custom_typechecks</span><span class="p">[</span><span class="n">broadcast_in_dim_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_broadcast_in_dim_typecheck_rule</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">broadcast_in_dim_p</span><span class="p">,</span> <span class="n">_broadcast_in_dim_lower</span><span class="p">)</span>
<span class="c1"># TODO(mattjj): un-comment the next line</span>
<span class="c1"># core.pp_eqn_rules[broadcast_in_dim_p] = _broadcast_in_dim_pp_rule</span>


<span class="k">def</span> <span class="nf">_clamp_shape_rule</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">min</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">min</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;clamp requires min.shape == operand.shape or min.shape == &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(), got min.shape=</span><span class="si">{</span><span class="nb">min</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;operand.shape=</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">max</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">max</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;clamp requires max.shape == operand.shape or max.shape == &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(), got max.shape=</span><span class="si">{</span><span class="nb">max</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;operand.shape=</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span>

<span class="n">_clamp_dtype_rule</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">naryop_dtype_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="p">[</span><span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">,</span> <span class="n">_any</span><span class="p">],</span>
                            <span class="s1">&#39;clamp&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_clamp_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
  <span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">min_bdim</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">max_bdim</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span>
              <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

  <span class="c1"># avoid transposes and some broadcasts in special cases</span>
  <span class="k">if</span> <span class="n">min_bdim</span> <span class="o">==</span> <span class="n">x_bdim</span> <span class="o">==</span> <span class="n">max_bdim</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">max</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="n">x_bdim</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="n">x_bdim</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="nb">min</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="n">min_bdim</span><span class="p">])</span>
      <span class="nb">max</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="n">max_bdim</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="n">x_bdim</span>
  <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x_bdim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="n">x_bdim</span>

  <span class="nb">min</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">min_bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="k">else</span> <span class="nb">min</span>
  <span class="nb">max</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">max_bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="k">else</span> <span class="nb">max</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">clamp_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="mi">0</span>

<span class="n">clamp_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_clamp_shape_rule</span><span class="p">,</span> <span class="n">_clamp_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;clamp&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp</span><span class="p">(</span><span class="n">clamp_p</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span>
          <span class="n">select</span><span class="p">(</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">operand</span><span class="p">),</span> <span class="n">lt</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)),</span>
                 <span class="n">g</span><span class="p">,</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">operand</span><span class="p">)),</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span>
          <span class="n">select</span><span class="p">(</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="nb">min</span><span class="p">),</span> <span class="n">lt</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="nb">max</span><span class="p">)),</span>
                 <span class="n">g</span><span class="p">,</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">operand</span><span class="p">)),</span>
          <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span>
          <span class="n">select</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">operand</span><span class="p">),</span> <span class="n">g</span><span class="p">,</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">clamp_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_clamp_batch_rule</span>
<span class="k">if</span> <span class="n">mlir_api_version</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span>
      <span class="n">clamp_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ClampOp</span><span class="p">,</span> <span class="n">explicit_type</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span>
      <span class="n">clamp_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_nary_lower_mhlo</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ClampOp</span><span class="p">))</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">clamp_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_concatenate_shape_rule</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">dimension</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimension&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">operands</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;concatenate expects at least one operand, got 0.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">UnshapedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;All objects to concatenate must be arrays, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="n">op</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operands</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">UnshapedArray</span><span class="p">))</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot concatenate arrays with different numbers of dimensions: got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">)))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;concatenate dimension out of bounds: dimension </span><span class="si">{}</span><span class="s2"> for shapes </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">])))</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot concatenate arrays with shapes that differ in dimensions &quot;</span>
           <span class="s2">&quot;other than the one being concatenated: concatenating along &quot;</span>
           <span class="s2">&quot;dimension </span><span class="si">{}</span><span class="s2"> for shapes </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">shapes</span><span class="p">))))</span>

  <span class="n">concat_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">)</span>
  <span class="n">ex_shape</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
  <span class="k">return</span> <span class="n">ex_shape</span><span class="p">[:</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">concat_size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ex_shape</span><span class="p">[</span><span class="n">dimension</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">_concatenate_dtype_rule</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">_check_same_dtypes</span><span class="p">(</span><span class="s1">&#39;concatenate&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_concatenate_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="n">operand_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="n">o</span><span class="o">.</span><span class="n">shape</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">limit_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">operand_shapes</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="n">s</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit_points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limits</span><span class="p">):</span>
      <span class="n">l</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">limits</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_concatenate_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">bdim</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span>
              <span class="k">if</span> <span class="n">bdim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">bdim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
              <span class="k">else</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,))</span>
              <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span>

<span class="n">concatenate_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_concatenate_shape_rule</span><span class="p">,</span> <span class="n">_concatenate_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;concatenate&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">concatenate_p</span><span class="p">,</span> <span class="n">_concatenate_transpose_rule</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">concatenate_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_concatenate_transpose_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">concatenate_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_concatenate_batch_rule</span>

<span class="k">def</span> <span class="nf">_concatenate_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ConcatenateOp</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">concatenate_p</span><span class="p">,</span> <span class="n">_concatenate_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">padding_value</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;pad operand and padding_value must be same dtype: got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">padding_value</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">_input_dtype</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_pad_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">padding_value</span>
  <span class="n">op_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding_config</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length of padding_config must equal the number of axes &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;of operand, got padding_config </span><span class="si">{</span><span class="n">padding_config</span><span class="si">}</span><span class="s2"> &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;for operand shape </span><span class="si">{</span><span class="n">op_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">padding_config</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interior padding in padding_config must be nonnegative, &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;got padding_config </span><span class="si">{</span><span class="n">padding_config</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">sum_dim</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">dilate_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                 <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">padding_config</span><span class="p">,</span> <span class="n">op_shape</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">greater_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">result</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension size after padding is not at least 0, &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;got result shape </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">, for padding_config </span><span class="si">{</span><span class="n">padding_config</span><span class="si">}</span><span class="s2">&quot;</span>
           <span class="sa">f</span><span class="s2">&quot; and operand shape </span><span class="si">{</span><span class="n">op_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_pad_transpose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="n">t_operand</span> <span class="o">=</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">t_padv</span> <span class="o">=</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">padding_value</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">padding_value</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">interior</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unzip3</span><span class="p">(</span><span class="n">padding_config</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">t_op</span><span class="p">():</span>
      <span class="n">unpad_config</span> <span class="o">=</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">lo</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">hi</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interior</span><span class="p">))</span>
      <span class="n">unpadded</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">unpad_config</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">slicing</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">unpadded</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lo</span><span class="p">),</span> <span class="n">unpadded</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">interior</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">t_operand</span> <span class="o">=</span> <span class="n">t_op</span><span class="p">()</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">t_padv</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">total</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">total</span><span class="p">(</span><span class="n">t_operand</span><span class="p">))</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">padding_value</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">t_operand</span><span class="p">,</span> <span class="n">t_padv</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_pad_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">operand_bdim</span><span class="p">,</span> <span class="n">padding_value_bdim</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="k">if</span> <span class="n">operand_bdim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">operand_bdim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="p">(</span><span class="n">padding_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">padding_value_bdim</span><span class="p">],))</span>

  <span class="n">padding_config</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">padding_config</span><span class="p">)</span>
  <span class="n">padding_config</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">operand_bdim</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">padding_value_bdim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pad</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">),</span> <span class="n">operand_bdim</span>

  <span class="k">assert</span> <span class="n">padding_value_bdim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padding_value_bdim</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">_zero</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">padding_config</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">full_like</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">)</span>
  <span class="n">broadcasted_padding</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">padding_value</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="p">(</span><span class="n">operand_bdim</span><span class="p">,))</span>
  <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">broadcasted_padding</span><span class="p">),</span> <span class="n">operand_bdim</span>

<span class="n">pad_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_pad_shape_rule</span><span class="p">,</span> <span class="n">_pad_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">pad_p</span><span class="p">,</span> <span class="n">_pad_transpose</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">pad_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_pad_batch_rule</span>

<span class="k">def</span> <span class="nf">_pad_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padding_config</span><span class="p">):</span>
  <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">interior</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unzip3</span><span class="p">(</span><span class="n">padding_config</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">PadOp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">padding_value</span><span class="p">,</span>
                    <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">low</span><span class="p">),</span>
                    <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">high</span><span class="p">),</span>
                    <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">interior</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">pad_p</span><span class="p">,</span> <span class="n">_pad_lower</span><span class="p">)</span>


<span class="c1"># The squeeze primitive exists for the benefit of masking and other</span>
<span class="c1"># transformations that need to keep track of axis identity.</span>
<span class="c1"># For example, consider reshaping a 2D array with shape (1, N) into a 1D array</span>
<span class="c1"># with shape (N,). This results in the following JAXpr:</span>
<span class="c1">#   reshape[ dimension=None new_sizes=(N,) ]</span>
<span class="c1"># For N &gt; 1, we can match up the output array axis with the second axis of the</span>
<span class="c1"># input. But for N = 1, it is not clear how axes match up: all we know from the</span>
<span class="c1"># JAXpr is that we are reshaping from (1, 1) to (1,).</span>
<span class="c1"># In constrast, squeeze[ dimensions=(0,) ] is unambiguous.</span>


<span class="k">def</span> <span class="nf">_squeeze_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_squeeze_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_compute_squeeze_shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">dimensions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_compute_squeeze_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">dims_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimensions are not unique: </span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims_set</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dimensions outside range [0, ndim): </span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">symbolic_equal_dim</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;cannot select an axis to squeeze out which has size not equal to &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;one, got shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and dimensions=</span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims_set</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_squeeze_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_squeeze_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">operand</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">),</span> <span class="mi">0</span>

<span class="n">squeeze_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_squeeze_shape_rule</span><span class="p">,</span> <span class="n">_squeeze_dtype_rule</span><span class="p">,</span>
                               <span class="s1">&#39;squeeze&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">squeeze_p</span><span class="p">,</span> <span class="n">_squeeze_transpose_rule</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">squeeze_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_squeeze_batch_rule</span>

<span class="k">def</span> <span class="nf">_squeeze_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">dimensions</span>  <span class="c1"># Implied by the output aval.</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="n">substitute</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_substitute_axis_sizes_in_aval</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">axis_size_env</span><span class="p">)</span>
    <span class="n">aval_out</span> <span class="o">=</span> <span class="n">substitute</span><span class="p">(</span><span class="n">aval_out</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DynamicReshapeOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">operand</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">shape_tensor</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReshapeOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">operand</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">squeeze_p</span><span class="p">,</span> <span class="n">_squeeze_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">shape_as_value</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Shape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Converts a shape that may contain Poly values into a JAX value.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">full</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">expand_dims</span><span class="p">(</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">dimension_as_value</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                  <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span>
  <span class="p">]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_singleton_reshape</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
  <span class="c1"># A singleton reshape is one where only singleton dimensions are added. We</span>
  <span class="c1"># want to detect them because they can be expressed as (lazy) broadcasts.</span>
  <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
  <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">bcast_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="ow">is</span> <span class="n">d2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">bcast_dims</span>
    <span class="k">elif</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span><span class="p">:</span>
      <span class="n">bcast_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">d2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">d2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">_reshape_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">greater_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">new_sizes</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;reshape new_sizes must all be positive, got </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">))</span>
  <span class="c1"># TODO(necula): re-enable this check</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">and</span>
      <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">same_shape_sizes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">new_sizes</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;reshape total size must be unchanged, got new_sizes </span><span class="si">{}</span><span class="s1"> for shape </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">operand</span><span class="p">))):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;reshape dimensions must be a permutation of operand dimensions, &#39;</span>
             <span class="s1">&#39;got dimensions </span><span class="si">{}</span><span class="s1"> for shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)))</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reshape_typecheck_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">out_aval</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">reshape_p</span><span class="o">.</span><span class="n">abstract_eval</span><span class="p">(</span>
        <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">new_sizes</span><span class="o">=</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">effects</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># TODO(mattjj, necula): perform more checks like _reshape_shape_rule</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">Literal</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
    <span class="n">out_aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                 <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span>


<span class="k">def</span> <span class="nf">_reshape_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_reshape_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">transpose</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))]</span>

<span class="k">def</span> <span class="nf">_reshape_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">operand</span> <span class="o">=</span> <span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">),</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_reshape_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">TransposeOp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span><span class="o">.</span><span class="n">result</span>
  <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DynamicReshapeOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">shape_tensor</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReshapeOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="k">def</span> <span class="nf">_reshape_staging_rule</span><span class="p">(</span>
    <span class="n">trace</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn</span><span class="p">,</span> <span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">new_sizes</span><span class="o">=</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">reshape_p</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">av</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">,</span> <span class="n">dyn</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_dyn_shape_staging_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">reshape_p</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

<span class="n">reshape_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_reshape_shape_rule</span><span class="p">,</span> <span class="n">_reshape_dtype_rule</span><span class="p">,</span>
                               <span class="s1">&#39;reshape&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">reshape_p</span><span class="p">,</span> <span class="n">_reshape_transpose_rule</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">reshape_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reshape_batch_rule</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reshape_p</span><span class="p">,</span> <span class="n">_reshape_lower</span><span class="p">)</span>
<span class="n">core</span><span class="o">.</span><span class="n">custom_typechecks</span><span class="p">[</span><span class="n">reshape_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reshape_typecheck_rule</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_staging_rules</span><span class="p">[</span><span class="n">reshape_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reshape_staging_rule</span>


<span class="k">def</span> <span class="nf">_rev_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">_check_shapelike</span><span class="p">(</span><span class="s1">&#39;rev&#39;</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;rev dimensions must be unique, got </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_max</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;rev dimensions must all be less than operand ndim, got dimensions &#39;</span>
           <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> for operand ndim </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span>

<span class="k">def</span> <span class="nf">_rev_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">new_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">bdim</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">rev</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">new_dimensions</span><span class="p">),</span> <span class="n">bdim</span>

<span class="n">rev_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_rev_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="s1">&#39;rev&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">rev_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="p">[</span><span class="n">rev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)])</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">rev_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rev_batch_rule</span>

<span class="k">def</span> <span class="nf">_rev_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReverseOp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">rev_p</span><span class="p">,</span> <span class="n">_rev_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_transpose_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;transpose permutation must be a tuple/list/ndarray, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">permutation</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;transpose permutation isn&#39;t a permutation of operand dimensions, &quot;</span>
           <span class="s2">&quot;got permutation </span><span class="si">{}</span><span class="s2"> for operand shape </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">old_idx</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_transpose_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">(</span><span class="n">bdim</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bdim</span> <span class="k">else</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">_transpose_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">transpose_mlir</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">permutation</span><span class="o">=</span><span class="n">permutation</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">TransposeOp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>

<span class="n">transpose_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_transpose_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span>
                                 <span class="s1">&#39;transpose&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">transpose_p</span><span class="p">,</span>
              <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">permutation</span><span class="p">:</span> <span class="p">[</span><span class="n">transpose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">permutation</span><span class="p">))])</span>  <span class="c1"># type: ignore[arg-type]</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">transpose_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_transpose_batch_rule</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">transpose_p</span><span class="p">,</span> <span class="n">_transpose_lower</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">transpose_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_select_shape_rule</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;select must have at least one case&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">case</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;select cases must have the same shapes, got [</span><span class="si">{}</span><span class="s2">].&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">])))</span>
  <span class="k">if</span> <span class="n">which</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">which</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;select `which` must be scalar or have the same shape as cases, &quot;</span>
           <span class="s2">&quot;got `which` shape </span><span class="si">{}</span><span class="s2"> but case shape </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

<span class="k">def</span> <span class="nf">_select_dtype_rule</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">):</span>
  <span class="n">_check_same_dtypes</span><span class="p">(</span><span class="s2">&quot;select&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">which</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="ow">and</span>
      <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">which</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;select `which` must be boolean or integer type, got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">which</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">which</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;select with boolean `which` cannot have &gt; 2 cases.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_select_weak_type_rule</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">weak_type</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_select_transpose_rule</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">):</span>
  <span class="k">assert</span> <span class="ow">not</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                     <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">full_like</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">select</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">_const</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">t</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">case</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">case</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">_select_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">**</span><span class="n">unused_kwargs</span><span class="p">):</span>
  <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">which_bdim</span><span class="p">,</span> <span class="o">*</span><span class="n">case_bdims</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="n">size</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span>
              <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

  <span class="c1"># avoid transposes and some broadcasts in special cases</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">which_bdim</span> <span class="o">==</span> <span class="n">bdim</span> <span class="k">for</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="n">case_bdims</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">),</span> <span class="n">which_bdim</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># vmapped function had a scalar which with nonscalar args</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="n">which</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="n">which_bdim</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">),</span> <span class="n">which_bdim</span>
  <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">bdim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="n">case_bdims</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">case_bdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bdim</span> <span class="k">for</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="n">case_bdims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">),</span> <span class="n">case_bdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">):</span>
      <span class="n">bdim</span> <span class="o">=</span> <span class="n">case_bdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">other_cases</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c_bdim</span><span class="p">,</span> <span class="n">bdim</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">case_bdims</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
      <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">other_cases</span><span class="p">),</span> <span class="n">bdim</span>

  <span class="n">which</span> <span class="o">=</span> <span class="p">(</span><span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">which_bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
           <span class="k">else</span> <span class="n">which</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">):</span>
    <span class="n">cases</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cases</span><span class="p">,</span> <span class="n">case_bdims</span><span class="p">)]</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="c1"># vmapped function had a scalar which with nonscalar args</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">which</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">cases</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">which</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">),</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">_select_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">case_primals</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">case_tangents</span> <span class="o">=</span> <span class="n">tangents</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">case_primals</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">case_tangents</span><span class="p">):</span>
    <span class="n">out_dot</span> <span class="o">=</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">(</span><span class="n">case_tangents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aval</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">case_tangents</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">))</span>
    <span class="n">case_tangents</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">else</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">case_tangents</span><span class="p">]</span>
    <span class="n">out_dot</span> <span class="o">=</span> <span class="n">select_n</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">case_tangents</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_dot</span>

<span class="k">def</span> <span class="nf">_select_mhlo_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">cases</span><span class="p">):</span>
  <span class="n">which_aval</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">which_aval</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">cases</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SelectOp</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">results</span>

  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">which_aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">):</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="s1">&#39;SIGNED&#39;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="s1">&#39;UNSIGNED&#39;</span>
  <span class="n">lt</span> <span class="o">=</span> <span class="s1">&#39;LT&#39;</span>

  <span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cases</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cases</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">compare_mhlo</span><span class="p">(</span><span class="n">which</span><span class="p">,</span>
                             <span class="n">mlir</span><span class="o">.</span><span class="n">full_like_aval</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">mid</span><span class="p">,</span> <span class="n">which_aval</span><span class="p">),</span>
                             <span class="n">lt</span><span class="p">,</span> <span class="n">compare_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SelectOp</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">_select</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cases</span><span class="p">[:</span><span class="n">mid</span><span class="p">]),</span>
                         <span class="n">_select</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">mid</span><span class="p">,</span> <span class="n">cases</span><span class="p">[</span><span class="n">mid</span><span class="p">:]))</span><span class="o">.</span><span class="n">result</span>

  <span class="k">return</span> <span class="p">[</span><span class="n">_select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cases</span><span class="p">)]</span>

<span class="n">select_n_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_select_shape_rule</span><span class="p">,</span> <span class="n">_select_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;select_n&#39;</span><span class="p">,</span>
    <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_select_weak_type_rule</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">select_n_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_select_jvp</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_transposes</span><span class="p">[</span><span class="n">select_n_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_select_transpose_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">select_n_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_select_batch_rule</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">select_n_p</span><span class="p">,</span> <span class="n">_select_mhlo_lowering</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">select_n_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reduce_shape_rule</span><span class="p">(</span><span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand_avals</span><span class="p">,</span> <span class="n">init_val_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">init_val_avals</span><span class="p">):</span>
    <span class="n">init_val_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">init_val_avals</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reduce found non-scalar initial value: </span><span class="si">{</span><span class="n">init_val_shapes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operand_avals</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_reduce_dtype_rule</span><span class="p">(</span><span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand_avals</span><span class="p">,</span> <span class="n">init_val_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="n">operand_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operand_avals</span><span class="p">]</span>
  <span class="n">init_val_dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">init_val_avals</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">operand_dtypes</span> <span class="o">!=</span> <span class="n">init_val_dtypes</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="s2">&quot;reduce operand dtypes should match corresponding initial value dtypes, &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;got operands=</span><span class="si">{</span><span class="n">operand_avals</span><span class="si">}</span><span class="s2"> and initial_values=</span><span class="si">{</span><span class="n">init_val_avals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">operand_dtypes</span>

<span class="k">def</span> <span class="nf">_reduce_weak_type_rule</span><span class="p">(</span><span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">operand_avals</span><span class="p">,</span> <span class="n">init_val_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">init_val</span><span class="o">.</span><span class="n">weak_type</span>
          <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">init_val</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">operand_avals</span><span class="p">,</span> <span class="n">init_val_avals</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_reduce_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span>
                       <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="c1"># TODO(mattjj,frostig): use batch_jaxpr, delete computation (assumes poly??)</span>
  <span class="n">num_operands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batched_args</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">operands</span><span class="p">,</span> <span class="n">init_values</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="p">[</span><span class="n">num_operands</span><span class="p">])</span>
  <span class="n">operand_bdims</span><span class="p">,</span> <span class="n">init_value_bdims</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">batch_dims</span><span class="p">,</span> <span class="p">[</span><span class="n">num_operands</span><span class="p">])</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">init_value_bdim</span> <span class="ow">is</span> <span class="n">batching</span><span class="o">.</span><span class="n">not_mapped</span>
         <span class="k">for</span> <span class="n">init_value_bdim</span> <span class="ow">in</span> <span class="n">init_value_bdims</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">batching</span><span class="o">.</span><span class="n">bdim_at_front</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">operand_bdims</span><span class="p">)]</span>
    <span class="n">new_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">]</span>
    <span class="n">new_operand_bdims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_operands</span>
    <span class="k">return</span> <span class="n">reduce_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">operands</span> <span class="o">+</span> <span class="n">init_values</span><span class="p">),</span>
                         <span class="n">computation</span><span class="o">=</span><span class="n">computation</span><span class="p">,</span>
                         <span class="n">dimensions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_dimensions</span><span class="p">),</span>
                         <span class="n">consts</span><span class="o">=</span><span class="n">consts</span><span class="p">,</span>
                         <span class="n">jaxpr</span><span class="o">=</span><span class="n">jaxpr</span><span class="p">),</span> <span class="n">new_operand_bdims</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># loop and stack</span>

<span class="k">def</span> <span class="nf">_reduce_jvp</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="n">input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">primals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">input_shape</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)])</span>
  <span class="n">non_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)),</span> <span class="n">axes</span><span class="p">)</span>

  <span class="c1"># Move the reduced axes to the front, and flatten them to 1D.</span>
  <span class="n">permutation</span> <span class="o">=</span> <span class="n">axes</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">non_axes</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_shape</span><span class="p">[</span><span class="n">non_axes</span><span class="p">])</span>
  <span class="n">primals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">permutation</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">primals</span><span class="p">)</span>
  <span class="n">tangents</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">permutation</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_axes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">reducer</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_reduce_tree</span><span class="p">(</span><span class="o">*</span><span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduce by repeatedly splitting the array and multiplying.&quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
      <span class="n">n1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
      <span class="n">n2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n1</span>
      <span class="n">xs1</span> <span class="o">=</span> <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
      <span class="n">xs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">slicing</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">n2</span> <span class="o">!=</span> <span class="n">n1</span><span class="p">:</span>
        <span class="n">paddings</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">paddings</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">xs2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">paddings</span><span class="p">)</span> <span class="k">for</span> <span class="n">x2</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs2</span><span class="p">,</span> <span class="n">init_values</span><span class="p">)]</span>
      <span class="n">xs</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">xs1</span> <span class="o">+</span> <span class="n">xs2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">full</span><span class="p">(</span><span class="n">input_shape</span><span class="p">[</span><span class="n">non_axes</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">init_values</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">axis</span><span class="p">,))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">api</span><span class="o">.</span><span class="n">jvp</span><span class="p">(</span><span class="n">_reduce_tree</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span>
                     <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="n">primal_xs</span><span class="p">,</span> <span class="n">init_values</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">primals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="n">tangent_xs</span><span class="p">,</span> <span class="n">tangent_init</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">tangents</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tangents</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="c1"># This test may be too strict, if a value is actually zero but we cannot prove</span>
  <span class="c1"># it is symbolically zero.</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangent_init</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
      <span class="s2">&quot;Gradient of general lax.reduce with non-zero tangents for &quot;</span>
      <span class="s2">&quot;initial values to reduction not implemented&quot;</span><span class="p">)</span>
  <span class="n">reducer</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">jaxpr_as_fun</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">ClosedJaxpr</span><span class="p">(</span><span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">_reduce_jvp</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">primal_xs</span><span class="p">,</span> <span class="n">tangent_xs</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_named_shape_rule</span><span class="p">(</span><span class="o">*</span><span class="n">avals</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="c1"># TODO(mattjj,frostig): see the TODOs noting limitations/assumptions in</span>
  <span class="c1"># _reduce_batching_rule. We&#39;re making the same assumptions here for now.</span>
  <span class="n">num_operands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">operand_avals</span><span class="p">,</span> <span class="n">init_avals</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">avals</span><span class="p">,</span> <span class="p">[</span><span class="n">num_operands</span><span class="p">])</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">named_shape</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">init_avals</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
  <span class="n">named_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">named_shape</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">operand_avals</span><span class="p">]</span>
  <span class="n">join</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">join_named_shapes</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">named_shape</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">operand_avals</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">join</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">named_shapes</span><span class="p">)</span>


<span class="n">reduce_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;reduce&#39;</span><span class="p">)</span>
<span class="n">reduce_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">reduce_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">reduce_p</span><span class="p">))</span>
<span class="n">reduce_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">standard_multi_result_abstract_eval</span><span class="p">,</span> <span class="n">reduce_p</span><span class="p">,</span> <span class="n">_reduce_shape_rule</span><span class="p">,</span>
            <span class="n">_reduce_dtype_rule</span><span class="p">,</span> <span class="n">_reduce_weak_type_rule</span><span class="p">,</span>
            <span class="n">_reduce_named_shape_rule</span><span class="p">))</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">reduce_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reduce_batch_rule</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">reduce_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reduce_jvp_rule</span>

<span class="k">def</span> <span class="nf">_reduce_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">computation</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">),</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span>
  <span class="n">operands</span><span class="p">,</span> <span class="n">init_values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">split_list</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
  <span class="n">init_value_avals</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReduceOp</span><span class="p">([</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span><span class="p">],</span>
                     <span class="n">operands</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
  <span class="n">ir_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">init_value_avals</span><span class="p">]</span>
  <span class="n">reducer</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ir_types</span> <span class="o">+</span> <span class="n">ir_types</span><span class="p">))</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">reducer</span><span class="p">):</span>
    <span class="n">reducer_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">module_context</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name_stack</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">new_name_stack</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">jaxpr</span><span class="o">.</span><span class="n">effects</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot lower effectful `reduce`.&#39;</span><span class="p">)</span>
    <span class="n">out_nodes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">jaxpr_subcomp</span><span class="p">(</span><span class="n">reducer_ctx</span><span class="p">,</span> <span class="n">jaxpr</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">TokenSet</span><span class="p">(),</span> <span class="n">consts</span><span class="p">,</span>
                                      <span class="o">*</span><span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">reducer</span><span class="o">.</span><span class="n">arguments</span><span class="p">))</span>
    <span class="n">mhlo</span><span class="o">.</span><span class="n">ReturnOp</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">out_nodes</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_p</span><span class="p">,</span> <span class="n">_reduce_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reduce_number_dtype_rule</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> does not accept dtype </span><span class="si">{}</span><span class="s2">. Accepted dtypes are subtypes &quot;</span>
                    <span class="s2">&quot;of number.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_sum_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduce_op_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_sum_transpose_rule</span><span class="p">(</span><span class="n">cotangent</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">ad</span><span class="o">.</span><span class="n">is_undefined_primal</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="n">input_shape</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span>
  <span class="n">broadcast_dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)),</span> <span class="n">axes</span><span class="p">))</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">cotangent</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">broadcast_dimensions</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">input_shape</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_reduce_sum_padding_rule</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">out_avals</span>
  <span class="n">aval</span><span class="p">,</span> <span class="o">=</span> <span class="n">in_avals</span>
  <span class="n">padded_axes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                 <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">BoundedAxisSize</span><span class="p">)]</span>
  <span class="n">masked_operand</span> <span class="o">=</span> <span class="n">_replace_masked_values</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padded_axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">_reduce_sum</span><span class="p">(</span><span class="n">masked_operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_replace_masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">padded_axes</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">padded_axes</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_scalar_type_to_dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
  <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">padded_axes</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">_reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">masks</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>


<span class="n">reduce_sum_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
  <span class="n">_reduce_sum_shape_rule</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce_number_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;reduce_sum&#39;</span><span class="p">),</span>
  <span class="s1">&#39;reduce_sum&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear2</span><span class="p">(</span><span class="n">reduce_sum_p</span><span class="p">,</span> <span class="n">_reduce_sum_transpose_rule</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_sum_p</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">reduce_sum_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reduce_sum_padding_rule</span>


<span class="k">def</span> <span class="nf">_reduce_op_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">input_shape</span>  <span class="c1"># Unused.</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;duplicate value in &#39;axes&#39; of reduction: </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">operand</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reduction axes </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2"> contains out-of-bounds indices for </span><span class="si">{</span><span class="n">operand</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_prod_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="n">reducer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">[</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
  <span class="n">primals_out</span><span class="p">,</span> <span class="n">tangents_out</span> <span class="o">=</span> <span class="n">_reduce_jvp</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="p">[</span><span class="n">_const</span><span class="p">(</span><span class="n">primals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)],</span>
                                          <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tangents_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">reduce_prod_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
  <span class="n">_reduce_op_shape_rule</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce_number_dtype_rule</span><span class="p">,</span> <span class="s1">&#39;reduce_prod&#39;</span><span class="p">),</span>
  <span class="s1">&#39;reduce_prod&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">reduce_prod_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_reduce_prod_jvp_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_prod_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reduce_chooser_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_reduce_chooser_jvp_rule</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="c1"># TODO(mattjj): an alternative is to use variadic reduce to compute the chosen</span>
  <span class="c1"># locations in a single pass (rather than comparing equality) and use a</span>
  <span class="c1"># gather, and/or even push along the chosen elements of g (b/112040122)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
  <span class="n">location_indicators</span> <span class="o">=</span> <span class="n">convert_element_type</span><span class="p">(</span>
      <span class="n">_eq_meet</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">reshape</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">shape</span><span class="p">)),</span> <span class="n">g</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="n">_reduce_sum</span><span class="p">(</span><span class="n">location_indicators</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">_reduce_sum</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">location_indicators</span><span class="p">),</span> <span class="n">axes</span><span class="p">),</span> <span class="n">counts</span><span class="p">)</span>

<span class="n">reduce_max_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_reduce_op_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span>
                                  <span class="s1">&#39;reduce_max&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">reduce_max_p</span><span class="p">,</span> <span class="n">_reduce_chooser_jvp_rule</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_max_p</span><span class="p">)</span>

<span class="n">reduce_min_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_reduce_op_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span>
                                  <span class="s1">&#39;reduce_min&#39;</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp2</span><span class="p">(</span><span class="n">reduce_min_p</span><span class="p">,</span> <span class="n">_reduce_chooser_jvp_rule</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_min_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_argminmax_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">):</span>
  <span class="n">axis</span><span class="p">,</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> for operand shape </span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">greater_equal_dim</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;argmin and argmax require non-empty reduced dimension. &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;operand.shape=</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_argminmax_dtype_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;index_dtype must be an integer type, but got </span><span class="si">{}</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">index_dtype</span>

<span class="k">def</span> <span class="nf">_compute_argminmax</span><span class="p">(</span><span class="n">value_comparator</span><span class="p">,</span> <span class="n">get_identity</span><span class="p">,</span>
                       <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="c1"># value_comparator is either lax.lt (for argmin) or lax.gt</span>
  <span class="c1"># get_identity(operand.dtype) is inf for argmin or -inf for argmax</span>
  <span class="n">axis</span><span class="p">,</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">reducer_fn</span><span class="p">(</span><span class="n">op_val_index</span><span class="p">,</span> <span class="n">acc_val_index</span><span class="p">):</span>
    <span class="n">op_val</span><span class="p">,</span> <span class="n">op_index</span> <span class="o">=</span> <span class="n">op_val_index</span>
    <span class="n">acc_val</span><span class="p">,</span> <span class="n">acc_index</span> <span class="o">=</span> <span class="n">acc_val_index</span>
    <span class="c1"># Pick op_val if Lt (for argmin) or if NaN</span>
    <span class="n">pick_op_val</span> <span class="o">=</span> <span class="n">bitwise_or</span><span class="p">(</span><span class="n">value_comparator</span><span class="p">(</span><span class="n">op_val</span><span class="p">,</span> <span class="n">acc_val</span><span class="p">),</span>
                             <span class="n">ne</span><span class="p">(</span><span class="n">op_val</span><span class="p">,</span> <span class="n">op_val</span><span class="p">))</span>
    <span class="c1"># If x and y are not NaN and x = y, then pick the first</span>
    <span class="n">pick_op_index</span> <span class="o">=</span> <span class="n">bitwise_or</span><span class="p">(</span><span class="n">pick_op_val</span><span class="p">,</span>
                               <span class="n">bitwise_and</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">op_val</span><span class="p">,</span> <span class="n">acc_val</span><span class="p">),</span>
                                           <span class="n">lt</span><span class="p">(</span><span class="n">op_index</span><span class="p">,</span> <span class="n">acc_index</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">pick_op_val</span><span class="p">,</span> <span class="n">op_val</span><span class="p">,</span> <span class="n">acc_val</span><span class="p">),</span>
            <span class="n">select</span><span class="p">(</span><span class="n">pick_op_index</span><span class="p">,</span> <span class="n">op_index</span><span class="p">,</span> <span class="n">acc_index</span><span class="p">))</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">([</span><span class="n">operand</span><span class="p">,</span> <span class="n">indices</span><span class="p">],</span>
               <span class="p">[</span><span class="n">get_identity</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)],</span>
               <span class="n">reducer_fn</span><span class="p">,</span>
               <span class="n">axes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">argmin_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_argminmax_shape_rule</span><span class="p">,</span> <span class="n">_argminmax_dtype_rule</span><span class="p">,</span>
                              <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">argmin_p</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">argmin_p</span><span class="p">)</span>

<span class="n">argmax_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span><span class="n">_argminmax_shape_rule</span><span class="p">,</span> <span class="n">_argminmax_dtype_rule</span><span class="p">,</span>
                              <span class="s1">&#39;argmax&#39;</span><span class="p">,</span> <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">argmax_p</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">defjvp_zero</span><span class="p">(</span><span class="n">argmax_p</span><span class="p">)</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">argmin_p</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">cache_lowering</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span>
  <span class="n">partial</span><span class="p">(</span><span class="n">_compute_argminmax</span><span class="p">,</span> <span class="n">lt</span><span class="p">,</span> <span class="n">_get_min_identity</span><span class="p">),</span>
  <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">argmax_p</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">cache_lowering</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span>
  <span class="n">partial</span><span class="p">(</span><span class="n">_compute_argminmax</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">_get_max_identity</span><span class="p">),</span>
  <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_reduce_logical_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;logical reduction requires operand dtype bool or int, got </span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>

<span class="n">reduce_or_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_reduce_logical_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="s1">&#39;reduce_or&#39;</span><span class="p">,</span>
    <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_or_p</span><span class="p">)</span>


<span class="n">reduce_and_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_reduce_logical_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="s1">&#39;reduce_and&#39;</span><span class="p">,</span>
    <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_and_p</span><span class="p">)</span>


<span class="n">reduce_xor_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_reduce_logical_shape_rule</span><span class="p">,</span> <span class="n">_input_dtype</span><span class="p">,</span> <span class="s1">&#39;reduce_xor&#39;</span><span class="p">,</span>
    <span class="n">weak_type_rule</span><span class="o">=</span><span class="n">_strip_weak_type</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defreducer</span><span class="p">(</span><span class="n">reduce_xor_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unary_reduce_lower</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">unit_factory</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReduceOp</span><span class="p">([</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">)],</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span>
                     <span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">(</span><span class="n">unit_factory</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span>
                     <span class="n">mlir</span><span class="o">.</span><span class="n">dense_int_elements</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
  <span class="n">scalar_type</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">dtype</span><span class="p">))</span>
  <span class="n">reducer_region</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scalar_type</span><span class="p">,</span> <span class="n">scalar_type</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">reducer_region</span><span class="p">):</span>
    <span class="n">add</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">(</span><span class="o">*</span><span class="n">reducer_region</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
    <span class="n">mhlo</span><span class="o">.</span><span class="n">ReturnOp</span><span class="p">(</span><span class="n">add</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_sum_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AddOp</span><span class="p">,</span>
                                         <span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_prod_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">MulOp</span><span class="p">,</span>
                                          <span class="k">lambda</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_or_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">OrOp</span><span class="p">,</span>
                                          <span class="n">_get_bitwise_or_identity</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_and_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AndOp</span><span class="p">,</span>
                                          <span class="n">_get_bitwise_and_identity</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_xor_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">XorOp</span><span class="p">,</span>
                                          <span class="n">_get_bitwise_or_identity</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_min_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">min_mhlo</span><span class="p">,</span>
                                         <span class="n">_get_min_identity</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_max_p</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_unary_reduce_lower</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">max_mhlo</span><span class="p">,</span>
                                         <span class="n">_get_max_identity</span><span class="p">))</span>




<span class="k">def</span> <span class="nf">_reduce_precision_shape_rule</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exponent_bits</span><span class="p">,</span> <span class="n">mantissa_bits</span><span class="p">):</span>
  <span class="n">exponent_bits</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">exponent_bits</span><span class="p">)</span>
  <span class="n">mantissa_bits</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mantissa_bits</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">exponent_bits</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reduce_precision: exponent_bits must be positive; got </span><span class="si">{</span><span class="n">exponent_bits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mantissa_bits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reduce_precision: mantissa_bits must be non-negative; got </span><span class="si">{</span><span class="n">mantissa_bits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span>


<span class="n">reduce_precision_p</span> <span class="o">=</span> <span class="n">standard_primitive</span><span class="p">(</span>
    <span class="n">_reduce_precision_shape_rule</span><span class="p">,</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">unop_dtype_rule</span><span class="p">,</span> <span class="n">_identity</span><span class="p">,</span> <span class="n">_float</span><span class="p">,</span> <span class="s1">&#39;reduce_precision&#39;</span><span class="p">),</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;reduce_precision&#39;</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">reduce_precision_p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduce_precision_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">exponent_bits</span><span class="p">,</span> <span class="n">mantissa_bits</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReducePrecisionOp</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">i32_attr</span><span class="p">(</span><span class="n">exponent_bits</span><span class="p">),</span>
                                <span class="n">mlir</span><span class="o">.</span><span class="n">i32_attr</span><span class="p">(</span><span class="n">mantissa_bits</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">reduce_precision_p</span><span class="p">,</span> <span class="n">_reduce_precision_lower</span><span class="p">)</span>



<span class="n">_UINT_DTYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span>
  <span class="mi">32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
  <span class="mi">64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">_INT_DTYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span>
  <span class="mi">32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
  <span class="mi">64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_sort_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Arguments to sort must have equal shapes, got: </span><span class="si">{</span><span class="n">shapes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">args</span>


<span class="k">def</span> <span class="nf">_float_to_int_for_sort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="c1"># Switch from a floating point value to a integer value in such a way that</span>
  <span class="c1"># when using the integer value to compare, we get the same result for normal</span>
  <span class="c1"># values, and -nan is treated as the smallest value, and nan is treated as</span>
  <span class="c1"># the largest value.</span>
  <span class="c1"># If f is a float, and</span>
  <span class="c1"># x = bit_cast&lt;int32&gt;(f);</span>
  <span class="c1"># y = x &lt; 0 ? int32_max - x : x;</span>
  <span class="c1"># then y is ordered as an int32 such that finite values have the obvious</span>
  <span class="c1"># order. In this scheme, -0 would be before 0, and -NaN and NaN appear at</span>
  <span class="c1"># the beginning and end of the ordering. This causes issues for stable</span>
  <span class="c1"># sorts, so we avoid this by standardizing the representation of zeros</span>
  <span class="c1"># and NaNs in the output.</span>
  <span class="c1"># Note that in order to avoid -x to overflow, we calculate</span>
  <span class="c1"># int32_max - x as unsigned, and then convert back to signed.</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
  <span class="n">nbits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span>
  <span class="n">signed_dtype</span> <span class="o">=</span> <span class="n">_INT_DTYPES</span><span class="p">[</span><span class="n">nbits</span><span class="p">]</span>
  <span class="n">unsigned_dtype</span> <span class="o">=</span> <span class="n">_UINT_DTYPES</span><span class="p">[</span><span class="n">nbits</span><span class="p">]</span>

  <span class="n">signed</span> <span class="o">=</span> <span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">signed_dtype</span><span class="p">)</span>
  <span class="n">unsigned</span> <span class="o">=</span> <span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unsigned_dtype</span><span class="p">)</span>

  <span class="c1"># We cannot standardize zeros in x because XLA elides this is some cases.</span>
  <span class="c1"># We cannot standardize NaNs in x because it triggers jax.debug_nans</span>
  <span class="c1"># So instead we do these replacements in the signed integer representation.</span>

  <span class="c1"># Standardize zeros:</span>
  <span class="n">signed</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">signed</span><span class="p">),</span> <span class="n">signed</span><span class="p">)</span>
  <span class="c1"># Standardize nans:</span>
  <span class="n">signed_nan</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">signed_dtype</span><span class="p">)</span>
  <span class="n">signed</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">full_like</span><span class="p">(</span><span class="n">signed</span><span class="p">,</span> <span class="n">signed_nan</span><span class="p">),</span> <span class="n">signed</span><span class="p">)</span>

  <span class="n">flipped</span> <span class="o">=</span> <span class="n">bitcast_convert_type</span><span class="p">(</span>
    <span class="n">sub</span><span class="p">(</span><span class="n">unsigned_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">signed_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">),</span> <span class="n">unsigned</span><span class="p">),</span> <span class="n">signed_dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">signed</span><span class="p">,</span> <span class="n">_zero</span><span class="p">(</span><span class="n">signed</span><span class="p">)),</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">signed</span><span class="p">)</span>

<span class="c1"># Default comparator that sorts the operands lexicographically on the</span>
<span class="c1"># first `num_keys` arguments.</span>
<span class="c1"># For floating point types, a total order is created where</span>
<span class="c1"># -infinity &lt; ... &lt; 0 &lt; ... &lt; infinity &lt; NaN.</span>
<span class="c1"># 0.0 and -0.0 are treated as equivalent, as are all NaN representations.</span>
<span class="c1"># For complex types, the (real, imag) pairs are sorted lexicographically</span>
<span class="c1"># (following NumPy&#39;s semantics).</span>
<span class="c1"># This code adds complex-number support and lexicographic ordering to the algorithm from:</span>
<span class="c1"># https://github.com/tensorflow/tensorflow/blob/ba43780830f09da72081fe5061c436f1c6203a92/tensorflow/compiler/xla/client/lib/comparators.h#L33</span>
<span class="k">def</span> <span class="nf">_sort_lt_comparator</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">x_keys</span><span class="p">,</span> <span class="n">y_keys</span> <span class="o">=</span> <span class="n">_operands_to_keys</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">)</span>
  <span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">for</span> <span class="n">xk</span><span class="p">,</span> <span class="n">yk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">),</span> <span class="n">bitwise_and</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
         <span class="k">else</span> <span class="n">lt</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">p</span>

<span class="c1"># Similar to sort_lt_comparator, but implements less than or equal. Used by</span>
<span class="c1"># the searchsorted() implementation.</span>
<span class="k">def</span> <span class="nf">_sort_le_comparator</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">x_keys</span><span class="p">,</span> <span class="n">y_keys</span> <span class="o">=</span> <span class="n">_operands_to_keys</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">)</span>
  <span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">for</span> <span class="n">xk</span><span class="p">,</span> <span class="n">yk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">lt</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">),</span> <span class="n">bitwise_and</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
         <span class="k">else</span> <span class="n">le</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">p</span>

<span class="k">def</span> <span class="nf">_operands_to_keys</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">operands</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">num_keys</span><span class="p">,</span> <span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">)</span>
  <span class="n">x_keys</span><span class="p">,</span> <span class="n">y_keys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operands</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">num_keys</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">num_keys</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
      <span class="n">x_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">))])</span>
      <span class="n">y_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">y</span><span class="p">))])</span>
    <span class="k">elif</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
      <span class="n">x_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
      <span class="n">y_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_float_to_int_for_sort</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">y_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x_keys</span><span class="p">,</span> <span class="n">y_keys</span>


<span class="k">def</span> <span class="nf">_sort_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">):</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">primals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
  <span class="n">iotas</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="n">iotas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
  <span class="n">primals</span> <span class="o">=</span> <span class="n">sort_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">primals</span> <span class="o">+</span> <span class="p">(</span><span class="n">iotas</span><span class="p">[</span><span class="n">dimension</span><span class="p">],)),</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                        <span class="n">is_stable</span><span class="o">=</span><span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">)</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">primals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">dimension</span> <span class="k">else</span> <span class="n">iotas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
  <span class="n">tangents_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span> <span class="k">else</span> <span class="n">t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">primals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tangents_out</span>

<span class="k">def</span> <span class="nf">_sort_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">):</span>
  <span class="n">prototype_arg</span><span class="p">,</span> <span class="n">new_bdim</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">bdim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">bdim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">prototype_arg</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">new_bdim</span><span class="p">)</span>
      <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prototype_arg</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dims</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batching</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">bdim</span><span class="p">,</span> <span class="n">new_bdim</span><span class="p">))</span>
  <span class="n">new_dimension</span> <span class="o">=</span> <span class="n">dimension</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_bdim</span> <span class="o">&lt;=</span> <span class="n">dimension</span><span class="p">)</span>
  <span class="n">bdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_bdim</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">sort_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">new_dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="o">=</span><span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">),</span>
          <span class="n">bdims</span><span class="p">)</span>


<span class="n">sort_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;sort&#39;</span><span class="p">)</span>
<span class="n">sort_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">sort_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">sort_p</span><span class="p">))</span>
<span class="n">sort_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_sort_abstract_eval</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">sort_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sort_jvp</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">sort_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sort_batch_rule</span>


<span class="k">def</span> <span class="nf">_sort_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">is_stable</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">),</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span>
  <span class="n">sort</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">SortOp</span><span class="p">([</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval</span><span class="p">)</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span><span class="p">],</span>
                     <span class="n">mlir</span><span class="o">.</span><span class="n">flatten_lowering_ir_args</span><span class="p">(</span><span class="n">operands</span><span class="p">),</span>
                     <span class="n">dimension</span><span class="o">=</span><span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
                     <span class="n">is_stable</span><span class="o">=</span><span class="n">ir</span><span class="o">.</span><span class="n">BoolAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">is_stable</span><span class="p">))</span>
  <span class="n">scalar_avals</span> <span class="o">=</span> <span class="p">[</span><span class="n">aval</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">())</span> <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">]</span>
  <span class="n">scalar_types</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">,</span> <span class="n">scalar_avals</span><span class="p">)</span>
  <span class="n">comparator</span> <span class="o">=</span> <span class="n">sort</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
      <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">scalar_types</span><span class="p">,</span> <span class="n">scalar_types</span><span class="p">)))</span>
  <span class="k">with</span> <span class="n">ir</span><span class="o">.</span><span class="n">InsertionPoint</span><span class="p">(</span><span class="n">comparator</span><span class="p">):</span>
    <span class="n">lower_comparator</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">lower_fun</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_sort_lt_comparator</span><span class="p">),</span>
                                      <span class="n">multiple_results</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sub_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">primitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">avals_in</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">scalar_avals</span><span class="p">,</span> <span class="n">scalar_avals</span><span class="p">)),</span>
                          <span class="n">avals_out</span><span class="o">=</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">lower_comparator</span><span class="p">(</span><span class="n">sub_ctx</span><span class="p">,</span> <span class="o">*</span><span class="p">[[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">comparator</span><span class="o">.</span><span class="n">arguments</span><span class="p">],</span>
                           <span class="n">num_keys</span><span class="o">=</span><span class="n">num_keys</span><span class="p">)</span>
    <span class="n">mhlo</span><span class="o">.</span><span class="n">ReturnOp</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">sort</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">sort_p</span><span class="p">,</span> <span class="n">_sort_lower</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_top_k_abstract_eval</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;k argument to top_k must be nonnegative, got </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;top_k operand must have &gt;= 1 dimension, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;k argument to top_k must be no larger than minor dimension; </span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
  <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                         <span class="n">weak_type</span><span class="o">=</span><span class="n">operand</span><span class="o">.</span><span class="n">weak_type</span><span class="p">),</span>
          <span class="n">operand</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_top_k_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">tangent</span><span class="p">,</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">primals_out</span> <span class="o">=</span> <span class="n">top_k</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
    <span class="n">tangent_out</span> <span class="o">=</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">primals_out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">k_idxs</span> <span class="o">=</span> <span class="n">primals_out</span>
    <span class="n">idx_shape</span> <span class="o">=</span> <span class="n">k_idxs</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">)</span>
    <span class="n">gather_index_shape</span> <span class="o">=</span> <span class="n">idx_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="n">gather_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">_iota</span> <span class="o">=</span> <span class="n">iota</span><span class="p">(</span><span class="n">k_idxs</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">idx_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">_iota</span> <span class="o">=</span> <span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">_iota</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_iota</span><span class="p">)</span>
    <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_idxs</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">))</span>
    <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span>
    <span class="n">slice_sizes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">rank</span>
    <span class="n">dnums</span> <span class="o">=</span> <span class="n">slicing</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
      <span class="n">offset_dims</span><span class="o">=</span><span class="p">(),</span>
      <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">)),</span>
      <span class="n">start_index_map</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">)))</span>
    <span class="n">tangent_out</span> <span class="o">=</span> <span class="n">slicing</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">tangent</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">,</span> <span class="n">dnums</span><span class="p">,</span> <span class="n">slice_sizes</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">primals_out</span><span class="p">,</span> <span class="p">(</span><span class="n">tangent_out</span><span class="p">,</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">primals_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">_top_k_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="n">operand</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">bdim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="k">if</span> <span class="n">bdim</span> <span class="o">==</span> <span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">perm</span><span class="p">[</span><span class="n">bdim</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">bdim</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">bdim</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">bdim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">top_k_v</span><span class="p">,</span> <span class="n">top_k_i</span> <span class="o">=</span> <span class="n">top_k</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">top_k_v</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span>
            <span class="n">transpose</span><span class="p">(</span><span class="n">top_k_i</span><span class="p">,</span> <span class="n">perm</span><span class="p">)),</span> <span class="p">(</span><span class="n">bdim</span><span class="p">,</span> <span class="n">bdim</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">top_k</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">bdim</span><span class="p">,</span> <span class="n">bdim</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_top_k_translation_rule</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">avals_in</span><span class="p">,</span> <span class="n">avals_out</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">xla</span><span class="o">.</span><span class="n">xla_destructure</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">builder</span><span class="p">,</span> <span class="n">xops</span><span class="o">.</span><span class="n">TopK</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>

<span class="n">top_k_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;top_k&#39;</span><span class="p">)</span>
<span class="n">top_k_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">top_k_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">top_k_p</span><span class="p">))</span>
<span class="n">top_k_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_top_k_abstract_eval</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_top_k_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">chlo</span><span class="o">.</span><span class="n">TopKOp</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">top_k_p</span><span class="p">,</span> <span class="n">_top_k_lower</span><span class="p">)</span>
<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">top_k_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_top_k_jvp</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">top_k_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_top_k_batch_rule</span>

<span class="k">def</span> <span class="nf">_stop_gradient_jvp_rule</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="c1"># if we don&#39;t call stop_gradient here, we&#39;d only peel off one autodiff tracer</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="k">return</span> <span class="n">stop_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ad_util</span><span class="o">.</span><span class="n">Zero</span><span class="o">.</span><span class="n">from_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_stop_gradient_batch_rule</span><span class="p">(</span><span class="n">batched_args</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">batched_args</span>
  <span class="n">dim</span><span class="p">,</span> <span class="o">=</span> <span class="n">batch_dims</span>
  <span class="k">return</span> <span class="n">stop_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dim</span>

<span class="n">ad</span><span class="o">.</span><span class="n">primitive_jvps</span><span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">stop_gradient_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_stop_gradient_jvp_rule</span>
<span class="n">batching</span><span class="o">.</span><span class="n">primitive_batchers</span><span class="p">[</span><span class="n">ad_util</span><span class="o">.</span><span class="n">stop_gradient_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_stop_gradient_batch_rule</span>


<span class="k">def</span> <span class="nf">create_token</span><span class="p">(</span><span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Creates an XLA token value with no preconditions for sequencing effects.</span>

<span class="sd">  Experimental.</span>

<span class="sd">  The argument is ignored. It exists for backward compatibility.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">create_token_p</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span>

<span class="n">create_token_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;create_token&quot;</span><span class="p">)</span>
<span class="n">create_token_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">create_token_p</span><span class="p">))</span>
<span class="n">create_token_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">_</span><span class="p">:</span> <span class="n">abstract_token</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_create_token_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">CreateTokenOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">create_token_p</span><span class="p">,</span> <span class="n">_create_token_lowering</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">after_all</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Merges one or more XLA token values. Experimental.</span>

<span class="sd">  Wraps the XLA AfterAll operator.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">after_all_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_after_all_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">abstract_token</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Arguments to after_all must be tokens&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">abstract_token</span>


<span class="n">after_all_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;after_all&quot;</span><span class="p">)</span>
<span class="n">after_all_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">after_all_p</span><span class="p">))</span>
<span class="n">after_all_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_after_all_abstract_eval</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_after_all_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">AfterAllOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span> <span class="n">operands</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">after_all_p</span><span class="p">,</span> <span class="n">_after_all_lowering</span><span class="p">)</span>


<span class="n">InOutFeedEffect</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">(</span><span class="s1">&#39;InOutFeedEffect&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Infeed&#39;</span><span class="p">,</span> <span class="s1">&#39;Outfeed&#39;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">infeed</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Consumes an infeed value of `shape` from the host. Experimental.</span>

<span class="sd">  `token` is used to sequence infeed and outfeed effects.</span>
<span class="sd">  `partitions` may be specified inside a `sharded_jit` function.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">flat_shapes</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">flat_shapes</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape argument to infeed must be a pytree of &quot;</span>
                      <span class="s2">&quot;ShapedArray values, got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Always replicate token.</span>
    <span class="c1"># We specifically use type() to raise an error for PartitionSpecs.</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">:</span>  <span class="c1"># pylint: disable=unidiomatic-typecheck</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;partitions&#39; argument to infeed should be a tuple, &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">partitions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">partitions</span> <span class="o">=</span> <span class="n">partitions</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
  <span class="n">xs_and_token</span> <span class="o">=</span> <span class="n">infeed_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flat_shapes</span><span class="p">),</span>
                               <span class="n">partitions</span><span class="o">=</span><span class="n">partitions</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">xs_and_token</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">xs_and_token</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_infeed_abstract_eval</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">partitions</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">token</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">abstract_token</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;First argument to infeed must be a token&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">,</span> <span class="n">abstract_token</span><span class="p">),</span> <span class="p">{</span><span class="n">InOutFeedEffect</span><span class="o">.</span><span class="n">Infeed</span><span class="p">}</span>


<span class="n">infeed_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;infeed&quot;</span><span class="p">)</span>
<span class="n">infeed_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">infeed_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">infeed_p</span><span class="p">))</span>
<span class="n">infeed_p</span><span class="o">.</span><span class="n">def_effectful_abstract_eval</span><span class="p">(</span><span class="n">_infeed_abstract_eval</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">lowerable_effects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">InOutFeedEffect</span><span class="o">.</span><span class="n">Infeed</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_infeed_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">partitions</span><span class="p">):</span>
  <span class="n">output_types</span> <span class="o">=</span> <span class="n">safe_map</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_types</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">flat_output_types</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">output_types</span><span class="p">)</span>
  <span class="c1"># TODO(phawkins): verify `shapes` have a major-to-minor layout.</span>
  <span class="n">layouts</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">ArrayAttr</span><span class="o">.</span><span class="n">get</span><span class="p">([</span>
      <span class="n">ir</span><span class="o">.</span><span class="n">ArrayAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
          <span class="p">[</span><span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
      <span class="k">for</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">shapes</span>
  <span class="p">])</span>
  <span class="n">infeed</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">InfeedOp</span><span class="p">(</span>
      <span class="n">flat_output_types</span> <span class="o">+</span> <span class="p">[</span><span class="n">mhlo</span><span class="o">.</span><span class="n">TokenType</span><span class="o">.</span><span class="n">get</span><span class="p">()],</span>
      <span class="n">token</span><span class="p">,</span>
      <span class="n">infeed_config</span><span class="o">=</span><span class="n">ir</span><span class="o">.</span><span class="n">StringAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span>
      <span class="n">layout</span><span class="o">=</span><span class="n">layouts</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">mlir</span><span class="o">.</span><span class="n">set_sharding</span><span class="p">(</span><span class="n">infeed</span><span class="p">,</span> <span class="n">xla</span><span class="o">.</span><span class="n">sharding_to_proto</span><span class="p">(</span><span class="n">partitions</span><span class="p">))</span>
  <span class="n">token</span> <span class="o">=</span> <span class="n">infeed</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">outs</span> <span class="o">=</span> <span class="n">infeed</span><span class="o">.</span><span class="n">results</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">safe_map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">output_types</span><span class="p">))</span> <span class="o">+</span> <span class="p">[[</span>
      <span class="n">token</span><span class="p">,</span>
  <span class="p">]]</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">infeed_p</span><span class="p">,</span> <span class="n">_infeed_lowering</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">outfeed</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">partitions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Outfeeds value `xs` to the host. Experimental.</span>

<span class="sd">  `token` is used to sequence infeed and outfeed effects.</span>
<span class="sd">  `partitions` may be specified inside a `sharded_jit` or `pjit` function.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># We specifically use type() to raise an error for PartitionSpecs.</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">:</span>  <span class="c1"># pylint: disable=unidiomatic-typecheck</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;partitions&#39; argument to outfeed should be a tuple, &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">partitions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">flat_xs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">outfeed_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="n">flat_xs</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="n">partitions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_outfeed_abstract_eval</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">,</span> <span class="n">partitions</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">token</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">abstract_token</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;First argument to outfeed must be a token&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">abstract_token</span><span class="p">,</span> <span class="p">{</span><span class="n">InOutFeedEffect</span><span class="o">.</span><span class="n">Outfeed</span><span class="p">}</span>

<span class="n">outfeed_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;outfeed&quot;</span><span class="p">)</span>
<span class="n">outfeed_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">outfeed_p</span><span class="p">))</span>
<span class="n">outfeed_p</span><span class="o">.</span><span class="n">def_effectful_abstract_eval</span><span class="p">(</span><span class="n">_outfeed_abstract_eval</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">lowerable_effects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">InOutFeedEffect</span><span class="o">.</span><span class="n">Outfeed</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_outfeed_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="n">xs</span><span class="p">,</span> <span class="n">partitions</span><span class="p">):</span>
  <span class="n">token_aval</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">outfeed</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">OutfeedOp</span><span class="p">(</span>
      <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">token_aval</span><span class="p">),</span>
      <span class="n">mlir</span><span class="o">.</span><span class="n">flatten_lowering_ir_args</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span>
      <span class="n">token</span><span class="p">,</span>
      <span class="n">outfeed_config</span><span class="o">=</span><span class="n">ir</span><span class="o">.</span><span class="n">StringAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">mlir</span><span class="o">.</span><span class="n">set_sharding</span><span class="p">(</span><span class="n">outfeed</span><span class="p">,</span> <span class="n">xla</span><span class="o">.</span><span class="n">sharding_to_proto</span><span class="p">(</span><span class="n">partitions</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">outfeed</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">outfeed_p</span><span class="p">,</span> <span class="n">_outfeed_lowering</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rng_uniform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Stateful PRNG generator. Experimental and its use is discouraged.</span>

<span class="sd">  Returns uniformly distributed random numbers in the range [a, b)</span>

<span class="sd">  You should use jax.random for most purposes; this function exists only for</span>
<span class="sd">  niche use cases with special performance requirements.</span>

<span class="sd">  This API may be removed at any time.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">rng_uniform_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_rng_uniform_abstract_eval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
      <span class="s2">&quot;Arguments to rng_uniform must have identical dtypes, got </span><span class="si">{}</span><span class="s2"> &quot;</span>
      <span class="s2">&quot;and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
      <span class="s2">&quot;Arguments to rng_uniform must be scalars; got shapes </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                  <span class="n">weak_type</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">weak_type</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">weak_type</span><span class="p">))</span>

<span class="n">rng_uniform_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;rng_uniform&quot;</span><span class="p">)</span>
<span class="n">rng_uniform_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">rng_uniform_p</span><span class="p">))</span>
<span class="n">rng_uniform_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_rng_uniform_abstract_eval</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_rng_uniform_lowering</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="n">shape</span><span class="p">,</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aval_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                             <span class="n">canonicalize_types</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RngOp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                    <span class="n">mhlo</span><span class="o">.</span><span class="n">RngDistributionAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;UNIFORM&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>

<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">rng_uniform_p</span><span class="p">,</span> <span class="n">_rng_uniform_lowering</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rng_bit_generator_shape_rule</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_rng_bit_generator_dtype_rule</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">shape</span><span class="p">,</span> <span class="n">algorithm</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_rng_bit_generator_weak_type_rule</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">weak_type</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">RandomAlgorithm</span> <span class="o">=</span> <span class="n">xops</span><span class="o">.</span><span class="n">RandomAlgorithm</span>
<span class="n">RandomAlgorithm</span><span class="o">.</span><span class="fm">__str__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">algorithm</span><span class="p">:</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># type: ignore[assignment]</span>

<span class="k">def</span> <span class="nf">_rng_algorithm</span><span class="p">(</span><span class="n">algorithm</span><span class="p">:</span> <span class="n">RandomAlgorithm</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="n">RandomAlgorithm</span><span class="o">.</span><span class="n">RNG_THREE_FRY</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RngAlgorithmAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;THREE_FRY&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="n">RandomAlgorithm</span><span class="o">.</span><span class="n">RNG_PHILOX</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RngAlgorithmAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PHILOX&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="n">RandomAlgorithm</span><span class="o">.</span><span class="n">RNG_DEFAULT</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RngAlgorithmAttr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEFAULT&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_rng_bit_generator_lowering</span><span class="p">(</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="n">key_type</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
  <span class="n">key_shape</span><span class="p">,</span> <span class="n">key_etype</span> <span class="o">=</span> <span class="n">key_type</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">key_type</span><span class="o">.</span><span class="n">element_type</span>
  <span class="c1"># While the RngBitGenerator HLO accepts a u64[2] key on all backends, we</span>
  <span class="c1"># typically represent the key argument to this primitive as a u32[4] so as to</span>
  <span class="c1"># sidestep issues with the jax_enable_x64=False configuration. As a result, we</span>
  <span class="c1"># need to convert u32[4] -&gt; u64[2] here in the translation rule. However, we</span>
  <span class="c1"># also polymorphically allow a u64[2] for backward compatibility.</span>
  <span class="c1">#</span>
  <span class="c1"># Separately, xops.RngBitGenerator doesn&#39;t support generating u8 or</span>
  <span class="c1"># u16, so we request u32 and truncate in that case.</span>
  <span class="n">u32_type</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">IntegerType</span><span class="o">.</span><span class="n">get_unsigned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
  <span class="n">u64_type</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">IntegerType</span><span class="o">.</span><span class="n">get_unsigned</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
  <span class="k">assert</span> <span class="p">((</span><span class="n">key_shape</span> <span class="o">==</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key_etype</span> <span class="o">==</span> <span class="n">u32_type</span><span class="p">)</span> <span class="ow">or</span>
          <span class="p">(</span><span class="n">key_shape</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key_etype</span> <span class="o">==</span> <span class="n">u64_type</span><span class="p">)),</span> <span class="p">(</span><span class="n">key_shape</span><span class="p">,</span> <span class="n">key_etype</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">etype</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">.</span><span class="n">dtype_to_ir_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">):</span>
    <span class="n">rbg_etype</span> <span class="o">=</span> <span class="n">etype</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">rbg_etype</span> <span class="o">=</span> <span class="n">u32_type</span>
  <span class="k">if</span> <span class="n">key_etype</span> <span class="o">==</span> <span class="n">u32_type</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">BitcastConvertOp</span><span class="p">(</span>
        <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">u64_type</span><span class="p">),</span>
        <span class="n">mhlo</span><span class="o">.</span><span class="n">ReshapeOp</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">u32_type</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span><span class="o">.</span><span class="n">result</span>
  <span class="n">algorithm_attr</span> <span class="o">=</span> <span class="n">_rng_algorithm</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
  <span class="n">out_key</span><span class="p">,</span> <span class="n">out_vals</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">RngBitGeneratorOp</span><span class="p">(</span>
      <span class="n">key</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
      <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">rbg_etype</span><span class="p">),</span>
      <span class="n">algorithm_attr</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">if</span> <span class="n">key_etype</span> <span class="o">==</span> <span class="n">u32_type</span><span class="p">:</span>
    <span class="n">out_key</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ReshapeOp</span><span class="p">(</span>
        <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">u32_type</span><span class="p">),</span>
        <span class="n">mhlo</span><span class="o">.</span><span class="n">BitcastConvertOp</span><span class="p">(</span>
            <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">u32_type</span><span class="p">),</span> <span class="n">out_key</span><span class="p">))</span><span class="o">.</span><span class="n">result</span>
  <span class="k">if</span> <span class="n">rbg_etype</span> <span class="o">!=</span> <span class="n">etype</span><span class="p">:</span>
    <span class="n">out_vals</span> <span class="o">=</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">ConvertOp</span><span class="p">(</span>
      <span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ir</span><span class="o">.</span><span class="n">RankedTensorType</span><span class="p">(</span><span class="n">out_vals</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">etype</span><span class="p">),</span>
      <span class="n">out_vals</span><span class="p">)</span><span class="o">.</span><span class="n">result</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">out_key</span><span class="p">,</span> <span class="n">out_vals</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_rng_bit_generator_named_shape_rule</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">named_shape</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">named_shape</span><span class="p">]</span>

<span class="n">rng_bit_generator_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s2">&quot;rng_bit_generator&quot;</span><span class="p">)</span>
<span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">multiple_results</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">rng_bit_generator_p</span><span class="p">))</span>
<span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span>
    <span class="n">partial</span><span class="p">(</span><span class="n">standard_multi_result_abstract_eval</span><span class="p">,</span> <span class="n">rng_bit_generator_p</span><span class="p">,</span>
            <span class="n">_rng_bit_generator_shape_rule</span><span class="p">,</span> <span class="n">_rng_bit_generator_dtype_rule</span><span class="p">,</span>
            <span class="n">_rng_bit_generator_weak_type_rule</span><span class="p">,</span>
            <span class="n">_rng_bit_generator_named_shape_rule</span><span class="p">))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">rng_bit_generator_p</span><span class="p">,</span>
                       <span class="n">_rng_bit_generator_lowering</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_copy</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">copy_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="c1"># The copy_p primitive exists for expressing making copies of runtime arrays.</span>
<span class="c1"># For that reason we don&#39;t simplify it out of jaxprs (e.g. for jit invariance).</span>
<span class="c1"># It&#39;s used in jnp.array(x, copy=True), which is the user-facing API.</span>
<span class="n">copy_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
<span class="n">copy_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">copy_p</span><span class="p">))</span>
<span class="n">copy_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">copy_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="n">ad</span><span class="o">.</span><span class="n">deflinear</span><span class="p">(</span><span class="n">copy_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">copy_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
<span class="n">pe</span><span class="o">.</span><span class="n">def_trivial_padding</span><span class="p">(</span><span class="n">copy_p</span><span class="p">)</span>
<span class="n">batching</span><span class="o">.</span><span class="n">defvectorized</span><span class="p">(</span><span class="n">copy_p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rng_bit_generator</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
                      <span class="n">algorithm</span><span class="o">=</span><span class="n">RandomAlgorithm</span><span class="o">.</span><span class="n">RNG_DEFAULT</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Stateless PRNG bit generator. Experimental and its use is discouraged.</span>

<span class="sd">  Returns uniformly distributed random bits with the specified shape and dtype</span>
<span class="sd">  (what is required to be an integer type) using the platform specific</span>
<span class="sd">  default algorithm or the one specified.</span>

<span class="sd">  It provides direct access to the RngBitGenerator primitive exposed by XLA</span>
<span class="sd">  (https://www.tensorflow.org/xla/operation_semantics#rngbitgenerator) for low</span>
<span class="sd">  level API access.</span>

<span class="sd">  Most users should use `jax.random` instead for a stable and more user</span>
<span class="sd">  friendly API.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">)}:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;rng_bit_generator: unsupported dtype </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
      <span class="n">rng_bit_generator_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
          <span class="n">key</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_iota_abstract_eval</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="n">_check_shapelike</span><span class="p">(</span><span class="s2">&quot;iota&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_num</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;iota does not accept dtype </span><span class="si">{}</span><span class="s1">. Accepted dtypes are subtypes of </span><span class="si">{}</span><span class="s1">.&#39;</span>
    <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">accepted_typenames</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_num</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">accepted_typenames</span><span class="p">)))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;iota dimension must be between 0 and len(shape), got &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;dimension=</span><span class="si">{</span><span class="n">dimension</span><span class="si">}</span><span class="s2"> for shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">BInt</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="c1"># TODO(mattjj): unify DShapedArray with ShapedArray, and remove this code</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">iota_p</span> <span class="o">=</span> <span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;iota&#39;</span><span class="p">)</span>
<span class="n">iota_p</span><span class="o">.</span><span class="n">def_impl</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">xla</span><span class="o">.</span><span class="n">apply_primitive</span><span class="p">,</span> <span class="n">iota_p</span><span class="p">))</span>
<span class="n">iota_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="n">_iota_abstract_eval</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_iota_staging_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">trace</span><span class="o">.</span><span class="n">default_process_primitive</span><span class="p">(</span><span class="n">iota_p</span><span class="p">,</span> <span class="p">(),</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_dyn_shape_staging_rule</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">iota_p</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">custom_staging_rules</span><span class="p">[</span><span class="n">iota_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_iota_staging_rule</span>

<span class="k">def</span> <span class="nf">_iota_typecheck_rule</span><span class="p">(</span><span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">out_aval</span><span class="p">,</span> <span class="n">effects</span> <span class="o">=</span> <span class="n">iota_p</span><span class="o">.</span><span class="n">abstract_eval</span><span class="p">(</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">effects</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">core</span><span class="o">.</span><span class="n">Literal</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
    <span class="n">out_aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">out_aval</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">no_effects</span>
<span class="n">core</span><span class="o">.</span><span class="n">custom_typechecks</span><span class="p">[</span><span class="n">iota_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_iota_typecheck_rule</span>

<span class="k">def</span> <span class="nf">_iota_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">dtype</span>
  <span class="n">aval_out</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">avals_out</span>
  <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">_merge_dyn_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">DynamicIotaOp</span><span class="p">(</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">shape_tensor</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
        <span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">results</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mhlo</span><span class="o">.</span><span class="n">IotaOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">.</span><span class="n">aval_to_ir_type</span><span class="p">(</span><span class="n">aval_out</span><span class="p">),</span>
                       <span class="n">mlir</span><span class="o">.</span><span class="n">i64_attr</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span><span class="o">.</span><span class="n">results</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">iota_p</span><span class="p">,</span> <span class="n">_iota_lower</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_iota_pp_rule</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
  <span class="n">printed_params</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">printed_params</span><span class="p">[</span><span class="s1">&#39;dimension&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eqn</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;dimension&#39;</span><span class="p">]</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">outvars</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">print_shapes</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">print_shapes</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">primitive</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
         <span class="n">core</span><span class="o">.</span><span class="n">pp_kv_pairs</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">printed_params</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">),</span>
         <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">core</span><span class="o">.</span><span class="n">pp_vars</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">invars</span><span class="p">,</span> <span class="n">context</span><span class="p">)]</span>
  <span class="n">annotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_info_util</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">eqn</span><span class="o">.</span><span class="n">source_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">source_info</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">),</span> <span class="o">*</span><span class="n">rhs</span><span class="p">]</span>
<span class="c1"># core.pp_eqn_rules[iota_p] = _iota_pp_rule</span>

<span class="k">def</span> <span class="nf">_iota_padding_rule</span><span class="p">(</span><span class="n">in_avals</span><span class="p">,</span> <span class="n">out_avals</span><span class="p">,</span> <span class="o">*</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
  <span class="n">out_aval</span><span class="p">,</span> <span class="o">=</span> <span class="n">out_avals</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">new_dyn_shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_aval</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">pe</span><span class="o">.</span><span class="n">BoundedAxisSize</span><span class="p">:</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span>
      <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
      <span class="n">new_dyn_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">iota_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">new_dyn_shape</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)]</span>
<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">iota_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_iota_padding_rule</span>


<span class="k">def</span> <span class="nf">make_bint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bd</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">bint_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bd</span><span class="o">=</span><span class="n">bd</span><span class="p">)</span>

<span class="n">bint_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;bint&#39;</span><span class="p">)</span>

<span class="nd">@bint_p</span><span class="o">.</span><span class="n">def_impl</span>
<span class="k">def</span> <span class="nf">_bint_impl</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bd</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">BInt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span>

<span class="nd">@bint_p</span><span class="o">.</span><span class="n">def_abstract_eval</span>
<span class="k">def</span> <span class="nf">bint_abstract_eval</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bd</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">AbstractBInt</span><span class="p">(</span><span class="n">bound</span><span class="o">=</span><span class="n">bd</span><span class="p">)</span>

<span class="n">pe</span><span class="o">.</span><span class="n">padding_rules</span><span class="p">[</span><span class="n">bint_p</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bd</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">bint_p</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bd</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>


<span class="c1">### util</span>

<span class="n">_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span>


<span class="k">def</span> <span class="nf">_dilate_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dilation</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Utility function for computing the shape resulting from a dilation.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">dilation</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;All dilations must be positive, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dilation</span><span class="p">))</span>
  <span class="n">dilation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dilation</span><span class="p">))</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dilation</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">dilate_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dilation</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_ceil_divide</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">x2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">padtype_to_pads</span><span class="p">(</span><span class="n">in_shape</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">,</span> <span class="n">window_strides</span><span class="p">,</span> <span class="n">padding</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Convert padding string to list of pairs of pad values.&quot;&quot;&quot;</span>
  <span class="n">PaddingType</span> <span class="o">=</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">PaddingType</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;VALID&#39;</span><span class="p">:</span> <span class="n">PaddingType</span><span class="o">.</span><span class="n">VALID</span><span class="p">,</span> <span class="s1">&#39;SAME&#39;</span><span class="p">:</span> <span class="n">PaddingType</span><span class="o">.</span><span class="n">SAME</span><span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">padding</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">padding</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unrecognized padding type: expected &#39;VALID&#39; or &#39;SAME&#39;, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">padding</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>

  <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="n">PaddingType</span><span class="o">.</span><span class="n">SAME</span><span class="p">:</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">_ceil_divide</span><span class="p">(</span><span class="n">in_shape</span><span class="p">,</span> <span class="n">window_strides</span><span class="p">)</span>
    <span class="n">pad_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">out_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_strides</span> <span class="o">+</span>
                                <span class="n">window_shape</span> <span class="o">-</span> <span class="n">in_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">pad_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_size</span> <span class="o">-</span> <span class="n">pad_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">pad_size</span> <span class="ow">in</span> <span class="n">pad_sizes</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">padding</span> <span class="o">==</span> <span class="n">PaddingType</span><span class="o">.</span><span class="n">VALID</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unknown padding type: </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">padding</span><span class="p">))</span>


<span class="c1"># Map of lax function to equivalent jax.numpy function for use in error string below.</span>
<span class="n">_JNP_FUNCTION_EQUIVALENTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;abs&#39;</span><span class="p">:</span> <span class="s1">&#39;fabs&#39;</span><span class="p">,</span>
  <span class="s1">&#39;acos&#39;</span><span class="p">:</span> <span class="s1">&#39;arccos&#39;</span><span class="p">,</span>
  <span class="s1">&#39;acosh&#39;</span><span class="p">:</span> <span class="s1">&#39;arccosh&#39;</span><span class="p">,</span>
  <span class="s1">&#39;add&#39;</span><span class="p">:</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span>
  <span class="s1">&#39;asin&#39;</span><span class="p">:</span> <span class="s1">&#39;arcsin&#39;</span><span class="p">,</span>
  <span class="s1">&#39;asinh&#39;</span><span class="p">:</span> <span class="s1">&#39;arcsinh&#39;</span><span class="p">,</span>
  <span class="s1">&#39;atan&#39;</span><span class="p">:</span> <span class="s1">&#39;arctan&#39;</span><span class="p">,</span>
  <span class="s1">&#39;atan2&#39;</span><span class="p">:</span> <span class="s1">&#39;arctan2&#39;</span><span class="p">,</span>
  <span class="s1">&#39;atanh&#39;</span><span class="p">:</span> <span class="s1">&#39;arctanh&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bitwise_and&#39;</span><span class="p">:</span> <span class="s1">&#39;bitwise_and&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bitwise_not&#39;</span><span class="p">:</span> <span class="s1">&#39;bitwise_not&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bitwise_or&#39;</span><span class="p">:</span> <span class="s1">&#39;bitwise_or&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bitwise_xor&#39;</span><span class="p">:</span> <span class="s1">&#39;bitwise_xor&#39;</span><span class="p">,</span>
  <span class="s1">&#39;cbrt&#39;</span><span class="p">:</span> <span class="s1">&#39;cbrt&#39;</span><span class="p">,</span>
  <span class="s1">&#39;ceil&#39;</span><span class="p">:</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span>
  <span class="s1">&#39;concatenate&#39;</span><span class="p">:</span> <span class="s1">&#39;concatenate&#39;</span><span class="p">,</span>
  <span class="s1">&#39;cos&#39;</span><span class="p">:</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span>
  <span class="s1">&#39;cosh&#39;</span><span class="p">:</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span>
  <span class="s1">&#39;div&#39;</span><span class="p">:</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span>
  <span class="s1">&#39;eq&#39;</span><span class="p">:</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span>
  <span class="s1">&#39;exp&#39;</span><span class="p">:</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span>
  <span class="s1">&#39;expm1&#39;</span><span class="p">:</span> <span class="s1">&#39;expm1&#39;</span><span class="p">,</span>
  <span class="s1">&#39;floor&#39;</span><span class="p">:</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span>
  <span class="s1">&#39;greater&#39;</span><span class="p">:</span> <span class="s1">&#39;greater&#39;</span><span class="p">,</span>
  <span class="s1">&#39;greater_equal&#39;</span><span class="p">:</span> <span class="s1">&#39;greater_equal&#39;</span><span class="p">,</span>
  <span class="s1">&#39;less&#39;</span><span class="p">:</span> <span class="s1">&#39;less&#39;</span><span class="p">,</span>
  <span class="s1">&#39;less_equal&#39;</span><span class="p">:</span> <span class="s1">&#39;less_equal&#39;</span><span class="p">,</span>
  <span class="s1">&#39;log&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
  <span class="s1">&#39;logical_and&#39;</span><span class="p">:</span> <span class="s1">&#39;logical_and&#39;</span><span class="p">,</span>
  <span class="s1">&#39;logical_not&#39;</span><span class="p">:</span> <span class="s1">&#39;logical_not&#39;</span><span class="p">,</span>
  <span class="s1">&#39;logical_or&#39;</span><span class="p">:</span> <span class="s1">&#39;logical_or&#39;</span><span class="p">,</span>
  <span class="s1">&#39;logical_xor&#39;</span><span class="p">:</span> <span class="s1">&#39;logical_xor&#39;</span><span class="p">,</span>
  <span class="s1">&#39;log1p&#39;</span><span class="p">:</span> <span class="s1">&#39;log1p&#39;</span><span class="p">,</span>
  <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="s1">&#39;maximum&#39;</span><span class="p">,</span>
  <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="s1">&#39;minimum&#39;</span><span class="p">,</span>
  <span class="s1">&#39;mul&#39;</span><span class="p">:</span> <span class="s1">&#39;multiply&#39;</span><span class="p">,</span>
  <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="s1">&#39;not_equal&#39;</span><span class="p">,</span>
  <span class="s1">&#39;neg&#39;</span><span class="p">:</span> <span class="s1">&#39;negative&#39;</span><span class="p">,</span>
  <span class="s1">&#39;nextafter&#39;</span><span class="p">:</span> <span class="s1">&#39;nextafter&#39;</span><span class="p">,</span>
  <span class="s1">&#39;pow&#39;</span><span class="p">:</span> <span class="s1">&#39;float_power&#39;</span><span class="p">,</span>
  <span class="s1">&#39;rount&#39;</span><span class="p">:</span> <span class="s1">&#39;rount&#39;</span><span class="p">,</span>
  <span class="s1">&#39;select&#39;</span><span class="p">:</span> <span class="s1">&#39;where&#39;</span><span class="p">,</span>
  <span class="s1">&#39;shift_left&#39;</span><span class="p">:</span> <span class="s1">&#39;left_shift&#39;</span><span class="p">,</span>
  <span class="s1">&#39;shift_right_logical&#39;</span><span class="p">:</span> <span class="s1">&#39;right_shift&#39;</span><span class="p">,</span>
  <span class="s1">&#39;shift_right_arithmetic&#39;</span><span class="p">:</span> <span class="s1">&#39;right_shift&#39;</span><span class="p">,</span>
  <span class="s1">&#39;sign&#39;</span><span class="p">:</span> <span class="s1">&#39;sign&#39;</span><span class="p">,</span>
  <span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span>
  <span class="s1">&#39;sinh&#39;</span><span class="p">:</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span>
  <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span>
  <span class="s1">&#39;sub&#39;</span><span class="p">:</span> <span class="s1">&#39;subtract&#39;</span><span class="p">,</span>
  <span class="s1">&#39;tan&#39;</span><span class="p">:</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span>
  <span class="s1">&#39;tanh&#39;</span><span class="p">:</span> <span class="s1">&#39;tanh&#39;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">_check_same_dtypes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ignore_fp_precision</span><span class="p">,</span> <span class="o">*</span><span class="n">ttypes</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Check that dtypes agree, possibly ignoring float precision.&quot;&quot;&quot;</span>
  <span class="c1"># the `ignore_fp_precision` flag exists because the XLA shape inference logic</span>
  <span class="c1"># allows mixed floating point precision, but the HLO verifier often rejects it</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ttypes</span><span class="p">):</span>
    <span class="k">return</span>  <span class="c1"># TODO(mattjj,frostig): do some checking, friend</span>
  <span class="n">types</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ttypes</span><span class="p">)</span>  <span class="c1"># canonicalize</span>
  <span class="k">if</span> <span class="n">ignore_fp_precision</span><span class="p">:</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">floating</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">dtype</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ignore_fp_precision</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;lax.</span><span class="si">{}</span><span class="s2"> requires arguments to have same dtypes up to floating point &quot;</span>
             <span class="s2">&quot;precision, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;lax.</span><span class="si">{}</span><span class="s2"> requires arguments to have the same dtypes, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_JNP_FUNCTION_EQUIVALENTS</span><span class="p">:</span>
      <span class="n">equiv</span> <span class="o">=</span> <span class="n">_JNP_FUNCTION_EQUIVALENTS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (Tip: jnp.</span><span class="si">{</span><span class="n">equiv</span><span class="si">}</span><span class="s2"> is a similar function that does automatic type promotion on inputs).&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">types</span><span class="p">))))</span>


<span class="k">def</span> <span class="nf">_check_shapelike</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">non_zero_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Check that `obj` is a shape-like value (e.g. tuple of nonnegative ints).&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> must be of type tuple/list/ndarray, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>
  <span class="c1"># bool(obj) for an ndarray raises an error, so we check len</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  <span class="c1"># pylint: disable=g-explicit-length-test</span>
    <span class="k">return</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span>
      <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">BInt</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)):</span>
    <span class="k">return</span>  <span class="c1"># TODO(mattjj): handle more checks in the dynamic shape case</span>
  <span class="n">obj_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">obj_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> must be 1-dimensional, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj_arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">obj_arr</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> must have every element be an integer type, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">obj</span><span class="p">))))</span> <span class="kn">from</span> <span class="nn">err</span>
  <span class="n">lower_bound</span><span class="p">,</span> <span class="n">bound_error</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;strictly positive&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">non_zero_shape</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;nonnegative&quot;</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">greater_equal_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">obj_arr</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> must have every element be </span><span class="si">{}</span><span class="s2">, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">bound_error</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_const</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_python_scalar</span><span class="p">(</span><span class="n">example</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">scalar_type_of</span><span class="p">(</span><span class="n">example</span><span class="p">)(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="n">_zeros</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">_zero</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">_ones</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_one</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_twos</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">_two</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">full_like</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">dtype</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_dtype</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_isnan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ranges_like</span><span class="p">(</span><span class="o">*</span><span class="n">xs</span><span class="p">):</span>
  <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
    <span class="n">x_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">x_len</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">x_len</span>


<span class="k">def</span> <span class="nf">remaining</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="o">*</span><span class="n">removed_lists</span><span class="p">):</span>
  <span class="n">removed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">removed_lists</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">original</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">canonicalize_precision</span><span class="p">(</span><span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">]]:</span>
  <span class="sd">&quot;&quot;&quot;Turns an API precision specification, into a pair of enumeration values.</span>

<span class="sd">  The API can take the precision as a string, or int, and either as a single</span>
<span class="sd">  value to apply to both operands, or as a sequence of two values.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">jax_default_matmul_precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span>
          <span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span>
          <span class="p">(</span><span class="n">Precision</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">jax_default_matmul_precision</span><span class="p">),</span>
           <span class="n">Precision</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">jax_default_matmul_precision</span><span class="p">)))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
          <span class="s2">&quot;jax_default_matmul_precision flag must be set to None or a value in &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">Precision</span><span class="o">.</span><span class="n">_strings</span><span class="p">)</span><span class="si">}</span><span class="s2">, but got </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">jax_default_matmul_precision</span><span class="si">}</span><span class="s2">&quot;</span>
      <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">precision</span> <span class="ow">in</span> <span class="n">Precision</span><span class="o">.</span><span class="n">_strings</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span>
                     <span class="p">(</span><span class="n">Precision</span><span class="p">(</span><span class="n">precision</span><span class="p">),</span> <span class="n">Precision</span><span class="p">(</span><span class="n">precision</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span> <span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">precision</span><span class="p">))</span>
  <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xla_client</span><span class="o">.</span><span class="n">PrecisionConfig</span><span class="o">.</span><span class="n">Precision</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">precision</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span> <span class="n">precision</span><span class="p">)</span>
  <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">precision</span><span class="p">)):</span>
    <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">precision</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span> <span class="n">canonicalize_precision</span><span class="p">(</span><span class="n">s1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">type_cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">PrecisionType</span><span class="p">,</span> <span class="n">PrecisionType</span><span class="p">],</span> <span class="n">canonicalize_precision</span><span class="p">(</span><span class="n">s2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Precision argument must be None, a string in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">Precision</span><span class="o">.</span><span class="n">_strings</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
        <span class="s2">&quot;a lax.Precision value or a tuple of two lax.Precision values or &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;strings; got </span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_balanced_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">_eq_meet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">_ones</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">_zeros</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span>
             <span class="n">select</span><span class="p">(</span><span class="n">_eq_meet</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">_twos</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">_ones</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_eq_meet</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="n">a_dtype</span><span class="p">,</span> <span class="n">b_dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_dtype</span> <span class="o">!=</span> <span class="n">b_dtype</span><span class="p">:</span>
    <span class="n">higher_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">b_dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">higher_dtype</span> <span class="o">==</span> <span class="n">a_dtype</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b_dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">convert_element_type</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a_dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_abstractify</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">raise_to_shaped</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fun_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># Avoid using `dtype in [...]` because of numpy dtype equality overloading.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">builtins</span><span class="o">.</span><span class="n">complex</span><span class="p">}:</span>
    <span class="k">return</span>
  <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;biufc&quot;</span> <span class="ow">and</span> <span class="n">np_dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;JAX only supports number and bool dtypes, got dtype </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; in </span><span class="si">{</span><span class="n">fun_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">fun_name</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np_dtype</span> <span class="o">!=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Explicitly requested dtype </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> is not available, &quot;</span>
           <span class="s2">&quot;and will be truncated to dtype </span><span class="si">{}</span><span class="s2">. To enable more dtypes, set the &quot;</span>
           <span class="s2">&quot;jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell &quot;</span>
           <span class="s2">&quot;environment variable. &quot;</span>
           <span class="s2">&quot;See https://github.com/google/jax#current-gotchas for more.&quot;</span><span class="p">)</span>
    <span class="n">fun_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;requested in </span><span class="si">{</span><span class="n">fun_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">fun_name</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">truncated_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fun_name</span> <span class="p">,</span> <span class="n">truncated_dtype</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">empty_p</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">empty_p</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Primitive</span><span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">)</span>
<span class="n">empty_p</span><span class="o">.</span><span class="n">def_abstract_eval</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">ShapedArray</span><span class="p">((),</span> <span class="n">dtype</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_empty_lower</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_opaque_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">_rules</span><span class="o">.</span><span class="n">empty_mlir</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">mlir</span><span class="o">.</span><span class="n">ir_constants</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)))</span>
<span class="n">mlir</span><span class="o">.</span><span class="n">register_lowering</span><span class="p">(</span><span class="n">empty_p</span><span class="p">,</span> <span class="n">_empty_lower</span><span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The JAX authors<br/>
  
      &copy; Copyright 2020, The JAX Authors. NumPy and SciPy documentation are copyright the respective authors..<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>