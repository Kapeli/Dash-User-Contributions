<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.3.1"/>
    <a class="dashingAutolink" name="autolink-200"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/openFrameworks%3A%20Class%20Index"></a><title>openFrameworks: Class Index</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
      $(document).ready(function() { searchBox.OnSelectItem(0); });
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="content">
      <div id="body-wrap">
      		<div class="page-wide">
	            <div class="page-left-split">
           		    <h1 class="documentation">reference</h1> <ul class="docsadvanced"><li><a href="documentation">basic</a></li> <li><a class="active" href="doxygen/annotated.html">advanced</a></li> </ul>
           		</div>
		        <div class="page-right-narrow">
			        <p>This documentation is automatically generated from the openFrameworks source code using doxygen and refers to the most recent release, version <strong>0.11.1</strong>.</p>
		        </div>
       		</div>
      		<div class="page-wide">
      		    <div class="doxy-mainmenu">
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> |
<a href="classof_mesh__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ofMesh_&lt; V, N, C, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a set of vertices in 3D spaces with normals, colors, and texture coordinates at those points.  
 <a href="classof_mesh__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="of_mesh_8h_source.html">ofMesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a53555600ee52411e88c3f907f2baf2ba"><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a53555600ee52411e88c3f907f2baf2ba">ofMesh_</a> ()</td></tr>
<tr class="memdesc:a53555600ee52411e88c3f907f2baf2ba"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This creates the mesh, using OF_PRIMITIVE_TRIANGLES without any initial vertices.  <a href="classof_mesh__.html#a53555600ee52411e88c3f907f2baf2ba">More...</a><br/></td></tr>
<tr class="separator:a53555600ee52411e88c3f907f2baf2ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5240f9014d1d32af12513b9bc3c12c29"><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a5240f9014d1d32af12513b9bc3c12c29">ofMesh_</a> (<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode, const std::vector&lt; V &gt; &amp;verts)</td></tr>
<tr class="memdesc:a5240f9014d1d32af12513b9bc3c12c29"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This allows to you to use one of the other ofPrimitiveModes: OF_PRIMITIVE_TRIANGLES, OF_PRIMITIVE_TRIANGLE_STRIP, OF_PRIMITIVE_TRIANGLE_FAN, OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP, OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS. See <a href="../gl/ofGLUtils.htm">ofGLUtils</a> for more information on these types.  <a href="classof_mesh__.html#a5240f9014d1d32af12513b9bc3c12c29">More...</a><br/></td></tr>
<tr class="separator:a5240f9014d1d32af12513b9bc3c12c29"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6a24a1fe83e7b43ece4b187b13800325"><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a6a24a1fe83e7b43ece4b187b13800325">~ofMesh_</a> ()</td></tr>
<tr class="separator:a6a24a1fe83e7b43ece4b187b13800325"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5d81b2924ae705979a81d6efc6af0fa6"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a5d81b2924ae705979a81d6efc6af0fa6">setFromTriangles</a> (const std::vector&lt; <a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt;&gt; &amp;tris, bool bUseFaceNormal=false)</td></tr>
<tr class="separator:a5d81b2924ae705979a81d6efc6af0fa6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh Mode</div></td></tr>
<tr class="memitem:a127eade588093f14bfe8a714ab819049"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049">setMode</a> (<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode)</td></tr>
<tr class="memdesc:a127eade588093f14bfe8a714ab819049"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows you to set the ofPrimitiveMode. The available modes are OF_PRIMITIVE_TRIANGLES, OF_PRIMITIVE_TRIANGLE_STRIP, OF_PRIMITIVE_TRIANGLE_FAN, OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP, OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS.  <a href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049">More...</a><br/></td></tr>
<tr class="separator:a127eade588093f14bfe8a714ab819049"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac9e2c4bb699285a51ce519126cb64e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac9e2c4bb699285a51ce519126cb64e69">getMode</a> () const</td></tr>
<tr class="memdesc:ac9e2c4bb699285a51ce519126cb64e69"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">\returns the primitive mode that the mesh is using.  <a href="classof_mesh__.html#ac9e2c4bb699285a51ce519126cb64e69">More...</a><br/></td></tr>
<tr class="separator:ac9e2c4bb699285a51ce519126cb64e69"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertices</div></td></tr>
<tr class="memitem:abf653cd7eb467c9165fa8a5c8a917be7"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a> (const V &amp;v)</td></tr>
<tr class="memdesc:abf653cd7eb467c9165fa8a5c8a917be7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new vertex at the end of the current list of vertices. It is important to remember that the order the vertices are added to the list determines how they link they form the polygons and strips (assuming you do not change their indeces). See the ofMesh class description for details.  <a href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">More...</a><br/></td></tr>
<tr class="separator:abf653cd7eb467c9165fa8a5c8a917be7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af849b874e00b6dee86d47547c855f4c5"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#af849b874e00b6dee86d47547c855f4c5">addVertices</a> (const std::vector&lt; V &gt; &amp;verts)</td></tr>
<tr class="memdesc:af849b874e00b6dee86d47547c855f4c5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vector of vertices to a mesh, allowing you to push out many at once rather than adding one at a time. The vector of vertices is added after the end of the current vertices list.  <a href="classof_mesh__.html#af849b874e00b6dee86d47547c855f4c5">More...</a><br/></td></tr>
<tr class="separator:af849b874e00b6dee86d47547c855f4c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1f1c926d782f070ae267cfbe7b21c045"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a1f1c926d782f070ae267cfbe7b21c045">addVertices</a> (const V *verts, std::size_t amt)</td></tr>
<tr class="memdesc:a1f1c926d782f070ae267cfbe7b21c045"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an array of vertices to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an int (amt). The vertices are added at the end of the current vertices list.  <a href="classof_mesh__.html#a1f1c926d782f070ae267cfbe7b21c045">More...</a><br/></td></tr>
<tr class="separator:a1f1c926d782f070ae267cfbe7b21c045"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a94821aafdb3d39c20097742114ac6252"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a94821aafdb3d39c20097742114ac6252">removeVertex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index)</td></tr>
<tr class="memdesc:a94821aafdb3d39c20097742114ac6252"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the vertex at the index in the vector.  <a href="classof_mesh__.html#a94821aafdb3d39c20097742114ac6252">More...</a><br/></td></tr>
<tr class="separator:a94821aafdb3d39c20097742114ac6252"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac14eba193f79cdb668e1b26251607971"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac14eba193f79cdb668e1b26251607971">setVertex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index, const V &amp;v)</td></tr>
<tr class="separator:ac14eba193f79cdb668e1b26251607971"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a57b3f747af2859da93af3166d8a27e18"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a57b3f747af2859da93af3166d8a27e18">clearVertices</a> ()</td></tr>
<tr class="memdesc:a57b3f747af2859da93af3166d8a27e18"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the vertices.  <a href="classof_mesh__.html#a57b3f747af2859da93af3166d8a27e18">More...</a><br/></td></tr>
<tr class="separator:a57b3f747af2859da93af3166d8a27e18"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9eeb879d86685a7e893f2531a3e262bc"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a9eeb879d86685a7e893f2531a3e262bc">clear</a> ()</td></tr>
<tr class="memdesc:a9eeb879d86685a7e893f2531a3e262bc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the vertices, colors, and indices from the mesh.  <a href="classof_mesh__.html#a9eeb879d86685a7e893f2531a3e262bc">More...</a><br/></td></tr>
<tr class="separator:a9eeb879d86685a7e893f2531a3e262bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08a667f68d358d304119c33d9bd1ac5a"><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a08a667f68d358d304119c33d9bd1ac5a">getNumVertices</a> () const</td></tr>
<tr class="separator:a08a667f68d358d304119c33d9bd1ac5a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a672de1fd17348248e1480e3a17c12335"><td class="memItemLeft" align="right" valign="top">V *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a672de1fd17348248e1480e3a17c12335">getVerticesPointer</a> ()</td></tr>
<tr class="separator:a672de1fd17348248e1480e3a17c12335"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af028a8dc0b424704a5ce1dd01b0db4fe"><td class="memItemLeft" align="right" valign="top">const V *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#af028a8dc0b424704a5ce1dd01b0db4fe">getVerticesPointer</a> () const</td></tr>
<tr class="separator:af028a8dc0b424704a5ce1dd01b0db4fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a96e7c2f3fa6fa821c8f32e0cef4a1ca7"><td class="memItemLeft" align="right" valign="top">V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a96e7c2f3fa6fa821c8f32e0cef4a1ca7">getVertex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i) const</td></tr>
<tr class="separator:a96e7c2f3fa6fa821c8f32e0cef4a1ca7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9a9943fbc47aa77ee3c777a1152df34d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; V &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a9a9943fbc47aa77ee3c777a1152df34d">getVertices</a> ()</td></tr>
<tr class="separator:a9a9943fbc47aa77ee3c777a1152df34d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6e1a0c348db4521ae77f313c42671ae3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; V &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a6e1a0c348db4521ae77f313c42671ae3">getVertices</a> () const</td></tr>
<tr class="separator:a6e1a0c348db4521ae77f313c42671ae3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa224945f6e629dd45912b2d9368fddf0"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa224945f6e629dd45912b2d9368fddf0">hasVertices</a> () const</td></tr>
<tr class="separator:aa224945f6e629dd45912b2d9368fddf0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a61a58a90fdae4bcfd7edc98a1775491e"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a61a58a90fdae4bcfd7edc98a1775491e">append</a> (const <a class="el" href="classof_mesh__.html">ofMesh_</a> &amp;mesh)</td></tr>
<tr class="memdesc:a61a58a90fdae4bcfd7edc98a1775491e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add the vertices, normals, texture coordinates and indices of one mesh onto another mesh. Everything from the referenced mesh is simply added at the end of the current mesh&#39;s lists.  <a href="classof_mesh__.html#a61a58a90fdae4bcfd7edc98a1775491e">More...</a><br/></td></tr>
<tr class="separator:a61a58a90fdae4bcfd7edc98a1775491e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a59910722bd457565b4568fc4244374c4"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a59910722bd457565b4568fc4244374c4">mergeDuplicateVertices</a> ()</td></tr>
<tr class="separator:a59910722bd457565b4568fc4244374c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeed33d7c52b4e05c71736f98dbedd665"><td class="memItemLeft" align="right" valign="top">V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aeed33d7c52b4e05c71736f98dbedd665">getCentroid</a> () const</td></tr>
<tr class="separator:aeed33d7c52b4e05c71736f98dbedd665"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Normals</div></td></tr>
<tr class="memitem:a1bec31f880cf743c0f3f361b657350ab"><td class="memItemLeft" align="right" valign="top">N&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a1bec31f880cf743c0f3f361b657350ab">getNormal</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i) const</td></tr>
<tr class="memdesc:a1bec31f880cf743c0f3f361b657350ab"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">\returns the normal at the index in the normals vector.  <a href="classof_mesh__.html#a1bec31f880cf743c0f3f361b657350ab">More...</a><br/></td></tr>
<tr class="separator:a1bec31f880cf743c0f3f361b657350ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5066645e2f1283fa80904d6b63b5a829"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a5066645e2f1283fa80904d6b63b5a829">addNormal</a> (const N &amp;n)</td></tr>
<tr class="memdesc:a5066645e2f1283fa80904d6b63b5a829"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a normal to the mesh as a 3D vector, typically perpendicular to the plane of the face. A normal is a vector that defines how a surface responds to lighting, i.e. how it is lit. The amount of light reflected by a surface is proportional to the angle between the light&#39;s direction and the normal. The smaller the angle the brighter the surface will look. See the normalsExample for advice on computing the normals. addNormal adds the 3D vector to the end of the list, so you need to make sure you add normals at the same index of the matching vertex.  <a href="classof_mesh__.html#a5066645e2f1283fa80904d6b63b5a829">More...</a><br/></td></tr>
<tr class="separator:a5066645e2f1283fa80904d6b63b5a829"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:add902534593bda650e730aa797a54d3d"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#add902534593bda650e730aa797a54d3d">addNormals</a> (const std::vector&lt; N &gt; &amp;norms)</td></tr>
<tr class="memdesc:add902534593bda650e730aa797a54d3d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vector of normals to a mesh, allowing you to push out many normals at once rather than adding one at a time. The vector of normals is added after the end of the current normals list.  <a href="classof_mesh__.html#add902534593bda650e730aa797a54d3d">More...</a><br/></td></tr>
<tr class="separator:add902534593bda650e730aa797a54d3d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae7eec98ee25a054f1e7fa5f191b6bbcf"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae7eec98ee25a054f1e7fa5f191b6bbcf">addNormals</a> (const N *norms, std::size_t amt)</td></tr>
<tr class="memdesc:ae7eec98ee25a054f1e7fa5f191b6bbcf"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an array of normals to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an std::size_t (amt). The normals are added at the end of the current normals list.  <a href="classof_mesh__.html#ae7eec98ee25a054f1e7fa5f191b6bbcf">More...</a><br/></td></tr>
<tr class="separator:ae7eec98ee25a054f1e7fa5f191b6bbcf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e538d931278c2a85af965db23817776"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a2e538d931278c2a85af965db23817776">removeNormal</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index)</td></tr>
<tr class="memdesc:a2e538d931278c2a85af965db23817776"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a normal.  <a href="classof_mesh__.html#a2e538d931278c2a85af965db23817776">More...</a><br/></td></tr>
<tr class="separator:a2e538d931278c2a85af965db23817776"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adf3e5ab3016e8b4d190062a0ebe28e95"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#adf3e5ab3016e8b4d190062a0ebe28e95">setNormal</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index, const N &amp;n)</td></tr>
<tr class="separator:adf3e5ab3016e8b4d190062a0ebe28e95"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0f399e35b19142c8dcffdfb520bbbb18"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a0f399e35b19142c8dcffdfb520bbbb18">clearNormals</a> ()</td></tr>
<tr class="memdesc:a0f399e35b19142c8dcffdfb520bbbb18"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the normals.  <a href="classof_mesh__.html#a0f399e35b19142c8dcffdfb520bbbb18">More...</a><br/></td></tr>
<tr class="separator:a0f399e35b19142c8dcffdfb520bbbb18"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4355ccbe359c368da268f6c065eecf56"><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4355ccbe359c368da268f6c065eecf56">getNumNormals</a> () const</td></tr>
<tr class="memdesc:a4355ccbe359c368da268f6c065eecf56"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will tell you how many normals are contained in the mesh.  <a href="classof_mesh__.html#a4355ccbe359c368da268f6c065eecf56">More...</a><br/></td></tr>
<tr class="separator:a4355ccbe359c368da268f6c065eecf56"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac9e2ab92a49ed8492c0ab55f81d761b2"><td class="memItemLeft" align="right" valign="top">N *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac9e2ab92a49ed8492c0ab55f81d761b2">getNormalsPointer</a> ()</td></tr>
<tr class="separator:ac9e2ab92a49ed8492c0ab55f81d761b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8dab2b9cf5f743e38d848e3940f7c732"><td class="memItemLeft" align="right" valign="top">const N *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8dab2b9cf5f743e38d848e3940f7c732">getNormalsPointer</a> () const</td></tr>
<tr class="separator:a8dab2b9cf5f743e38d848e3940f7c732"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac21a4d0c6be7ec265b28293850965bcb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; N &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac21a4d0c6be7ec265b28293850965bcb">getNormals</a> ()</td></tr>
<tr class="separator:ac21a4d0c6be7ec265b28293850965bcb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a198400c0d6e5e2d2e8423af539379641"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; N &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a198400c0d6e5e2d2e8423af539379641">getNormals</a> () const</td></tr>
<tr class="separator:a198400c0d6e5e2d2e8423af539379641"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a53dda7b405ca169ae53a7d6922fc9f91"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a53dda7b405ca169ae53a7d6922fc9f91">hasNormals</a> () const</td></tr>
<tr class="memdesc:a53dda7b405ca169ae53a7d6922fc9f91"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">/returnsWhether the mesh has any normals.  <a href="classof_mesh__.html#a53dda7b405ca169ae53a7d6922fc9f91">More...</a><br/></td></tr>
<tr class="separator:a53dda7b405ca169ae53a7d6922fc9f91"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2569384c5b9b600e5148e98a8e79e6b6"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a2569384c5b9b600e5148e98a8e79e6b6">enableNormals</a> ()</td></tr>
<tr class="memdesc:a2569384c5b9b600e5148e98a8e79e6b6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable mesh normals. Use <a class="el" href="classof_mesh__.html#a74344516e455506644ac8091dc41727f" title="Disable mesh normals. Use enableNormals() to turn normals back on.">disableNormals()</a> to turn normals off. Normals are enabled by default when they are added to the mesh.  <a href="classof_mesh__.html#a2569384c5b9b600e5148e98a8e79e6b6">More...</a><br/></td></tr>
<tr class="separator:a2569384c5b9b600e5148e98a8e79e6b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a74344516e455506644ac8091dc41727f"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a74344516e455506644ac8091dc41727f">disableNormals</a> ()</td></tr>
<tr class="memdesc:a74344516e455506644ac8091dc41727f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable mesh normals. Use <a class="el" href="classof_mesh__.html#a2569384c5b9b600e5148e98a8e79e6b6" title="Enable mesh normals. Use disableNormals() to turn normals off. Normals are enabled by default when th...">enableNormals()</a> to turn normals back on.  <a href="classof_mesh__.html#a74344516e455506644ac8091dc41727f">More...</a><br/></td></tr>
<tr class="separator:a74344516e455506644ac8091dc41727f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a367f2735ce6af1ed6eb8379228c97f84"><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a367f2735ce6af1ed6eb8379228c97f84">usingNormals</a> () const</td></tr>
<tr class="separator:a367f2735ce6af1ed6eb8379228c97f84"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8a7c1471ebe767c5dfe094d2e2018330"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8a7c1471ebe767c5dfe094d2e2018330">smoothNormals</a> (float angle)</td></tr>
<tr class="separator:a8a7c1471ebe767c5dfe094d2e2018330"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8e699453b708eaf9bf707552ebe1e73e"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8e699453b708eaf9bf707552ebe1e73e">flatNormals</a> ()</td></tr>
<tr class="memdesc:a8e699453b708eaf9bf707552ebe1e73e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicates vertices and updates normals to get a low-poly look.  <a href="classof_mesh__.html#a8e699453b708eaf9bf707552ebe1e73e">More...</a><br/></td></tr>
<tr class="separator:a8e699453b708eaf9bf707552ebe1e73e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Faces</div></td></tr>
<tr class="memitem:a97d0920e6b91c393f95188f160616a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a97d0920e6b91c393f95188f160616a33">getFace</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> faceId) const</td></tr>
<tr class="separator:a97d0920e6b91c393f95188f160616a33"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac647d91596a0bbffbbe739941c2dd134"><td class="memItemLeft" align="right" valign="top">std::vector&lt; N &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac647d91596a0bbffbbe739941c2dd134">getFaceNormals</a> (bool perVetex=false) const</td></tr>
<tr class="memdesc:ac647d91596a0bbffbbe739941c2dd134"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get normals for each face As a default it only calculates the normal for the face as a whole but by setting (perVertex = true) it will return the same normal value for each of the three vertices making up a face.  <a href="classof_mesh__.html#ac647d91596a0bbffbbe739941c2dd134">More...</a><br/></td></tr>
<tr class="separator:ac647d91596a0bbffbbe739941c2dd134"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a885903c31c3a061447dad2f4df4921a2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a885903c31c3a061447dad2f4df4921a2">getUniqueFaces</a> () const</td></tr>
<tr class="separator:a885903c31c3a061447dad2f4df4921a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Colors</div></td></tr>
<tr class="memitem:add3752ac399ccfc27f28243c34ec1c36"><td class="memItemLeft" align="right" valign="top">C&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#add3752ac399ccfc27f28243c34ec1c36">getColor</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i) const</td></tr>
<tr class="memdesc:add3752ac399ccfc27f28243c34ec1c36"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the color at the index in the colors vector.  <a href="classof_mesh__.html#add3752ac399ccfc27f28243c34ec1c36">More...</a><br/></td></tr>
<tr class="separator:add3752ac399ccfc27f28243c34ec1c36"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae7361115d8ce96c4a71d8f572b1ba02a"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae7361115d8ce96c4a71d8f572b1ba02a">addColor</a> (const C &amp;<a class="el" href="of_matrix4x4_8cpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>)</td></tr>
<tr class="memdesc:ae7361115d8ce96c4a71d8f572b1ba02a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This adds a color to the mesh, the color will be associated with the vertex in the same position.  <a href="classof_mesh__.html#ae7361115d8ce96c4a71d8f572b1ba02a">More...</a><br/></td></tr>
<tr class="separator:ae7361115d8ce96c4a71d8f572b1ba02a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3f6a666f26eca1ffa7fa7ceab996d67f"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a3f6a666f26eca1ffa7fa7ceab996d67f">addColors</a> (const std::vector&lt; C &gt; &amp;cols)</td></tr>
<tr class="memdesc:a3f6a666f26eca1ffa7fa7ceab996d67f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This adds colors using a reference to a vector of ofColors. For each color in the vector, this will put the colors at the corresponding vertex.  <a href="classof_mesh__.html#a3f6a666f26eca1ffa7fa7ceab996d67f">More...</a><br/></td></tr>
<tr class="separator:a3f6a666f26eca1ffa7fa7ceab996d67f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a620775bcc9cdf7943778eb68af43e4c9"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a620775bcc9cdf7943778eb68af43e4c9">addColors</a> (const C *cols, std::size_t amt)</td></tr>
<tr class="memdesc:a620775bcc9cdf7943778eb68af43e4c9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This adds a pointer of colors to the ofMesh instance with the amount passed as the second parameter.  <a href="classof_mesh__.html#a620775bcc9cdf7943778eb68af43e4c9">More...</a><br/></td></tr>
<tr class="separator:a620775bcc9cdf7943778eb68af43e4c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abed864b1d2509c6a717828b207bd7617"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#abed864b1d2509c6a717828b207bd7617">removeColor</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index)</td></tr>
<tr class="memdesc:abed864b1d2509c6a717828b207bd7617"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a color at the index in the colors vector.  <a href="classof_mesh__.html#abed864b1d2509c6a717828b207bd7617">More...</a><br/></td></tr>
<tr class="separator:abed864b1d2509c6a717828b207bd7617"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a83304aa16a2ba34781864966e535aa93"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a83304aa16a2ba34781864966e535aa93">setColor</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index, const C &amp;<a class="el" href="of_matrix4x4_8cpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>)</td></tr>
<tr class="memdesc:a83304aa16a2ba34781864966e535aa93"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the color at the index in the colors vector.  <a href="classof_mesh__.html#a83304aa16a2ba34781864966e535aa93">More...</a><br/></td></tr>
<tr class="separator:a83304aa16a2ba34781864966e535aa93"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afa98b173cc7d1ee6b23feb77da7ee47f"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#afa98b173cc7d1ee6b23feb77da7ee47f">clearColors</a> ()</td></tr>
<tr class="memdesc:afa98b173cc7d1ee6b23feb77da7ee47f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all the colors.  <a href="classof_mesh__.html#afa98b173cc7d1ee6b23feb77da7ee47f">More...</a><br/></td></tr>
<tr class="separator:afa98b173cc7d1ee6b23feb77da7ee47f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa921d88cf8172d40e8e41fc3e9df3147"><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa921d88cf8172d40e8e41fc3e9df3147">getNumColors</a> () const</td></tr>
<tr class="separator:aa921d88cf8172d40e8e41fc3e9df3147"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae31a249470bfa9f3ef6183f1cbf64268"><td class="memItemLeft" align="right" valign="top">C *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae31a249470bfa9f3ef6183f1cbf64268">getColorsPointer</a> ()</td></tr>
<tr class="separator:ae31a249470bfa9f3ef6183f1cbf64268"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a92fe00523acd0c648bdaae94faf24c3c"><td class="memItemLeft" align="right" valign="top">const C *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a92fe00523acd0c648bdaae94faf24c3c">getColorsPointer</a> () const</td></tr>
<tr class="separator:a92fe00523acd0c648bdaae94faf24c3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6b18598858a5007256b5cf8350d17b5a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; C &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a6b18598858a5007256b5cf8350d17b5a">getColors</a> ()</td></tr>
<tr class="separator:a6b18598858a5007256b5cf8350d17b5a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a910f103a42561930799246be77cc0b7c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; C &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a910f103a42561930799246be77cc0b7c">getColors</a> () const</td></tr>
<tr class="separator:a910f103a42561930799246be77cc0b7c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a592e8aeae8f0473cc35e5662cd757378"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a592e8aeae8f0473cc35e5662cd757378">hasColors</a> () const</td></tr>
<tr class="memdesc:a592e8aeae8f0473cc35e5662cd757378"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">/returns Whether the mesh has any colors.  <a href="classof_mesh__.html#a592e8aeae8f0473cc35e5662cd757378">More...</a><br/></td></tr>
<tr class="separator:a592e8aeae8f0473cc35e5662cd757378"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4b6a5a6bc27ff1090aa16ea476cd66e1"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4b6a5a6bc27ff1090aa16ea476cd66e1">enableColors</a> ()</td></tr>
<tr class="memdesc:a4b6a5a6bc27ff1090aa16ea476cd66e1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable mesh colors. Use <a class="el" href="classof_mesh__.html#aac8b40e7b05b9fb9c26b2b8a0e7601da" title="Disable mesh colors. Use enableColors() to turn colors back on.">disableColors()</a> to turn colors off. Colors are enabled by default when they are added to the mesh.  <a href="classof_mesh__.html#a4b6a5a6bc27ff1090aa16ea476cd66e1">More...</a><br/></td></tr>
<tr class="separator:a4b6a5a6bc27ff1090aa16ea476cd66e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aac8b40e7b05b9fb9c26b2b8a0e7601da"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aac8b40e7b05b9fb9c26b2b8a0e7601da">disableColors</a> ()</td></tr>
<tr class="memdesc:aac8b40e7b05b9fb9c26b2b8a0e7601da"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable mesh colors. Use <a class="el" href="classof_mesh__.html#a4b6a5a6bc27ff1090aa16ea476cd66e1" title="Enable mesh colors. Use disableColors() to turn colors off. Colors are enabled by default when they a...">enableColors()</a> to turn colors back on.  <a href="classof_mesh__.html#aac8b40e7b05b9fb9c26b2b8a0e7601da">More...</a><br/></td></tr>
<tr class="separator:aac8b40e7b05b9fb9c26b2b8a0e7601da"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9a8d4a9231c090c54d0d52189003660b"><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a9a8d4a9231c090c54d0d52189003660b">usingColors</a> () const</td></tr>
<tr class="separator:a9a8d4a9231c090c54d0d52189003660b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture Coordinates</div></td></tr>
<tr class="memitem:aa9fbb7b426591f99cc332dca02bbee77"><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa9fbb7b426591f99cc332dca02bbee77">getTexCoord</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i) const</td></tr>
<tr class="separator:aa9fbb7b426591f99cc332dca02bbee77"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa78c9cae51d3b01c33d693ae86630537"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa78c9cae51d3b01c33d693ae86630537">addTexCoord</a> (const T &amp;t)</td></tr>
<tr class="memdesc:aa78c9cae51d3b01c33d693ae86630537"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a Vec2f representing the texture coordinate. Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates.  <a href="classof_mesh__.html#aa78c9cae51d3b01c33d693ae86630537">More...</a><br/></td></tr>
<tr class="separator:aa78c9cae51d3b01c33d693ae86630537"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a659cf9460a5261f8908e72f8fb0f027a"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a659cf9460a5261f8908e72f8fb0f027a">addTexCoords</a> (const std::vector&lt; T &gt; &amp;tCoords)</td></tr>
<tr class="memdesc:a659cf9460a5261f8908e72f8fb0f027a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vector of texture coordinates to a mesh, allowing you to push out many at once rather than adding one at a time. The vector of texture coordinates is added after the end of the current texture coordinates list.  <a href="classof_mesh__.html#a659cf9460a5261f8908e72f8fb0f027a">More...</a><br/></td></tr>
<tr class="separator:a659cf9460a5261f8908e72f8fb0f027a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4744e686684a4f2441af6a43f247749c"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4744e686684a4f2441af6a43f247749c">addTexCoords</a> (const T *tCoords, std::size_t amt)</td></tr>
<tr class="memdesc:a4744e686684a4f2441af6a43f247749c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an array of texture coordinates to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an std::size_t (amt). The texture coordinates are added at the end of the current texture coordinates list.  <a href="classof_mesh__.html#a4744e686684a4f2441af6a43f247749c">More...</a><br/></td></tr>
<tr class="separator:a4744e686684a4f2441af6a43f247749c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8bd2dda59067556553a0a4c0add8df55"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8bd2dda59067556553a0a4c0add8df55">removeTexCoord</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index)</td></tr>
<tr class="memdesc:a8bd2dda59067556553a0a4c0add8df55"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a Vec2f representing the texture coordinate.  <a href="classof_mesh__.html#a8bd2dda59067556553a0a4c0add8df55">More...</a><br/></td></tr>
<tr class="separator:a8bd2dda59067556553a0a4c0add8df55"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad7ca0664fbf59a1c1d9813c72e0e25eb"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ad7ca0664fbf59a1c1d9813c72e0e25eb">setTexCoord</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index, const T &amp;t)</td></tr>
<tr class="separator:ad7ca0664fbf59a1c1d9813c72e0e25eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a50b374ad3869de450e17105c1fdeb13b"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a50b374ad3869de450e17105c1fdeb13b">clearTexCoords</a> ()</td></tr>
<tr class="memdesc:a50b374ad3869de450e17105c1fdeb13b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all the texture coordinates.  <a href="classof_mesh__.html#a50b374ad3869de450e17105c1fdeb13b">More...</a><br/></td></tr>
<tr class="separator:a50b374ad3869de450e17105c1fdeb13b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a81b72d407eaf60f1df9b6aee8913e165"><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a81b72d407eaf60f1df9b6aee8913e165">getNumTexCoords</a> () const</td></tr>
<tr class="memdesc:a81b72d407eaf60f1df9b6aee8913e165"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will tell you how many texture coordinates are contained in the mesh.  <a href="classof_mesh__.html#a81b72d407eaf60f1df9b6aee8913e165">More...</a><br/></td></tr>
<tr class="separator:a81b72d407eaf60f1df9b6aee8913e165"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ebe21b66f36a7a706b34cae522909a1"><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a1ebe21b66f36a7a706b34cae522909a1">getTexCoordsPointer</a> ()</td></tr>
<tr class="separator:a1ebe21b66f36a7a706b34cae522909a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4235e0cb978e0c8d589b2dee5d326623"><td class="memItemLeft" align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4235e0cb978e0c8d589b2dee5d326623">getTexCoordsPointer</a> () const</td></tr>
<tr class="memdesc:a4235e0cb978e0c8d589b2dee5d326623"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the <a class="el" href="classof_vec2f.html" title="ofVec2f is a class for storing a two dimensional vector.">ofVec2f</a> texture coordinates that the mesh contains.  <a href="classof_mesh__.html#a4235e0cb978e0c8d589b2dee5d326623">More...</a><br/></td></tr>
<tr class="separator:a4235e0cb978e0c8d589b2dee5d326623"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae7beaa9ae4ec2a533c948ba341288e7f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae7beaa9ae4ec2a533c948ba341288e7f">getTexCoords</a> ()</td></tr>
<tr class="memdesc:ae7beaa9ae4ec2a533c948ba341288e7f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector representing the texture coordinates of the mesh Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates. Use this if you plan to change the texture coordinates as part of this call as it will force a reset of the cache.  <a href="classof_mesh__.html#ae7beaa9ae4ec2a533c948ba341288e7f">More...</a><br/></td></tr>
<tr class="separator:ae7beaa9ae4ec2a533c948ba341288e7f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a521b68abfe5864f5f0d57c5f76b0fdd2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a521b68abfe5864f5f0d57c5f76b0fdd2">getTexCoords</a> () const</td></tr>
<tr class="separator:a521b68abfe5864f5f0d57c5f76b0fdd2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a30e928ba824858616b319a46fcb1ce35"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a30e928ba824858616b319a46fcb1ce35">hasTexCoords</a> () const</td></tr>
<tr class="memdesc:a30e928ba824858616b319a46fcb1ce35"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">/returns Whether the mesh has any textures assigned to it.  <a href="classof_mesh__.html#a30e928ba824858616b319a46fcb1ce35">More...</a><br/></td></tr>
<tr class="separator:a30e928ba824858616b319a46fcb1ce35"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1bc8979e0595fa3d691d458f6badb9c1"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a1bc8979e0595fa3d691d458f6badb9c1">enableTextures</a> ()</td></tr>
<tr class="memdesc:a1bc8979e0595fa3d691d458f6badb9c1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable mesh textures. Use <a class="el" href="classof_mesh__.html#aaae8fcc838769c03cb0127836b488282" title="Disable mesh textures. Use enableTextures() to turn textures back on.">disableTextures()</a> to turn textures off. Textures are enabled by default when they are added to the mesh.  <a href="classof_mesh__.html#a1bc8979e0595fa3d691d458f6badb9c1">More...</a><br/></td></tr>
<tr class="separator:a1bc8979e0595fa3d691d458f6badb9c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaae8fcc838769c03cb0127836b488282"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aaae8fcc838769c03cb0127836b488282">disableTextures</a> ()</td></tr>
<tr class="memdesc:aaae8fcc838769c03cb0127836b488282"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable mesh textures. Use <a class="el" href="classof_mesh__.html#a1bc8979e0595fa3d691d458f6badb9c1" title="Enable mesh textures. Use disableTextures() to turn textures off. Textures are enabled by default whe...">enableTextures()</a> to turn textures back on.  <a href="classof_mesh__.html#aaae8fcc838769c03cb0127836b488282">More...</a><br/></td></tr>
<tr class="separator:aaae8fcc838769c03cb0127836b488282"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a990c2c7465f15cb2742e769a97ddb0bd"><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a990c2c7465f15cb2742e769a97ddb0bd">usingTextures</a> () const</td></tr>
<tr class="separator:a990c2c7465f15cb2742e769a97ddb0bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indices</div></td></tr>
<tr class="memitem:a5d2a8a6ee700a42663c7cc56daa88e6e"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a5d2a8a6ee700a42663c7cc56daa88e6e">setupIndicesAuto</a> ()</td></tr>
<tr class="memdesc:a5d2a8a6ee700a42663c7cc56daa88e6e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow you to set up the indices automatically when you add a vertex.  <a href="classof_mesh__.html#a5d2a8a6ee700a42663c7cc56daa88e6e">More...</a><br/></td></tr>
<tr class="separator:a5d2a8a6ee700a42663c7cc56daa88e6e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6683c2df8c29be2b182031aa8196ff98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a6683c2df8c29be2b182031aa8196ff98">getIndices</a> ()</td></tr>
<tr class="memdesc:a6683c2df8c29be2b182031aa8196ff98"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this if you plan to change the indices as part of this call as it will force a reset of the cache.  <a href="classof_mesh__.html#a6683c2df8c29be2b182031aa8196ff98">More...</a><br/></td></tr>
<tr class="separator:a6683c2df8c29be2b182031aa8196ff98"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a49849cc267a811dc9992c2ded2a2bd52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a49849cc267a811dc9992c2ded2a2bd52">getIndex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i) const</td></tr>
<tr class="separator:a49849cc267a811dc9992c2ded2a2bd52"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a28a5c8eab600b62622a8d49439d5c973"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> i)</td></tr>
<tr class="separator:a28a5c8eab600b62622a8d49439d5c973"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa9ee4782d6adf9352b87a74e2fc87751"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa9ee4782d6adf9352b87a74e2fc87751">addIndices</a> (const std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp;inds)</td></tr>
<tr class="memdesc:aa9ee4782d6adf9352b87a74e2fc87751"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This adds a vector of indices.  <a href="classof_mesh__.html#aa9ee4782d6adf9352b87a74e2fc87751">More...</a><br/></td></tr>
<tr class="separator:aa9ee4782d6adf9352b87a74e2fc87751"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8182931332b366ad27a2ca610dc40a5b"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8182931332b366ad27a2ca610dc40a5b">addIndices</a> (const <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> *inds, std::size_t amt)</td></tr>
<tr class="memdesc:a8182931332b366ad27a2ca610dc40a5b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This adds indices to the ofMesh by pointing to an array of indices. The &#34;amt&#34; defines the length of the array.  <a href="classof_mesh__.html#a8182931332b366ad27a2ca610dc40a5b">More...</a><br/></td></tr>
<tr class="separator:a8182931332b366ad27a2ca610dc40a5b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7e43d2abd33b0a6bdb019174e49097b"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ac7e43d2abd33b0a6bdb019174e49097b">removeIndex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index)</td></tr>
<tr class="memdesc:ac7e43d2abd33b0a6bdb019174e49097b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an index.  <a href="classof_mesh__.html#ac7e43d2abd33b0a6bdb019174e49097b">More...</a><br/></td></tr>
<tr class="separator:ac7e43d2abd33b0a6bdb019174e49097b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a40431a7678900b79af0903122ec76e5c"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a40431a7678900b79af0903122ec76e5c">setIndex</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> val)</td></tr>
<tr class="memdesc:a40431a7678900b79af0903122ec76e5c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This sets the index at i.  <a href="classof_mesh__.html#a40431a7678900b79af0903122ec76e5c">More...</a><br/></td></tr>
<tr class="separator:a40431a7678900b79af0903122ec76e5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae67147b21dce8cddd069423012f0cf2f"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae67147b21dce8cddd069423012f0cf2f">clearIndices</a> ()</td></tr>
<tr class="memdesc:ae67147b21dce8cddd069423012f0cf2f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the indices of the mesh. This means that your mesh will be a point cloud.  <a href="classof_mesh__.html#ae67147b21dce8cddd069423012f0cf2f">More...</a><br/></td></tr>
<tr class="separator:ae67147b21dce8cddd069423012f0cf2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a94f31c02ff4139d8cb4e543cbb148420"><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a94f31c02ff4139d8cb4e543cbb148420">getNumIndices</a> () const</td></tr>
<tr class="memdesc:a94f31c02ff4139d8cb4e543cbb148420"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will tell you how many indices are contained in the mesh.  <a href="classof_mesh__.html#a94f31c02ff4139d8cb4e543cbb148420">More...</a><br/></td></tr>
<tr class="separator:a94f31c02ff4139d8cb4e543cbb148420"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad6886a8d1a9611b14bd75245662c88d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ad6886a8d1a9611b14bd75245662c88d8">getIndexPointer</a> ()</td></tr>
<tr class="separator:ad6886a8d1a9611b14bd75245662c88d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a744cd742fce649728e8ecbf47a50f6e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a744cd742fce649728e8ecbf47a50f6e9">getIndexPointer</a> () const</td></tr>
<tr class="separator:a744cd742fce649728e8ecbf47a50f6e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af2b7b1895a7991d7edcd5326b46b54fe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#af2b7b1895a7991d7edcd5326b46b54fe">getIndices</a> () const</td></tr>
<tr class="separator:af2b7b1895a7991d7edcd5326b46b54fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2ae8973fffdc6380357ee10334d35164"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a2ae8973fffdc6380357ee10334d35164">hasIndices</a> () const</td></tr>
<tr class="memdesc:a2ae8973fffdc6380357ee10334d35164"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">/returns Whether the mesh has any indices assigned to it.  <a href="classof_mesh__.html#a2ae8973fffdc6380357ee10334d35164">More...</a><br/></td></tr>
<tr class="separator:a2ae8973fffdc6380357ee10334d35164"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a19231dc0fa951047366ee939ee7823b5"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a19231dc0fa951047366ee939ee7823b5">addTriangle</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index1, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index2, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> index3)</td></tr>
<tr class="memdesc:a19231dc0fa951047366ee939ee7823b5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adding a triangle means using three of the vertices that have already been added to create a triangle. This is an easy way to create triangles in the mesh. The indices refer to the index of the vertex in the vector of vertices.  <a href="classof_mesh__.html#a19231dc0fa951047366ee939ee7823b5">More...</a><br/></td></tr>
<tr class="separator:a19231dc0fa951047366ee939ee7823b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0bb63c7dcf488db1c5b4ccfdb1392696"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a0bb63c7dcf488db1c5b4ccfdb1392696">enableIndices</a> ()</td></tr>
<tr class="memdesc:a0bb63c7dcf488db1c5b4ccfdb1392696"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable mesh indices. Use <a class="el" href="classof_mesh__.html#a94abf6a3552f051e61a8023ad0c3a7f3" title="Disable mesh indices. Use enableIndices() to turn indices back on.">disableIndices()</a> to turn indices off. Indices are enabled by default when they are added to the mesh.  <a href="classof_mesh__.html#a0bb63c7dcf488db1c5b4ccfdb1392696">More...</a><br/></td></tr>
<tr class="separator:a0bb63c7dcf488db1c5b4ccfdb1392696"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a94abf6a3552f051e61a8023ad0c3a7f3"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a94abf6a3552f051e61a8023ad0c3a7f3">disableIndices</a> ()</td></tr>
<tr class="memdesc:a94abf6a3552f051e61a8023ad0c3a7f3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable mesh indices. Use <a class="el" href="classof_mesh__.html#a0bb63c7dcf488db1c5b4ccfdb1392696" title="Enable mesh indices. Use disableIndices() to turn indices off. Indices are enabled by default when th...">enableIndices()</a> to turn indices back on.  <a href="classof_mesh__.html#a94abf6a3552f051e61a8023ad0c3a7f3">More...</a><br/></td></tr>
<tr class="separator:a94abf6a3552f051e61a8023ad0c3a7f3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af6a6ad647e073aa833b9c59d2156dea5"><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#af6a6ad647e073aa833b9c59d2156dea5">usingIndices</a> () const</td></tr>
<tr class="separator:af6a6ad647e073aa833b9c59d2156dea5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a031e6a96eccbe314d2279dd009ce2f99"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a031e6a96eccbe314d2279dd009ce2f99">setColorForIndices</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> startIndex, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> endIndex, C color)</td></tr>
<tr class="separator:a031e6a96eccbe314d2279dd009ce2f99"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afa569682f5f85e6c1ca8054cb474b837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#afa569682f5f85e6c1ca8054cb474b837">getMeshForIndices</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> startIndex, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> endIndex) const</td></tr>
<tr class="separator:afa569682f5f85e6c1ca8054cb474b837"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3c72a104168679e579e6d009663e4b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a3c72a104168679e579e6d009663e4b59">getMeshForIndices</a> (<a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> startIndex, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> endIndex, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> startVertIndex, <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> endVertIndex) const</td></tr>
<tr class="separator:a3c72a104168679e579e6d009663e4b59"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing</div></td></tr>
<tr class="memitem:afd563500a26de475dcbd62e1bdd23f01"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#afd563500a26de475dcbd62e1bdd23f01">drawVertices</a> () const</td></tr>
<tr class="memdesc:afd563500a26de475dcbd62e1bdd23f01"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This allows you draw just the vertices, meaning that you&#39;ll have a point cloud.  <a href="classof_mesh__.html#afd563500a26de475dcbd62e1bdd23f01">More...</a><br/></td></tr>
<tr class="separator:afd563500a26de475dcbd62e1bdd23f01"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af625869d4be685cede634017e7bee0f6"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#af625869d4be685cede634017e7bee0f6">drawWireframe</a> () const</td></tr>
<tr class="memdesc:af625869d4be685cede634017e7bee0f6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This draws the mesh as GL_LINES, meaning that you&#39;ll have a wireframe.  <a href="classof_mesh__.html#af625869d4be685cede634017e7bee0f6">More...</a><br/></td></tr>
<tr class="separator:af625869d4be685cede634017e7bee0f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a29c02e7d020a1bba974e0b2d967fc77d"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a29c02e7d020a1bba974e0b2d967fc77d">drawFaces</a> () const</td></tr>
<tr class="memdesc:a29c02e7d020a1bba974e0b2d967fc77d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This draws the mesh as faces, meaning that you&#39;ll have a collection of faces.  <a href="classof_mesh__.html#a29c02e7d020a1bba974e0b2d967fc77d">More...</a><br/></td></tr>
<tr class="separator:a29c02e7d020a1bba974e0b2d967fc77d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a589f79d56eab43ce5e210fc9bf3b5272"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a589f79d56eab43ce5e210fc9bf3b5272">draw</a> () const</td></tr>
<tr class="memdesc:a589f79d56eab43ce5e210fc9bf3b5272"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This draws the mesh using its primitive type, meaning that if you set them up to be triangles, this will draw the triangles.  <a href="classof_mesh__.html#a589f79d56eab43ce5e210fc9bf3b5272">More...</a><br/></td></tr>
<tr class="separator:a589f79d56eab43ce5e210fc9bf3b5272"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab93c670f946b1bb78ccda5557d849d7b"><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ab93c670f946b1bb78ccda5557d849d7b">draw</a> (<a class="el" href="of_graphics_constants_8h.html#a6beb1fbbaba728909c78cda1eadfe28e">ofPolyRenderMode</a> renderType) const</td></tr>
<tr class="memdesc:ab93c670f946b1bb78ccda5557d849d7b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This draws the mesh using a defined renderType, overriding the renderType defined with <a class="el" href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049" title="Allows you to set the ofPrimitiveMode. The available modes are OF_PRIMITIVE_TRIANGLES,...">setMode()</a>.  <a href="classof_mesh__.html#ab93c670f946b1bb78ccda5557d849d7b">More...</a><br/></td></tr>
<tr class="separator:ab93c670f946b1bb78ccda5557d849d7b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving and loading</div></td></tr>
<tr class="memitem:a707313f4d739d5c0a2b1f354c4ec18be"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a707313f4d739d5c0a2b1f354c4ec18be">load</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="memdesc:a707313f4d739d5c0a2b1f354c4ec18be"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a mesh from a file located at the provided path into the mesh. This will replace any existing data within the mesh.  <a href="classof_mesh__.html#a707313f4d739d5c0a2b1f354c4ec18be">More...</a><br/></td></tr>
<tr class="separator:a707313f4d739d5c0a2b1f354c4ec18be"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aed2fbf7555c7a275c42b36fbcda6fde6"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aed2fbf7555c7a275c42b36fbcda6fde6">save</a> (const std::filesystem::path &amp;path, bool useBinary=false) const</td></tr>
<tr class="memdesc:aed2fbf7555c7a275c42b36fbcda6fde6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the mesh at the passed path in the <a href="http://en.wikipedia.org/wiki/PLY_(file_format)">PLY Format</a>.  <a href="classof_mesh__.html#aed2fbf7555c7a275c42b36fbcda6fde6">More...</a><br/></td></tr>
<tr class="separator:aed2fbf7555c7a275c42b36fbcda6fde6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primitive constructor helper methods</div></td></tr>
<tr class="memitem:a410b09e5fd20b01bd2892a0491fc7ecf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a410b09e5fd20b01bd2892a0491fc7ecf">plane</a> (float <a class="el" href="of_icon_8h.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>, float <a class="el" href="of_icon_8h.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>, int columns=2, int rows=2, <a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode=<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a>)</td></tr>
<tr class="separator:a410b09e5fd20b01bd2892a0491fc7ecf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2380ed62ef45a236e2804f269645af53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a2380ed62ef45a236e2804f269645af53">sphere</a> (float radius, int res=12, <a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode=<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a>)</td></tr>
<tr class="separator:a2380ed62ef45a236e2804f269645af53"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa9b4d1199f717c378856fab760eacad8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aa9b4d1199f717c378856fab760eacad8">icosahedron</a> (float radius)</td></tr>
<tr class="separator:aa9b4d1199f717c378856fab760eacad8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adb8318a1d79b61f282a697a28d438e3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#adb8318a1d79b61f282a697a28d438e3b">icosphere</a> (float radius, std::size_t iterations=2)</td></tr>
<tr class="separator:adb8318a1d79b61f282a697a28d438e3b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d12cfda1bd4c71945084b72c96e593d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a8d12cfda1bd4c71945084b72c96e593d">cylinder</a> (float radius, float <a class="el" href="of_icon_8h.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>, int radiusSegments=12, int heightSegments=6, int numCapSegments=2, bool bCapped=true, <a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode=<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a>)</td></tr>
<tr class="memdesc:a8d12cfda1bd4c71945084b72c96e593d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper method that returns a cylinder made of triangles. The resolution settings for the radius, height, and cap are optional (they are set at a default of 12 segments around the radius, 6 segments in the height, and 2 on the cap). You have the option to cap the cylinder or not. The only valid modes are the default OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES.  <a href="classof_mesh__.html#a8d12cfda1bd4c71945084b72c96e593d">More...</a><br/></td></tr>
<tr class="separator:a8d12cfda1bd4c71945084b72c96e593d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4c53b813074a4e9348f7b95181ad4537"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4c53b813074a4e9348f7b95181ad4537">cone</a> (float radius, float <a class="el" href="of_icon_8h.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>, int radiusSegments=12, int heightSegments=6, int capSegments=2, <a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> mode=<a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a>)</td></tr>
<tr class="memdesc:a4c53b813074a4e9348f7b95181ad4537"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper method that returns a cone made of triangles. The resolution settings for the radius, height, and cap are optional (they are set at a default of 12 segments around the radius, 6 segments in the height, and 2 on the cap). The only valid modes are the default OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES.  <a href="classof_mesh__.html#a4c53b813074a4e9348f7b95181ad4537">More...</a><br/></td></tr>
<tr class="separator:a4c53b813074a4e9348f7b95181ad4537"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aff587a68f6aac12ee30fc0f405c5944d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#aff587a68f6aac12ee30fc0f405c5944d">box</a> (float <a class="el" href="of_icon_8h.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>, float <a class="el" href="of_icon_8h.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>, float depth, int resX=2, int resY=2, int resZ=2)</td></tr>
<tr class="memdesc:aff587a68f6aac12ee30fc0f405c5944d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper method that returns a box made of triangles. The resolution settings for the width and height are optional (they are both set at a default of 2 triangles per side).  <a href="classof_mesh__.html#aff587a68f6aac12ee30fc0f405c5944d">More...</a><br/></td></tr>
<tr class="separator:aff587a68f6aac12ee30fc0f405c5944d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd07244e7b0bb520b2eb076792005536"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classof_mesh__.html">ofMesh_</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#afd07244e7b0bb520b2eb076792005536">axis</a> (float size=1.0)</td></tr>
<tr class="memdesc:afd07244e7b0bb520b2eb076792005536"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an ofMesh representing an XYZ coordinate system.  <a href="classof_mesh__.html#afd07244e7b0bb520b2eb076792005536">More...</a><br/></td></tr>
<tr class="separator:afd07244e7b0bb520b2eb076792005536"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4e2780a560431d8bb36272a19c2c0514"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a4e2780a560431d8bb36272a19c2c0514">haveVertsChanged</a> ()</td></tr>
<tr class="separator:a4e2780a560431d8bb36272a19c2c0514"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad0f34d06dd1e215610d868abc2357a48"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ad0f34d06dd1e215610d868abc2357a48">haveNormalsChanged</a> ()</td></tr>
<tr class="separator:ad0f34d06dd1e215610d868abc2357a48"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a402415e2269de5bae1ea093482a23310"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a402415e2269de5bae1ea093482a23310">haveColorsChanged</a> ()</td></tr>
<tr class="separator:a402415e2269de5bae1ea093482a23310"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6a99f33c4ea99cda4c7e186a09e078d6"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#a6a99f33c4ea99cda4c7e186a09e078d6">haveTexCoordsChanged</a> ()</td></tr>
<tr class="separator:a6a99f33c4ea99cda4c7e186a09e078d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae79119cec73b47e67c7b5b13156291cb"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_mesh__.html#ae79119cec73b47e67c7b5b13156291cb">haveIndicesChanged</a> ()</td></tr>
<tr class="separator:ae79119cec73b47e67c7b5b13156291cb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class V, class N, class C, class T&gt;<br/>
class ofMesh_&lt; V, N, C, T &gt;</h3>

<p>Represents a set of vertices in 3D spaces with normals, colors, and texture coordinates at those points. </p>
<p>Each of these different properties is stored in a vector. Vertices are passed to your graphics card and your graphics card fill in the spaces in between them in a processing usually called the rendering pipeline. The rendering pipeline goes more or less like this:</p>
<ol type="1">
<li>Say how you&#39;re going to connect all the points.</li>
<li>Make some points.</li>
<li>Say that you&#39;re done making points.</li>
</ol>
<p>You may be thinking: I&#39;ll just make eight vertices and voila: a cube. Not so quick. There&#39;s a hitch and that hitch is that the OpenGL renderer has different ways of connecting the vertices that you pass to it and none are as efficient as to only need eight vertices to create a cube.</p>
<p>You&#39;ve probably seen a version of the following image somewhere before. <img src="3d/primitives_new-640x269.gif" alt="PRIMATIVES" class="inline"/> Generally you have to create your points to fit the drawing mode that you&#39;ve selected because of whats called winding. A vertex gets connected to another vertex in the order that the mode does its winding and this means that you might need multiple vertices in a given location to create the shape you want. The cube, for example, requires eighteen vertices, not the eight that you would expect. If you note the order of vertices in the GL chart above you&#39;ll see that all of them use their vertices slightly differently (in particular you should make note of the GL_TRIANGLE_STRIP example). Drawing a shape requires that you keep track of which drawing mode is being used and which order your vertices are declared in.</p>
<p>If you&#39;re thinking: it would be nice if there were an abstraction layer for this you&#39;re thinking right. Enter the mesh, which is really just an abstraction of the vertex and drawing mode that we started with but which has the added bonus of managing the draw order for you. That may seem insignificant at first, but it provides some real benefits when working with complex geometry.</p>
<p>A very typical usage is something like the following:</p>
<div class="fragment"><div class="line"><a class="code" href="classof_mesh__.html">ofMesh</a> mesh;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; <a class="code" href="of_app_e_g_l_window_8cpp.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>; y++){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x&lt;<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>; x++){</div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a>(glm::vec3(x,y,0)); <span class="comment">// make a new vertex</span></div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#ae7361115d8ce96c4a71d8f572b1ba02a">addColor</a>(<a class="code" href="of_shader_8h.html#ac32ecc231f9436904c104121b32baac0">ofFloatColor</a>(0,0,0));  <span class="comment">// add a color at that vertex</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassof_mesh___html"><div class="ttname"><a href="classof_mesh__.html">ofMesh_&lt; ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType &gt;</a></div></div>
<div class="ttc" id="aclassof_mesh___html_abf653cd7eb467c9165fa8a5c8a917be7"><div class="ttname"><a href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">ofMesh_::addVertex</a></div><div class="ttdeci">void addVertex(const V &amp;v)</div><div class="ttdoc">Add a new vertex at the end of the current list of vertices. It is important to remember that the ord...</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:181</div></div>
<div class="ttc" id="aclassof_mesh___html_ae7361115d8ce96c4a71d8f572b1ba02a"><div class="ttname"><a href="classof_mesh__.html#ae7361115d8ce96c4a71d8f572b1ba02a">ofMesh_::addColor</a></div><div class="ttdeci">void addColor(const C &amp;c)</div><div class="ttdoc">This adds a color to the mesh, the color will be associated with the vertex in the same position.</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:211</div></div>
<div class="ttc" id="aof_app_e_g_l_window_8cpp_html_ab2e78c61905b4419fcc7b4cfc500fe85"><div class="ttname"><a href="of_app_e_g_l_window_8cpp.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a></div><div class="ttdeci">unsigned int height</div><div class="ttdef"><b>Definition:</b> ofAppEGLWindow.cpp:122</div></div>
<div class="ttc" id="aof_app_e_g_l_window_8cpp_html_aca34d28e3d8bcbcadb8edb4e3af24f8c"><div class="ttname"><a href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a></div><div class="ttdeci">unsigned int width</div><div class="ttdef"><b>Definition:</b> ofAppEGLWindow.cpp:121</div></div>
<div class="ttc" id="aof_shader_8h_html_ac32ecc231f9436904c104121b32baac0"><div class="ttname"><a href="of_shader_8h.html#ac32ecc231f9436904c104121b32baac0">ofFloatColor</a></div><div class="ttdeci">ofColor_&lt; float &gt; ofFloatColor</div><div class="ttdoc">A typedef representing a floating (float) point RGBA color.</div><div class="ttdef"><b>Definition:</b> ofShader.h:23</div></div>
</div><!-- fragment --><p>Now it&#39;s important to make sure that each vertex is correctly connected with the other vertices around it. This is done using indices, which you can set up like so: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y&lt;<a class="code" href="of_app_e_g_l_window_8cpp.html#ab2e78c61905b4419fcc7b4cfc500fe85">height</a>-1; y++){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>-1; x++){</div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(x+y*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);               <span class="comment">// 0</span></div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>((x+1)+y*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);           <span class="comment">// 1</span></div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(x+(y+1)*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);           <span class="comment">// 10</span></div>
<div class="line"> </div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>((x+1)+y*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);           <span class="comment">// 1</span></div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>((x+1)+(y+1)*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);       <span class="comment">// 11</span></div>
<div class="line">        mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(x+(y+1)*<a class="code" href="of_app_e_g_l_window_8cpp.html#aca34d28e3d8bcbcadb8edb4e3af24f8c">width</a>);           <span class="comment">// 10</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassof_mesh___html_a28a5c8eab600b62622a8d49439d5c973"><div class="ttname"><a href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">ofMesh_::addIndex</a></div><div class="ttdeci">void addIndex(ofIndexType i)</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:310</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a53555600ee52411e88c3f907f2baf2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53555600ee52411e88c3f907f2baf2ba">&nbsp;</a></span>ofMesh_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::<a class="el" href="classof_mesh__.html">ofMesh_</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This creates the mesh, using OF_PRIMITIVE_TRIANGLES without any initial vertices. </p>

</div>
</div>
<a id="a5240f9014d1d32af12513b9bc3c12c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5240f9014d1d32af12513b9bc3c12c29">&nbsp;</a></span>ofMesh_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::<a class="el" href="classof_mesh__.html">ofMesh_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>verts</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This allows to you to use one of the other ofPrimitiveModes: OF_PRIMITIVE_TRIANGLES, OF_PRIMITIVE_TRIANGLE_STRIP, OF_PRIMITIVE_TRIANGLE_FAN, OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP, OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS. See <a href="../gl/ofGLUtils.htm">ofGLUtils</a> for more information on these types. </p>

</div>
</div>
<a id="a6a24a1fe83e7b43ece4b187b13800325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a24a1fe83e7b43ece4b187b13800325">&nbsp;</a></span>~ofMesh_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::~<a class="el" href="classof_mesh__.html">ofMesh_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae7361115d8ce96c4a71d8f572b1ba02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7361115d8ce96c4a71d8f572b1ba02a">&nbsp;</a></span>addColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addColor </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This adds a color to the mesh, the color will be associated with the vertex in the same position. </p>

</div>
</div>
<a id="a620775bcc9cdf7943778eb68af43e4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620775bcc9cdf7943778eb68af43e4c9">&nbsp;</a></span>addColors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addColors </td>
          <td>(</td>
          <td class="paramtype">const C *&nbsp;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>amt</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This adds a pointer of colors to the ofMesh instance with the amount passed as the second parameter. </p>

</div>
</div>
<a id="a3f6a666f26eca1ffa7fa7ceab996d67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a666f26eca1ffa7fa7ceab996d67f">&nbsp;</a></span>addColors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addColors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>cols</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This adds colors using a reference to a vector of ofColors. For each color in the vector, this will put the colors at the corresponding vertex. </p>

</div>
</div>
<a id="a28a5c8eab600b62622a8d49439d5c973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a5c8eab600b62622a8d49439d5c973">&nbsp;</a></span>addIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Add an index to the index vector. Each index represents the order of connection for vertices. This determines the way that the vertices are connected according to the polygon type set in the primitiveMode. It important to note that a particular vertex might be used for several faces and so would be referenced several times in the index vector. </p><div class="fragment"><div class="line"><a class="code" href="classof_mesh__.html">ofMesh</a> mesh;</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049">setMode</a>(<a class="code" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a56773d485b35d619c99840afc4b02193">OF_PRIMITIVE_TRIANGLES</a>);</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a>(glm::vec3(0,-200,0));</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a>(glm::vec3(200, 0, 0 ));</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a>(glm::vec3(-200, 0, 0 ));</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#abf653cd7eb467c9165fa8a5c8a917be7">addVertex</a>(glm::vec3(0, 200, 0 ));</div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(0); <span class="comment">//connect the first vertex we made, v0</span></div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(1); <span class="comment">//to v1</span></div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(2); <span class="comment">//to v2 to complete the face</span></div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(1); <span class="comment">//now start a new face beginning with v1</span></div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(2); <span class="comment">//that is connected to v2</span></div>
<div class="line">mesh.<a class="code" href="classof_mesh__.html#a28a5c8eab600b62622a8d49439d5c973">addIndex</a>(3); <span class="comment">//and we complete the face with v3</span></div>
<div class="ttc" id="aclassof_mesh___html_a127eade588093f14bfe8a714ab819049"><div class="ttname"><a href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049">ofMesh_::setMode</a></div><div class="ttdeci">void setMode(ofPrimitiveMode mode)</div><div class="ttdoc">Allows you to set the ofPrimitiveMode. The available modes are OF_PRIMITIVE_TRIANGLES,...</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:744</div></div>
<div class="ttc" id="aof_graphics_constants_8h_html_a0f71f0b23a18629a446952d5540e16e0a56773d485b35d619c99840afc4b02193"><div class="ttname"><a href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a56773d485b35d619c99840afc4b02193">OF_PRIMITIVE_TRIANGLES</a></div><div class="ttdeci">@ OF_PRIMITIVE_TRIANGLES</div><div class="ttdef"><b>Definition:</b> ofGraphicsConstants.h:21</div></div>
</div><!-- fragment --><p> Will give you this shape: <img src="3d/index.jpg" alt="image of basic use of indices" class="inline"/> </p>

</div>
</div>
<a id="a8182931332b366ad27a2ca610dc40a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8182931332b366ad27a2ca610dc40a5b">&nbsp;</a></span>addIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> *&nbsp;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>amt</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This adds indices to the ofMesh by pointing to an array of indices. The &#34;amt&#34; defines the length of the array. </p>

</div>
</div>
<a id="aa9ee4782d6adf9352b87a74e2fc87751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ee4782d6adf9352b87a74e2fc87751">&nbsp;</a></span>addIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>inds</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This adds a vector of indices. </p>

</div>
</div>
<a id="a5066645e2f1283fa80904d6b63b5a829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5066645e2f1283fa80904d6b63b5a829">&nbsp;</a></span>addNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addNormal </td>
          <td>(</td>
          <td class="paramtype">const N &amp;&nbsp;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a normal to the mesh as a 3D vector, typically perpendicular to the plane of the face. A normal is a vector that defines how a surface responds to lighting, i.e. how it is lit. The amount of light reflected by a surface is proportional to the angle between the light&#39;s direction and the normal. The smaller the angle the brighter the surface will look. See the normalsExample for advice on computing the normals. addNormal adds the 3D vector to the end of the list, so you need to make sure you add normals at the same index of the matching vertex. </p>

</div>
</div>
<a id="ae7eec98ee25a054f1e7fa5f191b6bbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eec98ee25a054f1e7fa5f191b6bbcf">&nbsp;</a></span>addNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addNormals </td>
          <td>(</td>
          <td class="paramtype">const N *&nbsp;</td>
          <td class="paramname"><em>norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>amt</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add an array of normals to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an std::size_t (amt). The normals are added at the end of the current normals list. </p>

</div>
</div>
<a id="add902534593bda650e730aa797a54d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add902534593bda650e730aa797a54d3d">&nbsp;</a></span>addNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addNormals </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>norms</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a vector of normals to a mesh, allowing you to push out many normals at once rather than adding one at a time. The vector of normals is added after the end of the current normals list. </p>

</div>
</div>
<a id="aa78c9cae51d3b01c33d693ae86630537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78c9cae51d3b01c33d693ae86630537">&nbsp;</a></span>addTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addTexCoord </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a Vec2f representing the texture coordinate. Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates. </p>

</div>
</div>
<a id="a659cf9460a5261f8908e72f8fb0f027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659cf9460a5261f8908e72f8fb0f027a">&nbsp;</a></span>addTexCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addTexCoords </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>tCoords</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a vector of texture coordinates to a mesh, allowing you to push out many at once rather than adding one at a time. The vector of texture coordinates is added after the end of the current texture coordinates list. </p>

</div>
</div>
<a id="a4744e686684a4f2441af6a43f247749c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4744e686684a4f2441af6a43f247749c">&nbsp;</a></span>addTexCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addTexCoords </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"><em>tCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>amt</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add an array of texture coordinates to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an std::size_t (amt). The texture coordinates are added at the end of the current texture coordinates list. </p>

</div>
</div>
<a id="a19231dc0fa951047366ee939ee7823b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19231dc0fa951047366ee939ee7823b5">&nbsp;</a></span>addTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index3</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Adding a triangle means using three of the vertices that have already been added to create a triangle. This is an easy way to create triangles in the mesh. The indices refer to the index of the vertex in the vector of vertices. </p>

</div>
</div>
<a id="abf653cd7eb467c9165fa8a5c8a917be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf653cd7eb467c9165fa8a5c8a917be7">&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addVertex </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&nbsp;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a new vertex at the end of the current list of vertices. It is important to remember that the order the vertices are added to the list determines how they link they form the polygons and strips (assuming you do not change their indeces). See the ofMesh class description for details. </p>

</div>
</div>
<a id="af849b874e00b6dee86d47547c855f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af849b874e00b6dee86d47547c855f4c5">&nbsp;</a></span>addVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addVertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>verts</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a vector of vertices to a mesh, allowing you to push out many at once rather than adding one at a time. The vector of vertices is added after the end of the current vertices list. </p>

</div>
</div>
<a id="a1f1c926d782f070ae267cfbe7b21c045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c926d782f070ae267cfbe7b21c045">&nbsp;</a></span>addVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::addVertices </td>
          <td>(</td>
          <td class="paramtype">const V *&nbsp;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>amt</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add an array of vertices to the mesh. Because you are using a pointer to the array you also have to define the length of the array as an int (amt). The vertices are added at the end of the current vertices list. </p>

</div>
</div>
<a id="a61a58a90fdae4bcfd7edc98a1775491e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a58a90fdae4bcfd7edc98a1775491e">&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add the vertices, normals, texture coordinates and indices of one mesh onto another mesh. Everything from the referenced mesh is simply added at the end of the current mesh&#39;s lists. </p>

</div>
</div>
<a id="afd07244e7b0bb520b2eb076792005536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd07244e7b0bb520b2eb076792005536">&nbsp;</a></span>axis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::axis </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>size</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Returns an ofMesh representing an XYZ coordinate system. </p>
<dl class="section return"><dt>Returns</dt><dd>an ofMesh representing an XYZ coordinate system. </dd></dl>

</div>
</div>
<a id="aff587a68f6aac12ee30fc0f405c5944d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff587a68f6aac12ee30fc0f405c5944d">&nbsp;</a></span>box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::box </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>resX</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>resY</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>resZ</em> = <code>2</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>A helper method that returns a box made of triangles. The resolution settings for the width and height are optional (they are both set at a default of 2 triangles per side). </p>
<div class="fragment"><div class="line"><a class="code" href="classof_mesh__.html">ofMesh</a> mesh;</div>
<div class="line">mesh = <a class="code" href="classof_mesh__.html#aff587a68f6aac12ee30fc0f405c5944d">ofMesh::box</a>(200.0, 200.0, 200.0);</div>
<div class="ttc" id="aclassof_mesh___html_aff587a68f6aac12ee30fc0f405c5944d"><div class="ttname"><a href="classof_mesh__.html#aff587a68f6aac12ee30fc0f405c5944d">ofMesh_&lt; ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType &gt;::box</a></div><div class="ttdeci">static ofMesh_ box(float width, float height, float depth, int resX=2, int resY=2, int resZ=2)</div><div class="ttdoc">A helper method that returns a box made of triangles. The resolution settings for the width and heigh...</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:2613</div></div>
</div><!-- fragment --><p><img src="3d/box.jpg" alt="image of a simple box" class="inline"/> </p>

</div>
</div>
<a id="a9eeb879d86685a7e893f2531a3e262bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeb879d86685a7e893f2531a3e262bc">&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clear</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Removes all the vertices, colors, and indices from the mesh. </p>

</div>
</div>
<a id="afa98b173cc7d1ee6b23feb77da7ee47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa98b173cc7d1ee6b23feb77da7ee47f">&nbsp;</a></span>clearColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clearColors</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Clear all the colors. </p>

</div>
</div>
<a id="ae67147b21dce8cddd069423012f0cf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67147b21dce8cddd069423012f0cf2f">&nbsp;</a></span>clearIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clearIndices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove all the indices of the mesh. This means that your mesh will be a point cloud. </p>

</div>
</div>
<a id="a0f399e35b19142c8dcffdfb520bbbb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f399e35b19142c8dcffdfb520bbbb18">&nbsp;</a></span>clearNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clearNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove all the normals. </p>

</div>
</div>
<a id="a50b374ad3869de450e17105c1fdeb13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b374ad3869de450e17105c1fdeb13b">&nbsp;</a></span>clearTexCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clearTexCoords</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Clear all the texture coordinates. </p>

</div>
</div>
<a id="a57b3f747af2859da93af3166d8a27e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b3f747af2859da93af3166d8a27e18">&nbsp;</a></span>clearVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::clearVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Removes all the vertices. </p>

</div>
</div>
<a id="a4c53b813074a4e9348f7b95181ad4537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c53b813074a4e9348f7b95181ad4537">&nbsp;</a></span>cone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::cone </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>radiusSegments</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>heightSegments</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>capSegments</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>A helper method that returns a cone made of triangles. The resolution settings for the radius, height, and cap are optional (they are set at a default of 12 segments around the radius, 6 segments in the height, and 2 on the cap). The only valid modes are the default OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES. </p>
<div class="fragment"><div class="line"><a class="code" href="classof_mesh__.html">ofMesh</a> mesh;</div>
<div class="line">mesh = <a class="code" href="classof_mesh__.html#a4c53b813074a4e9348f7b95181ad4537">ofMesh::cone</a>(100.0, 200.0);</div>
<div class="ttc" id="aclassof_mesh___html_a4c53b813074a4e9348f7b95181ad4537"><div class="ttname"><a href="classof_mesh__.html#a4c53b813074a4e9348f7b95181ad4537">ofMesh_&lt; ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType &gt;::cone</a></div><div class="ttdeci">static ofMesh_ cone(float radius, float height, int radiusSegments=12, int heightSegments=6, int capSegments=2, ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP)</div><div class="ttdoc">A helper method that returns a cone made of triangles. The resolution settings for the radius,...</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:2463</div></div>
</div><!-- fragment --><p><img src="3d/cone.jpg" alt="image of a simple cone" class="inline"/> </p>

</div>
</div>
<a id="a8d12cfda1bd4c71945084b72c96e593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d12cfda1bd4c71945084b72c96e593d">&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::cylinder </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>radiusSegments</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>heightSegments</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>numCapSegments</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>bCapped</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>A helper method that returns a cylinder made of triangles. The resolution settings for the radius, height, and cap are optional (they are set at a default of 12 segments around the radius, 6 segments in the height, and 2 on the cap). You have the option to cap the cylinder or not. The only valid modes are the default OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES. </p>
<div class="fragment"><div class="line"><a class="code" href="classof_mesh__.html">ofMesh</a> mesh;</div>
<div class="line">mesh = <a class="code" href="classof_mesh__.html#a8d12cfda1bd4c71945084b72c96e593d">ofMesh::cylinder</a>(100.0, 200.0);</div>
<div class="ttc" id="aclassof_mesh___html_a8d12cfda1bd4c71945084b72c96e593d"><div class="ttname"><a href="classof_mesh__.html#a8d12cfda1bd4c71945084b72c96e593d">ofMesh_&lt; ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType &gt;::cylinder</a></div><div class="ttdeci">static ofMesh_ cylinder(float radius, float height, int radiusSegments=12, int heightSegments=6, int numCapSegments=2, bool bCapped=true, ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP)</div><div class="ttdoc">A helper method that returns a cylinder made of triangles. The resolution settings for the radius,...</div><div class="ttdef"><b>Definition:</b> ofMesh.inl:2270</div></div>
</div><!-- fragment --><p><img src="3d/cylinder.jpg" alt="image of a simple cylinder" class="inline"/> </p>

</div>
</div>
<a id="aac8b40e7b05b9fb9c26b2b8a0e7601da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8b40e7b05b9fb9c26b2b8a0e7601da">&nbsp;</a></span>disableColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::disableColors</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Disable mesh colors. Use <a class="el" href="classof_mesh__.html#a4b6a5a6bc27ff1090aa16ea476cd66e1" title="Enable mesh colors. Use disableColors() to turn colors off. Colors are enabled by default when they a...">enableColors()</a> to turn colors back on. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a83e16cb5d79357a5c4e096fed601ae87">ofVboMesh</a>.</p>

</div>
</div>
<a id="a94abf6a3552f051e61a8023ad0c3a7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94abf6a3552f051e61a8023ad0c3a7f3">&nbsp;</a></span>disableIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::disableIndices</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Disable mesh indices. Use <a class="el" href="classof_mesh__.html#a0bb63c7dcf488db1c5b4ccfdb1392696" title="Enable mesh indices. Use disableIndices() to turn indices off. Indices are enabled by default when th...">enableIndices()</a> to turn indices back on. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a5dceef973800c07e2ae8521ce5ae2565">ofVboMesh</a>.</p>

</div>
</div>
<a id="a74344516e455506644ac8091dc41727f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74344516e455506644ac8091dc41727f">&nbsp;</a></span>disableNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::disableNormals</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Disable mesh normals. Use <a class="el" href="classof_mesh__.html#a2569384c5b9b600e5148e98a8e79e6b6" title="Enable mesh normals. Use disableNormals() to turn normals off. Normals are enabled by default when th...">enableNormals()</a> to turn normals back on. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a45273d9354958b9d12db86b7ab2f9ccf">ofVboMesh</a>.</p>

</div>
</div>
<a id="aaae8fcc838769c03cb0127836b488282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae8fcc838769c03cb0127836b488282">&nbsp;</a></span>disableTextures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::disableTextures</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Disable mesh textures. Use <a class="el" href="classof_mesh__.html#a1bc8979e0595fa3d691d458f6badb9c1" title="Enable mesh textures. Use disableTextures() to turn textures off. Textures are enabled by default whe...">enableTextures()</a> to turn textures back on. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#ac7770081d54b76d54f275b10e634082f">ofVboMesh</a>.</p>

</div>
</div>
<a id="a589f79d56eab43ce5e210fc9bf3b5272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589f79d56eab43ce5e210fc9bf3b5272">&nbsp;</a></span>draw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::draw</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This draws the mesh using its primitive type, meaning that if you set them up to be triangles, this will draw the triangles. </p>

</div>
</div>
<a id="ab93c670f946b1bb78ccda5557d849d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93c670f946b1bb78ccda5557d849d7b">&nbsp;</a></span>draw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a6beb1fbbaba728909c78cda1eadfe28e">ofPolyRenderMode</a>&nbsp;</td>
          <td class="paramname"><em>renderType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>This draws the mesh using a defined renderType, overriding the renderType defined with <a class="el" href="classof_mesh__.html#a127eade588093f14bfe8a714ab819049" title="Allows you to set the ofPrimitiveMode. The available modes are OF_PRIMITIVE_TRIANGLES,...">setMode()</a>. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a8357d5de8084ec7d1d58bef69d374724">ofVboMesh</a>.</p>

</div>
</div>
<a id="a29c02e7d020a1bba974e0b2d967fc77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c02e7d020a1bba974e0b2d967fc77d">&nbsp;</a></span>drawFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::drawFaces</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This draws the mesh as faces, meaning that you&#39;ll have a collection of faces. </p>

</div>
</div>
<a id="afd563500a26de475dcbd62e1bdd23f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd563500a26de475dcbd62e1bdd23f01">&nbsp;</a></span>drawVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::drawVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This allows you draw just the vertices, meaning that you&#39;ll have a point cloud. </p>

</div>
</div>
<a id="af625869d4be685cede634017e7bee0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af625869d4be685cede634017e7bee0f6">&nbsp;</a></span>drawWireframe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::drawWireframe</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This draws the mesh as GL_LINES, meaning that you&#39;ll have a wireframe. </p>

</div>
</div>
<a id="a4b6a5a6bc27ff1090aa16ea476cd66e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6a5a6bc27ff1090aa16ea476cd66e1">&nbsp;</a></span>enableColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::enableColors</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Enable mesh colors. Use <a class="el" href="classof_mesh__.html#aac8b40e7b05b9fb9c26b2b8a0e7601da" title="Disable mesh colors. Use enableColors() to turn colors back on.">disableColors()</a> to turn colors off. Colors are enabled by default when they are added to the mesh. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a944e9c341cfbc9d5f58b4adbef5a504d">ofVboMesh</a>.</p>

</div>
</div>
<a id="a0bb63c7dcf488db1c5b4ccfdb1392696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb63c7dcf488db1c5b4ccfdb1392696">&nbsp;</a></span>enableIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::enableIndices</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Enable mesh indices. Use <a class="el" href="classof_mesh__.html#a94abf6a3552f051e61a8023ad0c3a7f3" title="Disable mesh indices. Use enableIndices() to turn indices back on.">disableIndices()</a> to turn indices off. Indices are enabled by default when they are added to the mesh. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a2750f07c8b1b2968b1c1219c0e55920c">ofVboMesh</a>.</p>

</div>
</div>
<a id="a2569384c5b9b600e5148e98a8e79e6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2569384c5b9b600e5148e98a8e79e6b6">&nbsp;</a></span>enableNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::enableNormals</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Enable mesh normals. Use <a class="el" href="classof_mesh__.html#a74344516e455506644ac8091dc41727f" title="Disable mesh normals. Use enableNormals() to turn normals back on.">disableNormals()</a> to turn normals off. Normals are enabled by default when they are added to the mesh. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a511345c2fd74797224eaf980cd145f25">ofVboMesh</a>.</p>

</div>
</div>
<a id="a1bc8979e0595fa3d691d458f6badb9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc8979e0595fa3d691d458f6badb9c1">&nbsp;</a></span>enableTextures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::enableTextures</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Enable mesh textures. Use <a class="el" href="classof_mesh__.html#aaae8fcc838769c03cb0127836b488282" title="Disable mesh textures. Use enableTextures() to turn textures back on.">disableTextures()</a> to turn textures off. Textures are enabled by default when they are added to the mesh. </p>

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a78183d05b29e9172ca2cefcc1e2bc6b6">ofVboMesh</a>.</p>

</div>
</div>
<a id="a8e699453b708eaf9bf707552ebe1e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e699453b708eaf9bf707552ebe1e73e">&nbsp;</a></span>flatNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::flatNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Duplicates vertices and updates normals to get a low-poly look. </p>

</div>
</div>
<a id="aeed33d7c52b4e05c71736f98dbedd665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed33d7c52b4e05c71736f98dbedd665">&nbsp;</a></span>getCentroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">V <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getCentroid</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classof_vec3f.html" title="ofVec3f is a class for storing a three dimensional vector.">ofVec3f</a> defining the centroid of all the vetices in the mesh. </dd></dl>

</div>
</div>
<a id="add3752ac399ccfc27f28243c34ec1c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3752ac399ccfc27f28243c34ec1c36">&nbsp;</a></span>getColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">C <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the color at the index in the colors vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the color at the index in the colors vector. </dd></dl>

</div>
</div>
<a id="a6b18598858a5007256b5cf8350d17b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b18598858a5007256b5cf8350d17b5a">&nbsp;</a></span>getColors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; C &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getColors</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Use this if you plan to change the colors as part of this call as it will force a reset of the cache. </p><dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the colors of the mesh, if it has any. </dd></dl>

</div>
</div>
<a id="a910f103a42561930799246be77cc0b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910f103a42561930799246be77cc0b7c">&nbsp;</a></span>getColors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; C &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getColors</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the colors of the mesh, if it has any. (read only) </dd></dl>

</div>
</div>
<a id="ae31a249470bfa9f3ef6183f1cbf64268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31a249470bfa9f3ef6183f1cbf64268">&nbsp;</a></span>getColorsPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">C * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getColorsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Use this if you plan to change the colors as part of this call as it will force a reset of the cache. </p><dl class="section return"><dt>Returns</dt><dd>a pointer that contains all of the colors of the mesh, if it has any. </dd></dl>

</div>
</div>
<a id="a92fe00523acd0c648bdaae94faf24c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fe00523acd0c648bdaae94faf24c3c">&nbsp;</a></span>getColorsPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const C * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getColorsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer that contains all of the colors of the mesh, if it has any. (read only) </dd></dl>

</div>
</div>
<a id="a97d0920e6b91c393f95188f160616a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d0920e6b91c393f95188f160616a33">&nbsp;</a></span>getFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>faceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the faces of the mesh. This isn&#39;t currently implemented. </dd></dl>

</div>
</div>
<a id="ac647d91596a0bbffbbe739941c2dd134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac647d91596a0bbffbbe739941c2dd134">&nbsp;</a></span>getFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; N &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getFaceNormals </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>perVetex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get normals for each face As a default it only calculates the normal for the face as a whole but by setting (perVertex = true) it will return the same normal value for each of the three vertices making up a face. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the calculated normals of each face in the mesh. </dd></dl>

</div>
</div>
<a id="a49849cc267a811dc9992c2ded2a2bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49849cc267a811dc9992c2ded2a2bd52">&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the index from the index vector. Each index represents the index of the vertex in the vertices vector. This determines the way that the vertices are connected into the polgoynon type set in the primitiveMode. </dd></dl>

</div>
</div>
<a id="ad6886a8d1a9611b14bd75245662c88d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6886a8d1a9611b14bd75245662c88d8">&nbsp;</a></span>getIndexPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getIndexPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the indices that the mesh contains. </dd></dl>

</div>
</div>
<a id="a744cd742fce649728e8ecbf47a50f6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744cd742fce649728e8ecbf47a50f6e9">&nbsp;</a></span>getIndexPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getIndexPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the indices that the mesh contains. </dd></dl>

</div>
</div>
<a id="a6683c2df8c29be2b182031aa8196ff98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6683c2df8c29be2b182031aa8196ff98">&nbsp;</a></span>getIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getIndices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Use this if you plan to change the indices as part of this call as it will force a reset of the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the indices of the mesh, if it has any. </dd></dl>

</div>
</div>
<a id="af2b7b1895a7991d7edcd5326b46b54fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b7b1895a7991d7edcd5326b46b54fe">&nbsp;</a></span>getIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; <a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a> &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getIndices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the indices of the mesh, if it has any. (read only) </dd></dl>

</div>
</div>
<a id="afa569682f5f85e6c1ca8054cb474b837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa569682f5f85e6c1ca8054cb474b837">&nbsp;</a></span>getMeshForIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getMeshForIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>endIndex</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>The new mesh includes the mesh mode, colors, textures, and normals of the original mesh (assuming any were added). </p><dl class="section return"><dt>Returns</dt><dd>a mesh made up of a range of indices from startIndex to the endIndex. </dd></dl>

</div>
</div>
<a id="a3c72a104168679e579e6d009663e4b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c72a104168679e579e6d009663e4b59">&nbsp;</a></span>getMeshForIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getMeshForIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>startVertIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>endVertIndex</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9e2c4bb699285a51ce519126cb64e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e2c4bb699285a51ce519126cb64e69">&nbsp;</a></span>getMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a> <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getMode</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>\returns the primitive mode that the mesh is using. </p>

</div>
</div>
<a id="a1bec31f880cf743c0f3f361b657350ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bec31f880cf743c0f3f361b657350ab">&nbsp;</a></span>getNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">N <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>\returns the normal at the index in the normals vector. </p>

</div>
</div>
<a id="ac21a4d0c6be7ec265b28293850965bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21a4d0c6be7ec265b28293850965bcb">&nbsp;</a></span>getNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; N &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Use this if you plan to change the normals as part of this call as it will force a reset of the cache. </p><dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the normals of the mesh, if it has any. </dd></dl>

</div>
</div>
<a id="a198400c0d6e5e2d2e8423af539379641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198400c0d6e5e2d2e8423af539379641">&nbsp;</a></span>getNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; N &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the normals of the mesh, if it has any. (read only) </dd></dl>

</div>
</div>
<a id="ac9e2ab92a49ed8492c0ab55f81d761b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e2ab92a49ed8492c0ab55f81d761b2">&nbsp;</a></span>getNormalsPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">N * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNormalsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the normals that the mesh contains. </dd></dl>

</div>
</div>
<a id="a8dab2b9cf5f743e38d848e3940f7c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dab2b9cf5f743e38d848e3940f7c732">&nbsp;</a></span>getNormalsPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const N * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNormalsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the normals that the mesh contains. </dd></dl>

</div>
</div>
<a id="aa921d88cf8172d40e8e41fc3e9df3147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa921d88cf8172d40e8e41fc3e9df3147">&nbsp;</a></span>getNumColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNumColors</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the colors vector for the mesh. This will tell you how many colors are contained in the mesh. </dd></dl>

</div>
</div>
<a id="a94f31c02ff4139d8cb4e543cbb148420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f31c02ff4139d8cb4e543cbb148420">&nbsp;</a></span>getNumIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNumIndices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This will tell you how many indices are contained in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the indices vector for the mesh. </dd></dl>

</div>
</div>
<a id="a4355ccbe359c368da268f6c065eecf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4355ccbe359c368da268f6c065eecf56">&nbsp;</a></span>getNumNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNumNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This will tell you how many normals are contained in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the normals vector for the mesh. </dd></dl>

</div>
</div>
<a id="a81b72d407eaf60f1df9b6aee8913e165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b72d407eaf60f1df9b6aee8913e165">&nbsp;</a></span>getNumTexCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNumTexCoords</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This will tell you how many texture coordinates are contained in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the texture coordinates vector for the mesh. </dd></dl>

</div>
</div>
<a id="a08a667f68d358d304119c33d9bd1ac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a667f68d358d304119c33d9bd1ac5a">&nbsp;</a></span>getNumVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getNumVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the vertices vector for the mesh. This will tell you how many vertices are contained in the mesh. </dd></dl>

</div>
</div>
<a id="aa9fbb7b426591f99cc332dca02bbee77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fbb7b426591f99cc332dca02bbee77">&nbsp;</a></span>getTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getTexCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Vec2f representing the texture coordinate. Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates. </dd></dl>

</div>
</div>
<a id="ae7beaa9ae4ec2a533c948ba341288e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7beaa9ae4ec2a533c948ba341288e7f">&nbsp;</a></span>getTexCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; T &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getTexCoords</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get a vector representing the texture coordinates of the mesh Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates. Use this if you plan to change the texture coordinates as part of this call as it will force a reset of the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of Vec2f representing the texture coordinates for the whole mesh. </dd></dl>

</div>
</div>
<a id="a521b68abfe5864f5f0d57c5f76b0fdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521b68abfe5864f5f0d57c5f76b0fdd2">&nbsp;</a></span>getTexCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getTexCoords</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates. </p><dl class="section return"><dt>Returns</dt><dd>a vector of Vec2f representing the texture coordinates for the whole mesh. (read only) </dd></dl>

</div>
</div>
<a id="a1ebe21b66f36a7a706b34cae522909a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebe21b66f36a7a706b34cae522909a1">&nbsp;</a></span>getTexCoordsPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getTexCoordsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the texture coords that the mesh contains. </dd></dl>

</div>
</div>
<a id="a4235e0cb978e0c8d589b2dee5d326623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235e0cb978e0c8d589b2dee5d326623">&nbsp;</a></span>getTexCoordsPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const T * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getTexCoordsPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get a pointer to the <a class="el" href="classof_vec2f.html" title="ofVec2f is a class for storing a two dimensional vector.">ofVec2f</a> texture coordinates that the mesh contains. </p>

</div>
</div>
<a id="a885903c31c3a061447dad2f4df4921a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885903c31c3a061447dad2f4df4921a2">&nbsp;</a></span>getUniqueFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt; &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getUniqueFaces</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the mesh as a vector of unique ofMeshFace_s a list of triangles that do not share vertices or indices </dd></dl>

</div>
</div>
<a id="a96e7c2f3fa6fa821c8f32e0cef4a1ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e7c2f3fa6fa821c8f32e0cef4a1ca7">&nbsp;</a></span>getVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">V <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vertex at the index. </dd></dl>

</div>
</div>
<a id="a9a9943fbc47aa77ee3c777a1152df34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9943fbc47aa77ee3c777a1152df34d">&nbsp;</a></span>getVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; V &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the vertices of the mesh. </dd></dl>

</div>
</div>
<a id="a6e1a0c348db4521ae77f313c42671ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1a0c348db4521ae77f313c42671ae3">&nbsp;</a></span>getVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const std::vector&lt; V &gt; &amp; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector that contains all of the vertices of the mesh. </dd></dl>

</div>
</div>
<a id="a672de1fd17348248e1480e3a17c12335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672de1fd17348248e1480e3a17c12335">&nbsp;</a></span>getVerticesPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">V * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getVerticesPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the vertices that the mesh contains. </dd></dl>

</div>
</div>
<a id="af028a8dc0b424704a5ce1dd01b0db4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af028a8dc0b424704a5ce1dd01b0db4fe">&nbsp;</a></span>getVerticesPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">const V * <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::getVerticesPointer</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the vertices that the mesh contains. </dd></dl>

</div>
</div>
<a id="a592e8aeae8f0473cc35e5662cd757378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592e8aeae8f0473cc35e5662cd757378">&nbsp;</a></span>hasColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::hasColors</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>/returns Whether the mesh has any colors. </p>

</div>
</div>
<a id="a2ae8973fffdc6380357ee10334d35164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae8973fffdc6380357ee10334d35164">&nbsp;</a></span>hasIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::hasIndices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>/returns Whether the mesh has any indices assigned to it. </p>

</div>
</div>
<a id="a53dda7b405ca169ae53a7d6922fc9f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dda7b405ca169ae53a7d6922fc9f91">&nbsp;</a></span>hasNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::hasNormals</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>/returnsWhether the mesh has any normals. </p>

</div>
</div>
<a id="a30e928ba824858616b319a46fcb1ce35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e928ba824858616b319a46fcb1ce35">&nbsp;</a></span>hasTexCoords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::hasTexCoords</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>/returns Whether the mesh has any textures assigned to it. </p>

</div>
</div>
<a id="aa224945f6e629dd45912b2d9368fddf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa224945f6e629dd45912b2d9368fddf0">&nbsp;</a></span>hasVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::hasVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the mesh has any vertices. </dd></dl>

</div>
</div>
<a id="a402415e2269de5bae1ea093482a23310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402415e2269de5bae1ea093482a23310">&nbsp;</a></span>haveColorsChanged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::haveColorsChanged</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>If the colors of the mesh have changed, been added or removed. </dd></dl>

</div>
</div>
<a id="ae79119cec73b47e67c7b5b13156291cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79119cec73b47e67c7b5b13156291cb">&nbsp;</a></span>haveIndicesChanged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::haveIndicesChanged</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>If the indices of the mesh have changed, been added or removed. </dd></dl>

</div>
</div>
<a id="ad0f34d06dd1e215610d868abc2357a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f34d06dd1e215610d868abc2357a48">&nbsp;</a></span>haveNormalsChanged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::haveNormalsChanged</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>If the normals of the mesh have changed, been added or removed. </dd></dl>

</div>
</div>
<a id="a6a99f33c4ea99cda4c7e186a09e078d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a99f33c4ea99cda4c7e186a09e078d6">&nbsp;</a></span>haveTexCoordsChanged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::haveTexCoordsChanged</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>If the texture coords of the mesh have changed, been added or removed. </dd></dl>

</div>
</div>
<a id="a4e2780a560431d8bb36272a19c2c0514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2780a560431d8bb36272a19c2c0514">&nbsp;</a></span>haveVertsChanged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::haveVertsChanged</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>If the vertices of the mesh have changed, been added or removed. </dd></dl>

</div>
</div>
<a id="aa9b4d1199f717c378856fab760eacad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b4d1199f717c378856fab760eacad8">&nbsp;</a></span>icosahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::icosahedron </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="adb8318a1d79b61f282a697a28d438e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8318a1d79b61f282a697a28d438e3b">&nbsp;</a></span>icosphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::icosphere </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>iterations</em> = <code>2</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<p>Step 1 : Generate icosahedron</p>
<p>Step 2 : tessellate</p>
<p>Step 3 : generate texcoords</p>
<p>Step 4 : fix texcoords</p>

</div>
</div>
<a id="a707313f4d739d5c0a2b1f354c4ec18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707313f4d739d5c0a2b1f354c4ec18be">&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&nbsp;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Loads a mesh from a file located at the provided path into the mesh. This will replace any existing data within the mesh. </p>
<p>It expects that the file will be in the <a href="http://en.wikipedia.org/wiki/PLY_(file_format)">PLY Format</a>. It will only load meshes saved in the PLY ASCII format; the binary format is not supported. </p>
<p>flag to distinguish between uchar (more common) and float (less common) color format in ply file</p>

</div>
</div>
<a id="a59910722bd457565b4568fc4244374c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59910722bd457565b4568fc4244374c4">&nbsp;</a></span>mergeDuplicateVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::mergeDuplicateVertices</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a410b09e5fd20b01bd2892a0491fc7ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410b09e5fd20b01bd2892a0491fc7ecf">&nbsp;</a></span>plane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::plane </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>columns</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>rows</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="abed864b1d2509c6a717828b207bd7617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed864b1d2509c6a717828b207bd7617">&nbsp;</a></span>removeColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::removeColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove a color at the index in the colors vector. </p>

</div>
</div>
<a id="ac7e43d2abd33b0a6bdb019174e49097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e43d2abd33b0a6bdb019174e49097b">&nbsp;</a></span>removeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::removeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Removes an index. </p>

</div>
</div>
<a id="a2e538d931278c2a85af965db23817776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e538d931278c2a85af965db23817776">&nbsp;</a></span>removeNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::removeNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove a normal. </p>

</div>
</div>
<a id="a8bd2dda59067556553a0a4c0add8df55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd2dda59067556553a0a4c0add8df55">&nbsp;</a></span>removeTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::removeTexCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove a Vec2f representing the texture coordinate. </p>

</div>
</div>
<a id="a94821aafdb3d39c20097742114ac6252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94821aafdb3d39c20097742114ac6252">&nbsp;</a></span>removeVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::removeVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Removes the vertex at the index in the vector. </p>

</div>
</div>
<a id="aed2fbf7555c7a275c42b36fbcda6fde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2fbf7555c7a275c42b36fbcda6fde6">&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&nbsp;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>useBinary</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Saves the mesh at the passed path in the <a href="http://en.wikipedia.org/wiki/PLY_(file_format)">PLY Format</a>. </p>
<p>There are two format options for PLY: a binary format and an ASCII format. By default, it will save using the ASCII format. Passing <code>true</code> into the <code>useBinary</code> parameter will save it in the binary format.</p>
<p>If you&#39;re planning on reloading the mesh into ofMesh, ofMesh currently only supports loading the ASCII format.</p>
<p>For more information, see the <a href="http://paulbourke.net/dataformats/ply/">PLY format specification</a>. </p>

</div>
</div>
<a id="a83304aa16a2ba34781864966e535aa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83304aa16a2ba34781864966e535aa93">&nbsp;</a></span>setColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"><em>c</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Set the color at the index in the colors vector. </p>

</div>
</div>
<a id="a031e6a96eccbe314d2279dd009ce2f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e6a96eccbe314d2279dd009ce2f99">&nbsp;</a></span>setColorForIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setColorForIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&nbsp;</td>
          <td class="paramname"><em>color</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d81b2924ae705979a81d6efc6af0fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d81b2924ae705979a81d6efc6af0fa6">&nbsp;</a></span>setFromTriangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setFromTriangles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classof_mesh_face__.html">ofMeshFace_</a>&lt; V, N, C, T &gt;&gt; &amp;&nbsp;</td>
          <td class="paramname"><em>tris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>bUseFaceNormal</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a40431a7678900b79af0903122ec76e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40431a7678900b79af0903122ec76e5c">&nbsp;</a></span>setIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>val</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This sets the index at i. </p>

</div>
</div>
<a id="a127eade588093f14bfe8a714ab819049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127eade588093f14bfe8a714ab819049">&nbsp;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Allows you to set the ofPrimitiveMode. The available modes are OF_PRIMITIVE_TRIANGLES, OF_PRIMITIVE_TRIANGLE_STRIP, OF_PRIMITIVE_TRIANGLE_FAN, OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP, OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS. </p>

</div>
</div>
<a id="adf3e5ab3016e8b4d190062a0ebe28e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3e5ab3016e8b4d190062a0ebe28e95">&nbsp;</a></span>setNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&nbsp;</td>
          <td class="paramname"><em>n</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="dashingAutolink" name="autolink-199"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/Todo%3A"></a><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Documentation. </dd></dl>

</div>
</div>
<a id="ad7ca0664fbf59a1c1d9813c72e0e25eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ca0664fbf59a1c1d9813c72e0e25eb">&nbsp;</a></span>setTexCoord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setTexCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"><em>t</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d2a8a6ee700a42663c7cc56daa88e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2a8a6ee700a42663c7cc56daa88e6e">&nbsp;</a></span>setupIndicesAuto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setupIndicesAuto</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Allow you to set up the indices automatically when you add a vertex. </p>

</div>
</div>
<a id="ac14eba193f79cdb668e1b26251607971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14eba193f79cdb668e1b26251607971">&nbsp;</a></span>setVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::setVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="of_constants_8h.html#ad4acc3774c730c65a67b4419154717d3">ofIndexType</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&nbsp;</td>
          <td class="paramname"><em>v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a7c1471ebe767c5dfe094d2e2018330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7c1471ebe767c5dfe094d2e2018330">&nbsp;</a></span>smoothNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::smoothNormals </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a2380ed62ef45a236e2804f269645af53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2380ed62ef45a236e2804f269645af53">&nbsp;</a></span>sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt; <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::sphere </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>res</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0">ofPrimitiveMode</a>&nbsp;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="of_graphics_constants_8h.html#a0f71f0b23a18629a446952d5540e16e0a5799605679284702ca188191180c44c6">OF_PRIMITIVE_TRIANGLE_STRIP</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8d4a9231c090c54d0d52189003660b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d4a9231c090c54d0d52189003660b">&nbsp;</a></span>usingColors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::usingColors</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#aea177b97985a419dd987079b4e4fb7be">ofVboMesh</a>.</p>

</div>
</div>
<a id="af6a6ad647e073aa833b9c59d2156dea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a6ad647e073aa833b9c59d2156dea5">&nbsp;</a></span>usingIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::usingIndices</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#afd906de1d77c27152faef325f2d50906">ofVboMesh</a>.</p>

</div>
</div>
<a id="a367f2735ce6af1ed6eb8379228c97f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367f2735ce6af1ed6eb8379228c97f84">&nbsp;</a></span>usingNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::usingNormals</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a16151f46e17e711f0d910d4514f91da6">ofVboMesh</a>.</p>

</div>
</div>
<a id="a990c2c7465f15cb2742e769a97ddb0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990c2c7465f15cb2742e769a97ddb0bd">&nbsp;</a></span>usingTextures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class N , class C , class T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_mesh__.html">ofMesh_</a>&lt; V, N, C, T &gt;::usingTextures</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classof_vbo_mesh.html#a25255c6294a7d6590489d1a0df746f82">ofVboMesh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/anotherenergy/oF/libs/openFrameworks/3d/<a class="el" href="of_mesh_8h_source.html">ofMesh.h</a></li>
<li>/Users/anotherenergy/oF/libs/openFrameworks/3d/<a class="el" href="of_mesh_8inl.html">ofMesh.inl</a></li>
</ul>
</div><!-- contents -->

            </div>
      </div>
      <div id="footer">
        <a href="http://openframeworks.cc/">openFrameworks</a> Documentation, generated by Doxygen.
      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  

</body></html>