
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The uWSGI cheaper subsystem – adaptive process spawning &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The uWSGI Emperor – multi-app deployment" href="Emperor.html" />
    <link rel="prev" title="The Chunked input API" href="Chunked.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Emperor.html" title="The uWSGI Emperor – multi-app deployment"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Chunked.html" title="The Chunked input API"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-uwsgi-cheaper-subsystem-adaptive-process-spawning">
<h1>The uWSGI cheaper subsystem – adaptive process spawning<a class="headerlink" href="#the-uwsgi-cheaper-subsystem-adaptive-process-spawning" title="Permalink to this headline">¶</a></h1>
<p>uWSGI provides the ability to dynamically scale the number of running workers
via pluggable algorithms.  Use <code class="docutils literal notranslate"><span class="pre">uwsgi</span> <span class="pre">--cheaper-algos-list</span></code> to get the list
of available algorithms.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>To enable cheaper mode add the <code class="docutils literal notranslate"><span class="pre">cheaper</span> <span class="pre">=</span> <span class="pre">N</span></code> option to the uWSGI
configuration file, where N is the minimum number of workers uWSGI can run. The
<code class="docutils literal notranslate"><span class="pre">cheaper</span></code> value must be lower than the maximum number of configured workers
(<code class="docutils literal notranslate"><span class="pre">workers</span></code> or <code class="docutils literal notranslate"><span class="pre">processes</span></code> option).</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># set cheaper algorithm to use, if not set default will be used</span>
<span class="na">cheaper-algo</span> <span class="o">=</span> <span class="s">spare</span>

<span class="c1"># minimum number of workers to keep at all times</span>
<span class="na">cheaper</span> <span class="o">=</span> <span class="s">2</span>

<span class="c1"># number of workers to spawn at startup</span>
<span class="na">cheaper-initial</span> <span class="o">=</span> <span class="s">5</span>

<span class="c1"># maximum number of workers that can be spawned</span>
<span class="na">workers</span> <span class="o">=</span> <span class="s">10</span>

<span class="c1"># how many workers should be spawned at a time</span>
<span class="na">cheaper-step</span> <span class="o">=</span> <span class="s">1</span>
</pre></div>
</div>
<p>This configuration will tell uWSGI to run up to 10 workers under load. If the
app is idle uWSGI will stop workers but it will always leave at least 2 of them
running.  With <code class="docutils literal notranslate"><span class="pre">cheaper-initial</span></code> you can control how many workers should be
spawned at startup. If your average load requires more than minimum number of
workers you can have them spawned right away and then “cheaped” (killed off) if
load is low enough.  When the cheaper algorithm decides that it needs more
workers it will spawn <code class="docutils literal notranslate"><span class="pre">cheaper-step</span></code> of them. This is useful if you have a
high maximum number of workers – in the event of a sudden load spike it would
otherwise take a lot of time to spawn enough workers one by one.</p>
<p>Note: Worker is notified by uWSGI before being cheaped. Worker should finish until
timeout is reached (this is configured by <code class="docutils literal notranslate"><span class="pre">worker-reload-mercy</span></code> configuration parameter).
Otherwise, uWSGI kills the worker. Killing worker in the middle of serving request can cause
errors or partial responses to the client.</p>
</div>
<div class="section" id="setting-memory-limits">
<h2>Setting memory limits<a class="headerlink" href="#setting-memory-limits" title="Permalink to this headline">¶</a></h2>
<p>Starting with 1.9.16 rss memory limits can be set to stop cheaper spawning
new workers if process count limit was not reached, but total sum of rss
memory used by all workers reached given limit.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># soft limit will prevent cheaper from spawning new workers</span>
<span class="c1"># if workers total rss memory is equal or higher</span>
<span class="c1"># we use 128MB soft limit below (values are in bytes)</span>
<span class="na">cheaper-rss-limit-soft</span> <span class="o">=</span> <span class="s">134217728</span>

<span class="c1"># hard limit will force cheaper to cheap single worker</span>
<span class="c1"># if workers total rss memory is equal or higher</span>
<span class="c1"># we use 160MB hard limit below (values are in bytes)</span>
<span class="na">cheaper-rss-limit-hard</span> <span class="o">=</span> <span class="s">167772160</span>
</pre></div>
</div>
<p>Notes:</p>
<ul class="simple">
<li><p>Hard limit is optional, soft limit alone can be used.</p></li>
<li><p>Hard value must be higher then soft value, both values shouldn’t be too close to each other.</p></li>
<li><p>Hard value should be soft + at least average worker memory usage for given app.</p></li>
<li><p>Soft value is the limiter for cheaper, it won’t spawn more workers, but already running workers
memory usage might grow, to handle that reload-on-rss can be set too. To set unbreakable barrier
for app memory usage cgroups are recommended.</p></li>
</ul>
</div>
<div class="section" id="spare-cheaper-algorithm">
<h2><code class="docutils literal notranslate"><span class="pre">spare</span></code> cheaper algorithm<a class="headerlink" href="#spare-cheaper-algorithm" title="Permalink to this headline">¶</a></h2>
<p>This is the default algorithm.  If all workers are busy for
<code class="docutils literal notranslate"><span class="pre">cheaper_overload</span></code> seconds then uWSGI will spawn new workers. When the load
is gone it will begin stopping processes one at a time.</p>
</div>
<div class="section" id="spare2-cheaper-algorithm">
<h2><code class="docutils literal notranslate"><span class="pre">spare2</span></code> cheaper algorithm<a class="headerlink" href="#spare2-cheaper-algorithm" title="Permalink to this headline">¶</a></h2>
<p>This algorithm is similar to spare, but suitable for large scale by increase workers faster and
decrease workers slower.</p>
<p>When number of idle workers is smaller than number specified by <code class="docutils literal notranslate"><span class="pre">cheaper</span></code>, it spawns (<code class="docutils literal notranslate"><span class="pre">cheaper</span></code> -
number of idle workers) workers.  Maximum workers spawned at once can be limited by <code class="docutils literal notranslate"><span class="pre">cheaper-step</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">cheaper</span></code> is 4, there are 2 idle workers and <code class="docutils literal notranslate"><span class="pre">cheaper-step</span></code> is 1, it spawns 1 worker.</p>
<p>When number of idle workers is larger than <code class="docutils literal notranslate"><span class="pre">cheaper</span></code>, it increments internal counter.
When number of idle workers is smaller than or equal to <code class="docutils literal notranslate"><span class="pre">cheaper</span></code>, reset the counter.
When the counter is equal to <code class="docutils literal notranslate"><span class="pre">cheaper-idle</span></code>, cheap one worker and reset the counter.</p>
<p>Sample configuration:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">workers</span> <span class="o">=</span> <span class="s">64          # maximum number of workers</span>

<span class="na">cheaper-algo</span> <span class="o">=</span> <span class="s">spare2</span>
<span class="na">cheaper</span> <span class="o">=</span> <span class="s">8           # tries to keep 8 idle workers</span>
<span class="na">cheaper-initial</span> <span class="o">=</span> <span class="s">8   # starts with minimal workers</span>
<span class="na">cheaper-step</span> <span class="o">=</span> <span class="s">4      # spawn at most 4 workers at once</span>
<span class="na">cheaper-idle</span> <span class="o">=</span> <span class="s">60     # cheap one worker per minute while idle</span>
</pre></div>
</div>
</div>
<div class="section" id="backlog-cheaper-algorithm">
<h2><code class="docutils literal notranslate"><span class="pre">backlog</span></code> cheaper algorithm<a class="headerlink" href="#backlog-cheaper-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">backlog</span></code> is only available on Linux and only on TCP sockets (not UNIX domain sockets).</p>
</div>
<p>If the socket’s listen queue has more than <code class="docutils literal notranslate"><span class="pre">cheaper_overload</span></code> requests
waiting to be processed, uWSGI will spawn new workers.  If the backlog is lower
it will begin killing processes one at a time.</p>
</div>
<div class="section" id="busyness-cheaper-algorithm">
<h2><code class="docutils literal notranslate"><span class="pre">busyness</span></code> cheaper algorithm<a class="headerlink" href="#busyness-cheaper-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This algorithm is optional, it is only available if the <code class="docutils literal notranslate"><span class="pre">cheaper_busyness</span></code> plugin is compiled and loaded.</p>
</div>
<p>This plugin implements an algorithm which adds or removes workers based on
average utilization for a given time period. It’s goal is to keep more workers
than the minimum needed available at any given time, so the app will always
have capacity for new requests. If you want to run only minimum number of
workers then use the spare or backlog algorithms.</p>
<p>This plugin primarily is used because the way spare and backlog plugins work
causes very aggressive scaling behavior. If you set a low <code class="docutils literal notranslate"><span class="pre">cheaper</span></code> value
(for example 1), then uWSGI will keep only 1 worker running and spawn new
workers only when that running worker is overloaded.  If an app requires more
workers, then uWSGI will be spawning and stopping workers all the time. Only
during times of very low load the would the minimum number of workers be
enough.</p>
<p>The Busyness algorithm tries to do the opposite: spawn as many workers as
needed and stop some of them only when there is a good chance that they are not
needed. This should lead to a more stable worker count and much less respawns.
Since for most of the time we have more worker capacity  than actually needed,
average application response times should be lower than with other plugins.</p>
<p>Options:</p>
<div class="section" id="cheaper-overload">
<h3>cheaper-overload<a class="headerlink" href="#cheaper-overload" title="Permalink to this headline">¶</a></h3>
<p>Specifies the window, in seconds, for tracking the average busyness of workers. Example:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">cheaper-overload</span> <span class="o">=</span> <span class="s">30</span>
</pre></div>
</div>
<p>This option will check busyness every 30 seconds. If during the last 30 seconds
all workers were running for 3 seconds and idle for the remaining 27 seconds
the calculated busyness will be 10% (3/30). This value will decide how fast
uWSGI can respond to load spikes. New workers will be spawned at most every
<code class="docutils literal notranslate"><span class="pre">cheaper-overload</span></code> seconds (unless you are running uWSGI on Linux – see
<code class="docutils literal notranslate"><span class="pre">cheaper-busyness-backlog-alert</span></code> for details).</p>
<p>If you want to react to load spikes faster, keep this value low so busyness is
calculated more often. Keep in mind this may cause workers to be
started/stopped more often than required since every minor spike may spawn new
workers. With a high <code class="docutils literal notranslate"><span class="pre">cheaper-overload</span></code> value the worker count will change
much less since longer cycles will eat all short spikes of load and extreme
values.
Default is 3, for busyness plugin it’s best to use higher value (10-30).</p>
</div>
<div class="section" id="cheaper-step">
<h3>cheaper-step<a class="headerlink" href="#cheaper-step" title="Permalink to this headline">¶</a></h3>
<p>How many workers to spawn when the algorithm decides they are needed. Default
is 1.</p>
</div>
<div class="section" id="cheaper-initial">
<h3>cheaper-initial<a class="headerlink" href="#cheaper-initial" title="Permalink to this headline">¶</a></h3>
<p>The number of workers to be started when starting the application. After the
app is started the algorithm can stop or start workers if needed.</p>
</div>
<div class="section" id="cheaper-busyness-max">
<h3>cheaper-busyness-max<a class="headerlink" href="#cheaper-busyness-max" title="Permalink to this headline">¶</a></h3>
<p>This is the maximum busyness we allow. Every time the calculated busyness for
last <code class="docutils literal notranslate"><span class="pre">cheaper-overload</span></code> seconds is higher than this value, uWSGI will spawn
<code class="docutils literal notranslate"><span class="pre">cheaper-step</span></code> new workers.  Default is 50.</p>
</div>
<div class="section" id="cheaper-busyness-min">
<h3>cheaper-busyness-min<a class="headerlink" href="#cheaper-busyness-min" title="Permalink to this headline">¶</a></h3>
<p>This is minimum busyness. If current busyness is below this value, the app is
considered as being in an “idle cycl” and uWSGI will start counting them. Once
we reach needed number of idle cycles uWSGI will kill one worker.  Default is
25.</p>
</div>
<div class="section" id="cheaper-busyness-multiplier">
<h3>cheaper-busyness-multiplier<a class="headerlink" href="#cheaper-busyness-multiplier" title="Permalink to this headline">¶</a></h3>
<p>This option tells uWSGI how many idle cycles we need before stopping a worker.
After reaching this limit uWSGI will stop a worker and reset this counter.</p>
<p>For example:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">cheaper-overload</span> <span class="o">=</span> <span class="s">10</span>
<span class="na">cheaper-busyness-multiplier</span> <span class="o">=</span> <span class="s">20</span>
<span class="na">cheaper-busyness-min</span> <span class="o">=</span> <span class="s">25</span>
</pre></div>
</div>
<p>If average worker busyness is under 25% for 20 checks in a row, executed every
10 seconds (total of 200 seconds), one worker will be stopped. The idle cycles
counter will be reset if average busyness jumps above <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-max</span></code>
and we spawn new workers. If during idle cycle counting the average busyness
jumps above <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-min</span></code> but still below <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-max</span></code>,
then the idle cycles counter is adjusted and we need to wait extra one idle
cycle. If during idle cycle counting the average busyness jumps above
<code class="docutils literal notranslate"><span class="pre">cheaper-busyness-min</span></code> but still below <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-max</span></code> three times
in a row, then the idle cycle counter is reset.</p>
</div>
<div class="section" id="cheaper-busyness-penalty">
<h3>cheaper-busyness-penalty<a class="headerlink" href="#cheaper-busyness-penalty" title="Permalink to this headline">¶</a></h3>
<p>uWSGI will automatically tune the number of idle cycles needed to stop worker
when worker is stopped due to enough idle cycles and then spawned back to fast
(less than the same time we need to cheap worker), then we will increment the
<code class="docutils literal notranslate"><span class="pre">cheaper-busyness-multiplier</span></code> value this value.  Default is 1.</p>
<p>Example:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">cheaper-overload</span> <span class="o">=</span> <span class="s">10</span>
<span class="na">cheaper-busyness-multiplier</span> <span class="o">=</span> <span class="s">20</span>
<span class="na">cheaper-busyness-min</span> <span class="o">=</span> <span class="s">25</span>
<span class="na">cheaper-busyness-penalty</span> <span class="o">=</span> <span class="s">2</span>
</pre></div>
</div>
<p>If average worker busyness is under 25% for 20 checks in a row, executed every
10 seconds (total 200 seconds), one worker will be stopped. If new worker is
spawned in less than 200 seconds (counting from the time when we spawned the
last worker before it), the <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-multiplier</span></code> value will be
incremented up to 22 (20+2). Now we will need to wait 220 seconds (22*10) to
cheap another worker.  This option is used to prevent workers from being
started and stopped all the time since once we stop one worker, busyness might
jump up enough to hit <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-max</span></code>. Without this, or if tuned
poorly, we can get into a stop/start feedback loop .</p>
</div>
<div class="section" id="cheaper-busyness-verbose">
<h3>cheaper-busyness-verbose<a class="headerlink" href="#cheaper-busyness-verbose" title="Permalink to this headline">¶</a></h3>
<p>This option enables debug logs from the <code class="docutils literal notranslate"><span class="pre">cheaper_busyness</span></code> plugin.</p>
</div>
<div class="section" id="cheaper-busyness-backlog-alert">
<h3>cheaper-busyness-backlog-alert<a class="headerlink" href="#cheaper-busyness-backlog-alert" title="Permalink to this headline">¶</a></h3>
<p>This option is only available on Linux. It is used to allow quick response to
load spikes even with high <code class="docutils literal notranslate"><span class="pre">cheaper-overload</span></code> values. On every uWSGI master
cycle (default 1 second) the current listen queue is checked. If it is higher
than this value, an emergency worker is spawned. When using this option it is
safe to use high <code class="docutils literal notranslate"><span class="pre">cheaper-overload</span></code> values to have smoother scaling of worker
count. Default is 33.</p>
</div>
<div class="section" id="cheaper-busyness-backlog-multiplier">
<h3>cheaper-busyness-backlog-multiplier<a class="headerlink" href="#cheaper-busyness-backlog-multiplier" title="Permalink to this headline">¶</a></h3>
<p>This option is only available on Linux. It works just like
<code class="docutils literal notranslate"><span class="pre">cheaper-busyness-multiplier</span></code>, except it is used only for emergency workers
spawned when listen queue was higher than <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-backlog-alert</span></code>.</p>
<p>Emergency workers are spawned in case of big load spike to prevent currently
running workers from being overloaded. Sometimes load spike are random and
short which can spawn a lot of emergency workers. In such cases we would need
to wait several cycles before reaping those workers. This provides an alternate
multiplier to reap these processes faster.  Default is 3.</p>
</div>
<div class="section" id="cheaper-busyness-backlog-step">
<h3>cheaper-busyness-backlog-step<a class="headerlink" href="#cheaper-busyness-backlog-step" title="Permalink to this headline">¶</a></h3>
<p>This option is only available on Linux. It sets the number of emergency workers
spawned when listen queue is higher than <code class="docutils literal notranslate"><span class="pre">cheaper-busyness-backlog-alert</span></code>.
Defaults to 1.</p>
</div>
<div class="section" id="cheaper-busyness-backlog-nonzero">
<h3>cheaper-busyness-backlog-nonzero<a class="headerlink" href="#cheaper-busyness-backlog-nonzero" title="Permalink to this headline">¶</a></h3>
<p>This option is only available on Linux. It will spawn new emergency workers if
the request listen queue is &gt; 0 for more than N seconds.  It is used to protect
the server from the corner case where there is only a single worker running and
the worker is handling a long running request. If uWSGI receives new requests
they would stay in the request queue until that long running request is
completed. With this option we can detect such a condition and spawn new worker
to prevent queued requests from being timed out.  Default is 60.</p>
</div>
<div class="section" id="notes-regarding-busyness">
<h3>Notes regarding Busyness<a class="headerlink" href="#notes-regarding-busyness" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Experiment with settings, there is no one golden rule of what values should be used for everyone. Test and pick values that are best for you. Monitoring uWSGI stats (via Carbon, for instance) will make it easy to decide on good values.</p></li>
<li><p>Don’t expect busyness to be constant. it will change frequently. In the end, real users interact with your apps in very random way. It’s recommended to use longer –cheaper-overload values (&gt;=30) to have less spikes.</p></li>
<li><p>If you want to run some benchmarks with this plugin, you should use tools that add randomness to the work load</p></li>
<li><p>With a low number of workers (2-3) starting new worker or stopping one might affect busyness a lot, if You have 2 workers with busyness of 50%, than stopping one of them will increase busyness to 100%. Keep that in mind when picking min and max levels, with only few workers running most of the time max should be more than double of min, otherwise every time one worker is stopped it might increase busyness to above max level.</p></li>
<li><p>With a low number of workers (1-4) and default settings expect this plugin will keep average busyness below the minimum level; adjust levels to compensate for this.</p></li>
<li><p>With a higher number of workers required to handle load, worker count should stabilize somewhere near minimum busyness level, jumping a little bit around this value</p></li>
<li><p>When experimenting with this plugin it is advised to enable <code class="docutils literal notranslate"><span class="pre">--cheaper-busyness-verbose</span></code> to get an idea of what it is doing. An example log follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># These messages are logged at startup to show current settings</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">settings</span><span class="p">:</span> <span class="nb">min</span><span class="o">=</span><span class="mi">20</span><span class="o">%</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">60</span><span class="o">%</span><span class="p">,</span> <span class="n">overload</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">respawn</span> <span class="n">penalty</span><span class="o">=</span><span class="mi">3</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">backlog</span> <span class="n">alert</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">to</span> <span class="mi">33</span> <span class="n">request</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># With --cheaper-busyness-verbose enabled You can monitor calculated busyness</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">1</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">11</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">2</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">11</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">3</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">20</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">14</span><span class="o">%</span>

<span class="c1"># Average busyness is under 20%, we start counting idle cycles</span>
<span class="c1"># we have overload=20 and multiplier=15 so we need to wait 300 seconds before we can stop worker</span>
<span class="c1"># cycle we just had was counted as idle so we need to wait another 280 seconds</span>
<span class="c1"># 1 missing second below is just from rounding, master cycle is every 1 second but it also takes some time, this is normal</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">need</span> <span class="n">to</span> <span class="n">wait</span> <span class="mi">279</span> <span class="n">more</span> <span class="n">second</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">to</span> <span class="n">cheap</span> <span class="n">worker</span>

<span class="c1"># We waited long enough and we can stop one worker</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">1</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">6</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">2</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">22</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">3</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">19</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">15</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">15</span><span class="o">%</span><span class="p">,</span> <span class="n">cheap</span> <span class="n">one</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">running</span> <span class="n">workers</span>

<span class="c1"># After stopping one worker average busyness is now higher, which is no surprise</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">2</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">36</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">3</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">24</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">2</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">30</span><span class="o">%</span>
<span class="c1"># 30% is above our minimum (20%), but it&#39;s still far from our maximum (60%)</span>
<span class="c1"># since this is not idle cycle uWSGI will ignore it when counting when to stop worker</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">30</span><span class="o">%</span><span class="p">,</span> <span class="mi">1</span> <span class="n">non</span><span class="o">-</span><span class="n">idle</span> <span class="n">cycle</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">adjusting</span> <span class="n">cheaper</span> <span class="n">timer</span>

<span class="c1"># After a while our average busyness is still low enough, so we stop another worker</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">3</span><span class="o">%</span><span class="p">,</span> <span class="n">cheap</span> <span class="n">one</span> <span class="n">of</span> <span class="mi">2</span> <span class="n">running</span> <span class="n">workers</span>

<span class="c1"># With only one worker running we won&#39;t see per worker busyness since it&#39;s the same as total average</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">1</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">16</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">1</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">17</span><span class="o">%</span>

<span class="c1"># Shortly after stopping second worker and with only one running we have load spike that is enough to hit our maximum level</span>
<span class="c1"># this was just few cycles after stopping worker so uWSGI will increase multiplier</span>
<span class="c1"># now we need to wait extra 3 cycles before stopping worker</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">respawned</span> <span class="n">to</span> <span class="n">fast</span><span class="p">,</span> <span class="n">increasing</span> <span class="n">cheaper</span> <span class="n">multiplier</span> <span class="n">to</span> <span class="mi">18</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Initially we needed to wait only 300 seconds, now we need to have 360 subsequent seconds when workers busyness is below minimum level</span>
<span class="c1"># 10*20 + 3*20 = 360</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">1</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">9</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">2</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">17</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">3</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">17</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">worker</span> <span class="n">nr</span> <span class="mi">4</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">21</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="mi">20</span><span class="n">s</span> <span class="n">average</span> <span class="n">busyness</span> <span class="n">of</span> <span class="mi">4</span> <span class="n">worker</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">at</span> <span class="mi">16</span><span class="o">%</span>
<span class="p">[</span><span class="n">busyness</span><span class="p">]</span> <span class="n">need</span> <span class="n">to</span> <span class="n">wait</span> <span class="mi">339</span> <span class="n">more</span> <span class="n">second</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">to</span> <span class="n">cheap</span> <span class="n">worker</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The uWSGI cheaper subsystem – adaptive process spawning</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#setting-memory-limits">Setting memory limits</a></li>
<li><a class="reference internal" href="#spare-cheaper-algorithm"><code class="docutils literal notranslate"><span class="pre">spare</span></code> cheaper algorithm</a></li>
<li><a class="reference internal" href="#spare2-cheaper-algorithm"><code class="docutils literal notranslate"><span class="pre">spare2</span></code> cheaper algorithm</a></li>
<li><a class="reference internal" href="#backlog-cheaper-algorithm"><code class="docutils literal notranslate"><span class="pre">backlog</span></code> cheaper algorithm</a></li>
<li><a class="reference internal" href="#busyness-cheaper-algorithm"><code class="docutils literal notranslate"><span class="pre">busyness</span></code> cheaper algorithm</a><ul>
<li><a class="reference internal" href="#cheaper-overload">cheaper-overload</a></li>
<li><a class="reference internal" href="#cheaper-step">cheaper-step</a></li>
<li><a class="reference internal" href="#cheaper-initial">cheaper-initial</a></li>
<li><a class="reference internal" href="#cheaper-busyness-max">cheaper-busyness-max</a></li>
<li><a class="reference internal" href="#cheaper-busyness-min">cheaper-busyness-min</a></li>
<li><a class="reference internal" href="#cheaper-busyness-multiplier">cheaper-busyness-multiplier</a></li>
<li><a class="reference internal" href="#cheaper-busyness-penalty">cheaper-busyness-penalty</a></li>
<li><a class="reference internal" href="#cheaper-busyness-verbose">cheaper-busyness-verbose</a></li>
<li><a class="reference internal" href="#cheaper-busyness-backlog-alert">cheaper-busyness-backlog-alert</a></li>
<li><a class="reference internal" href="#cheaper-busyness-backlog-multiplier">cheaper-busyness-backlog-multiplier</a></li>
<li><a class="reference internal" href="#cheaper-busyness-backlog-step">cheaper-busyness-backlog-step</a></li>
<li><a class="reference internal" href="#cheaper-busyness-backlog-nonzero">cheaper-busyness-backlog-nonzero</a></li>
<li><a class="reference internal" href="#notes-regarding-busyness">Notes regarding Busyness</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Chunked.html"
                        title="previous chapter">The Chunked input API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Emperor.html"
                        title="next chapter">The uWSGI Emperor – multi-app deployment</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Cheaper.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Emperor.html" title="The uWSGI Emperor – multi-app deployment"
             >next</a> |</li>
        <li class="right" >
          <a href="Chunked.html" title="The Chunked input API"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>