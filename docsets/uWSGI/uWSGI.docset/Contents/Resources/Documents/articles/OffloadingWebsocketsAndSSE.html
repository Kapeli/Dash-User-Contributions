
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Offloading Websockets and Server-Sent Events AKA “Combine them with Django safely” &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="WSGI env behaviour policies" href="WSGIEnvBehaviour.html" />
    <link rel="prev" title="Fun with Perl, Eyetoy and RaspberryPi" href="FunWithPerlEyetoyRaspberrypi.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="WSGIEnvBehaviour.html" title="WSGI env behaviour policies"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="FunWithPerlEyetoyRaspberrypi.html" title="Fun with Perl, Eyetoy and RaspberryPi"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="offloading-websockets-and-server-sent-events-aka-combine-them-with-django-safely">
<h1>Offloading Websockets and Server-Sent Events AKA “Combine them with Django safely”<a class="headerlink" href="#offloading-websockets-and-server-sent-events-aka-combine-them-with-django-safely" title="Permalink to this headline">¶</a></h1>
<p>Author: Roberto De Ioris</p>
<p>Date: 20140315</p>
<div class="section" id="disclaimer">
<h2>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this headline">¶</a></h2>
<p>This article shows a pretty advanced way for combining websockets (or sse) apps with Django in a “safe way”. It will not show you
how cool websockets and sse are, or how to write better apps with them, it is an attempt to try to avoid bad practices with them.</p>
<p>In my opinion the Python web-oriented world is facing a communication/marketing problem: There is a huge number of people
running heavily blocking apps (like Django) on non-blocking technologies (like gevent) only because someone told them it is cool and will solve all of their scaling issues.</p>
<p>This is completely WRONG, DANGEROUS and EVIL, you cannot mix blocking apps with non-blocking engines, even a single, ultra-tiny blocking part
can potentially destroy your whole stack. As I have already said dozens of time, if your app is 99.9999999% non-blocking, it is still blocking.</p>
<p>And no, monkey-patching on your Django app is not magic. Unless you are using pretty-customized database adapters, tuned for working in a non-blocking way, you are doing it wrong.</p>
<p>At the cost of looking a huber-asshole, I strongly suggest you completely ignore people suggesting you move your Django app to gevent, eventlet, tornado or whatever, without warning you about
the hundreds of problems you may encounter.</p>
<p>Having said that, I love gevent, it is probably the best (with perl’s Coro::AnyEvent) supported loop engine in the uWSGI project. So in this article I will use gevent for managing websocket/sse traffic and plain multiprocessing for the Django part.</p>
<p>If this last sentence looks like nonsense to you, you probably do not know what uWSGI offloading is…</p>
</div>
<div class="section" id="uwsgi-offloading">
<h2>uWSGI offloading<a class="headerlink" href="#uwsgi-offloading" title="Permalink to this headline">¶</a></h2>
<p>The concept is not a new thing, or a uWSGI specific one. Projects like nodejs or twisted have used it for ages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>an example of a webapp serving a static file is not very interesting, nor the best thing to show, but will be useful later, when presenting a real-world scenario with X-Sendfile</p>
</div>
<p>Immagine this simple WSGI app:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/services&#39;</span><span class="p">)</span>
    <span class="c1"># do not do it, if the file is 4GB it will allocate 4GB of memory !!!</span>
    <span class="k">yield</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>This will simply return the content of /etc/services. It is a pretty tiny file, so in few milliseconds your process will be ready to process another request.</p>
<p>What if /etc/services is 4 gigabytes? Your process (or thread) will be blocked for several seconds (even minutes), and will not be able to manage another request
until the file is completely transferred.</p>
<p>Wouldn’t it be cool if you could tell another thread to send the file for you, so you will be able to manage another request?</p>
<p>Offloading is exactly this: it will give you one ore more threads for doing simple and slow task for you. Which kind of tasks? All of those that can be managed
in a non-blocking way, so a single thread can manage thousand of transfers for you.</p>
<p>You can see it as the DMA engine in your computer, your CPU will program the DMA to transfer memory from a controller to the RAM, and then will be freed to accomplish another task while the DMA works in background.</p>
<p>To enable offloading in uWSGI you only need to add the <code class="docutils literal notranslate"><span class="pre">--offload-threads</span> <span class="pre">&lt;n&gt;</span></code> option, where &lt;n&gt; is the number of threads per-process to spawn. (generally a single thread will be more than enough, but if you want to use/abuse your multiple cpu cores feel free to increase it)</p>
<p>Once offloading is enabled, uWSGI will automatically use it whenever it detects that an operation can be offloaded safely.</p>
<p>In the python/WSGI case any use of wsgi.file_wrapper will be offloaded automatically, as well as when you use the uWSGI proxy features for passing requests to other server speaking the uwsgi or HTTP protocol.</p>
<p>A cool example (showed even in the Snippets page of uWSGI docs) is implementing an offload-powered X-Sendfile feature:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">; load router_static plugin (compiled in by default in monolithic profiles)</span>
<span class="na">plugins</span> <span class="o">=</span> <span class="s">router_static</span>

<span class="c1">; spawn 2 offload threads</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>

<span class="c1">; files under /etc can be safely served (DANGEROUS !!!)</span>
<span class="na">static-safe</span> <span class="o">=</span> <span class="s">/etc</span>

<span class="c1">; collect the X-Sendfile response header as X_SENDFILE var</span>
<span class="na">collect-header</span> <span class="o">=</span> <span class="s">X-Sendfile X_SENDFILE</span>

<span class="c1">; if X_SENDFILE is not empty, pass its value to the &quot;static&quot; routing action (it will automatically use offloading if available)</span>
<span class="na">response-route-if-not</span> <span class="o">=</span> <span class="s">empty:${X_SENDFILE} static:${X_SENDFILE}</span>

<span class="c1">; now the classic options</span>
<span class="na">plugins</span> <span class="o">=</span> <span class="s">python</span>
<span class="c1">; bind to HTTP port 8080</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:8080</span>
<span class="c1">; load a simple wsgi-app</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">myapp.py</span>
</pre></div>
</div>
<p>Now in our app we can X-Sendfile to send static files without blocking:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,[(</span><span class="s1">&#39;X-Sendfile&#39;</span><span class="p">,</span><span class="s1">&#39;/etc/services&#39;</span><span class="p">)])</span>
    <span class="k">return</span> <span class="p">[]</span>
</pre></div>
</div>
<p>A very similar concept will be used in this article: We will use a normal Django to setup our session, to authorize the user and whatever (that is fast) you want, then we will return a special header that will instruct uWSGI to offload the connection to another uWSGI instance (listening on a private socket) that will manage the websocket/sse transaction using gevent in a non-blocking way.</p>
</div>
<div class="section" id="our-sse-app">
<h2>Our SSE app<a class="headerlink" href="#our-sse-app" title="Permalink to this headline">¶</a></h2>
<p>The SSE part will be very simple, a gevent-based WSGI app will send the current time every second:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sse</span> <span class="kn">import</span> <span class="n">Sse</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">e</span>
    <span class="c1"># create the SSE session</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">Sse</span><span class="p">()</span>
    <span class="c1"># prepare HTTP headers</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">headers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;text/event-stream&#39;</span><span class="p">))</span>
    <span class="n">headers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Cache-Control&#39;</span><span class="p">,</span><span class="s1">&#39;no-cache&#39;</span><span class="p">))</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
    <span class="c1"># enter the loop</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># monkey patching will prevent sleep() blocking</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># add the message</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add_message</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
        <span class="c1"># send to the client</span>
        <span class="k">yield</span> <span class="nb">str</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s run it on /tmp/foo UNIX socket (save the app as sseapp.py)</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --wsgi-file sseapp.py --socket /tmp/foo --gevent <span class="m">1000</span> --gevent-monkey-patch
</pre></div>
</div>
<p>(monkey patching is required for time.sleep(), feel free to use gevent primitives for sleeping if you want/prefer)</p>
</div>
<div class="section" id="the-boring-html-javascript">
<h2>The (boring) HTML/Javascript<a class="headerlink" href="#the-boring-html-javascript" title="Permalink to this headline">¶</a></h2>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Server sent events<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;event&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span><span class="p">&gt;</span>

      <span class="kd">var</span> <span class="nx">eventOutputContainer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;event&quot;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">evtSrc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventSource</span><span class="p">(</span><span class="s2">&quot;/subscribe&quot;</span><span class="p">);</span>

      <span class="nx">evtSrc</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="nx">eventOutputContainer</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
      <span class="p">};</span>

      <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>It is very simple, it will connect to /subscribe and will start waiting for events.</p>
</div>
<div class="section" id="the-django-view">
<h2>The Django view<a class="headerlink" href="#the-django-view" title="Permalink to this headline">¶</a></h2>
<p>Our django view, will be very simple, it will simply generate a special response header (we will call it X-Offload-to-SSE) with the username of the logged user as its value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">()</span>
    <span class="n">response</span><span class="p">[</span><span class="s1">&#39;X-Offload-to-SSE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>Now we are ready for the “advanced” part.</p>
</div>
<div class="section" id="let-s-offload-the-sse-transaction">
<h2>Let’s offload the SSE transaction<a class="headerlink" href="#let-s-offload-the-sse-transaction" title="Permalink to this headline">¶</a></h2>
<p>The configuration could look a bit complex but it is the same concept of the X-Sendfile seen before:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="c1">; collect X-Offload-to-SSE header and store in var X_OFFLOAD</span>
<span class="na">collect-header</span> <span class="o">=</span> <span class="s">X-Offload-to-SSE X_OFFLOAD</span>
<span class="c1">; if X_OFFLOAD is defined, do not send the headers generated by Django</span>
<span class="na">response-route-if-not</span> <span class="o">=</span> <span class="s">empty:${X_OFFLOAD} disableheaders:</span>
<span class="c1">; if X_OFFLOAD is defined, offload the request to the app running on /tmp/foo</span>
<span class="na">response-route-if-not</span> <span class="o">=</span> <span class="s">empty:${X_OFFLOAD} uwsgi:/tmp/foo,0,0</span>
</pre></div>
</div>
<p>The only “new’ part is the use of <code class="docutils literal notranslate"><span class="pre">disableheaders</span></code> routing action. It is required otherwise the headers generated by Django
will be sent along the ones generated by the gevent-based app.</p>
<p>You could avoid it (remember that <code class="docutils literal notranslate"><span class="pre">disableheaders</span></code> has been added only in 2.0.3) removing the call to start_response() in the gevent app (at the risk of being cursed by some WSGI-god) and changing the Django view
to set the right headers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">()</span>
    <span class="n">response</span><span class="p">[</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;text/event-stream&#39;</span>
    <span class="n">response</span><span class="p">[</span><span class="s1">&#39;X-Offload-to-SSE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>Eventually you may want to be more “streamlined” and simply detect for ‘text/event-stream’ content_type presence:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="c1">; collect Content-Type header and store in var CONTENT_TYPE</span>
<span class="na">collect-header</span> <span class="o">=</span> <span class="s">Content-Type CONTENT_TYPE</span>
<span class="c1">; if CONTENT_TYPE is &#39;text/event-stream&#39;, forward the request</span>
<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${CONTENT_TYPE};text/event-stream uwsgi:/tmp/foo,0,0</span>
</pre></div>
</div>
<p>Now, how to access the username of the Django-logged user in the gevent app?</p>
<p>You should have noted that the gevent-app prints the content of the WSGI environ on each request. That environment is the same
of the Django app + the collected headers. So accessing environ[‘X_OFFLOAD’] will return the logged username. (obviously in the second example, where the content type is used, the variable with the username is no longer collected, so you should fix it)</p>
<p>You can pass all of the information you need using the same approach, you can collect all of the vars you need and so on.</p>
<p>You can even add variables at runtime:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="c1">; collect Content-Type header and store in var CONTENT_TYPE</span>
<span class="na">collect-header</span> <span class="o">=</span> <span class="s">Content-Type CONTENT_TYPE</span>

<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${CONTENT_TYPE};text/event-stream addvar:FOO=BAR</span>
<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${CONTENT_TYPE};text/event-stream addvar:TEST1=TEST2</span>

<span class="c1">; if CONTENT_TYPE is &#39;text/event-stream&#39;, forward the request</span>
<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${CONTENT_TYPE};text/event-stream uwsgi:/tmp/foo,0,0</span>
</pre></div>
</div>
<p>Or (using goto for better readability):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="c1">; collect Content-Type header and store in var CONTENT_TYPE</span>
<span class="na">collect-header</span> <span class="o">=</span> <span class="s">Content-Type CONTENT_TYPE</span>

<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${CONTENT_TYPE};text/event-stream goto:offload</span>
<span class="na">response-route-run</span> <span class="o">=</span> <span class="s">last:</span>

<span class="na">response-route-label</span> <span class="o">=</span> <span class="s">offload</span>
<span class="na">response-route-run</span> <span class="o">=</span> <span class="s">addvar:FOO=BAR</span>
<span class="na">response-route-run</span> <span class="o">=</span> <span class="s">addvar:TEST1=TEST2</span>
<span class="na">response-route-run</span> <span class="o">=</span> <span class="s">uwsgi:/tmp/foo,0,0</span>
</pre></div>
</div>
</div>
<div class="section" id="simplifying-things-using-the-uwsgi-api-uwsgi-2-0-3">
<h2>Simplifying things using the uwsgi api (&gt;= uWSGI 2.0.3)<a class="headerlink" href="#simplifying-things-using-the-uwsgi-api-uwsgi-2-0-3" title="Permalink to this headline">¶</a></h2>
<p>While dealing with headers is pretty HTTP friendly, uWSGI 2.0.3 added the possibility to define per-request variables
directly in your code.</p>
<p>This allows a more “elegant” approach (even if highly non-portable):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uwsgi</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;LOGGED_IN_USER&quot;</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;USER_IS_UGLY&quot;</span><span class="p">,</span> <span class="s2">&quot;probably&quot;</span><span class="p">)</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;OFFLOAD_TO_SSE&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;OFFLOAD_SERVER&quot;</span><span class="p">,</span> <span class="s2">&quot;/tmp/foo&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">()</span>
</pre></div>
</div>
<p>Now the config can change to something more gentle:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="c1">; if OFFLOAD_TO_SSE is &#39;y&#39;, do not send the headers generated by Django</span>
<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${OFFLOAD_TO_SSE};y disableheaders:</span>
<span class="c1">; if OFFLOAD_TO_SSE is &#39;y&#39;, offload the request to the app running on &#39;OFFLOAD_SERVER&#39;</span>
<span class="na">response-route-if</span> <span class="o">=</span> <span class="s">equal:${OFFLOAD_TO_SSE};y uwsgi:${OFFLOAD_SERVER},0,0</span>
</pre></div>
</div>
<p>Have you noted how we allowed the Django app to set the backend server to use using a request variable?</p>
<p>Now we can go even further. We will not use the routing framework (except for disabling headers generation):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uwsgi</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;LOGGED_IN_USER&quot;</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="s2">&quot;USER_IS_UGLY&quot;</span><span class="p">,</span> <span class="s2">&quot;probably&quot;</span><span class="p">)</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;uwsgi&quot;</span><span class="p">,</span> <span class="s2">&quot;/tmp/foo,0,0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">()</span>
</pre></div>
</div>
<p>and a simple:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1">; the boring part</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:9090</span>
<span class="na">offload-threads</span> <span class="o">=</span> <span class="s">2</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">sseproject/wsgi.py</span>

<span class="na">response-route</span> <span class="o">=</span> <span class="s">^/subscribe disableheaders:</span>
</pre></div>
</div>
</div>
<div class="section" id="what-about-websockets">
<h2>What about Websockets ?<a class="headerlink" href="#what-about-websockets" title="Permalink to this headline">¶</a></h2>
<p>We have seen how to offload SSE (that are mono-directional). We can offload websockets too (that are bidirectional).</p>
<p>The concept is the same, you only need to ensure (as before) that no headers are sent by django, (otherwise the websocket handshake will fail) and then you
can change your gevent app:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">uwsgi</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">e</span>
    <span class="n">uwsgi</span><span class="o">.</span><span class="n">websocket_handshake</span><span class="p">()</span>
    <span class="c1"># enter the loop</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># monkey patching will prevent sleep() to block</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># send to the client</span>
        <span class="n">uwsgi</span><span class="o">.</span><span class="n">websocket_send</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="section" id="using-redis-or-uwsgi-caching-framework">
<h2>Using redis or uWSGI caching framework<a class="headerlink" href="#using-redis-or-uwsgi-caching-framework" title="Permalink to this headline">¶</a></h2>
<p>Request vars are handy (and funny), but they are limited (see below). If you need to pass a big amount of data between Django and the sse/websocket app, Redis
is a great way (and works perfectly with gevent). Basically you store infos from django to redis and than you pass only the hash key (via request vars) to the sse/websocket app.</p>
<p>The same can be accomplished with the uWSGI caching framework, but take into account redis has a lot of data primitives, while uWSGI only supports key-&gt;value items.</p>
</div>
<div class="section" id="common-pitfalls">
<h2>Common pitfalls<a class="headerlink" href="#common-pitfalls" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The amount of variables you can add per-request is limited by the uwsgi packet buffer (default 4k). You can increase it up to 64k with the –buffer-size option.</p></li>
<li><p>This is the whole point of this article: do not use the Django ORM in your gevent apps unless you know what you are doing!!! (read: you have a django database adapter that supports gevent and does not suck compared to the standard ones…)</p></li>
<li><p>Forget about finding a way to disable headers generation in django. This is a “limit/feature” of its WSGI adapter, use the uWSGI facilities (if available) or do not generate headers in your gevent app. Eventually you can modify wsgi.py in this way:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">WSGI config for sseproject project.</span>

<span class="sd">It exposes the WSGI callable as a module-level variable named ``application``.</span>

<span class="sd">For more information on this file, see</span>
<span class="sd">https://docs.djangoproject.com/en/1.6/howto/deployment/wsgi/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;DJANGO_SETTINGS_MODULE&quot;</span><span class="p">,</span> <span class="s2">&quot;sseproject.settings&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">django.core.wsgi</span> <span class="kn">import</span> <span class="n">get_wsgi_application</span>
<span class="n">django_application</span> <span class="o">=</span> <span class="n">get_wsgi_application</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">fake_start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PATH_INFO&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/subscribe&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">django_application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">fake_start_response</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">django_application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Offloading Websockets and Server-Sent Events AKA “Combine them with Django safely”</a><ul>
<li><a class="reference internal" href="#disclaimer">Disclaimer</a></li>
<li><a class="reference internal" href="#uwsgi-offloading">uWSGI offloading</a></li>
<li><a class="reference internal" href="#our-sse-app">Our SSE app</a></li>
<li><a class="reference internal" href="#the-boring-html-javascript">The (boring) HTML/Javascript</a></li>
<li><a class="reference internal" href="#the-django-view">The Django view</a></li>
<li><a class="reference internal" href="#let-s-offload-the-sse-transaction">Let’s offload the SSE transaction</a></li>
<li><a class="reference internal" href="#simplifying-things-using-the-uwsgi-api-uwsgi-2-0-3">Simplifying things using the uwsgi api (&gt;= uWSGI 2.0.3)</a></li>
<li><a class="reference internal" href="#what-about-websockets">What about Websockets ?</a></li>
<li><a class="reference internal" href="#using-redis-or-uwsgi-caching-framework">Using redis or uWSGI caching framework</a></li>
<li><a class="reference internal" href="#common-pitfalls">Common pitfalls</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="FunWithPerlEyetoyRaspberrypi.html"
                        title="previous chapter">Fun with Perl, Eyetoy and RaspberryPi</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="WSGIEnvBehaviour.html"
                        title="next chapter">WSGI env behaviour policies</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/articles/OffloadingWebsocketsAndSSE.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="WSGIEnvBehaviour.html" title="WSGI env behaviour policies"
             >next</a> |</li>
        <li class="right" >
          <a href="FunWithPerlEyetoyRaspberrypi.html" title="Fun with Perl, Eyetoy and RaspberryPi"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>