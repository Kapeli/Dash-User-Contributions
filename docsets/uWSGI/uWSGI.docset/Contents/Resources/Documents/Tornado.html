
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The Tornado loop engine &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="uGreen – uWSGI Green Threads" href="uGreen.html" />
    <link rel="prev" title="The Gevent loop engine" href="Gevent.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="uGreen.html" title="uGreen – uWSGI Green Threads"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Gevent.html" title="The Gevent loop engine"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-tornado-loop-engine">
<h1>The Tornado loop engine<a class="headerlink" href="#the-tornado-loop-engine" title="Permalink to this headline">¶</a></h1>
<p>Available from: <code class="docutils literal notranslate"><span class="pre">`uWSGI</span> <span class="pre">1.9.19-dev`</span></code></p>
<p>Supported suspend engines: <code class="docutils literal notranslate"><span class="pre">`greenlet`</span></code></p>
<p>Supported CPython versions: <code class="docutils literal notranslate"><span class="pre">`all</span> <span class="pre">of</span> <span class="pre">tornado</span> <span class="pre">supported</span> <span class="pre">versions`</span></code></p>
<p>The tornado loop engine allows you to integrate your uWSGI stack with the Tornado IOLoop class.</p>
<p>Basically every I/O operation of the server is mapped to a tornado IOLoop callback. Making RPC, remote caching, or simply writing responses
is managed by the Tornado engine.</p>
<p>As uWSGI is not written with a callback-based programming approach, integrating with those kind of libraries requires some form of “suspend” engine (green threads/coroutines)</p>
<p>Currently the only supported suspend engine is the “greenlet” one. Stackless python could work too (needs testing).</p>
<p>PyPy is currently not supported (albeit technically possible thanks to continulets). Drop a mail to Unbit staff if you are interested.</p>
<div class="section" id="why">
<h2>Why ?<a class="headerlink" href="#why" title="Permalink to this headline">¶</a></h2>
<p>The Tornado project includes a simple WSGI server by itself. In the same spirit of the Gevent plugin, the purpose of Loop engines is allowing external prejects
to use (and abuse) the uWSGI api, for better performance, versatility and (maybe the most important thing) resource usage.</p>
<p>All of the uWSGI subsystems are available (from caching, to websockets, to metrics) in your tornado apps, and the WSGI engine is the battle-tested uWSGI one.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The tornado plugin is currently not built-in by default. To have both tornado and greenlet in a single binary you can do</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">UWSGI_EMBED_PLUGINS</span><span class="o">=</span>tornado,greenlet pip install tornado greenlet uwsgi
</pre></div>
</div>
<p>or (from uWSGI sources, if you already have tornado and greenlet installed)</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">UWSGI_EMBED_PLUGINS</span><span class="o">=</span>tornado,greenlet make
</pre></div>
</div>
</div>
<div class="section" id="running-it">
<h2>Running it<a class="headerlink" href="#running-it" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">--tornado</span></code> option is exposed by the tornado plugin, allowing you to set optimal parameters:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --http-socket :9090 --wsgi-file myapp.py --tornado <span class="m">100</span> --greenlet
</pre></div>
</div>
<p>this will run a uWSGI instance on http port 9090 using tornado as I/O (and time) management and greenlet as suspend engine</p>
<p>100 async cores are allocated, allowing you to manage up to 100 concurrent requests</p>
</div>
<div class="section" id="integrating-wsgi-with-the-tornado-api">
<h2>Integrating WSGI with the tornado api<a class="headerlink" href="#integrating-wsgi-with-the-tornado-api" title="Permalink to this headline">¶</a></h2>
<p>For the way WSGI works, dealing with callback based programming is pretty hard (if not impossible).</p>
<p>Thanks to greenlet we can suspend the execution of our WSGI callable until a tornado IOLoop event is available:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.httpclient</span> <span class="kn">import</span> <span class="n">AsyncHTTPClient</span>
<span class="kn">import</span> <span class="nn">greenlet</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="c1"># this gives us access to the main IOLoop (the same used by uWSGI)</span>
<span class="kn">from</span> <span class="nn">tornado.ioloop</span> <span class="kn">import</span> <span class="n">IOLoop</span>
<span class="n">io_loop</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>

<span class="c1"># this is called at the end of the external HTTP request</span>
<span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Error:&quot;</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">me</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span>
    <span class="c1"># back to the WSGI callable</span>
    <span class="n">me</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>

 <span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
     <span class="n">me</span> <span class="o">=</span> <span class="n">greenlet</span><span class="o">.</span><span class="n">getcurrent</span><span class="p">()</span>
     <span class="n">http_client</span> <span class="o">=</span> <span class="n">AsyncHTTPClient</span><span class="p">()</span>
     <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s2">&quot;http://localhost:9191/services&quot;</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">handle_request</span><span class="p">,</span> <span class="n">me</span><span class="p">))</span>
     <span class="c1"># suspend the execution until an IOLoop event is available</span>
     <span class="n">me</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
     <span class="n">sr</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
     <span class="k">return</span> <span class="n">me</span><span class="o">.</span><span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="welcome-to-callback-hell">
<h2>Welcome to Callback-Hell<a class="headerlink" href="#welcome-to-callback-hell" title="Permalink to this headline">¶</a></h2>
<p>As always, it is not the job of uWSGI to judge programming approaches. It is a tool for sysadmins, and sysadmins should be tolerant with developers choices.</p>
<p>One of the things you will pretty soon experiment with this approach to programming is the callback-hell.</p>
<p>Let’s extend the previous example to wait 10 seconds before sending back the response to the client</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.httpclient</span> <span class="kn">import</span> <span class="n">AsyncHTTPClient</span>
<span class="kn">import</span> <span class="nn">greenlet</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="c1"># this gives us access to the main IOLoop (the same used by uWSGI)</span>
<span class="kn">from</span> <span class="nn">tornado.ioloop</span> <span class="kn">import</span> <span class="n">IOLoop</span>
<span class="n">io_loop</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">sleeper</span><span class="p">(</span><span class="n">me</span><span class="p">):</span>
    <span class="c1">#TIMED OUT</span>
    <span class="c1"># finally come back to WSGI callable</span>
    <span class="n">me</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>

<span class="c1"># this is called at the end of the external HTTP request</span>
<span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Error:&quot;</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">me</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span>
    <span class="c1"># add another callback in the chain</span>
    <span class="n">me</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">sleeper</span><span class="p">,</span> <span class="n">me</span><span class="p">))</span>

 <span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
     <span class="n">me</span> <span class="o">=</span> <span class="n">greenlet</span><span class="o">.</span><span class="n">getcurrent</span><span class="p">()</span>
     <span class="n">http_client</span> <span class="o">=</span> <span class="n">AsyncHTTPClient</span><span class="p">()</span>
     <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s2">&quot;http://localhost:9191/services&quot;</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">handle_request</span><span class="p">,</span> <span class="n">me</span><span class="p">))</span>
     <span class="c1"># suspend the execution until an IOLoop event is available</span>
     <span class="n">me</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
     <span class="c1"># unregister the timer</span>
     <span class="n">io_loop</span><span class="o">.</span><span class="n">remove_timeout</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
     <span class="n">sr</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
     <span class="k">return</span> <span class="n">me</span><span class="o">.</span><span class="n">result</span>
</pre></div>
</div>
<p>here we have chained two callbacks, with the last one being responsable for giving back control to the WSGI callable</p>
<p>The code could looks ugly or overcomplex (compared to other approaches like gevent) but this is basically the most efficient way to
increase concurrency (both in terms of memory usage and performance). Technologies like node.js are becoming popular thanks to the results they allow
to accomplish.</p>
</div>
<div class="section" id="wsgi-generators-aka-yield-all-over-the-place">
<h2>WSGI generators (aka yield all over the place)<a class="headerlink" href="#wsgi-generators-aka-yield-all-over-the-place" title="Permalink to this headline">¶</a></h2>
<p>Take the following WSGI app:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
    <span class="n">sr</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span><span class="s1">&#39;text/html&#39;</span><span class="p">)])</span>
    <span class="k">yield</span> <span class="s2">&quot;one&quot;</span>
    <span class="k">yield</span> <span class="s2">&quot;two&quot;</span>
    <span class="k">yield</span> <span class="s2">&quot;three&quot;</span>
</pre></div>
</div>
<p>if you have already played with uWSGI async mode, you knows that every yield internally calls the used suspend engine (greenlet.switch() in our case).</p>
<p>That means we will enter the tornado IOLoop engine soon after having called “application()”. How we can give the control back to our callable if we are not waiting for events ?</p>
<p>The uWSGI async api has been extended to support the “schedule_fix” hook. It allows you to call a hook soon after the suspend engine has been called.</p>
<p>In the tornado’s case this hook is mapped to something like:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">switch</span><span class="p">)</span>
</pre></div>
</div>
<p>in this way after every yield a me.switch() function is called allowing the resume of the callable.</p>
<p>Thanks to this hook you can transparently host standard WSGI applications without changing them.</p>
</div>
<div class="section" id="binding-and-listening-with-tornado">
<h2>Binding and listening with Tornado<a class="headerlink" href="#binding-and-listening-with-tornado" title="Permalink to this headline">¶</a></h2>
<p>The Tornado IOLoop is executed after fork() in every worker. If you want to bind to network addresses with Tornado, remember
to use different ports for each workers:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">uwsgidecorators</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">tornado.web</span>

<span class="c1"># this is our Tornado-managed app</span>
<span class="k">class</span> <span class="nc">MainHandler</span><span class="p">(</span><span class="n">tornado</span><span class="o">.</span><span class="n">web</span><span class="o">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>

<span class="n">t_application</span> <span class="o">=</span> <span class="n">tornado</span><span class="o">.</span><span class="n">web</span><span class="o">.</span><span class="n">Application</span><span class="p">([</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">MainHandler</span><span class="p">),</span>
<span class="p">])</span>

<span class="c1"># here happens the magic, we bind after every fork()</span>
<span class="nd">@postfork</span>
<span class="k">def</span> <span class="nf">start_the_tornado_servers</span><span class="p">():</span>
    <span class="n">application</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">8000</span> <span class="o">+</span> <span class="n">uwsgi</span><span class="o">.</span><span class="n">worker_id</span><span class="p">())</span>

<span class="c1"># this is our WSGI callable managed by uWSGI</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sr</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Remember: do no start the IOLoop class. uWSGI will do it by itself as soon as the setup is complete</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Tornado loop engine</a><ul>
<li><a class="reference internal" href="#why">Why ?</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#running-it">Running it</a></li>
<li><a class="reference internal" href="#integrating-wsgi-with-the-tornado-api">Integrating WSGI with the tornado api</a></li>
<li><a class="reference internal" href="#welcome-to-callback-hell">Welcome to Callback-Hell</a></li>
<li><a class="reference internal" href="#wsgi-generators-aka-yield-all-over-the-place">WSGI generators (aka yield all over the place)</a></li>
<li><a class="reference internal" href="#binding-and-listening-with-tornado">Binding and listening with Tornado</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Gevent.html"
                        title="previous chapter">The Gevent loop engine</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="uGreen.html"
                        title="next chapter">uGreen – uWSGI Green Threads</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Tornado.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="uGreen.html" title="uGreen – uWSGI Green Threads"
             >next</a> |</li>
        <li class="right" >
          <a href="Gevent.html" title="The Gevent loop engine"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>