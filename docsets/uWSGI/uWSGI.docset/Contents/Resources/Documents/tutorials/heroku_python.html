
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Running python webapps on Heroku with uWSGI &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Running Ruby/Rack webapps on Heroku with uWSGI" href="heroku_ruby.html" />
    <link rel="prev" title="Running uWSGI on Dreamhost shared hosting" href="dreamhost.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="heroku_ruby.html" title="Running Ruby/Rack webapps on Heroku with uWSGI"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dreamhost.html" title="Running uWSGI on Dreamhost shared hosting"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="running-python-webapps-on-heroku-with-uwsgi">
<h1>Running python webapps on Heroku with uWSGI<a class="headerlink" href="#running-python-webapps-on-heroku-with-uwsgi" title="Permalink to this headline">¶</a></h1>
<p>Prerequisites: a Heroku account (on the cedar platform), git (on the local system) and the heroku toolbelt.</p>
<p>Note: you need a uWSGI version &gt;= 1.4.6 to correctly run python apps. Older versions may work, but are not supported.</p>
<div class="section" id="preparing-the-environment">
<h2>Preparing the environment<a class="headerlink" href="#preparing-the-environment" title="Permalink to this headline">¶</a></h2>
<p>On your local system prepare a directory for your project:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>mkdir uwsgi-heroku
<span class="nb">cd</span> uwsgi-heroku
git init .
heroku create
</pre></div>
</div>
<p>the last command will create a new heroku application (you can check it on the web dashboard).</p>
<p>For our example we will run the Werkzeug WSGI testapp, so we need to install the werkzeug package in addition to uWSGI.</p>
<p>First step is creating a requirements.txt file and tracking it with git.</p>
<p>The content of the file will be simply</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi
werkzeug
</pre></div>
</div>
<p>Let’s track it with git</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>git add requirements.txt
</pre></div>
</div>
</div>
<div class="section" id="creating-the-uwsgi-config-file">
<h2>Creating the uWSGI config file<a class="headerlink" href="#creating-the-uwsgi-config-file" title="Permalink to this headline">¶</a></h2>
<p>Now we can create our uWSGI configuration file. Basically all of the features can be used on heroku</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:$(PORT)</span>
<span class="na">master</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">processes</span> <span class="o">=</span> <span class="s">4</span>
<span class="na">die-on-term</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">module</span> <span class="o">=</span> <span class="s">werkzeug.testapp:test_app</span>
<span class="na">memory-report</span> <span class="o">=</span> <span class="s">true</span>
</pre></div>
</div>
<p>as you can see this is a pretty standard configuration. The only heroku-required options are –http-socket and –die-on-term.</p>
<p>The first is required to bind the uWSGI socket to the port requested by the Heroku system (exported via the environment variable PORT we can access with $(PORT))</p>
<p>The second one (–die-on-term) is required to change the default behaviour of uWSGI when it receive a SIGTERM (brutal reload, while Heroku expect a shutdown)</p>
<p>The memory-report option (as we are in a memory constrained environment) is a good thing.</p>
<p>Remember to track the file</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>git add uwsgi.ini
</pre></div>
</div>
</div>
<div class="section" id="preparing-for-the-first-commit-push">
<h2>Preparing for the first commit/push<a class="headerlink" href="#preparing-for-the-first-commit-push" title="Permalink to this headline">¶</a></h2>
<p>We now need the last step: creating the Procfile.</p>
<p>The Procfile is a file describing which commands to start. Generally (with other deployment systems) you will use it for every
additional process required by your app (like memcached, redis, celery…), but under uWSGI you can continue using its advanced facilities to manage them.</p>
<p>So, the Procfile, only need to start your uWSGI instance:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>web: uwsgi uwsgi.ini
</pre></div>
</div>
<p>Track it</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>git add Procfile
</pre></div>
</div>
<p>And finally let’s commit all:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>git commit -a -m <span class="s2">&quot;first commit&quot;</span>
</pre></div>
</div>
<p>and push it (read: deploy) to Heroku:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>git push heroku master
</pre></div>
</div>
<p>The first time it will requires a couple of minutes as it need to prepare your virtualenv and compile uWSGI.</p>
<p>Following push will be much faster.</p>
</div>
<div class="section" id="checking-your-app">
<h2>Checking your app<a class="headerlink" href="#checking-your-app" title="Permalink to this headline">¶</a></h2>
<p>Running <code class="docutils literal notranslate"><span class="pre">heroku</span> <span class="pre">logs</span></code> you will be able to access uWSGI logs. You should get all of your familiar information, and eventually
some hint in case of problems.</p>
</div>
<div class="section" id="using-another-version-of-python">
<h2>Using another version of python<a class="headerlink" href="#using-another-version-of-python" title="Permalink to this headline">¶</a></h2>
<p>Heroku supports different python versions. By default (currently, february 2013), Python 2.7.3 is enabled.</p>
<p>If you need another version just create a runtime.txt in your repository with a string like that:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>python-2.7.2
</pre></div>
</div>
<p>to use python 2.7.2</p>
<p>Remember to add/commit that in the repository.</p>
<p>Every time you change the python version, a new uWSGI binary is built.</p>
</div>
<div class="section" id="multiprocess-or-multithread">
<h2>Multiprocess or Multithread ?<a class="headerlink" href="#multiprocess-or-multithread" title="Permalink to this headline">¶</a></h2>
<p>It obviosuly depend on your app. But as we are on a memory-limited environment you can expect better memory usage with threads.</p>
<p>In addition to this, if you plan to put production-apps on Heroku be sure to understand how Dynos and their proxy works
(it is very important. really)</p>
</div>
<div class="section" id="async-greethreads-coroutine">
<h2>Async/Greethreads/Coroutine ?<a class="headerlink" href="#async-greethreads-coroutine" title="Permalink to this headline">¶</a></h2>
<p>As always, do not trust people suggesting you to ALWAYS use some kind of async mode (like gevent). If your app
is async-friendly you can obviously use gevent (it is built by default in recent uWSGI releases), but if you do not know that, remain
with multiprocess (or multithread).</p>
</div>
<div class="section" id="harakiri">
<h2>Harakiri<a class="headerlink" href="#harakiri" title="Permalink to this headline">¶</a></h2>
<p>As said previously, if you plan to put production-apps on heroku, be sure to understand how dynos and their proxy works. Based on that,
try to always set the harakiri parameters to a good value for your app. (do not ask for a default value, IT IS APP-DEPENDENT)</p>
</div>
<div class="section" id="static-files">
<h2>Static files<a class="headerlink" href="#static-files" title="Permalink to this headline">¶</a></h2>
<p>Generally, serving static files on Heroku is not a good idea (mainly from a design point of view). You could obviously have that need.
In such a case remember to use uWSGI facilities for that, in particular offloading is the best way to leave your workers free while you serve big files (in addition to this remember that your static files must be tracked with git)</p>
</div>
<div class="section" id="adaptive-process-spawning">
<h2>Adaptive process spawning<a class="headerlink" href="#adaptive-process-spawning" title="Permalink to this headline">¶</a></h2>
<p>None of the supported algorithm are good for the Heroku approach and, very probably, it makes little sense to use a dynamic process
number on such a platform.</p>
</div>
<div class="section" id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p>If you plan to use heroku on production, remember to send your logs (via udp for example) on an external server (with persistent storage).</p>
<p>Check the uWSGI available loggers. Surely one will fit your need. (pay attention to security, as logs will fly in clear).</p>
<p>UPDATE: a udp logger with crypto features is on work.</p>
</div>
<div class="section" id="alarms">
<h2>Alarms<a class="headerlink" href="#alarms" title="Permalink to this headline">¶</a></h2>
<p>All of the alarms plugin should work without problems</p>
</div>
<div class="section" id="the-spooler">
<h2>The Spooler<a class="headerlink" href="#the-spooler" title="Permalink to this headline">¶</a></h2>
<p>As your app runs on a non-persistent filesystem, using the Spooler is a bad idea (you will easily lose tasks).</p>
</div>
<div class="section" id="mules">
<h2>Mules<a class="headerlink" href="#mules" title="Permalink to this headline">¶</a></h2>
<p>They can be used without problems</p>
</div>
<div class="section" id="signals-timers-filemonitors-crons">
<h2>Signals (timers, filemonitors, crons…)<a class="headerlink" href="#signals-timers-filemonitors-crons" title="Permalink to this headline">¶</a></h2>
<p>They all works, but do not rely on cron facilities, as heroku can kill/destroy/restarts your instances in every moment.</p>
</div>
<div class="section" id="external-daemons">
<h2>External daemons<a class="headerlink" href="#external-daemons" title="Permalink to this headline">¶</a></h2>
<p>The –attach-daemon option and its –smart variants work without problems. Just remember you are on a volatile filesystem and you are not
free to bind on port/addresses as you may wish</p>
</div>
<div class="section" id="monitoring-your-app-advanced-hacky">
<h2>Monitoring your app (advanced/hacky)<a class="headerlink" href="#monitoring-your-app-advanced-hacky" title="Permalink to this headline">¶</a></h2>
<p>Albeit Heroku works really well with newrelic services, you always need to monitor the internals of your uWSGI instance.</p>
<p>Generally you enable the stats subsystem with a tool like uwsgitop as the client.</p>
<p>You can simply add uwsgitop to you requirements.txt</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi
uwsgitop
werkzeug
</pre></div>
</div>
<p>and enable the stats server on a TCP port (unix sockets will not work as the instance running uwsgitop is not on the same server !!!):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:$(PORT)</span>
<span class="na">master</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">processes</span> <span class="o">=</span> <span class="s">4</span>
<span class="na">die-on-term</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">module</span> <span class="o">=</span> <span class="s">werkzeug.testapp:test_app</span>
<span class="na">memory-report</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">stats</span> <span class="o">=</span> <span class="s">:22222</span>
</pre></div>
</div>
<p>Now we have a problem: how to reach our instance ?</p>
<p>We need to know the LAN address of the machine where our instance is phisically running. To accomplish that, a raw trick is running
ifconfig on uWSGI startup:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">http-socket</span> <span class="o">=</span> <span class="s">:$(PORT)</span>
<span class="na">master</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">processes</span> <span class="o">=</span> <span class="s">4</span>
<span class="na">die-on-term</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">module</span> <span class="o">=</span> <span class="s">werkzeug.testapp:test_app</span>
<span class="na">memory-report</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">stats</span> <span class="o">=</span> <span class="s">:22222</span>
<span class="na">exec-pre-app</span> <span class="o">=</span> <span class="s">/sbin/ifconfig eth0</span>
</pre></div>
</div>
<p>Now thanks to the <code class="docutils literal notranslate"><span class="pre">heroku</span> <span class="pre">logs</span></code> command you can know where your stats server is</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>heroku run uwsgitop <span class="m">10</span>.x.x.x:22222
</pre></div>
</div>
<p>change x.x.x with the discovered address and remember that you could not be able to bind on port 22222, so change it accordingly.</p>
<p>Is it worthy to make such a mess to get monitoring ? If you are testing your app before going to production, it could be a good idea,
but if you plan to buy more dynos, all became so complex that you’d better to use some heroku-blessed technique (if any)</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Running python webapps on Heroku with uWSGI</a><ul>
<li><a class="reference internal" href="#preparing-the-environment">Preparing the environment</a></li>
<li><a class="reference internal" href="#creating-the-uwsgi-config-file">Creating the uWSGI config file</a></li>
<li><a class="reference internal" href="#preparing-for-the-first-commit-push">Preparing for the first commit/push</a></li>
<li><a class="reference internal" href="#checking-your-app">Checking your app</a></li>
<li><a class="reference internal" href="#using-another-version-of-python">Using another version of python</a></li>
<li><a class="reference internal" href="#multiprocess-or-multithread">Multiprocess or Multithread ?</a></li>
<li><a class="reference internal" href="#async-greethreads-coroutine">Async/Greethreads/Coroutine ?</a></li>
<li><a class="reference internal" href="#harakiri">Harakiri</a></li>
<li><a class="reference internal" href="#static-files">Static files</a></li>
<li><a class="reference internal" href="#adaptive-process-spawning">Adaptive process spawning</a></li>
<li><a class="reference internal" href="#logging">Logging</a></li>
<li><a class="reference internal" href="#alarms">Alarms</a></li>
<li><a class="reference internal" href="#the-spooler">The Spooler</a></li>
<li><a class="reference internal" href="#mules">Mules</a></li>
<li><a class="reference internal" href="#signals-timers-filemonitors-crons">Signals (timers, filemonitors, crons…)</a></li>
<li><a class="reference internal" href="#external-daemons">External daemons</a></li>
<li><a class="reference internal" href="#monitoring-your-app-advanced-hacky">Monitoring your app (advanced/hacky)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dreamhost.html"
                        title="previous chapter">Running uWSGI on Dreamhost shared hosting</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="heroku_ruby.html"
                        title="next chapter">Running Ruby/Rack webapps on Heroku with uWSGI</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/tutorials/heroku_python.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="heroku_ruby.html" title="Running Ruby/Rack webapps on Heroku with uWSGI"
             >next</a> |</li>
        <li class="right" >
          <a href="dreamhost.html" title="Running uWSGI on Dreamhost shared hosting"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>