
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The uWSGI caching framework &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="WebCaching framework" href="WebCaching.html" />
    <link rel="prev" title="The uWSGI alarm subsystem (from 1.3)" href="AlarmSubsystem.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="WebCaching.html" title="WebCaching framework"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AlarmSubsystem.html" title="The uWSGI alarm subsystem (from 1.3)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-uwsgi-caching-framework">
<h1>The uWSGI caching framework<a class="headerlink" href="#the-uwsgi-caching-framework" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This page is about “new-generation” cache introduced in uWSGI 1.9.
For old-style cache (now simply named “web caching”) check <a class="reference internal" href="WebCaching.html"><span class="doc">WebCaching framework</span></a></p>
</div>
<p>uWSGI includes a very fast, all-in-memory, zero-IPC, SMP-safe,
constantly-optimizing, highly-tunable, key-value store simply called “the
caching framework”.  A single uWSGI instance can create an unlimited number of
“caches” each one with different setup and purpose.</p>
<div class="section" id="creating-a-cache">
<h2>Creating a “cache”<a class="headerlink" href="#creating-a-cache" title="Permalink to this headline">¶</a></h2>
<p>To create a cache you use the <code class="docutils literal notranslate"><span class="pre">--cache2</span></code> option. It takes a dictionary of
arguments specifying the cache configuration.  To have a valid cache you need
to specify its name and the maximum number of items it can contains.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --cache2 <span class="nv">name</span><span class="o">=</span>mycache,items<span class="o">=</span><span class="m">100</span> --socket :3031
</pre></div>
</div>
<p>this will create a cache named “mycache” with a maximum of 100 items. Each item can be at most 64k.</p>
</div>
<div class="section" id="a-sad-weird-strange-bad-note-about-the-maximum-number-of-items">
<h2>A sad/weird/strange/bad note about “the maximum number of items”<a class="headerlink" href="#a-sad-weird-strange-bad-note-about-the-maximum-number-of-items" title="Permalink to this headline">¶</a></h2>
<p>If you start with a 100 item cache you will suddenly note that the true maximum number of items you can use is indeed 99.</p>
<p>This is because the first item of the cache is always internally used as “NULL/None/undef” item.</p>
<p>Remember this when you start planning your cache configuration.</p>
</div>
<div class="section" id="configuring-the-cache-how-it-works">
<h2>Configuring the cache (how it works)<a class="headerlink" href="#configuring-the-cache-how-it-works" title="Permalink to this headline">¶</a></h2>
<p>The uWSGI cache works like a file system. You have an area for storing keys
(metadata) followed by a series of fixed size blocks in which to store the
content of each key.  Another memory area, the hash table is allocated for fast
search of keys.  When you request a key, it is first hashed over the hash
table. Each hash points to a key in the metadata area.  Keys can be linked to
manage hash collisions. Each key has a reference to the block containing its
value.</p>
</div>
<div class="section" id="single-block-faster-vs-bitmaps-slower">
<h2>Single block (faster) vs. bitmaps (slower)<a class="headerlink" href="#single-block-faster-vs-bitmaps-slower" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Bitmap mode is considered production ready only from uWSGI 2.0.2! (That is, it was buggy before that.)</p>
</div>
<p>In the standard (“single block”) configuration a key can only map to a single
block. Thus if you have a cache block size of 64k your items can be at most
65,535 bytes long. Conversely items smaller than that will still consume 64k of
memory.  The advantage of this approach is its simplicity and speed. The system
does not need to scan the memory for free blocks every time you insert an
object in the cache.</p>
<p>If you need a more versatile (but relatively slower) approach, you can enable
the “bitmap” mode. Another memory area will be created containing a map of all
of the used and free blocks of the cache. When you insert an item the bitmap is
scanned for contiguous free blocks.  Blocks must be contiguous, this could lead
to a bit of fragmentation but it is not as big a problem as with disk storage,
and you can always tune the block size to reduce fragmentation.</p>
</div>
<div class="section" id="persistent-storage">
<h2>Persistent storage<a class="headerlink" href="#persistent-storage" title="Permalink to this headline">¶</a></h2>
<p>You can store cache data in a backing store file to implement persistence.  As
this is managed by <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> it is almost transparent to the user.  You should
not rely on this for data safety (disk syncing is managed asynchronously); use
it only for performance purposes.</p>
</div>
<div class="section" id="network-access">
<h2>Network access<a class="headerlink" href="#network-access" title="Permalink to this headline">¶</a></h2>
<p>All of your caches can be accessed over the network. A request plugin named
“cache” (modifier1 111) manages requests from external nodes. On a standard
monolithic build of uWSGI the cache plugin is always enabled.  The cache plugin
works in a fully non-blocking way, and it is greenthreads/coroutine friendly so
you can use technologies like gevent or Coro::AnyEvent with it safely.</p>
</div>
<div class="section" id="udp-sync">
<h2>UDP sync<a class="headerlink" href="#udp-sync" title="Permalink to this headline">¶</a></h2>
<p>This technique has been inspired by the STUD project, which uses something like
this for SSL session scaling (and coincidentally the same approach can be used
with uWSGI SSL/HTTPS routers).  Basically whenever you set/update/delete an
item from the cache, the operation is propagated to remote nodes via simple UDP
packets.  There are no built-in guarantees with UDP syncing so use it only for
very specific purposes, like <a class="reference internal" href="SSLScaling.html"><span class="doc">Scaling SSL connections (uWSGI 1.9)</span></a>.</p>
</div>
<div class="section" id="cache2-options">
<h2>–cache2 options<a class="headerlink" href="#cache2-options" title="Permalink to this headline">¶</a></h2>
<p>This is the list of all of the options (and their aliases) of <code class="docutils literal notranslate"><span class="pre">--cache2</span></code>.</p>
<div class="section" id="name">
<h3>name<a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h3>
<p>Set the name of the cache. Must be unique in an instance.</p>
</div>
<div class="section" id="max-items-maxitems-items">
<h3>max-items || maxitems || items<a class="headerlink" href="#max-items-maxitems-items" title="Permalink to this headline">¶</a></h3>
<p>Set the maximum number of cache items.</p>
</div>
<div class="section" id="blocksize">
<h3>blocksize<a class="headerlink" href="#blocksize" title="Permalink to this headline">¶</a></h3>
<p>Set the size (in bytes) of a single block.</p>
</div>
<div class="section" id="blocks">
<h3>blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<p>Set the number of blocks in the cache. Useful only in bitmap mode, otherwise
the number of blocks is equal to the maximum number of items.</p>
</div>
<div class="section" id="hash">
<h3>hash<a class="headerlink" href="#hash" title="Permalink to this headline">¶</a></h3>
<p>Set the hash algorithm used in the hash table. Currentl options are “djb33x”
(default) and “murmur2”.</p>
</div>
<div class="section" id="hashsize-hash-size">
<h3>hashsize || hash_size<a class="headerlink" href="#hashsize-hash-size" title="Permalink to this headline">¶</a></h3>
<p>this is the size of the hash table in bytes. Generally 65536 (the default) is a
good value. Change it only if you know what you are doing or if you have a lot
of collisions in your cache.</p>
</div>
<div class="section" id="keysize-key-size">
<h3>keysize || key_size<a class="headerlink" href="#keysize-key-size" title="Permalink to this headline">¶</a></h3>
<p>Set the maximum size of a key, in bytes (default 2048)</p>
</div>
<div class="section" id="store">
<h3>store<a class="headerlink" href="#store" title="Permalink to this headline">¶</a></h3>
<p>Set the filename for the persistent storage. If it doesn’t exist, the system
assumes an empty cache and the file will be created.</p>
</div>
<div class="section" id="store-sync-storesync">
<h3>store_sync || storesync<a class="headerlink" href="#store-sync-storesync" title="Permalink to this headline">¶</a></h3>
<p>Set the number of seconds after which msync() is called to flush memory cache
on disk when in persistent mode.  By default it is disabled leaving the
decision-making to the kernel.</p>
</div>
<div class="section" id="store-delete-storedelete">
<h3>store_delete || storedelete<a class="headerlink" href="#store-delete-storedelete" title="Permalink to this headline">¶</a></h3>
<p>uWSGI, by default, will not start if a cache file exists and the store file does not match the configured items/blocksize.
Setting this option will make uWSGI delete the existing file upon mismatch and create a new one.</p>
</div>
<div class="section" id="node-nodes">
<h3>node || nodes<a class="headerlink" href="#node-nodes" title="Permalink to this headline">¶</a></h3>
<p>A semicolon separated list of UDP servers which will receive UDP cache updates.</p>
</div>
<div class="section" id="sync">
<h3>sync<a class="headerlink" href="#sync" title="Permalink to this headline">¶</a></h3>
<p>A semicolon separated list of uwsgi addresses which the cache subsystem will
connect to for getting a full dump of the cache. It can be used for initial
cache synchronization. The first node sending a valid dump will stop the
procedure.</p>
</div>
<div class="section" id="udp-udp-servers-udp-server-udpserver">
<h3>udp || udp_servers || udp_server || udpserver<a class="headerlink" href="#udp-udp-servers-udp-server-udpserver" title="Permalink to this headline">¶</a></h3>
<p>A semicolon separated list of UDP addresses on which to bind the cache to wait for UDP updates.</p>
</div>
<div class="section" id="bitmap">
<h3>bitmap<a class="headerlink" href="#bitmap" title="Permalink to this headline">¶</a></h3>
<p>Set to 1 to enable bitmap mode.</p>
</div>
<div class="section" id="lastmod">
<h3>lastmod<a class="headerlink" href="#lastmod" title="Permalink to this headline">¶</a></h3>
<p>Setting lastmod to 1 will update last_modified_at timestamp of each cache on
every cache item modification.  Enable it if you want to track this value or if
other features depend on it. This value will then be accessible via the stats
socket.</p>
</div>
<div class="section" id="ignore-full">
<h3>ignore_full<a class="headerlink" href="#ignore-full" title="Permalink to this headline">¶</a></h3>
<p>By default uWSGI will print warning message on every cache set operation if the cache is full. To disable this warning set this option. Available since 2.0.4</p>
</div>
<div class="section" id="purge-lru">
<h3>purge_lru<a class="headerlink" href="#purge-lru" title="Permalink to this headline">¶</a></h3>
<p>This option allows the caching framework to evict Least Recently Used (LRU)
item when you try to add new item to cache storage that is full. The <code class="docutils literal notranslate"><span class="pre">expires</span></code>
argument described below will be ignored. An item is considered used when
it’s accessed, added and updated by cache_get(), cache_set() and
cache_update(); whereas the existence check by cache_exists() is not.</p>
</div>
</div>
<div class="section" id="accessing-the-cache-from-your-applications-using-the-cache-api">
<h2>Accessing the cache from your applications using the cache api<a class="headerlink" href="#accessing-the-cache-from-your-applications-using-the-cache-api" title="Permalink to this headline">¶</a></h2>
<p>You can access the various cache in your instance or on remote instances by
using the cache API.  Currently the following functions are exposed (each
language might name them a bit differently from the standard):</p>
<blockquote>
<div><ul class="simple">
<li><p>cache_get(key[,cache])</p></li>
<li><p>cache_set(key,value[,expires,cache])</p></li>
<li><p>cache_update(key,value[,expires,cache])</p></li>
<li><p>cache_exists(key[,cache])</p></li>
<li><p>cache_del(key[,cache])</p></li>
<li><p>cache_clear([cache])</p></li>
</ul>
</div></blockquote>
<p>If the language/platform calling the cache API differentiates between strings
and bytes (like Python 3 and Java) you have to assume that keys are strings and
values are bytes (or bytearray in the java way). Otherwise keys and values are
both strings in no specific encoding, as internally the cache values and keys
are simple binary blobs.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">expires</span></code> argument (default to 0 for disabled) is the number of seconds
after the object is no more valid (and will be removed by the cache sweeper
when <code class="docutils literal notranslate"><span class="pre">purge_lru</span></code> is not set, see below)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cache</span></code> argument is the so called “magic identifier”. Its syntax is
<code class="docutils literal notranslate"><span class="pre">cache[&#64;node]</span></code>.</p>
<p>To operate on the local cache “mycache” you set it as “mycache”, while to
operate on “yourcache” on the uWSGI server at 192.168.173.22 port 4040 the
value will be <code class="docutils literal notranslate"><span class="pre">yourcache&#64;192.168.173.22:4040</span></code>.</p>
<p>An empty cache value means the default cache which is generally the first
initialized. The default value is empty.</p>
<p>All of the network operations are transparent, fully non-blocking, and
threads/greenthreads friendly.</p>
</div>
<div class="section" id="the-cache-sweeper-thread">
<h2>The Cache sweeper thread<a class="headerlink" href="#the-cache-sweeper-thread" title="Permalink to this headline">¶</a></h2>
<p>When at least one cache is configured without <code class="docutils literal notranslate"><span class="pre">purge_lru</span></code> and the master
is enabled a thread named “the cache sweeper” is started.  Its main purpose
is deleting expired keys from the cache. So, if you want auto-expiring you
need to enable the master.</p>
</div>
<div class="section" id="web-caching">
<h2>Web caching<a class="headerlink" href="#web-caching" title="Permalink to this headline">¶</a></h2>
<p>In its first incarnation the uWSGI caching framework was meant only for caching
of web pages. The old system has been rebuilt. It is now named
<a class="reference internal" href="WebCaching.html"><span class="doc">WebCaching framework</span></a>. Enabling the old-style <code class="docutils literal notranslate"><span class="pre">--cache</span></code> option will create a
cache named “default”.</p>
</div>
<div class="section" id="monitoring-caches">
<h2>Monitoring caches<a class="headerlink" href="#monitoring-caches" title="Permalink to this headline">¶</a></h2>
<p>The stats server exposes cache information. An ncurses based tool (<a class="reference external" href="https://pypi.python.org/pypi/uwsgicachetop">https://pypi.python.org/pypi/uwsgicachetop</a>) exists that uses that information for real-time monitoring.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The uWSGI caching framework</a><ul>
<li><a class="reference internal" href="#creating-a-cache">Creating a “cache”</a></li>
<li><a class="reference internal" href="#a-sad-weird-strange-bad-note-about-the-maximum-number-of-items">A sad/weird/strange/bad note about “the maximum number of items”</a></li>
<li><a class="reference internal" href="#configuring-the-cache-how-it-works">Configuring the cache (how it works)</a></li>
<li><a class="reference internal" href="#single-block-faster-vs-bitmaps-slower">Single block (faster) vs. bitmaps (slower)</a></li>
<li><a class="reference internal" href="#persistent-storage">Persistent storage</a></li>
<li><a class="reference internal" href="#network-access">Network access</a></li>
<li><a class="reference internal" href="#udp-sync">UDP sync</a></li>
<li><a class="reference internal" href="#cache2-options">–cache2 options</a><ul>
<li><a class="reference internal" href="#name">name</a></li>
<li><a class="reference internal" href="#max-items-maxitems-items">max-items || maxitems || items</a></li>
<li><a class="reference internal" href="#blocksize">blocksize</a></li>
<li><a class="reference internal" href="#blocks">blocks</a></li>
<li><a class="reference internal" href="#hash">hash</a></li>
<li><a class="reference internal" href="#hashsize-hash-size">hashsize || hash_size</a></li>
<li><a class="reference internal" href="#keysize-key-size">keysize || key_size</a></li>
<li><a class="reference internal" href="#store">store</a></li>
<li><a class="reference internal" href="#store-sync-storesync">store_sync || storesync</a></li>
<li><a class="reference internal" href="#store-delete-storedelete">store_delete || storedelete</a></li>
<li><a class="reference internal" href="#node-nodes">node || nodes</a></li>
<li><a class="reference internal" href="#sync">sync</a></li>
<li><a class="reference internal" href="#udp-udp-servers-udp-server-udpserver">udp || udp_servers || udp_server || udpserver</a></li>
<li><a class="reference internal" href="#bitmap">bitmap</a></li>
<li><a class="reference internal" href="#lastmod">lastmod</a></li>
<li><a class="reference internal" href="#ignore-full">ignore_full</a></li>
<li><a class="reference internal" href="#purge-lru">purge_lru</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accessing-the-cache-from-your-applications-using-the-cache-api">Accessing the cache from your applications using the cache api</a></li>
<li><a class="reference internal" href="#the-cache-sweeper-thread">The Cache sweeper thread</a></li>
<li><a class="reference internal" href="#web-caching">Web caching</a></li>
<li><a class="reference internal" href="#monitoring-caches">Monitoring caches</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="AlarmSubsystem.html"
                        title="previous chapter">The uWSGI alarm subsystem (from 1.3)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="WebCaching.html"
                        title="next chapter">WebCaching framework</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Caching.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="WebCaching.html" title="WebCaching framework"
             >next</a> |</li>
        <li class="right" >
          <a href="AlarmSubsystem.html" title="The uWSGI alarm subsystem (from 1.3)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>