
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The uWSGI FastRouter &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="uWSGI internal routing" href="InternalRouting.html" />
    <link rel="prev" title="The uWSGI cron-like interface" href="Cron.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="InternalRouting.html" title="uWSGI internal routing"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Cron.html" title="The uWSGI cron-like interface"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-uwsgi-fastrouter">
<h1>The uWSGI FastRouter<a class="headerlink" href="#the-uwsgi-fastrouter" title="Permalink to this headline">¶</a></h1>
<p>For advanced setups uWSGI includes the “fastrouter” plugin, a
proxy/load-balancer/router speaking the uwsgi protocol. It is built in by
default.  You can put it between your webserver and real uWSGI instances to
have more control over the routing of HTTP requests to your application
servers.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>First of all you have to run the fastrouter, binding it to a specific address.
Multiple addresses are supported as well.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter /tmp/uwsgi.sock --fastrouter @foobar
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the most useless Fastrouter setup in the world.</p>
</div>
<p>Congratulations! You have just run the most useless Fastrouter setup in the
world. Simply binding the fastrouter to a couple of addresses will not instruct
it on how to route requests. To give it intelligence you have to tell it how to
route requests.</p>
</div>
<div class="section" id="way-1-fastrouter-use-base">
<h2>Way 1: –fastrouter-use-base<a class="headerlink" href="#way-1-fastrouter-use-base" title="Permalink to this headline">¶</a></h2>
<p>This option will tell the fastrouter to connect to a UNIX socket with the same
name of the requested host in a specified directory.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-use-base /tmp/sockets/
</pre></div>
</div>
<p>If you receive a request for <code class="docutils literal notranslate"><span class="pre">example.com</span></code> the fastrouter will forward the
request to <code class="docutils literal notranslate"><span class="pre">/tmp/sockets/example.com</span></code>.</p>
</div>
<div class="section" id="way-2-fastrouter-use-pattern">
<h2>Way 2: –fastrouter-use-pattern<a class="headerlink" href="#way-2-fastrouter-use-pattern" title="Permalink to this headline">¶</a></h2>
<p>Same as the previous setup but you will be able to use a pattern, with <code class="docutils literal notranslate"><span class="pre">%s</span></code>
mapping to the requested key/hostname.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-use-pattern /tmp/sockets/%s/uwsgi.sock
</pre></div>
</div>
<p>Requests for <code class="docutils literal notranslate"><span class="pre">example.com</span></code> will be mapped to
<code class="docutils literal notranslate"><span class="pre">/tmp/sockets/example.com/uwsgi.sock</span></code>.</p>
</div>
<div class="section" id="way-3-fastrouter-use-cache">
<h2>Way 3: –fastrouter-use-cache<a class="headerlink" href="#way-3-fastrouter-use-cache" title="Permalink to this headline">¶</a></h2>
<p>You can store the key/value mappings in the <a class="reference internal" href="Caching.html"><span class="doc">uWSGI cache</span></a>.
Choose a way to fill the cache, for instance a Python script like this…</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uwsgi</span>
<span class="c1"># Requests for example.com on port 8000 will go to 127.0.0.1:4040</span>
<span class="n">uwsgi</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s2">&quot;example.com:8000&quot;</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1:4040&quot;</span><span class="p">)</span>
<span class="c1"># Requests for unbit.it will go to 127.0.0.1:4040 with the modifier1 set to 5 (perl/PSGI)</span>
<span class="n">uwsgi</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s2">&quot;unbit.it&quot;</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1:4040,5&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then run your Fastrouter-enabled server, telling it to run the script first.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-use-cache --cache <span class="m">100</span> --file foobar.py
</pre></div>
</div>
</div>
<div class="section" id="way-4-fastrouter-subscription-server">
<h2>Way 4: –fastrouter-subscription-server<a class="headerlink" href="#way-4-fastrouter-subscription-server" title="Permalink to this headline">¶</a></h2>
<p>This is probably one of the best way for massive auto-scaling hosting. It uses
the <a class="reference internal" href="SubscriptionServer.html"><span class="doc">subscription server</span></a> to allow instances to
announce themselves and subscribe to the fastrouter.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-subscription-server <span class="m">192</span>.168.0.100:7000
</pre></div>
</div>
<p>This will spawn a subscription server on address 192.168.0.100 port 7000</p>
<p>Now you can spawn your instances subscribing to the fastrouter:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --socket :3031 -M --subscribe-to <span class="m">192</span>.168.0.100:7000:example.com
uwsgi --socket :3032 -M --subscribe-to <span class="m">192</span>.168.0.100:7000:unbit.it,5 --subscribe-to <span class="m">192</span>.168.0.100:7000:uwsgi.it
</pre></div>
</div>
<p>As you probably noted, you can subscribe to multiple fastrouters, with multiple
keys. Multiple instances subscribing to the same fastrouter with the same key
will automatically get load balanced and monitored. Handy, isn’t it?  Like with
the caching key/value store, <code class="docutils literal notranslate"><span class="pre">modifier1</span></code> can be set with a comma. (<code class="docutils literal notranslate"><span class="pre">,5</span></code>
above) Another feature of the subscription system is avoiding to choose ports.
You can bind instances to random port and the subscription system will send the
real value to the subscription server.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --socket <span class="m">192</span>.168.0.100:0 -M --subscribe-to <span class="m">192</span>.168.0.100:7000:example.com
</pre></div>
</div>
<div class="section" id="mapping-files">
<h3>Mapping files<a class="headerlink" href="#mapping-files" title="Permalink to this headline">¶</a></h3>
<p>If you need to specify a massive amount of keys, you can use a mapping file
instead.</p>
<div class="highlight-plain notranslate"><div class="highlight"><pre><span></span># mappings.txt
unbit.it
unbit.it:8000,5
uwsgi.it
projects.unbit.it
</pre></div>
</div>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --socket :3031 -M --subscribe-to <span class="m">192</span>.168.0.100:7000:@mappings.txt
</pre></div>
</div>
</div>
</div>
<div class="section" id="way-5-fastrouter-use-code-string">
<h2>Way 5: –fastrouter-use-code-string<a class="headerlink" href="#way-5-fastrouter-use-code-string" title="Permalink to this headline">¶</a></h2>
<p>If Darth Vader wears a t-shirt with your face (and in some other corner cases
too), you can customize the fastrouter with code-driven mappings.  Choose a
uWSGI-supported language (like Python or Lua) and define your mapping function.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;127.0.0.1:3031&#39;</span>
</pre></div>
</div>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-use-code-string <span class="m">0</span>:mapper.py:get
</pre></div>
</div>
<p>This will instruct the fastrouter to load the script <code class="docutils literal notranslate"><span class="pre">mapper.py</span></code> using plugin
(modifier1) 0 and call the ‘get’ global, passing it the key.  In the previous
example you will always route requests to 127.0.0.1:3031. Let’s create
a more advanced system, for fun!</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">domains</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">domains</span><span class="p">[</span><span class="s1">&#39;example.com&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1:3031&#39;</span><span class="p">,</span> <span class="s1">&#39;192.168.0.100:3032&#39;</span><span class="p">),</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="n">domains</span><span class="p">[</span><span class="s1">&#39;unbit.it&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1:3035,5&#39;</span><span class="p">,</span> <span class="s1">&#39;192.168.0.100:3035,5&#39;</span><span class="p">),</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

<span class="n">DEFAULT_NODE</span> <span class="o">=</span> <span class="s1">&#39;192.168.0.1:1717&#39;</span>

<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DEFAULT_NODE</span>

    <span class="c1"># get the node to forward requests to</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span>
    <span class="n">current_node</span> <span class="o">=</span> <span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">current_node</span><span class="p">]</span>

    <span class="c1"># round robin :P</span>
    <span class="n">next_node</span> <span class="o">=</span> <span class="n">current_node</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">next_node</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">domains</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span>

    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --fastrouter <span class="m">127</span>.0.0.1:3017 --fastrouter-use-code-string <span class="m">0</span>:megamapper.py:get
</pre></div>
</div>
<p>With only few lines we have implemented round-robin load-balancing with a
fallback node. Pow!  You could add some form of node monitoring, starting
threads in the script, or other insane things. (Be sure to add them to the
docs!)</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Remember to not put blocking code in your functions. The
fastrouter is totally non-blocking, do not ruin it!</p>
</div>
</div>
<div class="section" id="cheap-mode-and-shared-sockets">
<h2>Cheap mode and shared sockets<a class="headerlink" href="#cheap-mode-and-shared-sockets" title="Permalink to this headline">¶</a></h2>
<p>A common setup is having a webserver/proxy connected to a fastrouter and a
series of uWSGI instances subscribed to it.  Normally you’d use the webserver
node as a uWSGI instance node. This node will subscribe to the local
fastrouter. Well… don’t waste cycles on that!  Shared sockets are a way to
share sockets among various uWSGI components. Let’s use that to share a socket
between the fastrouter and uWSGI instance.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="c1">;create a shared socket (the webserver will connect to it)</span>
<span class="na">shared-socket</span> <span class="o">=</span> <span class="s">127.0.0.1:3031</span>

<span class="c1">; bind the fastrouter to the shared socket</span>
<span class="na">fastrouter</span> <span class="o">=</span> <span class="s">=0</span>
<span class="c1">; bind an instance to the same socket</span>
<span class="na">socket</span> <span class="o">=</span> <span class="s">=0</span>

<span class="c1">; having a master is always a good thing...</span>
<span class="na">master</span> <span class="o">=</span> <span class="s">true</span>
<span class="c1">; our subscription server</span>
<span class="na">fastrouter-subscription-server</span> <span class="o">=</span> <span class="s">192.168.0.100:4040</span>
<span class="c1">; our app</span>
<span class="na">wsgi-file</span> <span class="o">=</span> <span class="s">/var/www/myheavyapp.wsgi</span>
<span class="c1">; a bunch of processes</span>
<span class="na">processes</span> <span class="o">=</span> <span class="s">4</span>
<span class="c1">; and put the fastrouter in cheap mode</span>
<span class="na">fastrouter-cheap</span> <span class="o">=</span> <span class="s">true</span>
</pre></div>
</div>
<p>With this setup your requests will go directly to your app (no proxy overhead)
or to the fastrouter (to pass requests to remote nodes).  When the fastrouter
is in cheap mode, it will not respond to requests until a node is available.
This means that when there are no nodes subscribed, only your local app will
respond.  When all of the nodes go down, the fastrouter will return in cheap
mode. Seeing a pattern? Another step to awesome autoscaling.</p>
</div>
<div class="section" id="post-buffering-mode-uwsgi-2-0-9">
<h2>Post-buffering mode (uWSGI &gt;= 2.0.9)<a class="headerlink" href="#post-buffering-mode-uwsgi-2-0-9" title="Permalink to this headline">¶</a></h2>
<p>The fastrouter is (by default) a streaming proxy. This means that as soon as the uwsgi packet (read: the request headers) is parsed, it is forwarded to the backend/backends.</p>
<p>Now, if your web-proxy is a streaming-one too (like apache, or the uWSGI http router), your app could be blocked for ages in case of a request with a body. To be more clear:</p>
<ul class="simple">
<li><p>the client starts the request sending http headers</p></li>
<li><p>the web proxy receives it and send to the fastrouter</p></li>
<li><p>the fastrouter receives it and send to the backend</p></li>
<li><p>the client starts sending chunks of the request body (like a file upload)</p></li>
<li><p>the web proxy receives them and forward to the fastrouter</p></li>
<li><p>the fastrouter receives them and forward to the backend and so on</p></li>
</ul>
<p>now, imagine 10 concurrent clients doing this thing and you will end with 10 application server workers (or threads) busy for un undefined amount of time. (note: this problem is amplified by the fact that generally the number of threads/process is very limited, even in async modes you have a limited of concurrent requests but it is generally so high that the problem is not so relevant)</p>
<p>Web-proxies like nginx are “buffered”, so they wait til the whole request (and its body) has been read, and then it sends it to the backends.</p>
<p>You can instruct the fastrouter to behave like nginx with the <code class="docutils literal notranslate"><span class="pre">--fastrouter-post-buffering</span> <span class="pre">&lt;n&gt;</span></code> option, where &lt;n&gt; is the size of the request body after which the body will be stored to disk (as a temporary file) instead of memory:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">fastrouter</span> <span class="o">=</span> <span class="s">127.0.0.1:3031</span>
<span class="na">fastrouter-to</span> <span class="o">=</span> <span class="s">/var/run/app.socket</span>
<span class="na">fastrouter-post-buffering</span> <span class="o">=</span> <span class="s">8192</span>
</pre></div>
</div>
<p>will put the fastrouter in buffered mode, storing on a temp file every body bigger than 8192 bytes, and on memory everything lower (or equal)</p>
<p>Remember that post-buffering, is not a good-for-all solution (otherwise it would be the default), enabling it breaks websockets, chunked input, upload progress, iceast streaming and so on. Enable it only when needed.</p>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The fastrouter uses the following vars (in order of precedence) to choose a key to use:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">UWSGI_FASTROUTER_KEY</span></code> - the most versatile, as it doesn’t depend on the request in any way</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HTTP_HOST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SERVER_NAME</span></code></p></li>
</ul>
</li>
<li><p>You can increase the number of async events the fastrouter can manage (by
default it is system-dependent) using –fastrouter-events</p></li>
</ul>
<p>You can change the default timeout with –fastrouter-timeout By default the
fastrouter will set fd socket passing when used over unix sockets. If you do
not want it add –no-fd-passing</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The uWSGI FastRouter</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#way-1-fastrouter-use-base">Way 1: –fastrouter-use-base</a></li>
<li><a class="reference internal" href="#way-2-fastrouter-use-pattern">Way 2: –fastrouter-use-pattern</a></li>
<li><a class="reference internal" href="#way-3-fastrouter-use-cache">Way 3: –fastrouter-use-cache</a></li>
<li><a class="reference internal" href="#way-4-fastrouter-subscription-server">Way 4: –fastrouter-subscription-server</a><ul>
<li><a class="reference internal" href="#mapping-files">Mapping files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#way-5-fastrouter-use-code-string">Way 5: –fastrouter-use-code-string</a></li>
<li><a class="reference internal" href="#cheap-mode-and-shared-sockets">Cheap mode and shared sockets</a></li>
<li><a class="reference internal" href="#post-buffering-mode-uwsgi-2-0-9">Post-buffering mode (uWSGI &gt;= 2.0.9)</a></li>
<li><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Cron.html"
                        title="previous chapter">The uWSGI cron-like interface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="InternalRouting.html"
                        title="next chapter">uWSGI internal routing</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Fastrouter.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="InternalRouting.html" title="uWSGI internal routing"
             >next</a> |</li>
        <li class="right" >
          <a href="Cron.html" title="The uWSGI cron-like interface"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>