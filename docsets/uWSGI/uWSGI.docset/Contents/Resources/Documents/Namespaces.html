
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Jailing your apps using Linux Namespaces &#8212; uWSGI 2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="FreeBSD Jails" href="FreeBSDJails.html" />
    <link rel="prev" title="Using Linux KSM in uWSGI" href="KSM.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="FreeBSDJails.html" title="FreeBSD Jails"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="KSM.html" title="Using Linux KSM in uWSGI"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="jailing-your-apps-using-linux-namespaces">
<h1>Jailing your apps using Linux Namespaces<a class="headerlink" href="#jailing-your-apps-using-linux-namespaces" title="Permalink to this headline">¶</a></h1>
<p>If you have a recent Linux kernel (&gt;2.6.26) and you are not on the Itanium architecture you can use the namespaces support.</p>
<div class="section" id="what-are-namespaces">
<h2>What are namespaces?<a class="headerlink" href="#what-are-namespaces" title="Permalink to this headline">¶</a></h2>
<p>They are an elegant (more elegant than most of the jailing systems you might find in other operating systems) way to “detach” your processes from a specific layer of the kernel and assign them to a new one.</p>
<p>The ‘chroot’ system available on UNIX/Posix systems is a primal form of namespaces: a process sees a completely new file system root and has no access to the original one.</p>
<p>Linux extends this concept to the other OS layers (PIDs, users, IPC, networking etc.), so a specific process can live in a “virtual OS” with a new group of pids, a new set of users, a completely unshared IPC system (semaphores, shared memory etc.), a dedicated network interface and its own hostname.</p>
<p>uWSGI got full namespaces support in 1.9/2.0 development cycle.</p>
</div>
<div class="section" id="clone-vs-unshare">
<h2>clone() vs unshare()<a class="headerlink" href="#clone-vs-unshare" title="Permalink to this headline">¶</a></h2>
<p>To place the current process in a new namespace you have two syscalls: the venerable <code class="docutils literal notranslate"><span class="pre">clone()</span></code>, that will create a new process in the specified namespace
and the new kid on the block, <code class="docutils literal notranslate"><span class="pre">unshare()</span></code>, that changes namespaces for the current running process.</p>
<p><code class="docutils literal notranslate"><span class="pre">clone()</span></code> can be used by the Emperor to directly spawn vassals in new namespaces:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">emperor</span> <span class="o">=</span> <span class="s">/etc/uwsgi/vassals</span>
<span class="na">emperor-use-clone</span> <span class="o">=</span> <span class="s">fs,net,ipc,uts,pid</span>
</pre></div>
</div>
<p>will run each vassal with a dedicated filesystem, networking, SysV IPC and UTS view.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">unshare</span> <span class="o">=</span> <span class="s">ipc,uts</span>
<span class="na">...</span>
</pre></div>
</div>
<p>will run the current instance in the specified namespaces.</p>
<p>Some namespace subsystems require additional steps for sane usage (see below).</p>
</div>
<div class="section" id="supported-namespaces">
<h2>Supported namespaces<a class="headerlink" href="#supported-namespaces" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fs</span></code> -&gt; CLONE_NEWNS, filesystems</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ipc</span></code> -&gt; CLONE_NEWIPC, sysv ipc</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pid</span></code> -&gt; CLONE_NEWPID, when used with unshare() requires an additional <code class="docutils literal notranslate"><span class="pre">fork()</span></code>. Use one of the –refork-* options.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uts</span></code> -&gt; CLONE_NEWUTS, hostname</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">net</span></code> -&gt; CLONE_NEWNET, new networking, UNIX sockets from different namespaces are still usable, they are a good way for inter-namespaces communications</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user</span></code> -&gt; CLONE_NEWUSER, still complex to manage (and has differences in behaviours between kernel versions) use with caution</p></li>
</ul>
</div>
<div class="section" id="setns">
<h2>setns()<a class="headerlink" href="#setns" title="Permalink to this headline">¶</a></h2>
<p>In addition to creating new namespaces for a process you can attach to already running ones using the <code class="docutils literal notranslate"><span class="pre">setns()</span></code> call.</p>
<p>Each process exposes its namespaces via the <code class="docutils literal notranslate"><span class="pre">/proc/self/ns</span></code> directory. The setns() syscall uses the file descriptors obtained from the files in that directory
to attach to namespaces.</p>
<p>As we have already seen, UNIX sockets are a good way to communicate between namespaces, the uWSGI <code class="docutils literal notranslate"><span class="pre">setns()</span></code> feature works by creating an UNIX socket that receives requests
from processes wanting to join its namespace. As UNIX sockets allow file descriptors passing, the “client” only need to call setns() on them.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">setns-socket</span> <span class="pre">&lt;addr&gt;</span></code> exposes /proc/self/ns on the specified unix socket address</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setns</span> <span class="pre">&lt;addr&gt;</span></code> connect to the specified unix socket address, get the filedescriptors and use setns() on them</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setns-preopen</span></code> if enabled the /proc/self/ns files are opened on startup (before privileges drop) and cached. This is useful for avoiding running the main instance as root.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setns-socket-skip</span> <span class="pre">&lt;name&gt;</span></code> some file in /proc/self/ns can create problems (mostly the ‘user’ one). You can skip them specifying the name. (you can specify this option multiple times)</p></li>
</ul>
</div>
<div class="section" id="pivot-root">
<h2>pivot_root<a class="headerlink" href="#pivot-root" title="Permalink to this headline">¶</a></h2>
<p>This option allows you to change the rootfs of your currently running instance.</p>
<p>It is better than chroot as it allows you to access the old file system tree before (manually) unmounting it.</p>
<p>It is a bit complex to master correctly as it requires a couple of assumptions:</p>
<p><code class="docutils literal notranslate"><span class="pre">pivot_root</span> <span class="pre">&lt;new&gt;</span> <span class="pre">&lt;old&gt;</span></code></p>
<p>&lt;new&gt; is the directory to mount as the new rootfs and &lt;old&gt; is where to access the old tree.</p>
<p>&lt;new&gt; must be a mounted file system, and &lt;old&gt; must be under this file system.</p>
<p>A common pattern is:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">unshare</span> <span class="o">=</span> <span class="s">fs</span>
<span class="na">hook-post-jail</span> <span class="o">=</span> <span class="s">mount:none /distros/precise /ns bind</span>
<span class="na">pivot_root</span> <span class="o">=</span> <span class="s">/ns /ns/.old_root</span>
<span class="na">...</span>
</pre></div>
</div>
<p>(Remember to create <code class="docutils literal notranslate"><span class="pre">/ns</span></code> and <code class="docutils literal notranslate"><span class="pre">/distro/precise/.old_root</span></code>.)</p>
<p>When you have created the new file system layout you can umount /.old_root recursively:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[uwsgi]</span>
<span class="na">unshare</span> <span class="o">=</span> <span class="s">fs</span>
<span class="na">hook-post-jail</span> <span class="o">=</span> <span class="s">mount:none /distros/precise /ns bind</span>
<span class="na">pivot_root</span> <span class="o">=</span> <span class="s">/ns /ns/.old_root</span>
<span class="c1">; bind mount some useful fs like /dev and /proc</span>
<span class="na">hook-as-root</span> <span class="o">=</span> <span class="s">mount:proc none /proc nodev hidepid=2</span>
<span class="na">hook-as-root</span> <span class="o">=</span> <span class="s">mount:none /.old_root/dev /dev bind</span>
<span class="na">hook-as-root</span> <span class="o">=</span> <span class="s">mount:none /.old_root/dev/pts /dev/pts bind</span>
<span class="c1">; umount the old tree</span>
<span class="na">hook-as-root</span> <span class="o">=</span> <span class="s">umount:/.old_root rec,detach</span>
</pre></div>
</div>
</div>
<div class="section" id="why-not-lxc">
<h2>Why not lxc?<a class="headerlink" href="#why-not-lxc" title="Permalink to this headline">¶</a></h2>
<p>LXC (LinuX Containers) is a project allowing you to build full subsystems using Linux namespaces. You may ask why “reinvent the wheel” while LXC implements
a fully “virtualized” system. Apples and oranges…</p>
<p>LXC’s objective is giving users the view of a virtual server. uWSGI namespaces support is lower level – you can use it to detach
single components (for example you may only want to unshare IPC) to increase security and isolation.</p>
<p>Not all the scenario requires a full system-like view (and in lot of case is suboptimal, while in other is the best approach), try to
see namespaces as a way to increase security and isolation, when you need/can isolate a component do it with clone/unshare. When you want
to give users a full system-like access go with LXC.</p>
</div>
</div>
<div class="section" id="the-old-way-the-namespace-option">
<h1>The old way: the –namespace option<a class="headerlink" href="#the-old-way-the-namespace-option" title="Permalink to this headline">¶</a></h1>
<p>Before 1.9/2.0 a full featured system-like namespace support was added. It works as a chroot() on steroids.</p>
<p>It should be moved as an external plugin pretty soon, but will be always part of the main distribution, as it is used by lot of people
for its simplicity.</p>
<p>You basically need to set a root filesystem and an hostname to start your instance in a new namespace:</p>
<p>Let’s start by creating a new root filesystem for our jail. You’ll need <code class="docutils literal notranslate"><span class="pre">debootstrap</span></code> (or an equivalent package for your distribution).
We’re placing our rootfs in <code class="docutils literal notranslate"><span class="pre">/ns/001</span></code>, and then create a ‘uwsgi’ user that will run the uWSGI server.
We will use the chroot command to ‘adduser’ in the new rootfs, and we will install the Flask package, required by uwsgicc.</p>
<p>(All this needs to be executed as root)</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>mkdir -p /ns/001
debootstrap maverick /ns/001
chroot /ns/001
<span class="c1"># in the chroot jail now</span>
adduser uwsgi
apt-get install mercurial python-flask
su - uwsgi
<span class="c1"># as uwsgi now</span>
git clone https://github.com/unbit/uwsgicc.git .
<span class="nb">exit</span> <span class="c1"># out of su - uwsgi</span>
<span class="nb">exit</span> <span class="c1"># out of the jail</span>
</pre></div>
</div>
<p>Now on your real system run</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>uwsgi --socket <span class="m">127</span>.0.0.1:3031 --chdir /home/uwsgi/uwsgi --uid uwsgi --gid uwsgi --module uwsgicc --master --processes <span class="m">4</span> --namespace /ns/001:mybeautifulhostname
</pre></div>
</div>
<p>If all goes well, uWSGI will set <code class="docutils literal notranslate"><span class="pre">/ns/001</span></code> as the new root filesystem, assign <code class="docutils literal notranslate"><span class="pre">mybeautifulhostname</span></code> as the hostname and hide the PIDs and IPC of the host system.</p>
<p>The first thing you should note is the uWSGI master becoming PID 1 (the “init” process) in the new namespace.
All processes generated by the uWSGI stack will be reparented to it if something goes wrong. If the master dies, all jailed processes die.</p>
<p>Now point your web browser to your web server and you should see the uWSGI Control Center interface.</p>
<p>Pay attention to the information area. The node name (used by cluster subsystem) matches the real hostname as it does not make sense to have multiple jail in the same cluster group. In the hostname field instead you will see the hostname you have set.</p>
<p>Another important thing is that you can see all the jail processes from your real system (they will have a different set of PIDs), so if you want to take control of the jail
you can easily do it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A good way to limit hardware usage of jails is to combine them with the cgroups subsystem.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="Cgroups.html"><span class="doc">Running uWSGI in a Linux CGroup</span></a></p>
</div>
</div>
<div class="section" id="reloading-uwsgi">
<h2>Reloading uWSGI<a class="headerlink" href="#reloading-uwsgi" title="Permalink to this headline">¶</a></h2>
<p>When running in a jail, uWSGI uses another system for reloading: it’ll simply tell workers to bugger off and then exit. The parent process living outside the namespace will see this and respawn the stack in a new jail.</p>
</div>
<div class="section" id="how-secure-is-this-sort-of-jailing">
<h2>How secure is this sort of jailing?<a class="headerlink" href="#how-secure-is-this-sort-of-jailing" title="Permalink to this headline">¶</a></h2>
<p>Hard to say! All software tends to be secure until a hole is found.</p>
</div>
<div class="section" id="additional-filesystems">
<h2>Additional filesystems<a class="headerlink" href="#additional-filesystems" title="Permalink to this headline">¶</a></h2>
<p>When app is jailed to namespace it only has access to its virtual jail root filesystem. If there is any other filesystem mounted inside the jail directory, it won’t be accessible, unless you use <code class="docutils literal notranslate"><span class="pre">namespace-keep-mount</span></code>.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># app1 jail is located here</span>
<span class="na">namespace</span> <span class="o">=</span> <span class="s">/apps/app1</span>

<span class="c1"># nfs share mounted on the host side</span>
<span class="na">namespace-keep-mount</span> <span class="o">=</span> <span class="s">/apps/app1/nfs</span>
</pre></div>
</div>
<p>This will bind /apps/app1/nfs to jail, so that jailed app can access it under /nfs directory</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># app1 jail is located here</span>
<span class="na">namespace</span> <span class="o">=</span> <span class="s">/apps/app1</span>

<span class="c1"># nfs share mounted on the host side</span>
<span class="na">namespace-keep-mount</span> <span class="o">=</span> <span class="s">/mnt/nfs1:/nfs</span>
</pre></div>
</div>
<p>If the filesystem that we want to bind is mounted in path not contained inside our jail, than we can use “&lt;source&gt;:&lt;dest&gt;” syntax for –namespace-keep-mount. In this case the /mnt/nfs1 will be binded to /nfs directory inside the jail.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Jailing your apps using Linux Namespaces</a><ul>
<li><a class="reference internal" href="#what-are-namespaces">What are namespaces?</a></li>
<li><a class="reference internal" href="#clone-vs-unshare">clone() vs unshare()</a></li>
<li><a class="reference internal" href="#supported-namespaces">Supported namespaces</a></li>
<li><a class="reference internal" href="#setns">setns()</a></li>
<li><a class="reference internal" href="#pivot-root">pivot_root</a></li>
<li><a class="reference internal" href="#why-not-lxc">Why not lxc?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-old-way-the-namespace-option">The old way: the –namespace option</a><ul>
<li><a class="reference internal" href="#reloading-uwsgi">Reloading uWSGI</a></li>
<li><a class="reference internal" href="#how-secure-is-this-sort-of-jailing">How secure is this sort of jailing?</a></li>
<li><a class="reference internal" href="#additional-filesystems">Additional filesystems</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="KSM.html"
                        title="previous chapter">Using Linux KSM in uWSGI</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="FreeBSDJails.html"
                        title="next chapter">FreeBSD Jails</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Namespaces.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="FreeBSDJails.html" title="FreeBSD Jails"
             >next</a> |</li>
        <li class="right" >
          <a href="KSM.html" title="Using Linux KSM in uWSGI"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">uWSGI 2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016, uWSGI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>