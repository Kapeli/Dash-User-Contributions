

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nengo.builder.optimizer &#8212; Nengo 3.1.0.dev0 docs</title>
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,600|Rajdhani:700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
<link rel="stylesheet" href="https://www.nengo.ai/css/bootstrap.css" type="text/css">
<style>
  body .title-bar,
  body .documentation-source h1:after {
    background-color: #a8acaf;
  }
</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-41658423-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-41658423-2');
</script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://unpkg.com/scrollreveal"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stickyfill/2.1.0/stickyfill.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<!-- From basic/layout.html -->
<script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
  
  
<script src="../../../_static/underscore.js"></script>
  
  
<script src="../../../_static/doctools.js"></script>
  
  
<script src="../../../_static/language_data.js"></script>
  
  
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
  
  
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
<script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" type="text/css" href="../../../_static/custom.css">


<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  </head><body class="bg-dark">

<header class="fixed-top header-top shadow-sm">
  <nav class="navbar navbar-expand-md navbar-light bg-white">
    <a class="navbar-brand" href="https://www.nengo.ai/">
      <img
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
        class="logo"
      />
    </a>
    <button
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbar-collapse"
      aria-controls="navbar-collapse"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar-collapse">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/">What is Nengo?</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/examples/">Examples</a>
        </li>
        <li class="nav-item dropdown active">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-docs"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Documentation</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-docs"
          >
            
            <a class="dropdown-item" href="https://www.nengo.ai/nengo/">Nengo Core</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-gui/">Nengo GUI</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-dl/">Nengo DL</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-spa/">Nengo SPA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-extras/">Nengo Extras</a>
            <a class="dropdown-item" href="https://arvoelke.github.io/nengolib-docs/">Nengolib</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-fpga/">Nengo FPGA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-loihi/">Nengo Loihi</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-ocl">Nengo OpenCL</a>
            <a class="dropdown-item" href="https://github.com/project-rig/nengo_spinnaker">Nengo SpiNNaker</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-mpi">Nengo MPI</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/documentation/"
              >All documentation</a
            >
          </div>
        </li>
        <li class="nav-item dropdown">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-community"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Community</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-community"
          >
            <a class="dropdown-item" href="https://forum.nengo.ai">Forum</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/people/"
              >People</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/summer-school/"
              >Summer school</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/contributing/"
              >Contributing</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/publications/"
              >Publications</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/videos/"
              >Videos</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/conduct/"
              >Code of conduct</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/caa/">CAA</a>
          </div>
        </li>
        <li class="nav-item">
          <a
            class="nav-link btn btn-success btn-sm text-white"
            href="https://www.nengo.ai/getting-started/"
            >Getting started</a
          >
        </li>
      </ul>
    </div>
  </nav>
</header>
<div class="main-content gradient-top">
  <div class="container-fluid">
    <div class="row"><a class="toggle-sidenav d-block d-md-none" href="#"
  ><i class="icon-close fa fa-fw fa-arrow-left"></i
  ><i class="icon-open fa fa-fw fa-arrow-right"></i
></a>
<div role="complementary" class="sidenav col-4 col-xl-3 p-0 border-right">
  <h3 class="pt-5 px-5">
    <a href="../../../index.html">
      <img
        class="img-fluid documentation-image"
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
      />
    </a>
  </h3>
  
  <div class="p-5 toctree">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting-started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user-guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../project.html">Project information</a></li>
</ul>

  </div>
<form class="p-5 my-0 border-top" action="../../../search.html" method="get">
  <div class="form-group form-group-single">
    <input type="text" name="q" class="form-control" placeholder="Search" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <button type="submit" class="btn btn-link">
      <img src="https://www.nengo.ai/img/icon-search.svg" alt="Go" />
    </button>
  </div>
</form></div>
      

      <div class="col-12 col-md-8 col-xl-9">
        <div class="container">
          <div class="row">
            <div class="col-10 offset-1 pb-5 documentation-source" role="main">
              
  <h1>Source code for nengo.builder.optimizer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Operator graph optimizers.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">nengo.builder.neurons</span> <span class="kn">import</span> <span class="n">SimNeurons</span>
<span class="kn">from</span> <span class="nn">nengo.builder</span> <span class="kn">import</span> <span class="n">operator</span> <span class="k">as</span> <span class="n">op</span>
<span class="kn">from</span> <span class="nn">nengo.builder.signal</span> <span class="kn">import</span> <span class="n">Signal</span>
<span class="kn">from</span> <span class="nn">nengo.rc</span> <span class="kn">import</span> <span class="n">rc</span>
<span class="kn">from</span> <span class="nn">nengo.utils.graphs</span> <span class="kn">import</span> <span class="n">BidirectionalDAG</span><span class="p">,</span> <span class="n">transitive_closure</span>
<span class="kn">from</span> <span class="nn">nengo.utils.stdlib</span> <span class="kn">import</span> <span class="n">Timer</span><span class="p">,</span> <span class="n">WeakKeyDefaultDict</span><span class="p">,</span> <span class="n">WeakSet</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimizes the operator graph by merging operators.</span>

<span class="sd">    This reduces the number of iterators to iterate over in slow Python code</span>
<span class="sd">    (as opposed to fast C code). The resulting merged operators will also</span>
<span class="sd">    operate on larger chunks of sequential memory, making better use of CPU</span>
<span class="sd">    caching and prefetching.</span>

<span class="sd">    The optimization algorithm has worst case complexity :math:`O(n^2 + e)`,</span>
<span class="sd">    where :math:`n` is the number of operators and :math:`e` is the number</span>
<span class="sd">    of edges in the dependency graph. In practice the run time will be much</span>
<span class="sd">    better because not all :math:`n^2` pairwise combinations of operators</span>
<span class="sd">    will be evaluated. A grouping depending on the operator type and view</span>
<span class="sd">    bases is done with dictionaries. This grouping can be done in amortized</span>
<span class="sd">    linear time and reduces the actual worst-case runtime of the optimization</span>
<span class="sd">    algorithm to :math:`O(gm^2 + e)`, where :math:`g` is the number of groups</span>
<span class="sd">    and :math:`m` is the number of elements in a group. Moreover, information</span>
<span class="sd">    about memory alignment will be used to cut the inner loop short in</span>
<span class="sd">    many cases and gives a runtime much closer to linear in most cases.</span>

<span class="sd">    Note that this function modifies both ``model`` and ``dg``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `nengo.builder.Model`</span>
<span class="sd">        Builder output to optimize.</span>
<span class="sd">    dg : dict</span>
<span class="sd">        Dict of the form ``{a: {b, c}}`` where ``b`` and ``c`` depend on ``a``,</span>
<span class="sd">        specifying the operator dependency graph of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Optimizing model...&quot;</span><span class="p">)</span>

    <span class="c1"># We try first to merge operators with views only as these have a fixed</span>
    <span class="c1"># order for the memory alignment whereas operators without views could</span>
    <span class="c1"># be merged in a random order. Merging the views of operators will</span>
    <span class="c1"># propagate requirements in the memory ordering via the other</span>
    <span class="c1"># associated signals of the operator to other operators.</span>

    <span class="c1"># Once no more operators with views can be merged, we try to merge</span>
    <span class="c1"># operators without views and then try again merging views (because</span>
    <span class="c1"># each operator merge might generate new views).</span>

    <span class="n">single_pass</span> <span class="o">=</span> <span class="n">OpMergePass</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>

    <span class="n">n_initial_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
    <span class="n">cum_duration</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">only_merge_ops_with_view</span> <span class="ow">or</span> <span class="n">after</span> <span class="o">&lt;</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="n">before</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">before</span> <span class="o">!=</span> <span class="n">after</span>
        <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_pass</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">single_pass</span><span class="p">(</span><span class="n">only_merge_ops_with_view</span><span class="p">)</span>

        <span class="n">after</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_pass</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]: Reduced </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2"> operators in </span><span class="si">%f</span><span class="s2">s.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;views&quot;</span> <span class="k">if</span> <span class="n">only_merge_ops_with_view</span> <span class="k">else</span> <span class="s2">&quot;non-views&quot;</span><span class="p">,</span>
            <span class="n">before</span><span class="p">,</span>
            <span class="n">after</span><span class="p">,</span>
            <span class="n">t</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Prevent optimizer from running too long if we get up diminishing</span>
        <span class="c1"># returns.</span>
        <span class="c1"># Note that we don&#39;t break if there was no reduction at all because</span>
        <span class="c1"># in that case we want to toggle only_merge_ops_with_view which might</span>
        <span class="c1"># still yield some significant reduction.</span>
        <span class="n">cum_duration</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">duration</span>
        <span class="n">mean_reduction_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_initial_ops</span> <span class="o">-</span> <span class="n">after</span><span class="p">)</span> <span class="o">/</span> <span class="n">cum_duration</span>
        <span class="n">last_reduction_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">before</span> <span class="o">-</span> <span class="n">after</span><span class="p">)</span> <span class="o">/</span> <span class="n">t</span><span class="o">.</span><span class="n">duration</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">scaled_rate</span> <span class="o">=</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">mean_reduction_rate</span>
        <span class="k">if</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">last_reduction_rate</span> <span class="o">&lt;</span> <span class="n">scaled_rate</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Operator reduction rate fell below </span><span class="si">{}</span><span class="s2"> mean reduction rate. &quot;</span>
                <span class="s2">&quot;Stopping optimizer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># Update model signals</span>
    <span class="k">for</span> <span class="n">sigdict</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sigdict</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">in</span> <span class="n">single_pass</span><span class="o">.</span><span class="n">sig_replacements</span><span class="p">:</span>
                <span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_pass</span><span class="o">.</span><span class="n">sig_replacements</span><span class="p">[</span><span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span>

    <span class="c1"># Reinitialize the model&#39;s operator list</span>
    <span class="k">del</span> <span class="n">model</span><span class="o">.</span><span class="n">operators</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">dg</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span></div>


<div class="viewcode-block" id="OpMergePass"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMergePass">[docs]</a><span class="k">class</span> <span class="nc">OpMergePass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manages a single optimization pass.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dg</span> <span class="o">=</span> <span class="n">BidirectionalDAG</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_replacements</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span> <span class="o">=</span> <span class="n">WeakKeyDefaultDict</span><span class="p">(</span><span class="n">WeakSet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span> <span class="o">=</span> <span class="n">WeakKeyDefaultDict</span><span class="p">(</span><span class="n">WeakSet</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># These variables will be initialized and used on each pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span> <span class="o">=</span> <span class="n">OpInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_merge_ops_with_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a single optimization pass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        only_merge_ops_with_view : bool</span>
<span class="sd">            Limits operator merges to operators with views.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># --- Initialize pass state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="n">transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="n">only_merge_ops_with_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># --- Do an optimization pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges</span><span class="p">()</span>

<div class="viewcode-block" id="OpMergePass.perform_merges"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMergePass.perform_merges">[docs]</a>    <span class="k">def</span> <span class="nf">perform_merges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go through all operators and merge them where possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        only_merge_ops_with_view : bool</span>
<span class="sd">            Limit merges to operators with views.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We go through the ops grouped by type as only ops with the same</span>
        <span class="c1"># type can be merged.</span>
        <span class="n">by_type</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c1"># Note that we will stop once we merge any operator, so merges are</span>
        <span class="c1"># performed on at most one type of operator per pass.</span>
        <span class="c1"># The dependency graph and other information will be updated</span>
        <span class="c1"># before merging other operator types.</span>

        <span class="c1"># We go through ops in a heuristic order to reduce runtime</span>
        <span class="n">firstops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">ElementwiseInc</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">Copy</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">DotInc</span><span class="p">,</span> <span class="n">SimNeurons</span><span class="p">]</span>
        <span class="n">sortedops</span> <span class="o">=</span> <span class="n">firstops</span> <span class="o">+</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">by_type</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">firstops</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">optype</span> <span class="ow">in</span> <span class="n">sortedops</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">is_type_mergeable</span><span class="p">(</span><span class="n">optype</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_subset</span><span class="p">(</span><span class="n">by_type</span><span class="p">[</span><span class="n">optype</span><span class="p">])</span>

            <span class="c1"># If we&#39;re not only merging views, the memory layout changes</span>
            <span class="c1"># and non-views are turned into views. In that case we need</span>
            <span class="c1"># to update the signals the operators are referring to before</span>
            <span class="c1"># trying to merge a different type of operators. Thus, we break</span>
            <span class="c1"># the loop here.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="OpMergePass.perform_merges_for_subset"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMergePass.perform_merges_for_subset">[docs]</a>    <span class="k">def</span> <span class="nf">perform_merges_for_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs operator merges for a subset of operators.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : list</span>
<span class="sd">            Subset of operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">by_view</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">.</span><span class="n">v_base</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">by_view</span><span class="p">:</span>
                <span class="c1"># If an op has no views, v_base will be None.</span>
                <span class="c1"># If we&#39;re only merging views, then we get rid of this subset.</span>
                <span class="k">del</span> <span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">view_subset</span> <span class="ow">in</span> <span class="n">by_view</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">view_subset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_view_subset</span><span class="p">(</span><span class="n">view_subset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">by_view</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_view_subset</span><span class="p">(</span><span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span></div>

<div class="viewcode-block" id="OpMergePass.perform_merges_for_view_subset"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMergePass.perform_merges_for_view_subset">[docs]</a>    <span class="k">def</span> <span class="nf">perform_merges_for_view_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform merges for a subset of operators with the same view base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : list</span>
<span class="sd">            Subset of operators. These need to have the same view base (can be</span>
<span class="sd">            None if it is None for all) for their first signal in</span>
<span class="sd">            ``all_signals``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Sort to have sequential memory.</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">.</span><span class="n">v_offset</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rc</span><span class="o">.</span><span class="n">float_dtype</span>
        <span class="p">)</span>
        <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>
        <span class="n">sorted_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_indices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_subset</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">op1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">:</span>
                <span class="c1"># Cannot merge merged operator again until dependency graph</span>
                <span class="c1"># has been updated</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">op1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">tomerge</span> <span class="o">=</span> <span class="n">OpsToMerge</span><span class="p">(</span>
                <span class="n">op1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span>
            <span class="p">)</span>

            <span class="c1"># For a merge to be possible the view of the next operator has to</span>
            <span class="c1"># start where the view of op1 ends. Because we have sorted the</span>
            <span class="c1"># operators by the start of their views we can do a binary search</span>
            <span class="c1"># and potentially skip a number of operators at the beginning.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="n">offsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span><span class="o">.</span><span class="n">v_size</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">sorted_subset</span><span class="p">[</span><span class="n">start</span><span class="p">:]:</span>

                <span class="k">if</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">not_sequential</span><span class="p">(</span><span class="n">op2</span><span class="p">):</span>
                    <span class="c1"># If this check is true the view of op2 does not</span>
                    <span class="c1"># immediately follow the view of the operators being</span>
                    <span class="c1"># merged. Because we iterate over the operators sorted by</span>
                    <span class="c1"># view offset there will be a gap between the end of the</span>
                    <span class="c1"># operators being merged and all remaining operators to</span>
                    <span class="c1"># loop over. With such a gap a merge is never possible and</span>
                    <span class="c1"># we can cut the loop short.</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">op2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">is_mergeable</span><span class="p">(</span><span class="n">op2</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
                    <span class="n">tomerge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpMergePass.merge"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMergePass.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the given operators.</span>

<span class="sd">        This method will also update ``op_replacements``, ``sig_replacements``,</span>
<span class="sd">        and the internal list of merged operators to prevent further merges</span>
<span class="sd">        on the same operators before all required operators and signals have</span>
<span class="sd">        been replaced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_op</span><span class="p">,</span> <span class="n">merged_sig</span> <span class="o">=</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">merged_op</span><span class="p">)</span>

        <span class="c1"># Update tracking what has been merged and might be mergeable later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">merged_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">all_dependents</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="c1"># Mark all operators referencing the same signals as merged</span>
            <span class="c1"># (even though they are not) to prevent them from getting</span>
            <span class="c1"># merged before their signals have been updated.</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

        <span class="c1"># Signal related updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolve_views_on_replaced_signals</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_replacements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_op_signals</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_signal_indexing</span><span class="p">(</span><span class="n">merged_op</span><span class="p">,</span> <span class="n">merged_sig</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">resolve_views_on_replaced_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">replaced_signals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">view</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">sig</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">sig</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="n">view</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">sig</span>
                <span class="n">base_replacement</span> <span class="o">=</span> <span class="n">replaced_signals</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">offset</span>
                <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">a</span> <span class="o">//</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span>
                        <span class="n">view</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">view</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">base_replacement</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">fillvalue</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">offset</span>
                    <span class="n">base_replacement</span> <span class="o">=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">base</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">initial_value</span>
                <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
                    <span class="n">buffer</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                    <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">replaced_signals</span><span class="p">[</span><span class="n">view</span><span class="p">]</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span>
                    <span class="n">initial_value</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">base</span><span class="o">=</span><span class="n">base_replacement</span><span class="p">,</span>
                    <span class="n">readonly</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">readonly</span><span class="p">,</span>
                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_op_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">replaced_signals</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="c1"># Update the op&#39;s signals</span>
            <span class="n">v</span><span class="o">.</span><span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">sets</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">incs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">incs</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">reads</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">reads</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">updates</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">updates</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_signal_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merged_op</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">merged_op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">merged_op</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_sig</span><span class="p">,</span> <span class="n">to_sig</span> <span class="ow">in</span> <span class="n">replaced_signals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">to_sig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">from_sig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">to_sig</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">to_sig</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">to_sig</span><span class="p">)</span></div>


<div class="viewcode-block" id="OpInfo"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpInfo">[docs]</a><span class="k">class</span> <span class="nc">OpInfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Analyze and store extra information about operators.&quot;&quot;&quot;</span>

    <span class="n">_OpDetails</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;_OpDetails&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;first_view&quot;</span><span class="p">,</span> <span class="s2">&quot;v_offset&quot;</span><span class="p">,</span> <span class="s2">&quot;v_size&quot;</span><span class="p">,</span> <span class="s2">&quot;v_base&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">first_view</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OpDetails</span><span class="p">(</span>
                    <span class="n">first_view</span><span class="o">=</span><span class="n">first_view</span><span class="p">,</span>
                    <span class="n">v_offset</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                    <span class="n">v_size</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                    <span class="n">v_base</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">base</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OpDetails</span><span class="p">(</span>
                    <span class="n">first_view</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_base</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


<div class="viewcode-block" id="OpsToMerge"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpsToMerge">[docs]</a><span class="k">class</span> <span class="nc">OpsToMerge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Analyze and store extra information about a list of ops to be merged.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_op</span><span class="p">,</span> <span class="n">merged</span><span class="p">,</span> <span class="n">merged_dependents</span><span class="p">,</span> <span class="n">dependents</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="o">=</span> <span class="n">merged_dependents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="n">dependents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_op</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span> <span class="o">=</span> <span class="n">OpInfo</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_signals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initial_op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_dependents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">initial_op</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_signals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_dependents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">all_signals</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">all_signals</span><span class="p">):</span>
            <span class="c1"># If one op&#39;s signal is a view, the other must be as well</span>
            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">is_view</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s2</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="c1"># Views must be on the same base</span>
                <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s2</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Views must have the same strides</span>
                <span class="k">elif</span> <span class="n">s1</span><span class="o">.</span><span class="n">strides</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">not_sequential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">lastop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">lastop</span><span class="o">.</span><span class="n">v_offset</span> <span class="o">+</span> <span class="n">lastop</span><span class="o">.</span><span class="n">v_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">.</span><span class="n">v_offset</span></div>


<div class="viewcode-block" id="OpMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.OpMerger">[docs]</a><span class="k">class</span> <span class="nc">OpMerger</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manages the op merge classes known to the optimizer.&quot;&quot;&quot;</span>

    <span class="n">mergers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="n">merger</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span><span class="p">]</span>

        <span class="n">independent_of_ops_tomerge</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_dependents</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">independent_of_prior_merges</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged</span>
            <span class="ow">and</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged_dependents</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="ow">is</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span>
            <span class="ow">and</span> <span class="n">independent_of_ops_tomerge</span>
            <span class="ow">and</span> <span class="n">independent_of_prior_merges</span>
            <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">is_type_mergeable</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">op</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">merger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">merger</span><span class="o">.</span><span class="n">is_mergeable</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">last_op</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_type_mergeable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">optype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">optype</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">optype</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">merger</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">optype</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Merger for operator type </span><span class="si">{}</span><span class="s2"> overwritten.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">optype</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="n">optype</span><span class="p">]</span> <span class="o">=</span> <span class="n">merger</span>
            <span class="k">return</span> <span class="n">merger</span>

        <span class="k">return</span> <span class="n">register</span></div>


<div class="viewcode-block" id="Merger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.Merger">[docs]</a><span class="k">class</span> <span class="nc">Merger</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for all op merge classes.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement `is_mergeable`&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot merge arbitrary ops.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Merger.merge_dicts"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.Merger.merge_dicts">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_dicts</span><span class="p">(</span><span class="o">*</span><span class="n">dicts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the given dictionaries into a single dictionary.</span>

<span class="sd">        This function assumes and enforces that no keys overlap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">other_d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_d</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other_d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="ResetMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.ResetMerger">[docs]</a><span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">Reset</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ResetMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge `.Reset` ops.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst</span><span class="p">])</span> <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">dst</span><span class="p">,</span> <span class="n">replacements</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">dst</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">replacements</span></div>


<div class="viewcode-block" id="CopyMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.CopyMerger">[docs]</a><span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">Copy</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">CopyMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge `.Copy` ops.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">src</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">src_slice</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">dst_slice</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">src_slice</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst_slice</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">inc</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">inc</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_slice</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mixed Ellipsis with list of indices.&quot;</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">merged_slice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sig</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;Expecting a list of indices, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sl</span>
            <span class="n">merged_slice</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">merged_slice</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">src_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">src</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="n">dst_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">dst</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>

        <span class="n">src</span><span class="p">,</span> <span class="n">src_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">src_sigs</span><span class="p">)</span>
        <span class="n">dst</span><span class="p">,</span> <span class="n">dst_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dst_sigs</span><span class="p">)</span>
        <span class="n">src_slice</span> <span class="o">=</span> <span class="n">CopyMerger</span><span class="o">.</span><span class="n">merge_slice</span><span class="p">(</span><span class="n">src_sigs</span><span class="p">,</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">src_slice</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">dst_slice</span> <span class="o">=</span> <span class="n">CopyMerger</span><span class="o">.</span><span class="n">merge_slice</span><span class="p">(</span><span class="n">dst_sigs</span><span class="p">,</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">dst_slice</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">op</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src_slice</span><span class="o">=</span><span class="n">src_slice</span><span class="p">,</span> <span class="n">dst_slice</span><span class="o">=</span><span class="n">dst_slice</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inc</span><span class="p">),</span>
            <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">src_sigr</span><span class="p">,</span> <span class="n">dst_sigr</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ElementwiseIncMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.ElementwiseIncMerger">[docs]</a><span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">ElementwiseInc</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ElementwiseIncMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge `.ElementwiseInc` ops.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="n">scalar_mult</span> <span class="o">=</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="n">non_scalar_mult</span> <span class="o">=</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">scalar_mult</span> <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">non_scalar_mult</span>
                    <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">==</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">)</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">X_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">ElementwiseInc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">A_sigr</span><span class="p">,</span> <span class="n">X_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">))</span></div>


<div class="viewcode-block" id="DotIncMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.DotIncMerger">[docs]</a><span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">DotInc</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DotIncMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge `.DotInc` ops.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="n">none_shared</span> <span class="o">=</span> <span class="n">Merger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">X</span>
        <span class="p">)</span>
        <span class="n">all_x_shared</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span><span class="o">.</span><span class="n">A</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span>
            <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">Y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">X</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">Y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">none_shared</span> <span class="ow">or</span> <span class="n">all_x_shared</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">op1</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">:</span>
            <span class="c1"># simple merge might be possible</span>
            <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span> <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

        <span class="c1"># check if BSR merge is possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Not using check() for A, because A must not be a view.</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>
            <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>
                <span class="n">bsr_matrix</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">assert</span> <span class="n">bsr_matrix</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Skipping some optimization steps because SciPy is &quot;</span>
                <span class="s2">&quot;not installed. Installing SciPy may result in &quot;</span>
                <span class="s2">&quot;faster simulations.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="c1"># Simple merge if all X are the same.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">DotInc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">A_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">))</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">o2</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="k">for</span> <span class="n">o2</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>

        <span class="c1"># BSR merge if X differ</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">X_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>

        <span class="c1"># Construct sparse A representation</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rc</span><span class="o">.</span><span class="n">float_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;A.ndim should be &gt; 2&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;A.ndim should be &gt; 2&quot;</span><span class="p">)</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rc</span><span class="o">.</span><span class="n">int_dtype</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rc</span><span class="o">.</span><span class="n">int_dtype</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bsr_merged&lt;</span><span class="si">{first}</span><span class="s2">, ..., </span><span class="si">{last}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">first</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
        <span class="n">readonly</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="n">readonly</span><span class="p">)</span>
        <span class="n">A_sigr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]):</span>
            <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%i</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                <span class="n">base</span><span class="o">=</span><span class="n">A</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">i</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">reshape</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">reshape_dot</span><span class="p">(</span>
            <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span>
            <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span>
            <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">op</span><span class="o">.</span><span class="n">BsrDotInc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="o">=</span><span class="n">indptr</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="n">reshape</span><span class="p">),</span>
            <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">X_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">,</span> <span class="n">A_sigr</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SimNeuronsMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SimNeuronsMerger">[docs]</a><span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">SimNeurons</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SimNeuronsMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge `.SimNeurons` ops.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op1</span><span class="o">.</span><span class="n">neurons</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">neurons</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">all_signals</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">J</span><span class="p">,</span> <span class="n">J_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">J</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">state_sigr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">state_sigs</span><span class="p">:</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">st_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">sets</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">state_sigs</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
            <span class="n">state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
            <span class="n">state_sigr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">st_sigr</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">state_extra</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">state_extra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Extra state has been modified when merging two or more SimNeurons &quot;</span>
                <span class="s2">&quot;ops associated with </span><span class="si">%r</span><span class="s2"> neuron types. If this causes issues, turn off &quot;</span>
                <span class="s2">&quot;the optimizer.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">SimNeurons</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">),</span>
            <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">J_sigr</span><span class="p">,</span> <span class="n">state_sigr</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SigMerger"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger">[docs]</a><span class="k">class</span> <span class="nc">SigMerger</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Merge signals.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SigMerger.check"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.check">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signals can be concatenated along a given axis.</span>

<span class="sd">        For views, this includes also a check that the signals have a common</span>
<span class="sd">        base and agree on the strides.</span>

<span class="sd">        In comparison to the ``check_*`` functions, this function  does</span>
<span class="sd">        not throw exceptions and allows for either signals or signal views.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">signals</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signals</span><span class="p">):</span>
            <span class="c1"># Signal appears twice in list.</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mix of signals and not signals</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we haven&#39;t failed yet, then the signals are compatible</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SigMerger.check_signals"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.check_signals">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signals can be merged along a given axis.</span>

<span class="sd">        If this is not possible, or any signals are views, a</span>
<span class="sd">        ``ValueError`` will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge views.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sparse</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge sparse Signals&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have the same number of dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;0-d signals must have the same initial value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have same shape except on concatenation axis.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have the same dtype.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SigMerger.check_views"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.check_views">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signal views can be merged along a given axis.</span>

<span class="sd">        If this is not possible, or any signals are not views,</span>
<span class="sd">        a ``ValueError`` will be raised.</span>

<span class="sd">        ``signals`` must be ordered by the offset into the base signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge non-views.&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must share the same base.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have the same number of dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">strides</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have equal strides.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have same shape except on concatenation axis.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Views are not sequential.&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">nbytes</span></div>

<div class="viewcode-block" id="SigMerger.merge"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.merge">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signals or signal views into one contiguous signal.</span>

<span class="sd">        Note that if any of the signals are linked to another signal (by being</span>
<span class="sd">        the base of a view), the merged signal will not reflect those links</span>
<span class="sd">        anymore.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must not contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">are_views</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_views</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_views</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge mixed views and non-views.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SigMerger.merge_signals"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.merge_signals">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signal into one contiguous signal.</span>

<span class="sd">        Note that if any of the signals are linked to another signal (by being</span>
<span class="sd">        the base of a view), the merged signal will not reflect</span>
<span class="sd">        those links anymore.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must not contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span>
        <span class="n">readonly</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;merged&lt;&quot;</span> <span class="o">+</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;, ..., &quot;</span> <span class="o">+</span> <span class="n">signals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="n">merged_signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="n">readonly</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="n">indexing</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">initial_value</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">indexing</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_signal</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexing</span><span class="p">)]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">merged_signal</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">merged_signal</span><span class="p">,</span> <span class="n">replacements</span></div>

<div class="viewcode-block" id="SigMerger.merge_views"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.SigMerger.merge_views">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signal views into one contiguous signal view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must only contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># abs_offset = min(s.abs_offset for s in signals)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">),)</span>
            <span class="o">+</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="p">)</span>
        <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">merged_signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span>
            <span class="n">initial_value</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">,</span>
            <span class="n">readonly</span><span class="o">=</span><span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">),</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_signal</span><span class="p">,</span> <span class="p">{}</span></div></div>


<div class="viewcode-block" id="groupby"><a class="viewcode-back" href="../../../backend-api.html#nengo.builder.optimizer.groupby">[docs]</a><span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Groups the given list by the value returned by ``keyfunc``.</span>

<span class="sd">    Similar to ``itertools.groupby``, but returns a dict, and does not depend</span>
<span class="sd">    on the order of the input list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">keyfunc</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span></div>
</pre></div>

            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div><footer class="text-light footer-main gradient-bottom">
  <p class="small text-center mb-0">
    <a class="no-hover-line" href="https://appliedbrainresearch.com">
      <img
        src="https://appliedbrainresearch.com/img/logo-blue-notext.svg"
        height="48"
      />
    </a>
    <a href="https://www.nengo.ai/">What is Nengo?</a>
    <a href="https://www.nengo.ai/examples/">Examples</a>
    <a href="https://www.nengo.ai/documentation/">Documentation</a>
    <a href="https://www.nengo.ai/getting-started/">Getting started</a>
    <a href="https://www.nengo.ai/privacy/">Privacy</a>
  </p>
  <p class="small text-center mb-0">&copy; Applied Brain Research</p>
</footer>
<script>
  var elements = document.querySelectorAll('.sidenav');
  Stickyfill.add(elements);
</script>
<script>
  ScrollReveal().reveal(".fade-in", {
      scale: 0.85,
      duration: 1000,
      delay: 250,
      interval: 50
  });
</script>
<script>
  $('a.toggle-sidenav').on('click', function(e) {
    e.preventDefault();
    if ( $(this).hasClass('active') ) {
      $(this).removeClass('active');
      $('.sidenav').removeClass('open');
    } else {
      $(this).addClass('active');
      $('.sidenav').addClass('open');
    }
  });
</script>
<script>
  var lists = document.querySelectorAll('.toctree ul');
  lists.forEach((ul) => {
      ul.classList.add("nav");
  });
  var links = document.querySelectorAll('.toctree a');
  links.forEach((link) => {
      link.classList.add("nav-link");
  });
  $("body").scrollspy({target: ".sidenav"});
</script>
  </body>
</html>