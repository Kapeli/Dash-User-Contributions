<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Using Hooks &mdash; The Pyramid Web Framework v1.5</title>
    
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="The Pyramid Web Framework v1.5" href="../index.html" />
    <link rel="next" title="Pyramid Configuration Introspection" href="introspector.html" />
    <link rel="prev" title="Invoking a Subrequest" href="subrequest.html" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head>
  <body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="introspector.html" title="Pyramid Configuration Introspection"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="subrequest.html" title="Invoking a Subrequest"
             accesskey="P">previous</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="using-hooks">
<span id="hooks-chapter"></span><h1>Using Hooks<a class="headerlink" href="#using-hooks" title="Permalink to this headline">¶</a></h1>
<p>&quot;Hooks&quot; can be used to influence the behavior of the <span>Pyramid</span> framework
in various ways.</p>
<div class="section" id="changing-the-not-found-view">
<span id="changing-the-notfound-view"></span><span id="index-0"></span><h2>Changing the Not Found View<a class="headerlink" href="#changing-the-not-found-view" title="Permalink to this headline">¶</a></h2>
<p>When <span>Pyramid</span> can't map a URL to view code, it invokes a <a class="reference internal" href="../glossary.html#term-not-found-view"><em class="xref std std-term">Not
Found View</em></a>, which is a <a class="reference internal" href="../glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a>. The default Not Found View
can be overridden through application configuration.</p>
<p>If your application uses <a class="reference internal" href="../glossary.html#term-imperative-configuration"><em class="xref std std-term">imperative configuration</em></a>, you can replace
the Not Found View by using the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></tt></a> method:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Not Found, dude&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_notfound_view</span><span class="p">(</span><span class="n">notfound</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The <a class="reference internal" href="../glossary.html#term-not-found-view"><em class="xref std std-term">Not Found View</em></a> callable is a view callable like any other.</p>
<p>If your application instead uses <a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.view_config</span></tt></a> decorators
and a <a class="reference internal" href="../glossary.html#term-scan"><em class="xref std std-term">scan</em></a>, you can replace the Not Found View by using the
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.notfound_view_config</span></tt></a> decorator:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">notfound_view_config</span>

<span class="nd">@notfound_view_config</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Not Found, dude&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>This does exactly what the imperative example above showed.</p>
<p>Your application can define <em>multiple</em> Not Found Views if necessary.  Both
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></tt></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.notfound_view_config</span></tt></a> take most of the same arguments as
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.config.Configurator.add_view</span></tt></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.view_config</span></tt></a>, respectively.  This means that Not Found
Views can carry predicates limiting their applicability.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">notfound_view_config</span>

<span class="nd">@notfound_view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s">&#39;GET&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notfound_get</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Not Found during GET, dude&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="nd">@notfound_view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notfound_post</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Not Found during POST, dude&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
   <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">notfound_get</span></tt> view will be called when a view could not be found and
the request method was <tt class="docutils literal"><span class="pre">GET</span></tt>.  The <tt class="docutils literal"><span class="pre">notfound_post</span></tt> view will be called
when a view could not be found and the request method was <tt class="docutils literal"><span class="pre">POST</span></tt>.</p>
<p>Like any other view, the Not Found View must accept at least a <tt class="docutils literal"><span class="pre">request</span></tt>
parameter, or both <tt class="docutils literal"><span class="pre">context</span></tt> and <tt class="docutils literal"><span class="pre">request</span></tt>.  The <tt class="docutils literal"><span class="pre">request</span></tt> is the
current <a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a> representing the denied action.  The <tt class="docutils literal"><span class="pre">context</span></tt> (if
used in the call signature) will be the instance of the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><tt class="xref py py-exc docutils literal"><span class="pre">HTTPNotFound</span></tt></a> exception that caused the view to
be called.</p>
<p>Both <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></tt></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.notfound_view_config</span></tt></a> can be used to automatically
redirect requests to slash-appended routes. See
<a class="reference internal" href="urldispatch.html#redirecting-to-slash-appended-routes"><em>Redirecting to Slash-Appended Routes</em></a> for examples.</p>
<p>Here's some sample code that implements a minimal <a class="reference internal" href="../glossary.html#term-not-found-view"><em class="xref std std-term">Not Found View</em></a>
callable:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.httpexceptions</span> <span class="kn">import</span> <span class="n">HTTPNotFound</span>

<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HTTPNotFound</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When a Not Found View callable is invoked, it is passed a
<a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a>.  The <tt class="docutils literal"><span class="pre">exception</span></tt> attribute of the request will be an
instance of the <a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><tt class="xref py py-exc docutils literal"><span class="pre">HTTPNotFound</span></tt></a> exception that
caused the Not Found View to be called.  The value of
<tt class="docutils literal"><span class="pre">request.exception.message</span></tt> will be a value explaining why the Not Found
error was raised.  This message has different values depending whether the
<tt class="docutils literal"><span class="pre">pyramid.debug_notfound</span></tt> environment setting is true or false.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></tt></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.notfound_view_config</span></tt></a> are new as of Pyramid 1.3.
Older Pyramid documentation instructed users to use <tt class="docutils literal"><span class="pre">add_view</span></tt> instead,
with a <tt class="docutils literal"><span class="pre">context</span></tt> of <tt class="docutils literal"><span class="pre">HTTPNotFound</span></tt>.  This still works; the convenience
method and decorator are just wrappers around this functionality.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When a Not Found View callable accepts an argument list as
described in <a class="reference internal" href="views.html#request-and-context-view-definitions"><em>Alternate View Callable Argument/Calling Conventions</em></a>, the <tt class="docutils literal"><span class="pre">context</span></tt>
passed as the first argument to the view callable will be the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><tt class="xref py py-exc docutils literal"><span class="pre">HTTPNotFound</span></tt></a> exception instance.  If
available, the resource context will still be available as
<tt class="docutils literal"><span class="pre">request.context</span></tt>.</p>
</div>
</div>
<div class="section" id="changing-the-forbidden-view">
<span id="index-1"></span><span id="id1"></span><h2>Changing the Forbidden View<a class="headerlink" href="#changing-the-forbidden-view" title="Permalink to this headline">¶</a></h2>
<p>When <span>Pyramid</span> can't authorize execution of a view based on the
<a class="reference internal" href="../glossary.html#term-authorization-policy"><em class="xref std std-term">authorization policy</em></a> in use, it invokes a <a class="reference internal" href="../glossary.html#term-forbidden-view"><em class="xref std std-term">forbidden view</em></a>.
The default forbidden response has a 403 status code and is very plain, but
the view which generates it can be overridden as necessary.</p>
<p>The <a class="reference internal" href="../glossary.html#term-forbidden-view"><em class="xref std std-term">forbidden view</em></a> callable is a view callable like any other.  The
<a class="reference internal" href="../glossary.html#term-view-configuration"><em class="xref std std-term">view configuration</em></a> which causes it to be a &quot;forbidden&quot; view consists
of using the <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_forbidden_view" title="pyramid.config.Configurator.add_forbidden_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_forbidden_view()</span></tt></a> API or the
<a class="reference internal" href="../api/view.html#pyramid.view.forbidden_view_config" title="pyramid.view.forbidden_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.forbidden_view_config</span></tt></a> decorator.</p>
<p>For example, you can add a forbidden view by using the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_forbidden_view" title="pyramid.config.Configurator.add_forbidden_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_forbidden_view()</span></tt></a> method to register a
forbidden view:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;forbidden&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_forbidden_view</span><span class="p">(</span><span class="n">forbidden_view</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If instead you prefer to use decorators and a <a class="reference internal" href="../glossary.html#term-scan"><em class="xref std std-term">scan</em></a>, you can use the
<a class="reference internal" href="../api/view.html#pyramid.view.forbidden_view_config" title="pyramid.view.forbidden_view_config"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.view.forbidden_view_config</span></tt></a> decorator to mark a view callable
as a forbidden view:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">forbidden_view_config</span>

<span class="nd">@forbidden_view_config</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;forbidden&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
   <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Like any other view, the forbidden view must accept at least a <tt class="docutils literal"><span class="pre">request</span></tt>
parameter, or both <tt class="docutils literal"><span class="pre">context</span></tt> and <tt class="docutils literal"><span class="pre">request</span></tt>.  If a forbidden view
callable accepts both <tt class="docutils literal"><span class="pre">context</span></tt> and <tt class="docutils literal"><span class="pre">request</span></tt>, the HTTP Exception is passed
as context. The <tt class="docutils literal"><span class="pre">context</span></tt> as found by the router when view was
denied (that you normally would expect) is available as
<tt class="docutils literal"><span class="pre">request.context</span></tt>.  The <tt class="docutils literal"><span class="pre">request</span></tt> is the  current <a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a>
representing the denied action.</p>
<p>Here's some sample code that implements a minimal forbidden view:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">forbidden_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;forbidden&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When a forbidden view callable is invoked, it is passed a
<a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a>.  The <tt class="docutils literal"><span class="pre">exception</span></tt> attribute of the request will be an
instance of the <a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPForbidden" title="pyramid.httpexceptions.HTTPForbidden"><tt class="xref py py-exc docutils literal"><span class="pre">HTTPForbidden</span></tt></a> exception
that caused the forbidden view to be called.  The value of
<tt class="docutils literal"><span class="pre">request.exception.message</span></tt> will be a value explaining why the forbidden
was raised and <tt class="docutils literal"><span class="pre">request.exception.result</span></tt> will be extended information
about the forbidden exception.  These messages have different values
depending whether the <tt class="docutils literal"><span class="pre">pyramid.debug_authorization</span></tt> environment setting
is true or false.</p>
</div>
</div>
<div class="section" id="changing-the-request-factory">
<span id="index-2"></span><span id="id2"></span><h2>Changing the Request Factory<a class="headerlink" href="#changing-the-request-factory" title="Permalink to this headline">¶</a></h2>
<p>Whenever <span>Pyramid</span> handles a request from a <a class="reference internal" href="../glossary.html#term-wsgi"><em class="xref std std-term">WSGI</em></a> server, it
creates a <a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a> object based on the WSGI environment it has been
passed.  By default, an instance of the <a class="reference internal" href="../api/request.html#pyramid.request.Request" title="pyramid.request.Request"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.request.Request</span></tt></a>
class is created to represent the request object.</p>
<p>The class (aka &quot;factory&quot;) that <span>Pyramid</span> uses to create a request object
instance can be changed by passing a <tt class="docutils literal"><span class="pre">request_factory</span></tt> argument to the
constructor of the <a class="reference internal" href="../glossary.html#term-configurator"><em class="xref std std-term">configurator</em></a>.  This argument can be either a
callable or a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python name</em></a> representing a callable.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">class</span> <span class="nc">MyRequest</span><span class="p">(</span><span class="n">Request</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">(</span><span class="n">request_factory</span><span class="o">=</span><span class="n">MyRequest</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If you're doing imperative configuration, and you'd rather do it after you've
already constructed a <a class="reference internal" href="../glossary.html#term-configurator"><em class="xref std std-term">configurator</em></a> it can also be registered via the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_request_factory" title="pyramid.config.Configurator.set_request_factory"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.set_request_factory()</span></tt></a> method:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">class</span> <span class="nc">MyRequest</span><span class="p">(</span><span class="n">Request</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">set_request_factory</span><span class="p">(</span><span class="n">MyRequest</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="adding-methods-or-properties-to-request-object">
<span id="adding-request-method"></span><span id="index-3"></span><h2>Adding Methods or Properties to Request Object<a class="headerlink" href="#adding-methods-or-properties-to-request-object" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4..</span></p>
</div>
<p>Since each Pyramid application can only have one <a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a> factory,
<a class="reference internal" href="#changing-the-request-factory"><em>changing the request factory</em></a>
is not that extensible, especially if you want to build composable features
(e.g., Pyramid add-ons and plugins).</p>
<p>A lazy property can be registered to the request object via the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_request_method" title="pyramid.config.Configurator.add_request_method"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_request_method()</span></tt></a> API. This allows you
to specify a callable that will be available on the request object, but will not
actually execute the function until accessed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will silently override methods and properties from <a class="reference internal" href="../glossary.html#term-request-factory"><em class="xref std std-term">request
factory</em></a> that have the same name.</p>
</div>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;getting the property&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">&quot;the property&quot;</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, <tt class="docutils literal"><span class="pre">total</span></tt> is added as a method. However, <tt class="docutils literal"><span class="pre">prop</span></tt> is added
as a property and its result is cached per-request by setting <tt class="docutils literal"><span class="pre">reify=True</span></tt>.
This way, we eliminate the overhead of running the function multiple times.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">prop</span>
<span class="go">getting the property</span>
<span class="go">the property</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">prop</span>
<span class="go">the property</span>
</pre></div>
</div>
<p>To not cache the result of <tt class="docutils literal"><span class="pre">request.prop</span></tt>, set <tt class="docutils literal"><span class="pre">property=True</span></tt> instead of
<tt class="docutils literal"><span class="pre">reify=True</span></tt>.</p>
<p>Here is an example of passing a class to <tt class="docutils literal"><span class="pre">Configurator.add_request_method</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.decorator</span> <span class="kn">import</span> <span class="n">reify</span>

<span class="k">class</span> <span class="nc">ExtraStuff</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span>

    <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># use @property if you don&#39;t want to cache the result</span>
    <span class="nd">@reify</span>
    <span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;getting the property&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;the property&quot;</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">ExtraStuff</span><span class="p">,</span> <span class="s">&#39;extra&#39;</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>We attach and cache an object named <tt class="docutils literal"><span class="pre">extra</span></tt> to the <tt class="docutils literal"><span class="pre">request</span></tt> object.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">prop</span>
<span class="go">getting the property</span>
<span class="go">the property</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">prop</span>
<span class="go">the property</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-before-render-event">
<span id="beforerender-event"></span><span id="index-4"></span><h2>Using The Before Render Event<a class="headerlink" href="#using-the-before-render-event" title="Permalink to this headline">¶</a></h2>
<p>Subscribers to the <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.BeforeRender</span></tt></a> event may introspect
and modify the set of <a class="reference internal" href="../glossary.html#term-renderer-globals"><em class="xref std std-term">renderer globals</em></a> before they are passed to a
<a class="reference internal" href="../glossary.html#term-renderer"><em class="xref std std-term">renderer</em></a>.  This event object iself has a dictionary-like interface
that can be used for this purpose.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>
<span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">BeforeRender</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">BeforeRender</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_global</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="p">[</span><span class="s">&#39;mykey&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span>
</pre></div>
</td></tr></table></div>
<p>An object of this type is sent as an event just before a <a class="reference internal" href="../glossary.html#term-renderer"><em class="xref std std-term">renderer</em></a>
is invoked.</p>
<p>If a subscriber attempts to add a key that already exist in the renderer
globals dictionary, a <a class="reference external" href="http://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.4)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> is raised.  This limitation is enforced
because event subscribers do not possess any relative ordering.  The set of
keys added to the renderer globals dictionary by all
<a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.BeforeRender</span></tt></a> subscribers and renderer globals
factories must be unique.</p>
<p>The dictionary returned from the view is accessible through the
<tt class="xref py py-attr docutils literal"><span class="pre">rendering_val</span></tt> attribute of a <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">BeforeRender</span></tt></a>
event.</p>
<p>Suppose you return <tt class="docutils literal"><span class="pre">{'mykey':</span> <span class="pre">'somevalue',</span> <span class="pre">'mykey2':</span> <span class="pre">'somevalue2'}</span></tt> from
your view callable, like so:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">renderer</span><span class="o">=</span><span class="s">&#39;some_renderer&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;mykey&#39;</span><span class="p">:</span> <span class="s">&#39;somevalue&#39;</span><span class="p">,</span> <span class="s">&#39;mykey2&#39;</span><span class="p">:</span> <span class="s">&#39;somevalue2&#39;</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">rendering_val</span></tt> can be used to access these values from the
<a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">BeforeRender</span></tt></a> object:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>
<span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">BeforeRender</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">BeforeRender</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_return</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c"># {&#39;mykey&#39;: &#39;somevalue&#39;} is returned from the view</span>
    <span class="k">print</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">rendering_val</span><span class="p">[</span><span class="s">&#39;mykey&#39;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
<p>See the API documentation for the <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">BeforeRender</span></tt></a> event
interface at <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IBeforeRender" title="pyramid.interfaces.IBeforeRender"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.interfaces.IBeforeRender</span></tt></a>.</p>
</div>
<div class="section" id="using-response-callbacks">
<span id="index-5"></span><span id="id3"></span><h2>Using Response Callbacks<a class="headerlink" href="#using-response-callbacks" title="Permalink to this headline">¶</a></h2>
<p>Unlike many other web frameworks, <span>Pyramid</span> does not eagerly create a
global response object.  Adding a <a class="reference internal" href="../glossary.html#term-response-callback"><em class="xref std std-term">response callback</em></a> allows an
application to register an action to be performed against whatever response
object is returned by a view, usually in order to mutate the response.</p>
<p>The <a class="reference internal" href="../api/request.html#pyramid.request.Request.add_response_callback" title="pyramid.request.Request.add_response_callback"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.request.Request.add_response_callback()</span></tt></a> method is used to
register a response callback.</p>
<p>A response callback is a callable which accepts two positional parameters:
<tt class="docutils literal"><span class="pre">request</span></tt> and <tt class="docutils literal"><span class="pre">response</span></tt>.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">cache_callback</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the cache_control max_age for the response&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">exception</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">cache_control</span><span class="o">.</span><span class="n">max_age</span> <span class="o">=</span> <span class="mi">360</span>
<span class="n">request</span><span class="o">.</span><span class="n">add_response_callback</span><span class="p">(</span><span class="n">cache_callback</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>No response callback is called if an unhandled exception happens in
application code, or if the response object returned by a <a class="reference internal" href="../glossary.html#term-view-callable"><em class="xref std std-term">view
callable</em></a> is invalid.  Response callbacks <em>are</em>, however, invoked when a
<a class="reference internal" href="../glossary.html#term-exception-view"><em class="xref std std-term">exception view</em></a> is rendered successfully: in such a case, the
<tt class="xref py py-attr docutils literal"><span class="pre">request.exception</span></tt> attribute of the request when it enters a response
callback will be an exception object instead of its default value of
<tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>Response callbacks are called in the order they're added
(first-to-most-recently-added).  All response callbacks are called <em>before</em>
the <a class="reference internal" href="../api/events.html#pyramid.events.NewResponse" title="pyramid.events.NewResponse"><tt class="xref py py-class docutils literal"><span class="pre">NewResponse</span></tt></a> event is sent.  Errors raised by
response callbacks are not handled specially.  They will be propagated to the
caller of the <span>Pyramid</span> router application.</p>
<p>A response callback has a lifetime of a <em>single</em> request.  If you want a
response callback to happen as the result of <em>every</em> request, you must
re-register the callback into every new request (perhaps within a subscriber
of a <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><tt class="xref py py-class docutils literal"><span class="pre">NewRequest</span></tt></a> event).</p>
</div>
<div class="section" id="using-finished-callbacks">
<span id="index-6"></span><span id="id4"></span><h2>Using Finished Callbacks<a class="headerlink" href="#using-finished-callbacks" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="../glossary.html#term-finished-callback"><em class="xref std std-term">finished callback</em></a> is a function that will be called unconditionally
by the <span>Pyramid</span> <a class="reference internal" href="../glossary.html#term-router"><em class="xref std std-term">router</em></a> at the very end of request processing.
A finished callback can be used to perform an action at the end of a request
unconditionally.</p>
<p>The <a class="reference internal" href="../api/request.html#pyramid.request.Request.add_finished_callback" title="pyramid.request.Request.add_finished_callback"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.request.Request.add_finished_callback()</span></tt></a> method is used to
register a finished callback.</p>
<p>A finished callback is a callable which accepts a single positional
parameter: <tt class="docutils literal"><span class="pre">request</span></tt>.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">logging</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">log_callback</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log information at the end of request&quot;&quot;&quot;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Request is finished.&#39;</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">add_finished_callback</span><span class="p">(</span><span class="n">log_callback</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Finished callbacks are called in the order they're added
(first-to-most-recently-added).  Finished callbacks (unlike a
<a class="reference internal" href="../glossary.html#term-response-callback"><em class="xref std std-term">response callback</em></a>) are <em>always</em> called, even if an exception
happens in application code that prevents a response from being
generated.</p>
<p>The set of finished callbacks associated with a request are called <em>very
late</em> in the processing of that request; they are essentially the very last
thing called by the <a class="reference internal" href="../glossary.html#term-router"><em class="xref std std-term">router</em></a> before a request &quot;ends&quot;. They are called
after response processing has already occurred in a top-level <tt class="docutils literal"><span class="pre">finally:</span></tt>
block within the router request processing code.  As a result, mutations
performed to the <tt class="docutils literal"><span class="pre">request</span></tt> provided to a finished callback will have no
meaningful effect, because response processing will have already occurred,
and the request's scope will expire almost immediately after all finished
callbacks have been processed.</p>
<p>Errors raised by finished callbacks are not handled specially.  They
will be propagated to the caller of the <span>Pyramid</span> router
application.</p>
<p>A finished callback has a lifetime of a <em>single</em> request.  If you want a
finished callback to happen as the result of <em>every</em> request, you must
re-register the callback into every new request (perhaps within a subscriber
of a <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><tt class="xref py py-class docutils literal"><span class="pre">NewRequest</span></tt></a> event).</p>
</div>
<div class="section" id="changing-the-traverser">
<span id="index-7"></span><span id="id5"></span><h2>Changing the Traverser<a class="headerlink" href="#changing-the-traverser" title="Permalink to this headline">¶</a></h2>
<p>The default <a class="reference internal" href="../glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> algorithm that <span>Pyramid</span> uses is explained
in <a class="reference internal" href="traversal.html#traversal-algorithm"><em>The Traversal Algorithm</em></a>.  Though it is rarely necessary, this default
algorithm can be swapped out selectively for a different traversal pattern
via configuration.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">Traverser</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_traverser</span><span class="p">(</span><span class="n">Traverser</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the example above, <tt class="docutils literal"><span class="pre">myapp.traversal.Traverser</span></tt> is assumed to be a class
that implements the following interface:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Traverser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Accept the root object returned from the root factory &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a dictionary with (at least) the keys ``root``,</span>
<span class="sd">        ``context``, ``view_name``, ``subpath``, ``traversed``,</span>
<span class="sd">        ``virtual_root``, and ``virtual_root_path``.  These values are</span>
<span class="sd">        typically the result of a resource tree traversal.  ``root``</span>
<span class="sd">        is the physical root object, ``context`` will be a resource</span>
<span class="sd">        object, ``view_name`` will be the view name used (a Unicode</span>
<span class="sd">        name), ``subpath`` will be a sequence of Unicode names that</span>
<span class="sd">        followed the view name but were not traversed, ``traversed``</span>
<span class="sd">        will be a sequence of Unicode names that were traversed</span>
<span class="sd">        (including the virtual root path, if any) ``virtual_root``</span>
<span class="sd">        will be a resource object representing the virtual root (or the</span>
<span class="sd">        physical root if traversal was not performed), and</span>
<span class="sd">        ``virtual_root_path`` will be a sequence representing the</span>
<span class="sd">        virtual root path (a sequence of Unicode names) or None if</span>
<span class="sd">        traversal was not performed.</span>

<span class="sd">        Extra keys for special purpose functionality can be added as</span>
<span class="sd">        necessary.</span>

<span class="sd">        All values returned in the dictionary will be made available</span>
<span class="sd">        as attributes of the ``request`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</pre></div>
</td></tr></table></div>
<p>More than one traversal algorithm can be active at the same time.  For
instance, if your <a class="reference internal" href="../glossary.html#term-root-factory"><em class="xref std std-term">root factory</em></a> returns more than one type of object
conditionally, you could claim that an alternate traverser adapter is &quot;for&quot;
only one particular class or interface.  When the root factory returned an
object that implemented that class or interface, a custom traverser would be
used.  Otherwise, the default traverser would be used.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">Traverser</span>
<span class="kn">from</span> <span class="nn">myapp.resources</span> <span class="kn">import</span> <span class="n">MyRoot</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_traverser</span><span class="p">(</span><span class="n">Traverser</span><span class="p">,</span> <span class="n">MyRoot</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If the above stanza was added to a Pyramid <tt class="docutils literal"><span class="pre">__init__.py</span></tt> file's <tt class="docutils literal"><span class="pre">main</span></tt>
function, <span>Pyramid</span> would use the <tt class="docutils literal"><span class="pre">myapp.traversal.Traverser</span></tt> only
when the application <a class="reference internal" href="../glossary.html#term-root-factory"><em class="xref std std-term">root factory</em></a> returned an instance of the
<tt class="docutils literal"><span class="pre">myapp.resources.MyRoot</span></tt> object.  Otherwise it would use the default
<span>Pyramid</span> traverser to do traversal.</p>
</div>
<div class="section" id="changing-how-pyramid-request-request-resource-url-generates-a-url">
<span id="changing-resource-url"></span><span id="index-8"></span><h2>Changing How <a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.request.Request.resource_url()</span></tt></a> Generates a URL<a class="headerlink" href="#changing-how-pyramid-request-request-resource-url-generates-a-url" title="Permalink to this headline">¶</a></h2>
<p>When you add a traverser as described in <a class="reference internal" href="#changing-the-traverser"><em>Changing the Traverser</em></a>, it's
often convenient to continue to use the
<a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.request.Request.resource_url()</span></tt></a> API.  However, since the way
traversal is done will have been modified, the URLs it generates by default
may be incorrect when used against resources derived from your custom
traverser.</p>
<p>If you've added a traverser, you can change how
<a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><tt class="xref py py-meth docutils literal"><span class="pre">resource_url()</span></tt></a> generates a URL for a specific
type of resource by adding a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_resource_url_adapter" title="pyramid.config.Configurator.add_resource_url_adapter"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_resource_url_adapter()</span></tt></a>.</p>
<p>For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">ResourceURLAdapter</span>
<span class="kn">from</span> <span class="nn">myapp.resources</span> <span class="kn">import</span> <span class="n">MyRoot</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_resource_url_adapter</span><span class="p">(</span><span class="n">ResourceURLAdapter</span><span class="p">,</span> <span class="n">MyRoot</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, the <tt class="docutils literal"><span class="pre">myapp.traversal.ResourceURLAdapter</span></tt> class will
be used to provide services to <a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><tt class="xref py py-meth docutils literal"><span class="pre">resource_url()</span></tt></a>
any time the <a class="reference internal" href="../glossary.html#term-resource"><em class="xref std std-term">resource</em></a> passed to <tt class="docutils literal"><span class="pre">resource_url</span></tt> is of the class
<tt class="docutils literal"><span class="pre">myapp.resources.MyRoot</span></tt>.  The <tt class="docutils literal"><span class="pre">resource_iface</span></tt> argument <tt class="docutils literal"><span class="pre">MyRoot</span></tt>
represents the type of interface that must be possessed by the resource for
this resource url factory to be found.  If the <tt class="docutils literal"><span class="pre">resource_iface</span></tt> argument is
omitted, this resource url adapter will be used for <em>all</em> resources.</p>
<p>The API that must be implemented by a class that provides
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResourceURL" title="pyramid.interfaces.IResourceURL"><tt class="xref py py-class docutils literal"><span class="pre">IResourceURL</span></tt></a> is as follows:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyResourceURL</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An adapter which provides the virtual and physical paths of a</span>
<span class="sd">        resource</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Accept the resource and request and set self.physical_path and</span>
<span class="sd">        self.virtual_path&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtual_path</span> <span class="o">=</span>  <span class="n">some_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physical_path</span> <span class="o">=</span>  <span class="n">some_other_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The default context URL generator is available for perusal as the class
<tt class="xref py py-class docutils literal"><span class="pre">pyramid.traversal.ResourceURL</span></tt> in the <a class="reference external" href="https://github.com/Pylons/pyramid/blob/master/pyramid/traversal.py">traversal module</a> of the
<a class="reference internal" href="../glossary.html#term-pylons"><em class="xref std std-term">Pylons</em></a> GitHub Pyramid repository.</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.add_resource_url_adapter()</span></tt> for more information.</p>
</div>
<div class="section" id="changing-how-pyramid-treats-view-responses">
<span id="using-iresponse"></span><span id="index-9"></span><h2>Changing How Pyramid Treats View Responses<a class="headerlink" href="#changing-how-pyramid-treats-view-responses" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<p>It is possible to control how Pyramid treats the result of calling a view
callable on a per-type basis by using a hook involving
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_response_adapter" title="pyramid.config.Configurator.add_response_adapter"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_response_adapter()</span></tt></a> or the
<a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><tt class="xref py py-class docutils literal"><span class="pre">response_adapter</span></tt></a> decorator.</p>
<p>Pyramid, in various places, adapts the result of calling a view callable to
the <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><tt class="xref py py-class docutils literal"><span class="pre">IResponse</span></tt></a> interface to ensure that the
object returned by the view callable is a &quot;true&quot; response object.  The vast
majority of time, the result of this adaptation is the result object itself,
as view callables written by &quot;civilians&quot; who read the narrative documentation
contained in this manual will always return something that implements the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><tt class="xref py py-class docutils literal"><span class="pre">IResponse</span></tt></a> interface.  Most typically, this will
be an instance of the <a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.response.Response</span></tt></a> class or a subclass.
If a civilian returns a non-Response object from a view callable that isn't
configured to use a <a class="reference internal" href="../glossary.html#term-renderer"><em class="xref std std-term">renderer</em></a>, he will typically expect the router to
raise an error.  However, you can hook Pyramid in such a way that users can
return arbitrary values from a view callable by providing an adapter which
converts the arbitrary return value into something that implements
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><tt class="xref py py-class docutils literal"><span class="pre">IResponse</span></tt></a>.</p>
<p>For example, if you'd like to allow view callables to return bare string
objects (without requiring a <a class="reference internal" href="../glossary.html#term-renderer"><em class="xref std std-term">renderer</em></a> to convert a string to a
response object), you can register an adapter which converts the string to a
Response:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">string_response_adapter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="c"># config is an instance of pyramid.config.Configurator</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">string_response_adapter</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Likewise, if you want to be able to return a simplified kind of response
object from view callables, you can use the IResponse hook to register an
adapter to the more complex IResponse interface:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">class</span> <span class="nc">SimpleResponse</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>

<span class="k">def</span> <span class="nf">simple_response_adapter</span><span class="p">(</span><span class="n">simple_response</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">simple_response</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="c"># config is an instance of pyramid.config.Configurator</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">simple_response_adapter</span><span class="p">,</span> <span class="n">SimpleResponse</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If you want to implement your own Response object instead of using the
<a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.response.Response</span></tt></a> object in any capacity at all, you'll have
to make sure the object implements every attribute and method outlined in
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.interfaces.IResponse</span></tt></a> and you'll have to ensure that it uses
<tt class="docutils literal"><span class="pre">zope.interface.implementer(IResponse)</span></tt> as a class decoratoror.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IResponse</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IResponse</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyResponse</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># ... an implementation of every method and attribute</span>
    <span class="c"># documented in IResponse should follow ...</span>
</pre></div>
</td></tr></table></div>
<p>When an alternate response object implementation is returned by a view
callable, if that object asserts that it implements
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><tt class="xref py py-class docutils literal"><span class="pre">IResponse</span></tt></a> (via
<tt class="docutils literal"><span class="pre">zope.interface.implementer(IResponse)</span></tt>) , an adapter needn't be registered
for the object; Pyramid will use it directly.</p>
<p>An IResponse adapter for <tt class="docutils literal"><span class="pre">webob.Response</span></tt> (as opposed to
<a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.response.Response</span></tt></a>) is registered by Pyramid by default at
startup time, as by their nature, instances of this class (and instances of
subclasses of the class) will natively provide IResponse.  The adapter
registered for <tt class="docutils literal"><span class="pre">webob.Response</span></tt> simply returns the response object.</p>
<p>Instead of using <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_response_adapter" title="pyramid.config.Configurator.add_response_adapter"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_response_adapter()</span></tt></a>,
you can use the <a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.response.response_adapter</span></tt></a> decorator:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">response_adapter</span>

<span class="nd">@response_adapter</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">string_response_adapter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</td></tr></table></div>
<p>The above example, when scanned, has the same effect as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">string_response_adapter</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><tt class="xref py py-class docutils literal"><span class="pre">response_adapter</span></tt></a> decorator will have no effect
until activated by a <a class="reference internal" href="../glossary.html#term-scan"><em class="xref std std-term">scan</em></a>.</p>
</div>
<div class="section" id="using-a-view-mapper">
<span id="index-10"></span><span id="id6"></span><h2>Using a View Mapper<a class="headerlink" href="#using-a-view-mapper" title="Permalink to this headline">¶</a></h2>
<p>The default calling conventions for view callables are documented in the
<a class="reference internal" href="views.html#views-chapter"><em>Views</em></a> chapter.  You can change the way users define view
callables by employing a <a class="reference internal" href="../glossary.html#term-view-mapper"><em class="xref std std-term">view mapper</em></a>.</p>
<p>A view mapper is an object that accepts a set of keyword arguments and which
returns a callable.  The returned callable is called with the <a class="reference internal" href="../glossary.html#term-view-callable"><em class="xref std std-term">view
callable</em></a> object.  The returned callable should itself return another
callable which can be called with the &quot;internal calling protocol&quot; <tt class="docutils literal"><span class="pre">(context,</span>
<span class="pre">request)</span></tt>.</p>
<p>You can use a view mapper in a number of ways:</p>
<ul class="simple">
<li>by setting a <tt class="docutils literal"><span class="pre">__view_mapper__</span></tt> attribute (which is the view mapper
object) on the view callable itself</li>
<li>by passing the mapper object to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_view()</span></tt></a> (or its declarative/decorator
equivalents) as the <tt class="docutils literal"><span class="pre">mapper</span></tt> argument.</li>
<li>by registering a <em>default</em> view mapper.</li>
</ul>
<p>Here's an example of a view mapper that emulates (somewhat) a Pylons
&quot;controller&quot;.  The mapper is initialized with some keyword arguments.  Its
<tt class="docutils literal"><span class="pre">__call__</span></tt> method accepts the view object (which will be a class).  It uses
the <tt class="docutils literal"><span class="pre">attr</span></tt> keyword argument it is passed to determine which attribute
should be used as an action method.  The wrapper method it returns accepts
<tt class="docutils literal"><span class="pre">(context,</span> <span class="pre">request)</span></tt> and returns the result of calling the action method
with keyword arguments implied by the <a class="reference internal" href="../glossary.html#term-matchdict"><em class="xref std std-term">matchdict</em></a> after popping the
<tt class="docutils literal"><span class="pre">action</span></tt> out of it.  This somewhat emulates the Pylons style of calling
action methods with routing parameters pulled out of the route matching dict
as keyword arguments.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># framework</span>

<span class="k">class</span> <span class="nc">PylonsControllerViewMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">[</span><span class="s">&#39;attr&#39;</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
            <span class="n">matchdict</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">matchdict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;action&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">view</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="o">**</span><span class="n">matchdict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">class</span> <span class="nc">BaseController</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__view_mapper__</span> <span class="o">=</span> <span class="n">PylonsControllerViewMapper</span>
</pre></div>
</td></tr></table></div>
<p>A user might make use of these framework components like so:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># user application</span>

<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">import</span> <span class="nn">pyramid_handlers</span>
<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>

<span class="k">class</span> <span class="nc">MyController</span><span class="p">(</span><span class="n">BaseController</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">pyramid_handlers</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s">&#39;one&#39;</span><span class="p">,</span> <span class="s">&#39;/{id}&#39;</span><span class="p">,</span> <span class="n">MyController</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s">&#39;two&#39;</span><span class="p">,</span> <span class="s">&#39;/{action}/{id}&#39;</span><span class="p">,</span> <span class="n">MyController</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">make_server</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">())</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>The <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_view_mapper" title="pyramid.config.Configurator.set_view_mapper"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.set_view_mapper()</span></tt></a> method can be used to
set a <em>default</em> view mapper (overriding the superdefault view mapper used by
Pyramid itself).</p>
<p>A <em>single</em> view registration can use a view mapper by passing the mapper as
the <tt class="docutils literal"><span class="pre">mapper</span></tt> argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><tt class="xref py py-meth docutils literal"><span class="pre">add_view()</span></tt></a>.</p>
</div>
<div class="section" id="registering-configuration-decorators">
<span id="index-11"></span><span id="id7"></span><h2>Registering Configuration Decorators<a class="headerlink" href="#registering-configuration-decorators" title="Permalink to this headline">¶</a></h2>
<p>Decorators such as <a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><tt class="xref py py-class docutils literal"><span class="pre">view_config</span></tt></a> don't change the
behavior of the functions or classes they're decorating.  Instead, when a
<a class="reference internal" href="../glossary.html#term-scan"><em class="xref std std-term">scan</em></a> is performed, a modified version of the function or class is
registered with <span>Pyramid</span>.</p>
<p>You may wish to have your own decorators that offer such behaviour. This is
possible by using the <a class="reference internal" href="../glossary.html#term-venusian"><em class="xref std std-term">Venusian</em></a> package in the same way that it is
used by <span>Pyramid</span>.</p>
<p>By way of example, let's suppose you want to write a decorator that registers
the function it wraps with a <a class="reference internal" href="../glossary.html#term-zope-component-architecture"><em class="xref std std-term">Zope Component Architecture</em></a> &quot;utility&quot;
within the <a class="reference internal" href="../glossary.html#term-application-registry"><em class="xref std std-term">application registry</em></a> provided by <span>Pyramid</span>. The
application registry and the utility inside the registry is likely only to be
available once your application's configuration is at least partially
completed. A normal decorator would fail as it would be executed before the
configuration had even begun.</p>
<p>However, using <a class="reference internal" href="../glossary.html#term-venusian"><em class="xref std std-term">Venusian</em></a>, the decorator could be written as
follows:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">venusian</span>
<span class="kn">from</span> <span class="nn">mypackage.interfaces</span> <span class="kn">import</span> <span class="n">IMyUtility</span>

<span class="k">class</span> <span class="nc">registerFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scanner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="n">registry</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">registry</span>
        <span class="n">registry</span><span class="o">.</span><span class="n">getUtility</span><span class="p">(</span><span class="n">IMyUtility</span><span class="p">)</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="n">venusian</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</td></tr></table></div>
<p>This decorator could then be used to register functions throughout
your code:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nd">@registerFunction</span><span class="p">(</span><span class="s">&#39;/some/path&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
   <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>However, the utility would only be looked up when a <a class="reference internal" href="../glossary.html#term-scan"><em class="xref std std-term">scan</em></a> was
performed, enabling you to set up the utility in advance:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">mypackage.interfaces</span> <span class="kn">import</span> <span class="n">IMyUtility</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IMyUtility</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">UtilityImplementation</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">registrations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">callable_</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">registrations</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">callable_</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">registerUtility</span><span class="p">(</span><span class="n">UtilityImplementation</span><span class="p">())</span>
    <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>For full details, please read the <a class="reference external" href="http://docs.repoze.org/venusian">Venusian documentation</a>.</p>
</div>
<div class="section" id="registering-tweens">
<span id="id8"></span><h2>Registering Tweens<a class="headerlink" href="#registering-tweens" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.2: </span>Tweens</p>
</div>
<p>A <a class="reference internal" href="../glossary.html#term-tween"><em class="xref std std-term">tween</em></a> (a contraction of the word &quot;between&quot;) is a bit of code that
sits between the Pyramid router's main request handling function and the
upstream WSGI component that uses <span>Pyramid</span> as its &quot;app&quot;.  This is a
feature that may be used by Pyramid framework extensions, to provide, for
example, Pyramid-specific view timing support bookkeeping code that examines
exceptions before they are returned to the upstream WSGI application.  Tweens
behave a bit like <a class="reference internal" href="../glossary.html#term-wsgi"><em class="xref std std-term">WSGI</em></a> <a class="reference internal" href="../glossary.html#term-middleware"><em class="xref std std-term">middleware</em></a> but they have the benefit of
running in a context in which they have access to the Pyramid <a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a>,
<a class="reference internal" href="../glossary.html#term-response"><em class="xref std std-term">response</em></a> and <a class="reference internal" href="../glossary.html#term-application-registry"><em class="xref std std-term">application registry</em></a> as well as the Pyramid
rendering machinery.</p>
<div class="section" id="creating-a-tween">
<h3>Creating a Tween<a class="headerlink" href="#creating-a-tween" title="Permalink to this headline">¶</a></h3>
<p>To create a tween, you must write a &quot;tween factory&quot;.  A tween factory
must be a globally importable callable which accepts two arguments:
<tt class="docutils literal"><span class="pre">handler</span></tt> and <tt class="docutils literal"><span class="pre">registry</span></tt>.  <tt class="docutils literal"><span class="pre">handler</span></tt> will be the either the main
Pyramid request handling function or another tween.  <tt class="docutils literal"><span class="pre">registry</span></tt> will be the
Pyramid <a class="reference internal" href="../glossary.html#term-application-registry"><em class="xref std std-term">application registry</em></a> represented by this Configurator.  A
tween factory must return the tween (a callable object) when it is called.</p>
<p>A tween is called with a single argument, <tt class="docutils literal"><span class="pre">request</span></tt>, which is the
<a class="reference internal" href="../glossary.html#term-request"><em class="xref std std-term">request</em></a> created by Pyramid's router when it receives a WSGI request.
A tween should return a <a class="reference internal" href="../glossary.html#term-response"><em class="xref std std-term">response</em></a>, usually the one generated by the
downstream Pyramid application.</p>
<p>You can write the tween factory as a simple closure-returning function:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">simple_tween_factory</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
    <span class="c"># one-time configuration code goes here</span>

    <span class="k">def</span> <span class="nf">simple_tween</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="c"># code to be executed for each request before</span>
        <span class="c"># the actual application code goes here</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c"># code to be executed for each request after</span>
        <span class="c"># the actual application code goes here</span>

        <span class="k">return</span> <span class="n">response</span>

    <span class="k">return</span> <span class="n">simple_tween</span>
</pre></div>
</td></tr></table></div>
<p>Alternatively, the tween factory can be a class with the <tt class="docutils literal"><span class="pre">__call__</span></tt> magic
method:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">simple_tween_factory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">registry</span>

        <span class="c"># one-time configuration code goes here</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c"># code to be executed for each request before</span>
        <span class="c"># the actual application code goes here</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c"># code to be executed for each request after</span>
        <span class="c"># the actual application code goes here</span>

        <span class="k">return</span> <span class="n">response</span>
</pre></div>
</td></tr></table></div>
<p>The closure style performs slightly better and enables you to conditionally
omit the tween from the request processing pipeline (see the following timing
tween example), whereas the class style makes it easier to have shared mutable
state, and it allows subclassing.</p>
<p>Here's a complete example of a tween that logs the time spent processing each
request:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># in a module named myapp.tweens</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pyramid.settings</span> <span class="kn">import</span> <span class="n">asbool</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">timing_tween_factory</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">asbool</span><span class="p">(</span><span class="n">registry</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;do_timing&#39;</span><span class="p">)):</span>
        <span class="c"># if timing support is enabled, return a wrapper</span>
        <span class="k">def</span> <span class="nf">timing_tween</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;The request took </span><span class="si">%s</span><span class="s"> seconds&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">response</span>
        <span class="k">return</span> <span class="n">timing_tween</span>
    <span class="c"># if timing support is not enabled, return the original</span>
    <span class="c"># handler</span>
    <span class="k">return</span> <span class="n">handler</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, the tween factory defines a <tt class="docutils literal"><span class="pre">timing_tween</span></tt> tween and
returns it if <tt class="docutils literal"><span class="pre">asbool(registry.settings.get('do_timing'))</span></tt> is true.  It
otherwise simply returns the handler it was given.  The <tt class="docutils literal"><span class="pre">registry.settings</span></tt>
attribute is a handle to the deployment settings provided by the user
(usually in an <tt class="docutils literal"><span class="pre">.ini</span></tt> file).  In this case, if the user has defined a
<tt class="docutils literal"><span class="pre">do_timing</span></tt> setting, and that setting is <tt class="docutils literal"><span class="pre">True</span></tt>, the user has said she
wants to do timing, so the tween factory returns the timing tween; it
otherwise just returns the handler it has been provided, preventing any
timing.</p>
<p>The example timing tween simply records the start time, calls the downstream
handler, logs the number of seconds consumed by the downstream handler, and
returns the response.</p>
</div>
<div class="section" id="registering-an-implicit-tween-factory">
<h3>Registering an Implicit Tween Factory<a class="headerlink" href="#registering-an-implicit-tween-factory" title="Permalink to this headline">¶</a></h3>
<p>Once you've created a tween factory, you can register it into the implicit
tween chain using the <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a> method
using its <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python name</em></a>.</p>
<p>Here's an example of registering a tween factory as an &quot;implicit&quot; tween in a
Pyramid application:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tweens.timing_tween_factory&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Note that you must use a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python name</em></a> as the first argument to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a>; this must point at a tween
factory.  You cannot pass the tween factory object itself to the method: it
must be <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python name</em></a> that points to a globally importable
object.  In the above example, we assume that a <tt class="docutils literal"><span class="pre">timing_tween_factory</span></tt>
tween factory was defined in a module named <tt class="docutils literal"><span class="pre">myapp.tweens</span></tt>, so the tween
factory is importable as <tt class="docutils literal"><span class="pre">myapp.tweens.timing_tween_factory</span></tt>.</p>
<p>When you use <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a>, you're
instructing the system to use your tween factory at startup time unless the
user has provided an explicit tween list in his configuration.  This is
what's meant by an &quot;implicit&quot; tween.  A user can always elect to supply an
explicit tween list, reordering or disincluding implicitly added tweens.  See
<a class="reference internal" href="#explicit-tween-ordering"><em>Explicit Tween Ordering</em></a> for more information about explicit tween
ordering.</p>
<p>If more than one call to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a> is
made within a single application configuration, the tweens will be chained
together at application startup time.  The <em>first</em> tween factory added via
<tt class="docutils literal"><span class="pre">add_tween</span></tt> will be called with the Pyramid exception view tween factory as
its <tt class="docutils literal"><span class="pre">handler</span></tt> argument, then the tween factory added directly after that
one will be called with the result of the first tween factory as its
<tt class="docutils literal"><span class="pre">handler</span></tt> argument, and so on, ad infinitum until all tween factories have
been called. The Pyramid router will use the outermost tween produced by this
chain (the tween generated by the very last tween factory added) as its
request handler function.  For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tween_factory1&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tween_factory2&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory2</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory1</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="suggesting-implicit-tween-ordering">
<h3>Suggesting Implicit Tween Ordering<a class="headerlink" href="#suggesting-implicit-tween-ordering" title="Permalink to this headline">¶</a></h3>
<p>By default, as described above, the ordering of the chain is controlled
entirely by the relative ordering of calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a>.  However, the caller of
add_tween can provide an optional hint that can influence the implicit tween
chain ordering by supplying <tt class="docutils literal"><span class="pre">under</span></tt> or <tt class="docutils literal"><span class="pre">over</span></tt> (or both) arguments to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">add_tween()</span></tt></a>.  These hints are only
used when an explicit tween ordering is not used. See
<a class="reference internal" href="#explicit-tween-ordering"><em>Explicit Tween Ordering</em></a> for a description of how to set an explicit
tween ordering.</p>
<p>Allowable values for <tt class="docutils literal"><span class="pre">under</span></tt> or <tt class="docutils literal"><span class="pre">over</span></tt> (or both) are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">None</span></tt> (the default).</li>
<li>A <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python name</em></a> to a tween factory: a string representing the
predicted dotted name of a tween factory added in a call to <tt class="docutils literal"><span class="pre">add_tween</span></tt>
in the same configuration session.</li>
<li>One of the constants <a class="reference internal" href="../api/tweens.html#pyramid.tweens.MAIN" title="pyramid.tweens.MAIN"><tt class="xref py py-attr docutils literal"><span class="pre">pyramid.tweens.MAIN</span></tt></a>,
<a class="reference internal" href="../api/tweens.html#pyramid.tweens.INGRESS" title="pyramid.tweens.INGRESS"><tt class="xref py py-attr docutils literal"><span class="pre">pyramid.tweens.INGRESS</span></tt></a>, or <a class="reference internal" href="../api/tweens.html#pyramid.tweens.EXCVIEW" title="pyramid.tweens.EXCVIEW"><tt class="xref py py-attr docutils literal"><span class="pre">pyramid.tweens.EXCVIEW</span></tt></a>.</li>
<li>An iterable of any combination of the above. This allows the user to specify
fallbacks if the desired tween is not included, as well as compatibility
with multiple other tweens.</li>
</ul>
<p>Effectively, <tt class="docutils literal"><span class="pre">over</span></tt> means &quot;closer to the request ingress than&quot; and
<tt class="docutils literal"><span class="pre">under</span></tt> means &quot;closer to the main Pyramid application than&quot;.
You can think of an onion with outer layers over the inner layers,
the application being under all the layers at the center.</p>
<p>For example, the following call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">add_tween()</span></tt></a> will attempt to place the
tween factory represented by <tt class="docutils literal"><span class="pre">myapp.tween_factory</span></tt> directly 'above' (in
<tt class="docutils literal"><span class="pre">ptweens</span></tt> order) the main Pyramid request handler.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyramid.tweens</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tween_factory&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, calling the following call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">add_tween()</span></tt></a> will attempt to place this
tween factory 'above' the main handler but 'below' a separately added tween
factory:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyramid.tweens</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tween_factory1&#39;</span><span class="p">,</span>
                 <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s">&#39;myapp.tween_factory2&#39;</span><span class="p">,</span>
                 <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">,</span>
                 <span class="n">under</span><span class="o">=</span><span class="s">&#39;myapp.tween_factory1&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory1</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory2</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
<p>Specifying neither <tt class="docutils literal"><span class="pre">over</span></tt> nor <tt class="docutils literal"><span class="pre">under</span></tt> is equivalent to specifying
<tt class="docutils literal"><span class="pre">under=INGRESS</span></tt>.</p>
<p>If all options for <tt class="docutils literal"><span class="pre">under</span></tt> (or <tt class="docutils literal"><span class="pre">over</span></tt>) cannot be found in the current
configuration, it is an error. If some options are specified purely for
compatibilty with other tweens, just add a fallback of MAIN or INGRESS.
For example, <tt class="docutils literal"><span class="pre">under=('someothertween',</span> <span class="pre">'someothertween2',</span> <span class="pre">INGRESS)</span></tt>.
This constraint will require the tween to be located under both the
'someothertween' tween, the 'someothertween2' tween, and INGRESS. If any of
these is not in the current configuration, this constraint will only organize
itself based on the tweens that are present.</p>
</div>
<div class="section" id="explicit-tween-ordering">
<span id="id9"></span><h3>Explicit Tween Ordering<a class="headerlink" href="#explicit-tween-ordering" title="Permalink to this headline">¶</a></h3>
<p>Implicit tween ordering is obviously only best-effort.  Pyramid will attempt
to provide an implicit order of tweens as best it can using hints provided by
calls to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">add_tween()</span></tt></a>, but because it's
only best-effort, if very precise tween ordering is required, the only
surefire way to get it is to use an explicit tween order.  The deploying user
can override the implicit tween inclusion and ordering implied by calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">add_tween()</span></tt></a> entirely by using the
<tt class="docutils literal"><span class="pre">pyramid.tweens</span></tt> settings value.  When used, this settings value must be a
list of Python dotted names which will override the ordering (and inclusion)
of tween factories in the implicit tween chain.  For example:</p>
<div class="highlight-ini"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">[app:main]</span>
<span class="na">use</span> <span class="o">=</span> <span class="s">egg:MyApp</span>
<span class="na">pyramid.reload_templates</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">pyramid.debug_authorization</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_notfound</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_routematch</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_templates</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">pyramid.tweens</span> <span class="o">=</span> <span class="s">myapp.my_cool_tween_factory</span>
<span class="s">                 pyramid.tweens.excview_tween_factory</span>
</pre></div>
</td></tr></table></div>
<p>In the above configuration, calls made during configuration to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a> are ignored, and the user is
telling the system to use the tween factories he has listed in the
<tt class="docutils literal"><span class="pre">pyramid.tweens</span></tt> configuration setting (each is a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted Python
name</em></a> which points to a tween factory) instead of any tween factories added
via <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a>.  The <em>first</em> tween factory
in the <tt class="docutils literal"><span class="pre">pyramid.tweens</span></tt> list will be used as the producer of the effective
<span>Pyramid</span> request handling function; it will wrap the tween factory
declared directly &quot;below&quot; it, ad infinitum.  The &quot;main&quot; Pyramid request
handler is implicit, and always &quot;at the bottom&quot;.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Pyramid's own <a class="reference internal" href="../glossary.html#term-exception-view"><em class="xref std std-term">exception view</em></a> handling logic is implemented
as a tween factory function: <a class="reference internal" href="../api/tweens.html#pyramid.tweens.excview_tween_factory" title="pyramid.tweens.excview_tween_factory"><tt class="xref py py-func docutils literal"><span class="pre">pyramid.tweens.excview_tween_factory()</span></tt></a>.
If Pyramid exception view handling is desired, and tween factories are
specified via the <tt class="docutils literal"><span class="pre">pyramid.tweens</span></tt> configuration setting, the
<a class="reference internal" href="../api/tweens.html#pyramid.tweens.excview_tween_factory" title="pyramid.tweens.excview_tween_factory"><tt class="xref py py-func docutils literal"><span class="pre">pyramid.tweens.excview_tween_factory()</span></tt></a> function must be added to the
<tt class="docutils literal"><span class="pre">pyramid.tweens</span></tt> configuration setting list explicitly.  If it is not
present, Pyramid will not perform exception view handling.</p>
</div>
</div>
<div class="section" id="tween-conflicts-and-ordering-cycles">
<h3>Tween Conflicts and Ordering Cycles<a class="headerlink" href="#tween-conflicts-and-ordering-cycles" title="Permalink to this headline">¶</a></h3>
<p>Pyramid will prevent the same tween factory from being added to the tween
chain more than once using configuration conflict detection.  If you wish to
add the same tween factory more than once in a configuration, you should
either: a) use a tween factory that is a separate globally importable
instance object from the factory that it conflicts with b) use a function or
class as a tween factory with the same logic as the other tween factory it
conflicts with but with a different <tt class="docutils literal"><span class="pre">__name__</span></tt> attribute or c) call
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.commit" title="pyramid.config.Configurator.commit"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.commit()</span></tt></a> between calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_tween()</span></tt></a>.</p>
<p>If a cycle is detected in implicit tween ordering when <tt class="docutils literal"><span class="pre">over</span></tt> and <tt class="docutils literal"><span class="pre">under</span></tt>
are used in any call to &quot;add_tween&quot;, an exception will be raised at startup
time.</p>
</div>
<div class="section" id="displaying-tween-ordering">
<h3>Displaying Tween Ordering<a class="headerlink" href="#displaying-tween-ordering" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">ptweens</span></tt> command-line utility can be used to report the current
implict and explicit tween chains used by an application.  See
<a class="reference internal" href="commandline.html#displaying-tweens"><em>Displaying &quot;Tweens&quot;</em></a>.</p>
</div>
</div>
<div class="section" id="adding-a-third-party-view-route-or-subscriber-predicate">
<span id="registering-thirdparty-predicates"></span><h2>Adding A Third Party View, Route, or Subscriber Predicate<a class="headerlink" href="#adding-a-third-party-view-route-or-subscriber-predicate" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.</span></p>
</div>
<div class="section" id="view-and-route-predicates">
<span id="id10"></span><h3>View and Route Predicates<a class="headerlink" href="#view-and-route-predicates" title="Permalink to this headline">¶</a></h3>
<p>View and route predicates used during configuration allow you to narrow the
set of circumstances under which a view or route will match.  For example,
the <tt class="docutils literal"><span class="pre">request_method</span></tt> view predicate can be used to ensure a view callable
is only invoked when the request's method is <tt class="docutils literal"><span class="pre">POST</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">someview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Likewise, a similar predicate can be used as a <em>route</em> predicate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;/foo&#39;</span><span class="p">,</span> <span class="n">request_method</span><span class="o">=</span><span class="s">&#39;POST&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Many other built-in predicates exists (<tt class="docutils literal"><span class="pre">request_param</span></tt>, and others).  You
can add third-party predicates to the list of available predicates by using
one of <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view_predicate" title="pyramid.config.Configurator.add_view_predicate"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_view_predicate()</span></tt></a> or
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_route_predicate" title="pyramid.config.Configurator.add_route_predicate"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_route_predicate()</span></tt></a>.  The former adds a
view predicate, the latter a route predicate.</p>
<p>When using one of those APIs, you pass a <em>name</em> and a <em>factory</em> to add a
predicate during Pyramid's configuration stage.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">config</span><span class="o">.</span><span class="n">add_view_predicate</span><span class="p">(</span><span class="s">&#39;content_type&#39;</span><span class="p">,</span> <span class="n">ContentTypePredicate</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example adds a new predicate named <tt class="docutils literal"><span class="pre">content_type</span></tt> to the list of
available predicates for views.  This will allow the following view
configuration statement to work:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nd">@view_config</span><span class="p">(</span><span class="n">content_type</span><span class="o">=</span><span class="s">&#39;File&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</td></tr></table></div>
<p>The first argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view_predicate" title="pyramid.config.Configurator.add_view_predicate"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_view_predicate()</span></tt></a>,
the name, is a string representing the name that is expected to be passed to
<tt class="docutils literal"><span class="pre">view_config</span></tt> (or its imperative analogue <tt class="docutils literal"><span class="pre">add_view</span></tt>).</p>
<p>The second argument is a view or route predicate factory, or a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><em class="xref std std-term">dotted
Python name</em></a> which refers to a view or route predicate factory.  A view or
route predicate factory is most often a class with a constructor
(<tt class="docutils literal"><span class="pre">__init__</span></tt>), a <tt class="docutils literal"><span class="pre">text</span></tt> method, a <tt class="docutils literal"><span class="pre">phash</span></tt> method and a <tt class="docutils literal"><span class="pre">__call__</span></tt>
method. For example:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ContentTypePredicate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;content_type = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,)</span>

    <span class="n">phash</span> <span class="o">=</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s">&#39;content_type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</pre></div>
</td></tr></table></div>
<p>The constructor of a predicate factory takes two arguments: <tt class="docutils literal"><span class="pre">val</span></tt> and
<tt class="docutils literal"><span class="pre">config</span></tt>.  The <tt class="docutils literal"><span class="pre">val</span></tt> argument will be the argument passed to
<tt class="docutils literal"><span class="pre">view_config</span></tt> (or <tt class="docutils literal"><span class="pre">add_view</span></tt>).  In the example above, it will be the
string <tt class="docutils literal"><span class="pre">File</span></tt>.  The second arg, <tt class="docutils literal"><span class="pre">config</span></tt> will be the Configurator
instance at the time of configuration.</p>
<p>The <tt class="docutils literal"><span class="pre">text</span></tt> method must return a string.  It should be useful to describe
the behavior of the predicate in error messages.</p>
<p>The <tt class="docutils literal"><span class="pre">phash</span></tt> method must return a string or a sequence of strings.  It's
most often the same as <tt class="docutils literal"><span class="pre">text</span></tt>, as long as <tt class="docutils literal"><span class="pre">text</span></tt> uniquely describes the
predicate's name and the value passed to the constructor.  If <tt class="docutils literal"><span class="pre">text</span></tt> is
more general, or doesn't describe things that way, <tt class="docutils literal"><span class="pre">phash</span></tt> should return a
string with the name and the value serialized.  The result of <tt class="docutils literal"><span class="pre">phash</span></tt> is
not seen in output anywhere, it just informs the uniqueness constraints for
view configuration.</p>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method of a predicate factory must accept a resource
(<tt class="docutils literal"><span class="pre">context</span></tt>) and a request, and must return <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.  It is
the &quot;meat&quot; of the predicate.</p>
<p>You can use the same predicate factory as both a view predicate and as a
route predicate, but you'll need to call <tt class="docutils literal"><span class="pre">add_view_predicate</span></tt> and
<tt class="docutils literal"><span class="pre">add_route_predicate</span></tt> separately with the same factory.</p>
</div>
<div class="section" id="subscriber-predicates">
<span id="id11"></span><h3>Subscriber Predicates<a class="headerlink" href="#subscriber-predicates" title="Permalink to this headline">¶</a></h3>
<p>Subscriber predicates work almost exactly like view and route predicates.
They narrow the set of circumstances in which a subscriber will be called.
There are several minor differences between a subscriber predicate and a
view/route predicate:</p>
<ul class="simple">
<li>There are no default subscriber predicates.  You must register one to use
one.</li>
<li>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method of a subscriber predicate accepts a single
<tt class="docutils literal"><span class="pre">event</span></tt> object instead of a <tt class="docutils literal"><span class="pre">context</span></tt> and a <tt class="docutils literal"><span class="pre">request</span></tt>.</li>
<li>Not every subscriber predicate can be used with every event type.  Some
subscriber predicates will assume a certain event type.</li>
</ul>
<p>Here's an example of a subscriber predicate that can be used in conjunction
with a subscriber that subscribes to the <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.NewRequest</span></tt></a>
event type.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">RequestPathStartsWith</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;path_startswith = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,)</span>

    <span class="n">phash</span> <span class="o">=</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Once you've created a subscriber predicate, it may registered via
<tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_subscriber_predicate()</span></tt>.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">config</span><span class="o">.</span><span class="n">add_subscriber_predicate</span><span class="p">(</span>
    <span class="s">&#39;request_path_startswith&#39;</span><span class="p">,</span> <span class="n">RequestPathStartsWith</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a subscriber predicate is registered, you can use it in a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_subscriber" title="pyramid.config.Configurator.add_subscriber"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_subscriber()</span></tt></a> or to
<a class="reference internal" href="../api/events.html#pyramid.events.subscriber" title="pyramid.events.subscriber"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.subscriber</span></tt></a>.  Here's an example of using the
previously registered <tt class="docutils literal"><span class="pre">request_path_startswith</span></tt> predicate in a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_subscriber" title="pyramid.config.Configurator.add_subscriber"><tt class="xref py py-meth docutils literal"><span class="pre">add_subscriber()</span></tt></a>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># define a subscriber in your code</span>

<span class="k">def</span> <span class="nf">yosubscriber</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="s">&#39;YO!&#39;</span>

<span class="c"># and at configuration time</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_subscriber</span><span class="p">(</span><span class="n">yosubscriber</span><span class="p">,</span> <span class="n">NewRequest</span><span class="p">,</span>
       <span class="n">request_path_startswith</span><span class="o">=</span><span class="s">&#39;/add_yo&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Here's the same subscriber/predicate/event-type combination used via
<a class="reference internal" href="../api/events.html#pyramid.events.subscriber" title="pyramid.events.subscriber"><tt class="xref py py-class docutils literal"><span class="pre">subscriber</span></tt></a>.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">NewRequest</span><span class="p">,</span> <span class="n">request_path_startswith</span><span class="o">=</span><span class="s">&#39;/add_yo&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">yosubscriber</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="s">&#39;YO!&#39;</span>
</pre></div>
</td></tr></table></div>
<p>In either of the above configurations, the <tt class="docutils literal"><span class="pre">yosubscriber</span></tt> callable will
only be called if the request path starts with <tt class="docutils literal"><span class="pre">/add_yo</span></tt>.  Otherwise the
event subscriber will not be called.</p>
<p>Note that the <tt class="docutils literal"><span class="pre">request_path_startswith</span></tt> subscriber you defined can be used
with events that have a <tt class="docutils literal"><span class="pre">request</span></tt> attribute, but not ones that do not.  So,
for example, the predicate can be used with subscribers registered for
<a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.NewRequest</span></tt></a> and <a class="reference internal" href="../api/events.html#pyramid.events.ContextFound" title="pyramid.events.ContextFound"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.ContextFound</span></tt></a>
events, but it cannot be used with subscribers registered for
<a class="reference internal" href="../api/events.html#pyramid.events.ApplicationCreated" title="pyramid.events.ApplicationCreated"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.events.ApplicationCreated</span></tt></a> because the latter type of event
has no <tt class="docutils literal"><span class="pre">request</span></tt> attribute.  The point being: unlike route and view
predicates, not every type of subscriber predicate will necessarily be
applicable for use in every subscriber registration.  It is not the
responsibility of the predicate author to make every predicate make sense for
every event type; it is the responsibility of the predicate consumer to use
predicates that make sense for a particular event type registration.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using Hooks</a><ul>
<li><a class="reference internal" href="#changing-the-not-found-view">Changing the Not Found View</a></li>
<li><a class="reference internal" href="#changing-the-forbidden-view">Changing the Forbidden View</a></li>
<li><a class="reference internal" href="#changing-the-request-factory">Changing the Request Factory</a></li>
<li><a class="reference internal" href="#adding-methods-or-properties-to-request-object">Adding Methods or Properties to Request Object</a></li>
<li><a class="reference internal" href="#using-the-before-render-event">Using The Before Render Event</a></li>
<li><a class="reference internal" href="#using-response-callbacks">Using Response Callbacks</a></li>
<li><a class="reference internal" href="#using-finished-callbacks">Using Finished Callbacks</a></li>
<li><a class="reference internal" href="#changing-the-traverser">Changing the Traverser</a></li>
<li><a class="reference internal" href="#changing-how-pyramid-request-request-resource-url-generates-a-url">Changing How <tt class="docutils literal"><span class="pre">pyramid.request.Request.resource_url()</span></tt> Generates a URL</a></li>
<li><a class="reference internal" href="#changing-how-pyramid-treats-view-responses">Changing How Pyramid Treats View Responses</a></li>
<li><a class="reference internal" href="#using-a-view-mapper">Using a View Mapper</a></li>
<li><a class="reference internal" href="#registering-configuration-decorators">Registering Configuration Decorators</a></li>
<li><a class="reference internal" href="#registering-tweens">Registering Tweens</a><ul>
<li><a class="reference internal" href="#creating-a-tween">Creating a Tween</a></li>
<li><a class="reference internal" href="#registering-an-implicit-tween-factory">Registering an Implicit Tween Factory</a></li>
<li><a class="reference internal" href="#suggesting-implicit-tween-ordering">Suggesting Implicit Tween Ordering</a></li>
<li><a class="reference internal" href="#explicit-tween-ordering">Explicit Tween Ordering</a></li>
<li><a class="reference internal" href="#tween-conflicts-and-ordering-cycles">Tween Conflicts and Ordering Cycles</a></li>
<li><a class="reference internal" href="#displaying-tween-ordering">Displaying Tween Ordering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-a-third-party-view-route-or-subscriber-predicate">Adding A Third Party View, Route, or Subscriber Predicate</a><ul>
<li><a class="reference internal" href="#view-and-route-predicates">View and Route Predicates</a></li>
<li><a class="reference internal" href="#subscriber-predicates">Subscriber Predicates</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="subrequest.html"
                        title="previous chapter">Invoking a Subrequest</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="introspector.html"
                        title="next chapter">Pyramid Configuration Introspection</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="introspector.html" title="Pyramid Configuration Introspection"
             >next</a> |</li>
        <li class="right" >
          <a href="subrequest.html" title="Invoking a Subrequest"
             >previous</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2008-2014, Agendaless Consulting.
      Last updated on Nov 09, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>