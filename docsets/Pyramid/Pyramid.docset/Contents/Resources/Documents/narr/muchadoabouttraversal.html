<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Much Ado About Traversal &mdash; The Pyramid Web Framework v1.5</title>
    
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="The Pyramid Web Framework v1.5" href="../index.html" />
    <link rel="next" title="Traversal" href="traversal.html" />
    <link rel="prev" title="Hello Traversal World" href="hellotraversal.html" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head>
  <body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="traversal.html" title="Traversal"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hellotraversal.html" title="Hello Traversal World"
             accesskey="P">previous</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="much-ado-about-traversal">
<span id="much-ado-about-traversal-chapter"></span><h1>Much Ado About Traversal<a class="headerlink" href="#much-ado-about-traversal" title="Permalink to this headline">¶</a></h1>
<p>(Or, why you should care about it)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This chapter was adapted, with permission, from a blog post by <a class="reference external" href="http://blog.nonsequitarian.org/">Rob
Miller</a>, originally published at
<a class="reference external" href="http://blog.nonsequitarian.org/2010/much-ado-about-traversal/">http://blog.nonsequitarian.org/2010/much-ado-about-traversal/</a> .</p>
</div>
<p>Traversal is an alternative to <a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a> which allows
<span>Pyramid</span> applications to map URLs to code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Ex-Zope users who are already familiar with traversal and view lookup
conceptually may want to skip directly to the <a class="reference internal" href="traversal.html#traversal-chapter"><em>Traversal</em></a>
chapter, which discusses technical details.  This chapter is mostly aimed
at people who have previous <a class="reference internal" href="../glossary.html#term-pylons"><em class="xref std std-term">Pylons</em></a> experience or experience in
another framework which does not provide traversal, and need an
introduction to the &quot;why&quot; of traversal.</p>
</div>
<p>Some folks who have been using Pylons and its Routes-based URL matching for a
long time are being exposed for the first time, via <span>Pyramid</span>, to new
ideas such as &quot;<a class="reference internal" href="../glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a>&quot; and &quot;<a class="reference internal" href="../glossary.html#term-view-lookup"><em class="xref std std-term">view lookup</em></a>&quot; as a way to route
incoming HTTP requests to callable code.  Some of the same folks believe that
traversal is hard to understand.  Others question its usefulness; URL
matching has worked for them so far, why should they even consider dealing
with another approach, one which doesn't fit their brain and which doesn't
provide any immediately obvious value?</p>
<p>You can be assured that if you don't want to understand traversal, you don't
have to.  You can happily build <span>Pyramid</span> applications with only
<a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>.  However, there are some straightforward, real-world
use cases that are much more easily served by a traversal-based approach than
by a pattern-matching mechanism.  Even if you haven't yet hit one of these
use cases yourself, understanding these new ideas is worth the effort for any
web developer so you know when you might want to use them.  <a class="reference internal" href="../glossary.html#term-traversal"><em class="xref std std-term">Traversal</em></a>
is actually a straightforward metaphor easily comprehended by anyone who's
ever used a run-of-the-mill file system with folders and files.</p>
<div class="section" id="url-dispatch">
<span id="index-0"></span><h2>URL Dispatch<a class="headerlink" href="#url-dispatch" title="Permalink to this headline">¶</a></h2>
<p>Let's step back and consider the problem we're trying to solve.  An
HTTP request for a particular path has been routed to our web
application.  The requested path will possibly invoke a specific
<a class="reference internal" href="../glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a> function defined somewhere in our app.  We're
trying to determine <em>which</em> callable function, if any, should be
invoked for a given requested URL.</p>
<p>Many systems, including Pyramid, offer a simple solution.  They offer the
concept of &quot;URL matching&quot;.  URL matching approaches this problem by parsing
the URL path and comparing the results to a set of registered &quot;patterns&quot;,
defined by a set of regular expressions, or some other URL path templating
syntax.  Each pattern is mapped to a callable function somewhere; if the
request path matches a specific pattern, the associated function is called.
If the request path matches more than one pattern, some conflict resolution
scheme is used, usually a simple order precedence so that the first match
will take priority over any subsequent matches.  If a request path doesn't
match any of the defined patterns, a &quot;404 Not Found&quot; response is returned.</p>
<p>In Pyramid, we offer an implementation of URL matching which we call
<a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>.  Using <span>Pyramid</span> syntax, we might have a match
pattern such as <tt class="docutils literal"><span class="pre">/{userid}/photos/{photoid}</span></tt>, mapped to a <tt class="docutils literal"><span class="pre">photo_view()</span></tt>
function defined somewhere in our code.  Then a request for a path such as
<tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1</span></tt> would be a match, and the <tt class="docutils literal"><span class="pre">photo_view()</span></tt>
function would be invoked to handle the request.  Similarly,
<tt class="docutils literal"><span class="pre">/{userid}/blog/{year}/{month}/{postid}</span></tt> might map to a
<tt class="docutils literal"><span class="pre">blog_post_view()</span></tt> function, so <tt class="docutils literal"><span class="pre">/joeschmoe/blog/2010/12/urlmatching</span></tt>
would trigger the function, which presumably would know how to find and
render the <tt class="docutils literal"><span class="pre">urlmatching</span></tt> blog post.</p>
</div>
<div class="section" id="historical-refresher">
<h2>Historical Refresher<a class="headerlink" href="#historical-refresher" title="Permalink to this headline">¶</a></h2>
<p>Now that we've refreshed our understanding of <a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>, we'll dig
in to the idea of traversal.  Before we do, though, let's take a trip down
memory lane.  If you've been doing web work for a while, you may remember a
time when we didn't have fancy web frameworks like <a class="reference internal" href="../glossary.html#term-pylons"><em class="xref std std-term">Pylons</em></a> and
<span>Pyramid</span>.  Instead, we had general purpose HTTP servers that primarily
served files off of a file system.  The &quot;root&quot; of a given site mapped to a
particular folder somewhere on the file system.  Each segment of the request
URL path represented a subdirectory.  The final path segment would be either
a directory or a file, and once the server found the right file it would
package it up in an HTTP response and send it back to the client.  So serving
up a request for <tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1</span></tt> literally meant that there was
a <tt class="docutils literal"><span class="pre">joeschmoe</span></tt> folder somewhere, which contained a <tt class="docutils literal"><span class="pre">photos</span></tt> folder, which
in turn contained a <tt class="docutils literal"><span class="pre">photo1</span></tt> file.  If at any point along the way we find
that there is not a folder or file matching the requested path, we return a
404 response.</p>
<p>As the web grew more dynamic, however, a little bit of extra complexity was
added.  Technologies such as CGI and HTTP server modules were developed.
Files were still looked up on the file system, but if the file ended with
(for example) <tt class="docutils literal"><span class="pre">.cgi</span></tt> or <tt class="docutils literal"><span class="pre">.php</span></tt>, or if it lived in a special folder,
instead of simply sending the file to the client the server would read the
file, execute it using an interpreter of some sort, and then send the output
from this process to the client as the final result.  The server
configuration specified which files would trigger some dynamic code, with the
default case being to just serve the static file.</p>
</div>
<div class="section" id="traversal-aka-resource-location">
<span id="index-1"></span><h2>Traversal (aka Resource Location)<a class="headerlink" href="#traversal-aka-resource-location" title="Permalink to this headline">¶</a></h2>
<p>Believe it or not, if you understand how serving files from a file system
works, you understand traversal.  And if you understand that a server might do
something different based on what type of file a given request specifies,
then you understand view lookup.</p>
<p>The major difference between file system lookup and traversal is that a file
system lookup steps through nested directories and files in a file system
tree, while traversal steps through nested dictionary-type objects in a
<a class="reference internal" href="../glossary.html#term-resource-tree"><em class="xref std std-term">resource tree</em></a>.  Let's take a detailed look at one of our example
paths, so we can see what I mean:</p>
<p>The path <tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1</span></tt>, has four segments: <tt class="docutils literal"><span class="pre">/</span></tt>,
<tt class="docutils literal"><span class="pre">joeschmoe</span></tt>, <tt class="docutils literal"><span class="pre">photos</span></tt> and <tt class="docutils literal"><span class="pre">photo1</span></tt>.  With file system lookup we might
have a root folder (<tt class="docutils literal"><span class="pre">/</span></tt>) containing a nested folder (<tt class="docutils literal"><span class="pre">joeschmoe</span></tt>), which
contains another nested folder (<tt class="docutils literal"><span class="pre">photos</span></tt>), which finally contains a JPG
file (<tt class="docutils literal"><span class="pre">photo1</span></tt>).  With traversal, we instead have a dictionary-like root
object.  Asking for the <tt class="docutils literal"><span class="pre">joeschmoe</span></tt> key gives us another dictionary-like
object.  Asking this in turn for the <tt class="docutils literal"><span class="pre">photos</span></tt> key gives us yet another
mapping object, which finally (hopefully) contains the resource that we're
looking for within its values, referenced by the <tt class="docutils literal"><span class="pre">photo1</span></tt> key.</p>
<p>In pure Python terms, then, the traversal or &quot;resource location&quot;
portion of satisfying the <tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1</span></tt> request
will look something like this pseudocode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">get_root</span><span class="p">()[</span><span class="s">&#39;joeschmoe&#39;</span><span class="p">][</span><span class="s">&#39;photos&#39;</span><span class="p">][</span><span class="s">&#39;photo1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">get_root()</span></tt> is some function that returns a root traversal
<a class="reference internal" href="../glossary.html#term-resource"><em class="xref std std-term">resource</em></a>.  If all of the specified keys exist, then the returned
object will be the resource that is being requested, analogous to the JPG
file that was retrieved in the file system example.  If a <a class="reference external" href="http://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.4)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> is
generated anywhere along the way, <span>Pyramid</span> will return 404.  (This
isn't precisely true, as you'll see when we learn about view lookup below,
but the basic idea holds.)</p>
</div>
<div class="section" id="what-is-a-resource">
<span id="index-2"></span><h2>What Is a &quot;Resource&quot;?<a class="headerlink" href="#what-is-a-resource" title="Permalink to this headline">¶</a></h2>
<p>&quot;Files on a file system I understand&quot;, you might say.  &quot;But what are these
nested dictionary things?  Where do these objects, these 'resources', live?
What <em>are</em> they?&quot;</p>
<p>Since <span>Pyramid</span> is not a highly opinionated framework, it makes no
restriction on how a <a class="reference internal" href="../glossary.html#term-resource"><em class="xref std std-term">resource</em></a> is implemented; a developer can
implement them as he wishes.  One common pattern used is to persist all of
the resources, including the root, in a database as a graph.  The root object
is a dictionary-like object.  Dictionary-like objects in Python supply a
<tt class="docutils literal"><span class="pre">__getitem__</span></tt> method which is called when key lookup is done.  Under the
hood, when <tt class="docutils literal"><span class="pre">adict</span></tt> is a dictionary-like object, Python translates
<tt class="docutils literal"><span class="pre">adict['a']</span></tt> to <tt class="docutils literal"><span class="pre">adict.__getitem__('a')</span></tt>.  Try doing this in a Python
interpreter prompt if you don't believe us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The dictionary-like root object stores the ids of all of its subresources as
keys, and provides a <tt class="docutils literal"><span class="pre">__getitem__</span></tt> implementation that fetches them.  So
<tt class="docutils literal"><span class="pre">get_root()</span></tt> fetches the unique root object, while
<tt class="docutils literal"><span class="pre">get_root()['joeschmoe']</span></tt> returns a different object, also stored in the
database, which in turn has its own subresources and <tt class="docutils literal"><span class="pre">__getitem__</span></tt>
implementation, etc.  These resources might be persisted in a relational
database, one of the many &quot;NoSQL&quot; solutions that are becoming popular these
days, or anywhere else, it doesn't matter.  As long as the returned objects
provide the dictionary-like API (i.e. as long as they have an appropriately
implemented <tt class="docutils literal"><span class="pre">__getitem__</span></tt> method) then traversal will work.</p>
<p>In fact, you don't need a &quot;database&quot; at all.  You could use plain
dictionaries, with your site's URL structure hard-coded directly in
the Python source.  Or you could trivially implement a set of objects
with <tt class="docutils literal"><span class="pre">__getitem__</span></tt> methods that search for files in specific
directories, and thus precisely recreate the traditional mechanism of
having the URL path mapped directly to a folder structure on the file
system.  Traversal is in fact a superset of file system lookup.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See the chapter entitled <a class="reference internal" href="resources.html#resources-chapter"><em>Resources</em></a> for a more
technical overview of resources.</p>
</div>
</div>
<div class="section" id="view-lookup">
<span id="index-3"></span><h2>View Lookup<a class="headerlink" href="#view-lookup" title="Permalink to this headline">¶</a></h2>
<p>At this point we're nearly there.  We've covered traversal, which is the
process by which a specific resource is retrieved according to a specific URL
path.  But what is &quot;view lookup&quot;?</p>
<p>The need for view lookup is simple: there is more than one possible action
that you might want to take after finding a <a class="reference internal" href="../glossary.html#term-resource"><em class="xref std std-term">resource</em></a>.  With our photo
example, for instance, you might want to view the photo in a page, but you
might also want to provide a way for the user to edit the photo and any
associated metadata.  We'll call the former the <tt class="docutils literal"><span class="pre">view</span></tt> view, and the latter
will be the <tt class="docutils literal"><span class="pre">edit</span></tt> view.  (Original, I know.)  <span>Pyramid</span> has a
centralized view <a class="reference internal" href="../glossary.html#term-application-registry"><em class="xref std std-term">application registry</em></a> where named views can be
associated with specific resource types.  So in our example, we'll assume
that we've registered <tt class="docutils literal"><span class="pre">view</span></tt> and <tt class="docutils literal"><span class="pre">edit</span></tt> views for photo objects, and that
we've specified the <tt class="docutils literal"><span class="pre">view</span></tt> view as the default, so that
<tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1/view</span></tt> and <tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1</span></tt> are
equivalent.  The edit view would sensibly be provided by a request for
<tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1/edit</span></tt>.</p>
<p>Hopefully it's clear that the first portion of the edit view's URL path is
going to resolve to the same resource as the non-edit version, specifically
the resource returned by <tt class="docutils literal"><span class="pre">get_root()['joeschmoe']['photos']['photo1']</span></tt>.
But traveral ends there; the <tt class="docutils literal"><span class="pre">photo1</span></tt> resource doesn't have an <tt class="docutils literal"><span class="pre">edit</span></tt>
key.  In fact, it might not even be a dictionary-like object, in which case
<tt class="docutils literal"><span class="pre">photo1['edit']</span></tt> would be meaningless.  When the <span>Pyramid</span> resource
location has been resolved to a <em>leaf</em> resource, but the entire request path
has not yet been expended, the <em>very next</em> path segment is treated as a
<a class="reference internal" href="../glossary.html#term-view-name"><em class="xref std std-term">view name</em></a>.  The registry is then checked to see if a view of the
given name has been specified for a resource of the given type.  If so, the
view callable is invoked, with the resource passed in as the related
<tt class="docutils literal"><span class="pre">context</span></tt> object (also available as <tt class="docutils literal"><span class="pre">request.context</span></tt>).  If a view
callable could not be found, <span>Pyramid</span> will return a &quot;404 Not Found&quot;
response.</p>
<p>You might conceptualize a request for <tt class="docutils literal"><span class="pre">/joeschmoe/photos/photo1/edit</span></tt> as
ultimately converted into the following piece of Pythonic pseudocode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">context</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">()[</span><span class="s">&#39;joeschmoe&#39;</span><span class="p">][</span><span class="s">&#39;photos&#39;</span><span class="p">][</span><span class="s">&#39;photo1&#39;</span><span class="p">]</span>
<span class="n">view_callable</span> <span class="o">=</span> <span class="n">get_view</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s">&#39;edit&#39;</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
<span class="n">view_callable</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">get_root</span></tt> and <tt class="docutils literal"><span class="pre">get_view</span></tt> functions don't really exist.  Internally,
<span>Pyramid</span> does something more complicated.  But the example above
is a reasonable approximation of the view lookup algorithm in pseudocode.</p>
</div>
<div class="section" id="use-cases">
<h2>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>Why should we care about traversal?  URL matching is easier to explain, and
it's good enough, right?</p>
<p>In some cases, yes, but certainly not in all cases.  So far we've had very
structured URLs, where our paths have had a specific, small number of pieces,
like this:</p>
<div class="highlight-python"><div class="highlight"><pre>/{userid}/{typename}/{objectid}[/{view_name}]
</pre></div>
</div>
<p>In all of the examples thus far, we've hard coded the typename value,
assuming that we'd know at development time what names were going to be used
(&quot;photos&quot;, &quot;blog&quot;, etc.).  But what if we don't know what these names will
be?  Or, worse yet, what if we don't know <em>anything</em> about the structure of
the URLs inside a user's folder?  We could be writing a CMS where we want the
end user to be able to arbitrarily add content and other folders inside his
folder.  He might decide to nest folders dozens of layers deep.  How will you
construct matching patterns that could account for every possible combination
of paths that might develop?</p>
<p>It might be possible, but it certainly won't be easy.  The matching
patterns are going to become complex quickly as you try to handle all
of the edge cases.</p>
<p>With traversal, however, it's straightforward.  Twenty layers of nesting
would be no problem.  <span>Pyramid</span> will happily call <tt class="docutils literal"><span class="pre">__getitem__</span></tt> as
many times as it needs to, until it runs out of path segments or until a
resource raises a <a class="reference external" href="http://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.4)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a>.  Each resource only needs to know how to
fetch its immediate children, the traversal algorithm takes care of the rest.
Also, since the structure of the resource tree can live in the database and
not in the code, it's simple to let users modify the tree at runtime to set
up their own personalized &quot;directory&quot; structures.</p>
<p>Another use case in which traversal shines is when there is a need to support
a context-dependent security policy.  One example might be a document
management infrastructure for a large corporation, where members of different
departments have varying access levels to the various other departments'
files.  Reasonably, even specific files might need to be made available to
specific individuals.  Traversal does well here if your resources actually
represent the data objects related to your documents, because the idea of a
resource authorization is baked right into the code resolution and calling
process.  Resource objects can store ACLs, which can be inherited and/or
overridden by the subresources.</p>
<p>If each resource can thus generate a context-based ACL, then whenever view
code is attempting to perform a sensitive action, it can check against that
ACL to see whether the current user should be allowed to perform the action.
In this way you achieve so called &quot;instance based&quot; or &quot;row level&quot; security
which is considerably harder to model using a traditional tabular approach.
<span>Pyramid</span> actively supports such a scheme, and in fact if you register
your views with guard permissions and use an authorization policy,
<span>Pyramid</span> can check against a resource's ACL when deciding whether or
not the view itself is available to the current user.</p>
<p>In summary, there are entire classes of problems that are more easily served
by traversal and view lookup than by <a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>.  If your problems
don't require it, great: stick with <a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>.  But if you're
using <span>Pyramid</span> and you ever find that you <em>do</em> need to support one of
these use cases, you'll be glad you have traversal in your toolkit.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is even possible to mix and match <a class="reference internal" href="../glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> with
<a class="reference internal" href="../glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a> in the same <span>Pyramid</span> application. See the
<a class="reference internal" href="hybrid.html#hybrid-chapter"><em>Combining Traversal and URL Dispatch</em></a> chapter for details.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Much Ado About Traversal</a><ul>
<li><a class="reference internal" href="#url-dispatch">URL Dispatch</a></li>
<li><a class="reference internal" href="#historical-refresher">Historical Refresher</a></li>
<li><a class="reference internal" href="#traversal-aka-resource-location">Traversal (aka Resource Location)</a></li>
<li><a class="reference internal" href="#what-is-a-resource">What Is a &quot;Resource&quot;?</a></li>
<li><a class="reference internal" href="#view-lookup">View Lookup</a></li>
<li><a class="reference internal" href="#use-cases">Use Cases</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="hellotraversal.html"
                        title="previous chapter">Hello Traversal World</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="traversal.html"
                        title="next chapter">Traversal</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="traversal.html" title="Traversal"
             >next</a> |</li>
        <li class="right" >
          <a href="hellotraversal.html" title="Hello Traversal World"
             >previous</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 2008-2014, Agendaless Consulting.
      Last updated on Nov 09, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>