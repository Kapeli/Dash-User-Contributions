<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Defending Pyramid&#39;s Design &mdash; The Pyramid Web Framework v1.5</title>
    
    <link rel="stylesheet" href="_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="The Pyramid Web Framework v1.5" href="index.html" />
    <link rel="next" title="Glossary" href="glossary.html" />
    <link rel="prev" title="Pyramid Change History" href="changes.html" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="_static/pyramid.ico"/>

  </head>
  <body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="index.html">
      		<img class="logo" src="_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="glossary.html" title="Glossary"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Pyramid Change History"
             accesskey="P">previous</a> |</li>
    	<li><a href="index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="defending-pyramid-s-design">
<span id="design-defense"></span><h1>Defending Pyramid's Design<a class="headerlink" href="#defending-pyramid-s-design" title="Permalink to this headline">¶</a></h1>
<p>From time to time, challenges to various aspects of <span>Pyramid</span> design are
lodged.  To give context to discussions that follow, we detail some of the
design decisions and trade-offs here.  In some cases, we acknowledge that the
framework can be made better and we describe future steps which will be taken
to improve it; in some cases we just file the challenge as noted, as
obviously you can't please everyone all of the time.</p>
<div class="section" id="pyramid-provides-more-than-one-way-to-do-it">
<h2>Pyramid Provides More Than One Way to Do It<a class="headerlink" href="#pyramid-provides-more-than-one-way-to-do-it" title="Permalink to this headline">¶</a></h2>
<p>A canon of Python popular culture is &quot;TIOOWTDI&quot; (&quot;there is only one way to do
it&quot;, a slighting, tongue-in-cheek reference to Perl's &quot;TIMTOWTDI&quot;, which is
an acronym for &quot;there is more than one way to do it&quot;).</p>
<p><span>Pyramid</span> is, for better or worse, a &quot;TIMTOWTDI&quot; system.  For example,
it includes more than one way to resolve a URL to a <a class="reference internal" href="glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a>:
via <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">url dispatch</em></a> or <a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a>.  Multiple methods of
configuration exist: <a class="reference internal" href="glossary.html#term-imperative-configuration"><em class="xref std std-term">imperative configuration</em></a>, <a class="reference internal" href="glossary.html#term-configuration-decoration"><em class="xref std std-term">configuration
decoration</em></a>, and <a class="reference internal" href="glossary.html#term-zcml"><em class="xref std std-term">ZCML</em></a> (optionally via <a class="reference internal" href="glossary.html#term-pyramid-zcml"><em class="xref std std-term">pyramid_zcml</em></a>). It works
with multiple different kinds of persistence and templating systems.  And so
on.  However, the existence of most of these overlapping ways to do things
are not without reason and purpose: we have a number of audiences to serve,
and we believe that TIMTOWTI at the web framework level actually <em>prevents</em> a
much more insidious and harmful set of duplication at higher levels in the
Python web community.</p>
<p><span>Pyramid</span> began its life as <tt class="xref py py-mod docutils literal"><span class="pre">repoze.bfg</span></tt>, written by a team of
people with many years of prior <a class="reference internal" href="glossary.html#term-zope"><em class="xref std std-term">Zope</em></a> experience.  The idea of
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> and the way <a class="reference internal" href="glossary.html#term-view-lookup"><em class="xref std std-term">view lookup</em></a> works was stolen entirely
from Zope.  The authorization subsystem provided by <span>Pyramid</span> is a
derivative of Zope's.  The idea that an application can be <em>extended</em> without
forking is also a Zope derivative.</p>
<p>Implementations of these features were <em>required</em> to allow the <span>Pyramid</span>
authors to build the bread-and-butter CMS-type systems for customers in the
way in which they were accustomed.  No other system, save for Zope itself,
had such features, and Zope itself was beginning to show signs of its age.
We were becoming hampered by consequences of its early design mistakes.
Zope's lack of documentation was also difficult to work around: it was hard
to hire smart people to work on Zope applications, because there was no
comprehensive documentation set to point them at which explained &quot;it all&quot; in
one consumable place, and it was too large and self-inconsistent to document
properly.  Before <tt class="xref py py-mod docutils literal"><span class="pre">repoze.bfg</span></tt> went under development, its authors
obviously looked around for other frameworks that fit the bill.  But no
non-Zope framework did.  So we embarked on building <tt class="xref py py-mod docutils literal"><span class="pre">repoze.bfg</span></tt>.</p>
<p>As the result of our research, however, it became apparent that, despite the
fact that no <em>one</em> framework had all the features we required, lots of
existing frameworks had good, and sometimes very compelling ideas.  In
particular, <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a> is a more direct mechanism to map URLs to
code.</p>
<p>So, although we couldn't find a framework, save for Zope, that fit our needs,
and while we incorporated a lot of Zope ideas into BFG, we also emulated the
features we found compelling in other frameworks (such as <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">url
dispatch</em></a>).  After the initial public release of BFG, as time went on,
features were added to support people allergic to various Zope-isms in the
system, such as the ability to configure the application using
<a class="reference internal" href="glossary.html#term-imperative-configuration"><em class="xref std std-term">imperative configuration</em></a> and <a class="reference internal" href="glossary.html#term-configuration-decoration"><em class="xref std std-term">configuration decoration</em></a> rather
than solely using <a class="reference internal" href="glossary.html#term-zcml"><em class="xref std std-term">ZCML</em></a>, and the elimination of the required use of
<a class="reference internal" href="glossary.html#term-interface"><em class="xref std std-term">interface</em></a> objects.  It soon became clear that we had a system that
was very generic, and was beginning to appeal to non-Zope users as well as
ex-Zope users.</p>
<p>As the result of this generalization, it became obvious BFG shared 90% of its
featureset with the featureset of Pylons 1, and thus had a very similar
target market.  Because they were so similar, choosing between the two
systems was an exercise in frustration for an otherwise non-partisan
developer.  It was also strange for the Pylons and BFG development
communities to be in competition for the same set of users, given how similar
the two frameworks were.  So the Pylons and BFG teams began to work together
to form a plan to merge.  The features missing from BFG (notably <a class="reference internal" href="glossary.html#term-view-handler"><em class="xref std std-term">view
handler</em></a> classes, flash messaging, and other minor missing bits), were added,
to provide familiarity to ex-Pylons users.  The result is <span>Pyramid</span>.</p>
<p>The Python web framework space is currently notoriously balkanized.  We're
truly hoping that the amalgamation of components in <span>Pyramid</span> will
appeal to at least two currently very distinct sets of users: Pylons and BFG
users.  By unifying the best concepts from Pylons and BFG into a single
codebase and leaving the bad concepts from their ancestors behind, we'll be
able to consolidate our efforts better, share more code, and promote our
efforts as a unit rather than competing pointlessly.  We hope to be able to
shortcut the pack mentality which results in a <em>much larger</em> duplication of
effort, represented by competing but incredibly similar applications and
libraries, each built upon a specific low level stack that is incompatible
with the other.  We'll also shrink the choice of credible Python web
frameworks down by at least one.  We're also hoping to attract users from
other communities (such as Zope's and TurboGears') by providing the features
they require, while allowing enough flexibility to do things in a familiar
fashion.  Some overlap of functionality to achieve these goals is expected
and unavoidable, at least if we aim to prevent pointless duplication at
higher levels.  If we've done our job well enough, the various audiences will
be able to coexist and cooperate rather than firing at each other across some
imaginary web framework DMZ.</p>
</div>
<div class="section" id="pyramid-uses-a-zope-component-architecture-zca-registry">
<h2>Pyramid Uses A Zope Component Architecture (&quot;ZCA&quot;) Registry<a class="headerlink" href="#pyramid-uses-a-zope-component-architecture-zca-registry" title="Permalink to this headline">¶</a></h2>
<p><span>Pyramid</span> uses a <a class="reference internal" href="glossary.html#term-zope-component-architecture"><em class="xref std std-term">Zope Component Architecture</em></a> (ZCA) &quot;component
registry&quot; as its <a class="reference internal" href="glossary.html#term-application-registry"><em class="xref std std-term">application registry</em></a> under the hood.  This is a
point of some contention.  <span>Pyramid</span> is of a <a class="reference internal" href="glossary.html#term-zope"><em class="xref std std-term">Zope</em></a> pedigree, so
it was natural for its developers to use a ZCA registry at its inception.
However, we understand that using a ZCA registry has issues and consequences,
which we've attempted to address as best we can.  Here's an introspection
about <span>Pyramid</span> use of a ZCA registry, and the trade-offs its usage
involves.</p>
<div class="section" id="problems">
<h3>Problems<a class="headerlink" href="#problems" title="Permalink to this headline">¶</a></h3>
<p>The global API that may be used to access data in a ZCA component registry
is not particularly pretty or intuitive, and sometimes it's just plain
obtuse.  Likewise, the conceptual load on a casual source code reader of code
that uses the ZCA global API is somewhat high.  Consider a ZCA neophyte
reading the code that performs a typical &quot;unnamed utility&quot; lookup using the
<a class="reference external" href="http://docs.zope.org/zope.component/api/utility.html#zope.component.getUtility" title="(in zope.configuration v4.0)"><tt class="xref py py-func docutils literal"><span class="pre">zope.component.getUtility()</span></tt></a> global API:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">ISettings</span>
<span class="kn">from</span> <span class="nn">zope.component</span> <span class="kn">import</span> <span class="n">getUtility</span>
<span class="n">settings</span> <span class="o">=</span> <span class="n">getUtility</span><span class="p">(</span><span class="n">ISettings</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>After this code runs, <tt class="docutils literal"><span class="pre">settings</span></tt> will be a Python dictionary.  But it's
unlikely that any civilian would know that just by reading the code.  There
are a number of comprehension issues with the bit of code above that are
obvious.</p>
<p>First, what's a &quot;utility&quot;?  Well, for the purposes of this discussion, and
for the purpose of the code above, it's just not very important.  If you
really want to know, you can read <a class="reference external" href="http://www.muthukadan.net/docs/zca.html#utility">this</a>.  However, still, readers
of such code need to understand the concept in order to parse it.  This is
problem number one.</p>
<p>Second, what's this <tt class="docutils literal"><span class="pre">ISettings</span></tt> thing?  It's an <a class="reference internal" href="glossary.html#term-interface"><em class="xref std std-term">interface</em></a>.  Is that
important here?  Not really, we're just using it as a key for some lookup
based on its identity as a marker: it represents an object that has the
dictionary API, but that's not very important in this context.  That's
problem number two.</p>
<p>Third of all, what does the <tt class="docutils literal"><span class="pre">getUtility</span></tt> function do?  It's performing a
lookup for the <tt class="docutils literal"><span class="pre">ISettings</span></tt> &quot;utility&quot; that should return.. well, a utility.
Note how we've already built up a dependency on the understanding of an
<a class="reference internal" href="glossary.html#term-interface"><em class="xref std std-term">interface</em></a> and the concept of &quot;utility&quot; to answer this question: a bad
sign so far.  Note also that the answer is circular, a <em>really</em> bad sign.</p>
<p>Fourth, where does <tt class="docutils literal"><span class="pre">getUtility</span></tt> look to get the data?  Well, the &quot;component
registry&quot; of course.  What's a component registry?  Problem number four.</p>
<p>Fifth, assuming you buy that there's some magical registry hanging around,
where <em>is</em> this registry?  <em>Homina homina</em>... &quot;around&quot;?  That's sort of the
best answer in this context (a more specific answer would require knowledge
of internals).  Can there be more than one registry?  Yes.  So <em>which</em>
registry does it find the registration in?  Well, the &quot;current&quot; registry of
course.  In terms of <span>Pyramid</span>, the current registry is a thread local
variable.  Using an API that consults a thread local makes understanding how
it works non-local.</p>
<p>You've now bought in to the fact that there's a registry that is just hanging
around.  But how does the registry get populated?  Why, via code that calls
directives like <tt class="docutils literal"><span class="pre">config.add_view</span></tt>.  In this particular case, however, the
registration of <tt class="docutils literal"><span class="pre">ISettings</span></tt> is made by the framework itself under the hood:
it's not present in any user configuration.  This is extremely hard to
comprehend.  Problem number six.</p>
<p>Clearly there's some amount of cognitive load here that needs to be borne by
a reader of code that extends the <span>Pyramid</span> framework due to its use of
the ZCA, even if he or she is already an expert Python programmer and whom is
an expert in the domain of web applications.  This is suboptimal.</p>
</div>
<div class="section" id="ameliorations">
<h3>Ameliorations<a class="headerlink" href="#ameliorations" title="Permalink to this headline">¶</a></h3>
<p>First, the primary amelioration: <span>Pyramid</span> <em>does not expect application
developers to understand ZCA concepts or any of its APIs</em>.  If an
<em>application</em> developer needs to understand a ZCA concept or API during the
creation of a <span>Pyramid</span> application, we've failed on some axis.</p>
<p>Instead, the framework hides the presence of the ZCA registry behind
special-purpose API functions that <em>do</em> use ZCA APIs.  Take for example the
<tt class="docutils literal"><span class="pre">pyramid.security.authenticated_userid</span></tt> function, which returns the userid
present in the current request or <tt class="docutils literal"><span class="pre">None</span></tt> if no userid is present in the
current request.  The application developer calls it like so:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.security</span> <span class="kn">import</span> <span class="n">authenticated_userid</span>
<span class="n">userid</span> <span class="o">=</span> <span class="n">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>He now has the current user id.</p>
<p>Under its hood however, the implementation of <tt class="docutils literal"><span class="pre">authenticated_userid</span></tt>
is this:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the userid of the currently authenticated user or</span>
<span class="sd">    ``None`` if there is no authentication policy in effect or there</span>
<span class="sd">    is no currently authenticated user. &quot;&quot;&quot;</span>

    <span class="n">registry</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">registry</span> <span class="c"># the ZCA component registry</span>
    <span class="n">policy</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">queryUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">policy</span><span class="o">.</span><span class="n">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Using such wrappers, we strive to always hide the ZCA API from application
developers.  Application developers should just never know about the ZCA API:
they should call a Python function with some object germane to the domain as
an argument, and it should return a result.  A corollary that follows is
that any reader of an application that has been written using <span>Pyramid</span>
needn't understand the ZCA API either.</p>
<p>Hiding the ZCA API from application developers and code readers is a form of
enhancing domain specificity.  No application developer wants to need to
understand the small, detailed mechanics of how a web framework does its
thing.  People want to deal in concepts that are closer to the domain they're
working in: for example, web developers want to know about <em>users</em>, not
<em>utilities</em>.  <span>Pyramid</span> uses the ZCA as an implementation detail, not as
a feature which is exposed to end users.</p>
<p>However, unlike application developers, <em>framework developers</em>, including
people who want to override <span>Pyramid</span> functionality via preordained
framework plugpoints like traversal or view lookup <em>must</em> understand the ZCA
registry API.</p>
<p><span>Pyramid</span> framework developers were so concerned about conceptual load
issues of the ZCA registry API for framework developers that a <a class="reference external" href="https://github.com/repoze/repoze.component">replacement
registry implementation</a>
named <tt class="xref py py-mod docutils literal"><span class="pre">repoze.component</span></tt> was actually developed.  Though this package
has a registry implementation which is fully functional and well-tested, and
its API is much nicer than the ZCA registry API, work on it was largely
abandoned and it is not used in <span>Pyramid</span>.  We continued to use a ZCA
registry within <span>Pyramid</span> because it ultimately proved a better fit.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We continued using ZCA registry rather than disusing it in
favor of using the registry implementation in
<tt class="xref py py-mod docutils literal"><span class="pre">repoze.component</span></tt> largely because the ZCA concept of
interfaces provides for use of an interface hierarchy, which is
useful in a lot of scenarios (such as context type inheritance).
Coming up with a marker type that was something like an interface
that allowed for this functionality seemed like it was just
reinventing the wheel.</p>
</div>
<p>Making framework developers and extenders understand the ZCA registry API is
a trade-off.  We (the <span>Pyramid</span> developers) like the features that the
ZCA registry gives us, and we have long-ago borne the weight of understanding
what it does and how it works.  The authors of <span>Pyramid</span> understand the
ZCA deeply and can read code that uses it as easily as any other code.</p>
<p>But we recognize that developers who might want to extend the framework are not
as comfortable with the ZCA registry API as the original developers are with
it.  So, for the purposes of being kind to third-party <span>Pyramid</span>
framework developers in, we've drawn some lines in the sand.</p>
<p>In all core code, We've made use of ZCA global API functions such as
<tt class="docutils literal"><span class="pre">zope.component.getUtility</span></tt> and <tt class="docutils literal"><span class="pre">zope.component.getAdapter</span></tt> the exception
instead of the rule.  So instead of:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IAuthenticationPolicy</span>
<span class="kn">from</span> <span class="nn">zope.component</span> <span class="kn">import</span> <span class="n">getUtility</span>
<span class="n">policy</span> <span class="o">=</span> <span class="n">getUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><span>Pyramid</span> code will usually do:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IAuthenticationPolicy</span>
<span class="kn">from</span> <span class="nn">pyramid.threadlocal</span> <span class="kn">import</span> <span class="n">get_current_registry</span>
<span class="n">registry</span> <span class="o">=</span> <span class="n">get_current_registry</span><span class="p">()</span>
<span class="n">policy</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">getUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>While the latter is more verbose, it also arguably makes it more obvious
what's going on.  All of the <span>Pyramid</span> core code uses this pattern
rather than the ZCA global API.</p>
</div>
<div class="section" id="rationale">
<h3>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h3>
<p>Here are the main rationales involved in the <span>Pyramid</span> decision to use
the ZCA registry:</p>
<ul class="simple">
<li>History.  A nontrivial part of the answer to this question is &quot;history&quot;.
Much of the design of <span>Pyramid</span> is stolen directly from <a class="reference internal" href="glossary.html#term-zope"><em class="xref std std-term">Zope</em></a>.
Zope uses the ZCA registry to do a number of tricks.  <span>Pyramid</span> mimics
these tricks, and, because the ZCA registry works well for that set of
tricks, <span>Pyramid</span> uses it for the same purposes.  For example, the way
that <span>Pyramid</span> maps a <a class="reference internal" href="glossary.html#term-request"><em class="xref std std-term">request</em></a> to a <a class="reference internal" href="glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a> using
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> is lifted almost entirely from Zope.  The ZCA registry
plays an important role in the particulars of how this request to view
mapping is done.</li>
<li>Features.  The ZCA component registry essentially provides what can be
considered something like a superdictionary, which allows for more complex
lookups than retrieving a value based on a single key.  Some of this lookup
capability is very useful for end users, such as being able to register a
view that is only found when the context is some class of object, or when
the context implements some <a class="reference internal" href="glossary.html#term-interface"><em class="xref std std-term">interface</em></a>.</li>
<li>Singularity.  There's only one place where &quot;application configuration&quot;
lives in a <span>Pyramid</span> application: in a component registry.  The
component registry answers questions made to it by the framework at runtime
based on the configuration of <em>an application</em>.  Note: &quot;an application&quot; is
not the same as &quot;a process&quot;, multiple independently configured copies of
the same <span>Pyramid</span> application are capable of running in the same
process space.</li>
<li>Composability.  A ZCA component registry can be populated imperatively, or
there's an existing mechanism to populate a registry via the use of a
configuration file (ZCML, via the optional <a class="reference internal" href="glossary.html#term-pyramid-zcml"><em class="xref std std-term">pyramid_zcml</em></a> package).
We didn't need to write a frontend from scratch to make use of
configuration-file-driven registry population.</li>
<li>Pluggability.  Use of the ZCA registry allows for framework extensibility
via a well-defined and widely understood plugin architecture.  As long as
framework developers and extenders understand the ZCA registry, it's
possible to extend <span>Pyramid</span> almost arbitrarily.  For example, it's
relatively easy to build a directive that registers several views all at
once, allowing app developers to use that directive as a &quot;macro&quot; in code
that they write.  This is somewhat of a differentiating feature from other
(non-Zope) frameworks.</li>
<li>Testability.  Judicious use of the ZCA registry in framework code makes
testing that code slightly easier.  Instead of using monkeypatching or
other facilities to register mock objects for testing, we inject
dependencies via ZCA registrations and then use lookups in the code find
our mock objects.</li>
<li>Speed.  The ZCA registry is very fast for a specific set of complex lookup
scenarios that <span>Pyramid</span> uses, having been optimized through the years
for just these purposes.  The ZCA registry contains optional C code for
this purpose which demonstrably has no (or very few) bugs.</li>
<li>Ecosystem.  Many existing Zope packages can be used in <span>Pyramid</span> with
few (or no) changes due to our use of the ZCA registry.</li>
</ul>
</div>
<div class="section" id="conclusion">
<h3>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h3>
<p>If you only <em>develop applications</em> using <span>Pyramid</span>, there's not much to
complain about here.  You just should never need to understand the ZCA
registry API: use documented <span>Pyramid</span> APIs instead.  However, you may
be an application developer who doesn't read API documentation because it's
unmanly. Instead you read the raw source code, and because you haven't read
the documentation, you don't know what functions, classes, and methods even
<em>form</em> the <span>Pyramid</span> API.  As a result, you've now written code that
uses internals and you've painted yourself into a conceptual corner as a
result of needing to wrestle with some ZCA-using implementation detail.  If
this is you, it's extremely hard to have a lot of sympathy for you.  You'll
either need to get familiar with how we're using the ZCA registry or you'll
need to use only the documented APIs; that's why we document them as APIs.</p>
<p>If you <em>extend</em> or <em>develop</em> <span>Pyramid</span> (create new directives, use some
of the more obscure hooks as described in <a class="reference internal" href="narr/hooks.html#hooks-chapter"><em>Using Hooks</em></a>, or work on
the <span>Pyramid</span> core code), you will be faced with needing to understand
at least some ZCA concepts.  In some places it's used unabashedly, and will
be forever.  We know it's quirky, but it's also useful and fundamentally
understandable if you take the time to do some reading about it.</p>
</div>
</div>
<div class="section" id="pyramid-encourages-use-of-zcml">
<span id="zcml-encouragement"></span><h2>Pyramid &quot;Encourages Use of ZCML&quot;<a class="headerlink" href="#pyramid-encourages-use-of-zcml" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="glossary.html#term-zcml"><em class="xref std std-term">ZCML</em></a> is a configuration language that can be used to configure the
<a class="reference internal" href="glossary.html#term-zope-component-architecture"><em class="xref std std-term">Zope Component Architecture</em></a> registry that <span>Pyramid</span> uses for
application configuration.  Often people claim that Pyramid &quot;needs ZCML&quot;.</p>
<p>It doesn't.  In <span>Pyramid</span> 1.0, ZCML doesn't ship as part of the core;
instead it ships in the <a class="reference internal" href="glossary.html#term-pyramid-zcml"><em class="xref std std-term">pyramid_zcml</em></a> add-on package, which is
completely optional.  No ZCML is required at all to use <span>Pyramid</span>, nor
any other sort of frameworky declarative frontend to application
configuration.</p>
</div>
<div class="section" id="pyramid-does-traversal-and-i-don-t-like-traversal">
<h2>Pyramid Does Traversal, And I Don't Like Traversal<a class="headerlink" href="#pyramid-does-traversal-and-i-don-t-like-traversal" title="Permalink to this headline">¶</a></h2>
<p>In <span>Pyramid</span>, <a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> is the act of resolving a URL path to a
<a class="reference internal" href="glossary.html#term-resource"><em class="xref std std-term">resource</em></a> object in a resource tree.  Some people are uncomfortable
with this notion, and believe it is wrong.  Thankfully, if you use
<span>Pyramid</span>, and you don't want to model your application in terms of a
resource tree, you needn't use it at all.  Instead, use <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>
to map URL paths to views.</p>
<p>The idea that some folks believe traversal is unilaterally wrong is
understandable.  The people who believe it is wrong almost invariably have
all of their data in a relational database.  Relational databases aren't
naturally hierarchical, so traversing one like a tree is not possible.</p>
<p>However, folks who deem traversal unilaterally wrong are neglecting to take
into account that many persistence mechanisms <em>are</em> hierarchical.  Examples
include a filesystem, an LDAP database, a <a class="reference internal" href="glossary.html#term-zodb"><em class="xref std std-term">ZODB</em></a> (or another type of
graph) database, an XML document, and the Python module namespace.  It is
often convenient to model the frontend to a hierarchical data store as a
graph, using traversal to apply views to objects that either <em>are</em> the
resources in the tree being traversed (such as in the case of ZODB) or at
least ones which stand in for them (such as in the case of wrappers for files
from the filesystem).</p>
<p>Also, many website structures are naturally hierarchical, even if the data
which drives them isn't.  For example, newspaper websites are often extremely
hierarchical: sections within sections within sections, ad infinitum.  If you
want your URLs to indicate this structure, and the structure is indefinite
(the number of nested sections can be &quot;N&quot; instead of some fixed number), a
resource tree is an excellent way to model this, even if the backend is a
relational database.  In this situation, the resource tree is just a site
structure.</p>
<p>Traversal also offers better composability of applications than URL dispatch,
because it doesn't rely on a fixed ordering of URL matching.  You can compose
a set of disparate functionality (and add to it later) around a mapping of
view to resource more predictably than trying to get the right ordering of
URL pattern matching.</p>
<p>But the point is ultimately moot.  If you don't want to use traversal, you
needn't.  Use URL dispatch instead.</p>
</div>
<div class="section" id="pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch">
<h2>Pyramid Does URL Dispatch, And I Don't Like URL Dispatch<a class="headerlink" href="#pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch" title="Permalink to this headline">¶</a></h2>
<p>In <span>Pyramid</span>, <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">url dispatch</em></a> is the act of resolving a URL path to
a <a class="reference internal" href="glossary.html#term-view"><em class="xref std std-term">view</em></a> callable by performing pattern matching against some set of
ordered route definitions.  The route definitions are examined in order: the
first pattern which matches is used to associate the URL with a view
callable.</p>
<p>Some people are uncomfortable with this notion, and believe it is wrong.
These are usually people who are steeped deeply in <a class="reference internal" href="glossary.html#term-zope"><em class="xref std std-term">Zope</em></a>.  Zope does
not provide any mechanism except <a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> to map code to URLs.  This
is mainly because Zope effectively requires use of <a class="reference internal" href="glossary.html#term-zodb"><em class="xref std std-term">ZODB</em></a>, which is a
hierarchical object store.  Zope also supports relational databases, but
typically the code that calls into the database lives somewhere in the ZODB
object graph (or at least is a <a class="reference internal" href="glossary.html#term-view"><em class="xref std std-term">view</em></a> related to a node in the object
graph), and traversal is required to reach this code.</p>
<p>I'll argue that URL dispatch is ultimately useful, even if you want to use
traversal as well.  You can actually <em>combine</em> URL dispatch and traversal in
<span>Pyramid</span> (see <a class="reference internal" href="narr/hybrid.html#hybrid-chapter"><em>Combining Traversal and URL Dispatch</em></a>).  One example of such a usage: if
you want to emulate something like Zope 2's &quot;Zope Management Interface&quot; UI on
top of your object graph (or any administrative interface), you can register
a route like <tt class="docutils literal"><span class="pre">config.add_route('manage',</span> <span class="pre">'/manage/*traverse')</span></tt> and then
associate &quot;management&quot; views in your code by using the <tt class="docutils literal"><span class="pre">route_name</span></tt>
argument to a <tt class="docutils literal"><span class="pre">view</span></tt> configuration,
e.g. <tt class="docutils literal"><span class="pre">config.add_view('.some.callable',</span> <span class="pre">context=&quot;.some.Resource&quot;,</span>
<span class="pre">route_name='manage')</span></tt>.  If you wire things up this way someone then walks up
to for example, <tt class="docutils literal"><span class="pre">/manage/ob1/ob2</span></tt>, they might be presented with a
management interface, but walking up to <tt class="docutils literal"><span class="pre">/ob1/ob2</span></tt> would present them with
the default object view.  There are other tricks you can pull in these hybrid
configurations if you're clever (and maybe masochistic) too.</p>
<p>Also, if you are a URL dispatch hater, if you should ever be asked to write
an application that must use some legacy relational database structure, you
might find that using URL dispatch comes in handy for one-off associations
between views and URL paths.  Sometimes it's just pointless to add a node to
the object graph that effectively represents the entry point for some bit of
code.  You can just use a route and be done with it.  If a route matches, a
view associated with the route will be called; if no route matches,
<span>Pyramid</span> falls back to using traversal.</p>
<p>But the point is ultimately moot.  If you use <span>Pyramid</span>, and you really
don't want to use URL dispatch, you needn't use it at all.  Instead, use
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> exclusively to map URL paths to views, just like you do in
<a class="reference internal" href="glossary.html#term-zope"><em class="xref std std-term">Zope</em></a>.</p>
</div>
<div class="section" id="pyramid-views-do-not-accept-arbitrary-keyword-arguments">
<h2>Pyramid Views Do Not Accept Arbitrary Keyword Arguments<a class="headerlink" href="#pyramid-views-do-not-accept-arbitrary-keyword-arguments" title="Permalink to this headline">¶</a></h2>
<p>Many web frameworks (Zope, TurboGears, Pylons 1.X, Django) allow for their
variant of a <a class="reference internal" href="glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a> to accept arbitrary keyword or positional
arguments, which are filled in using values present in the <tt class="docutils literal"><span class="pre">request.POST</span></tt>
or <tt class="docutils literal"><span class="pre">request.GET</span></tt> dictionaries or by values present in the route match
dictionary.  For example, a Django view will accept positional arguments
which match information in an associated &quot;urlconf&quot; such as
<tt class="docutils literal"><span class="pre">r'^polls/(?P&lt;poll_id&gt;\d+)/$</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">poll_id</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="n">poll_id</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Zope, likewise allows you to add arbitrary keyword and positional
arguments to any method of a resource object found via traversal:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">persistent</span> <span class="kn">import</span> <span class="n">Persistent</span>

<span class="k">class</span> <span class="nc">MyZopeObject</span><span class="p">(</span><span class="n">Persistent</span><span class="p">):</span>
     <span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%c</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>When this method is called as the result of being the published callable, the
Zope request object's GET and POST namespaces are searched for keys which
match the names of the positional and keyword arguments in the request, and
the method is called (if possible) with its argument list filled with values
mentioned therein.  TurboGears and Pylons 1.X operate similarly.</p>
<p>Out of the box, <span>Pyramid</span> is configured to have none of these features.
By default, <span>Pyramid</span> view callables always accept only <tt class="docutils literal"><span class="pre">request</span></tt> and
no other arguments.  The rationale: this argument specification matching done
aggressively can be costly, and <span>Pyramid</span> has performance as one of its
main goals, so we've decided to make people, by default, obtain information
by interrogating the request object within the view callable body instead of
providing magic to do unpacking into the view argument list.</p>
<p>However, as of <span>Pyramid</span> 1.0a9, user code can influence the way view
callables are expected to be called, making it possible to compose a system
out of view callables which are called with arbitrary arguments.  See
<a class="reference internal" href="narr/hooks.html#using-a-view-mapper"><em>Using a View Mapper</em></a>.</p>
</div>
<div class="section" id="pyramid-provides-too-few-rails">
<h2>Pyramid Provides Too Few &quot;Rails&quot;<a class="headerlink" href="#pyramid-provides-too-few-rails" title="Permalink to this headline">¶</a></h2>
<p>By design, <span>Pyramid</span> is not a particularly opinionated web framework.
It has a relatively parsimonious feature set.  It contains no built in ORM
nor any particular database bindings.  It contains no form generation
framework.  It has no administrative web user interface.  It has no built in
text indexing.  It does not dictate how you arrange your code.</p>
<p>Such opinionated functionality exists in applications and frameworks built
<em>on top</em> of <span>Pyramid</span>.  It's intended that higher-level systems emerge
built using <span>Pyramid</span> as a base.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">See also <a class="reference internal" href="#apps-are-extensible"><em>Pyramid Applications are Extensible; I Don't Believe In Application Extensibility</em></a>.</p>
</div>
</div>
<div class="section" id="pyramid-provides-too-many-rails">
<h2>Pyramid Provides Too Many &quot;Rails&quot;<a class="headerlink" href="#pyramid-provides-too-many-rails" title="Permalink to this headline">¶</a></h2>
<p><span>Pyramid</span> provides some features that other web frameworks do not.
These are features meant for use cases that might not make sense to you if
you're building a simple bespoke web application:</p>
<ul class="simple">
<li>An optional way to map URLs to code using <a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> which implies a
walk of a <a class="reference internal" href="glossary.html#term-resource-tree"><em class="xref std std-term">resource tree</em></a>.</li>
<li>The ability to aggregate Pyramid application configuration from multiple
sources using <a class="reference internal" href="api/config.html#pyramid.config.Configurator.include" title="pyramid.config.Configurator.include"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.include()</span></tt></a>.</li>
<li>View and subscriber registrations made using <a class="reference internal" href="glossary.html#term-interface"><em class="xref std std-term">interface</em></a> objects
instead of class objects (e.g. <a class="reference internal" href="narr/traversal.html#using-resource-interfaces"><em>Using Resource Interfaces In View Configuration</em></a>).</li>
<li>A declarative <a class="reference internal" href="glossary.html#term-authorization"><em class="xref std std-term">authorization</em></a> system.</li>
<li>Multiple separate I18N <a class="reference internal" href="glossary.html#term-translation-string"><em class="xref std std-term">translation string</em></a> factories, each of which
can name its own domain.</li>
</ul>
<p>These features are important to the authors of <span>Pyramid</span>.  The
<span>Pyramid</span> authors are often commissioned to build CMS-style
applications.  Such applications are often frameworky because they have more
than one deployment.  Each deployment requires a slightly different
composition of sub-applications, and the framework and sub-applications often
need to be <em>extensible</em>.  Because the application has more than one
deployment, pluggability and extensibility is important, as maintaining
multiple forks of the application, one per deployment, is extremely
undesirable.  Because it's easier to extend a system that uses
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> from the outside than it is to do the same in a system that
uses <a class="reference internal" href="glossary.html#term-url-dispatch"><em class="xref std std-term">URL dispatch</em></a>, each deployment uses a <a class="reference internal" href="glossary.html#term-resource-tree"><em class="xref std std-term">resource tree</em></a>
composed of a persistent tree of domain model objects, and uses
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> to map <a class="reference internal" href="glossary.html#term-view-callable"><em class="xref std std-term">view callable</em></a> code to resources in the tree.
The resource tree contains very granular security declarations, as resources
are owned and accessible by different sets of users.  Interfaces are used to
make unit testing and implementation substitutability easier.</p>
<p>In a bespoke web application, usually there's a single canonical deployment,
and therefore no possibility of multiple code forks.  Extensibility is not
required; the code is just changed in-place.  Security requirements are often
less granular.  Using the features listed above will often be overkill for
such an application.</p>
<p>If you don't like these features, it doesn't mean you can't or shouldn't use
<span>Pyramid</span>.  They are all optional, and a lot of time has been spent
making sure you don't need to know about them up-front.  You can build
&quot;Pylons-1.X-style&quot; applications using <span>Pyramid</span> that are purely bespoke
by ignoring the features above.  You may find these features handy later
after building a bespoke web application that suddenly becomes popular and
requires extensibility because it must be deployed in multiple locations.</p>
</div>
<div class="section" id="pyramid-is-too-big">
<h2>Pyramid Is Too Big<a class="headerlink" href="#pyramid-is-too-big" title="Permalink to this headline">¶</a></h2>
<p>&quot;The <span>Pyramid</span> compressed tarball is larger than 2MB.  It must be
enormous!&quot;</p>
<p>No.  We just ship it with docs, test code, and scaffolding.  Here's a
breakdown of what's included in subdirectories of the package tree:</p>
<p>docs/</p>
<blockquote>
<div>4.9MB</div></blockquote>
<p>pyramid/tests/</p>
<blockquote>
<div>2.0MB</div></blockquote>
<p>pyramid/scaffolds/</p>
<blockquote>
<div>460KB</div></blockquote>
<p>pyramid/ (except for <tt class="docutils literal"><span class="pre">pyramd/tests</span></tt> and <tt class="docutils literal"><span class="pre">pyramid/scaffolds</span></tt>)</p>
<blockquote>
<div>844KB</div></blockquote>
<p>Of the approximately 34K lines of Python code in the package, the code
that actually has a chance of executing during normal operation, excluding
tests and scaffolding Python files, accounts for approximately 10K lines.</p>
</div>
<div class="section" id="pyramid-has-too-many-dependencies">
<h2>Pyramid Has Too Many Dependencies<a class="headerlink" href="#pyramid-has-too-many-dependencies" title="Permalink to this headline">¶</a></h2>
<p>Over time, we've made lots of progress on reducing the number of packaging
dependencies Pyramid has had.  Pyramid 1.2 had 15 of them.  Pyramid 1.3 and 1.4
had 12 of them.  The current release as of this writing, Pyramid 1.5, has
only 7.  This number is unlikely to become any smaller.</p>
<p>A port to Python 3 completed in Pyramid 1.3 helped us shed a good number of
dependencies by forcing us to make better packaging decisions.  Removing
Chameleon and Mako templating system dependencies in the Pyramid core in 1.5
let us shed most of the remainder of them.</p>
</div>
<div class="section" id="pyramid-cheats-to-obtain-speed">
<h2>Pyramid &quot;Cheats&quot; To Obtain Speed<a class="headerlink" href="#pyramid-cheats-to-obtain-speed" title="Permalink to this headline">¶</a></h2>
<p>Complaints have been lodged by other web framework authors at various times
that <span>Pyramid</span> &quot;cheats&quot; to gain performance.  One claimed cheating
mechanism is our use (transitively) of the C extensions provided by
<tt class="xref py py-mod docutils literal"><span class="pre">zope.interface</span></tt> to do fast lookups.  Another claimed cheating mechanism
is the religious avoidance of extraneous function calls.</p>
<p>If there's such a thing as cheating to get better performance, we want to
cheat as much as possible.  We optimize <span>Pyramid</span> aggressively.  This
comes at a cost: the core code has sections that could be expressed more
readably.  As an amelioration, we've commented these sections liberally.</p>
</div>
<div class="section" id="pyramid-gets-its-terminology-wrong-mvc">
<h2>Pyramid Gets Its Terminology Wrong (&quot;MVC&quot;)<a class="headerlink" href="#pyramid-gets-its-terminology-wrong-mvc" title="Permalink to this headline">¶</a></h2>
<p>&quot;I'm a MVC web framework user, and I'm confused.  <span>Pyramid</span> calls the
controller a view!  And it doesn't have any controllers.&quot;</p>
<p>If you are in this camp, you might have come to expect things about how your
existing &quot;MVC&quot; framework uses its terminology.  For example, you probably
expect that models are ORM models, controllers are classes that have methods
that map to URLs, and views are templates.  <span>Pyramid</span> indeed has each of
these concepts, and each probably <em>works</em> almost exactly like your existing
&quot;MVC&quot; web framework. We just don't use the MVC terminology, as we can't
square its usage in the web framework space with historical reality.</p>
<p>People very much want to give web applications the same properties as common
desktop GUI platforms by using similar terminology, and to provide some frame
of reference for how various components in the common web framework might
hang together.  But in the opinion of the author, &quot;MVC&quot; doesn't match the web
very well in general. Quoting from the <a class="reference external" href="http://en.wikipedia.org/wiki/Model–view–controller">Model-View-Controller Wikipedia entry</a>:</p>
<div class="highlight-text"><div class="highlight"><pre>Though MVC comes in different flavors, control flow is generally as
follows:

  The user interacts with the user interface in some way (for
  example, presses a mouse button).

  The controller handles the input event from the user interface,
  often via a registered handler or callback and converts the event
  into appropriate user action, understandable for the model.

  The controller notifies the model of the user action, possibly
  resulting in a change in the model&#39;s state. (For example, the
  controller updates the user&#39;s shopping cart.)[5]

  A view queries the model in order to generate an appropriate
  user interface (for example, the view lists the shopping cart&#39;s
  contents). Note that the view gets its own data from the model.

  The controller may (in some implementations) issue a general
  instruction to the view to render itself. In others, the view is
  automatically notified by the model of changes in state
  (Observer) which require a screen update.

  The user interface waits for further user interactions, which
  restarts the cycle.
</pre></div>
</div>
<p>To the author, it seems as if someone edited this Wikipedia definition,
tortuously couching concepts in the most generic terms possible in order to
account for the use of the term &quot;MVC&quot; by current web frameworks.  I doubt
such a broad definition would ever be agreed to by the original authors of
the MVC pattern.  But <em>even so</em>, it seems most MVC web frameworks fail to
meet even this falsely generic definition.</p>
<p>For example, do your templates (views) always query models directly as is
claimed in &quot;note that the view gets its own data from the model&quot;?  Probably
not.  My &quot;controllers&quot; tend to do this, massaging the data for easier use by
the &quot;view&quot; (template). What do you do when your &quot;controller&quot; returns JSON? Do
your controllers use a template to generate JSON? If not, what's the &quot;view&quot;
then?  Most MVC-style GUI web frameworks have some sort of event system
hooked up that lets the view detect when the model changes.  The web just has
no such facility in its current form: it's effectively pull-only.</p>
<p>So, in the interest of not mistaking desire with reality, and instead of
trying to jam the square peg that is the web into the round hole of &quot;MVC&quot;, we
just punt and say there are two things: resources and views. The resource
tree represents a site structure, the view presents a resource.  The
templates are really just an implementation detail of any given view: a view
doesn't need a template to return a response.  There's no &quot;controller&quot;: it
just doesn't exist.  The &quot;model&quot; is either represented by the resource tree
or by a &quot;domain model&quot; (like a SQLAlchemy model) that is separate from the
framework entirely.  This seems to us like more reasonable terminology, given
the current constraints of the web.</p>
</div>
<div class="section" id="pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility">
<span id="apps-are-extensible"></span><h2>Pyramid Applications are Extensible; I Don't Believe In Application Extensibility<a class="headerlink" href="#pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility" title="Permalink to this headline">¶</a></h2>
<p>Any <span>Pyramid</span> application written obeying certain constraints is
<em>extensible</em>. This feature is discussed in the <span>Pyramid</span> documentation
chapters named <a class="reference internal" href="narr/extending.html#extending-chapter"><em>Extending An Existing Pyramid Application</em></a> and <a class="reference internal" href="narr/advconfig.html#advconfig-narr"><em>Advanced Configuration</em></a>.  It is
made possible by the use of the <a class="reference internal" href="glossary.html#term-zope-component-architecture"><em class="xref std std-term">Zope Component Architecture</em></a> and
within <span>Pyramid</span>.</p>
<p>&quot;Extensible&quot;, in this context, means:</p>
<ul class="simple">
<li>The behavior of an application can be overridden or extended in a
particular <em>deployment</em> of the application without requiring that
the deployer modify the source of the original application.</li>
<li>The original developer is not required to anticipate any
extensibility plugpoints at application creation time to allow
fundamental application behavior to be overriden or extended.</li>
<li>The original developer may optionally choose to anticipate an
application-specific set of plugpoints, which may be hooked by
a deployer.  If he chooses to use the facilities provided by the
ZCA, the original developer does not need to think terribly hard
about the mechanics of introducing such a plugpoint.</li>
</ul>
<p>Many developers seem to believe that creating extensible applications is not
worth it.  They instead suggest that modifying the source of a given
application for each deployment to override behavior is more reasonable.
Much discussion about version control branching and merging typically ensues.</p>
<p>It's clear that making every application extensible isn't required.  The
majority of web applications only have a single deployment, and thus needn't
be extensible at all.  However, some web applications have multiple
deployments, and some have <em>many</em> deployments.  For example, a generic
content management system (CMS) may have basic functionality that needs to be
extended for a particular deployment.  That CMS system may be deployed for
many organizations at many places.  Some number of deployments of this CMS
may be deployed centrally by a third party and managed as a group.  It's
easier to be able to extend such a system for each deployment via preordained
plugpoints than it is to continually keep each software branch of the system
in sync with some upstream source: the upstream developers may change code in
such a way that your changes to the same codebase conflict with theirs in
fiddly, trivial ways.  Merging such changes repeatedly over the lifetime of a
deployment can be difficult and time consuming, and it's often useful to be
able to modify an application for a particular deployment in a less invasive
way.</p>
<p>If you don't want to think about <span>Pyramid</span> application extensibility at
all, you needn't.  You can ignore extensibility entirely.  However, if you
follow the set of rules defined in <a class="reference internal" href="narr/extending.html#extending-chapter"><em>Extending An Existing Pyramid Application</em></a>, you don't need
to <em>make</em> your application extensible: any application you write in the
framework just <em>is</em> automatically extensible at a basic level.  The
mechanisms that deployers use to extend it will be necessarily coarse:
typically, views, routes, and resources will be capable of being
overridden. But for most minor (and even some major) customizations, these
are often the only override plugpoints necessary: if the application doesn't
do exactly what the deployment requires, it's often possible for a deployer
to override a view, route, or resource and quickly make it do what he or she
wants it to do in ways <em>not necessarily anticipated by the original
developer</em>.  Here are some example scenarios demonstrating the benefits of
such a feature.</p>
<ul class="simple">
<li>If a deployment needs a different styling, the deployer may override the
main template and the CSS in a separate Python package which defines
overrides.</li>
<li>If a deployment needs an application page to do something differently, or
to expose more or different information, the deployer may override the
view that renders the page within a separate Python package.</li>
<li>If a deployment needs an additional feature, the deployer may add a view to
the override package.</li>
</ul>
<p>As long as the fundamental design of the upstream package doesn't change,
these types of modifications often survive across many releases of the
upstream package without needing to be revisited.</p>
<p>Extending an application externally is not a panacea, and carries a set of
risks similar to branching and merging: sometimes major changes upstream will
cause you to need to revisit and update some of your modifications.  But you
won't regularly need to deal wth meaningless textual merge conflicts that
trivial changes to upstream packages often entail when it comes time to
update the upstream package, because if you extend an application externally,
there just is no textual merge done.  Your modifications will also, for
whatever it's worth, be contained in one, canonical, well-defined place.</p>
<p>Branching an application and continually merging in order to get new features
and bugfixes is clearly useful.  You can do that with a <span>Pyramid</span>
application just as usefully as you can do it with any application.  But
deployment of an application written in <span>Pyramid</span> makes it possible to
avoid the need for this even if the application doesn't define any plugpoints
ahead of time.  It's possible that promoters of competing web frameworks
dismiss this feature in favor of branching and merging because applications
written in their framework of choice aren't extensible out of the box in a
comparably fundamental way.</p>
<p>While <span>Pyramid</span> applications are fundamentally extensible even if you
don't write them with specific extensibility in mind, if you're moderately
adventurous, you can also take it a step further.  If you learn more about
the <a class="reference internal" href="glossary.html#term-zope-component-architecture"><em class="xref std std-term">Zope Component Architecture</em></a>, you can optionally use it to expose
other more domain-specific configuration plugpoints while developing an
application.  The plugpoints you expose needn't be as coarse as the ones
provided automatically by <span>Pyramid</span> itself.  For example, you might
compose your own directive that configures a set of views for a prebaked
purpose (e.g. <tt class="docutils literal"><span class="pre">restview</span></tt> or somesuch) , allowing other people to refer to
that directive when they make declarations in the <tt class="docutils literal"><span class="pre">includeme</span></tt> of their
customization package.  There is a cost for this: the developer of an
application that defines custom plugpoints for its deployers will need to
understand the ZCA or he will need to develop his own similar extensibility
system.</p>
<p>Ultimately, any argument about whether the extensibility features lent to
applications by <span>Pyramid</span> are good or bad is mostly pointless. You
needn't take advantage of the extensibility features provided by a particular
<span>Pyramid</span> application in order to affect a modification for a particular
set of its deployments.  You can ignore the application's extensibility
plugpoints entirely, and use version control branching and merging to
manage application deployment modifications instead, as if you were deploying
an application written using any other web framework.</p>
</div>
<div class="section" id="zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not">
<h2>Zope 3 Enforces &quot;TTW&quot; Authorization Checks By Default; Pyramid Does Not<a class="headerlink" href="#zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not" title="Permalink to this headline">¶</a></h2>
<div class="section" id="challenge">
<h3>Challenge<a class="headerlink" href="#challenge" title="Permalink to this headline">¶</a></h3>
<p><span>Pyramid</span> performs automatic authorization checks only at <a class="reference internal" href="glossary.html#term-view"><em class="xref std std-term">view</em></a>
execution time.  Zope 3 wraps context objects with a <a class="reference external" href="http://wiki.zope.org/zope3/WhatAreSecurityProxies">security proxy</a>, which causes Zope 3 to
do also security checks during attribute access.  I like this, because it
means:</p>
<ol class="arabic simple">
<li>When I use the security proxy machinery, I can have a view that
conditionally displays certain HTML elements (like form fields) or
prevents certain attributes from being modified depending on the
permissions that the accessing user possesses with respect to a context
object.</li>
<li>I want to also expose my resources via a REST API using Twisted Web. If
Pyramid performed authorization based on attribute access via Zope3's
security proxies, I could enforce my authorization policy in both
<span>Pyramid</span> and in the Twisted-based system the same way.</li>
</ol>
</div>
<div class="section" id="defense">
<h3>Defense<a class="headerlink" href="#defense" title="Permalink to this headline">¶</a></h3>
<p><span>Pyramid</span> was developed by folks familiar with Zope 2, which has a
&quot;through the web&quot; security model.  This TTW security model was the precursor
to Zope 3's security proxies.  Over time, as the <span>Pyramid</span> developers
(working in Zope 2) created such sites, we found authorization checks during
code interpretation extremely useful in a minority of projects.  But much of
the time, TTW authorization checks usually slowed down the development
velocity of projects that had no delegation requirements.  In particular, if
we weren't allowing untrusted users to write arbitrary Python code to be
executed by our application, the burden of through the web security checks
proved too costly to justify.  We (collectively) haven't written an
application on top of which untrusted developers are allowed to write code in
many years, so it seemed to make sense to drop this model by default in a new
web framework.</p>
<p>And since we tend to use the same toolkit for all web applications, it's just
never been a concern to be able to use the same set of restricted-execution
code under two web different frameworks.</p>
<p>Justifications for disabling security proxies by default notwithstanding,
given that Zope 3 security proxies are viral by nature, the only requirement
to use one is to make sure you wrap a single object in a security proxy and
make sure to access that object normally when you want proxy security checks
to happen.  It is possible to override the <span>Pyramid</span> traverser for a
given application (see <a class="reference internal" href="narr/hooks.html#changing-the-traverser"><em>Changing the Traverser</em></a>).  To get Zope3-like
behavior, it is possible to plug in a different traverser which returns
Zope3-security-proxy-wrapped objects for each traversed object (including the
<a class="reference internal" href="glossary.html#term-context"><em class="xref std std-term">context</em></a> and the <a class="reference internal" href="glossary.html#term-root"><em class="xref std std-term">root</em></a>).  This would have the effect of
creating a more Zope3-like environment without much effort.</p>
</div>
</div>
<div class="section" id="pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc">
<span id="http-exception-hierarchy"></span><h2>Pyramid Uses its Own HTTP Exception Class Hierarchy Rather Than <tt class="docutils literal"><span class="pre">webob.exc</span></tt><a class="headerlink" href="#pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<p>The HTTP exception classes defined in <a class="reference internal" href="api/httpexceptions.html#module-pyramid.httpexceptions" title="pyramid.httpexceptions"><tt class="xref py py-mod docutils literal"><span class="pre">pyramid.httpexceptions</span></tt></a> are very
much like the ones defined in <tt class="docutils literal"><span class="pre">webob.exc</span></tt>
(e.g. <a class="reference internal" href="api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><tt class="xref py py-class docutils literal"><span class="pre">HTTPNotFound</span></tt></a>,
<a class="reference internal" href="api/httpexceptions.html#pyramid.httpexceptions.HTTPForbidden" title="pyramid.httpexceptions.HTTPForbidden"><tt class="xref py py-class docutils literal"><span class="pre">HTTPForbidden</span></tt></a>, etc).  They have the same
names and largely the same behavior and all have a very similar
implementation, but not the same identity.  Here's why they have a separate
identity:</p>
<ul class="simple">
<li>Making them separate allows the HTTP exception classes to subclass
<a class="reference internal" href="api/response.html#pyramid.response.Response" title="pyramid.response.Response"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.response.Response</span></tt></a>.  This speeds up response generation
slightly due to the way the Pyramid router works.  The same speedup could
be gained by monkeypatching <tt class="docutils literal"><span class="pre">webob.response.Response</span></tt> but it's usually
the case that monkeypatching turns out to be evil and wrong.</li>
<li>Making them separate allows them to provide alternate <tt class="docutils literal"><span class="pre">__call__</span></tt> logic
which also speeds up response generation.</li>
<li>Making them separate allows the exception classes to provide for the proper
value of <tt class="docutils literal"><span class="pre">RequestClass</span></tt> (<a class="reference internal" href="api/request.html#pyramid.request.Request" title="pyramid.request.Request"><tt class="xref py py-class docutils literal"><span class="pre">pyramid.request.Request</span></tt></a>).</li>
<li>Making them separate allows us freedom from having to think about backwards
compatibility code present in <tt class="docutils literal"><span class="pre">webob.exc</span></tt> having to do with Python 2.4,
which we no longer support in Pyramid 1.1+.</li>
<li>We change the behavior of two classes
(<a class="reference internal" href="api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><tt class="xref py py-class docutils literal"><span class="pre">HTTPNotFound</span></tt></a> and
<a class="reference internal" href="api/httpexceptions.html#pyramid.httpexceptions.HTTPForbidden" title="pyramid.httpexceptions.HTTPForbidden"><tt class="xref py py-class docutils literal"><span class="pre">HTTPForbidden</span></tt></a>) in the module so that they
can be used by Pyramid internally for notfound and forbidden exceptions.</li>
<li>Making them separate allows us to influence the docstrings of the exception
classes to provide Pyramid-specific documentation.</li>
<li>Making them separate allows us to silence a stupid deprecation warning
under Python 2.6 when the response objects are used as exceptions (related
to <tt class="docutils literal"><span class="pre">self.message</span></tt>).</li>
</ul>
</div>
<div class="section" id="pyramid-has-simpler-traversal-machinery-than-does-zope">
<span id="simpler-traversal-model"></span><h2>Pyramid has Simpler Traversal Machinery than Does Zope<a class="headerlink" href="#pyramid-has-simpler-traversal-machinery-than-does-zope" title="Permalink to this headline">¶</a></h2>
<p>Zope's default traverser:</p>
<ul class="simple">
<li>Allows developers to mutate the traversal name stack while traversing (they
can add and remove path elements).</li>
<li>Attempts to use an adaptation to obtain the next element in the path from
the currently traversed object, falling back to <tt class="docutils literal"><span class="pre">__bobo_traverse__</span></tt>,
<tt class="docutils literal"><span class="pre">__getitem__</span></tt> and eventually <tt class="docutils literal"><span class="pre">__getattr__</span></tt>.</li>
</ul>
<p>Zope's default traverser allows developers to mutate the traversal name stack
during traversal by mutating <tt class="docutils literal"><span class="pre">REQUEST['TraversalNameStack']</span></tt>.  Pyramid's
default traverser (<tt class="docutils literal"><span class="pre">pyramid.traversal.ResourceTreeTraverser</span></tt>) does not
offer a way to do this; it does not maintain a stack as a request attribute
and, even if it did, it does not pass the request to resource objects while
it's traversing.  While it was handy at times, this feature was abused in
frameworks built atop Zope (like CMF and Plone), often making it difficult to
tell exactly what was happening when a traversal didn't match a view.  I felt
it was better to make folks that wanted the feature replace the traverser
rather than build that particular honey pot in to the default traverser.</p>
<p>Zope uses multiple mechanisms to attempt to obtain the next element in the
resource tree based on a name.  It first tries an adaptation of the current
resource to <tt class="docutils literal"><span class="pre">ITraversable</span></tt>, and if that fails, it falls back to attempting
number of magic methods on the resource (<tt class="docutils literal"><span class="pre">__bobo_traverse__</span></tt>,
<tt class="docutils literal"><span class="pre">__getitem__</span></tt>, and <tt class="docutils literal"><span class="pre">__getattr__</span></tt>).  My experience while both using Zope
and attempting to reimplement its publisher in <tt class="docutils literal"><span class="pre">repoze.zope2</span></tt> led me to
believe the following:</p>
<ul class="simple">
<li>The <em>default</em> traverser should be as simple as possible.  Zope's publisher
is somewhat difficult to follow and replicate due to the fallbacks it tried
when one traversal method failed.  It is also slow.</li>
<li>The <em>entire traverser</em> should be replaceable, not just elements of the
traversal machinery.  Pyramid has a few big components rather than a
plethora of small ones.  If the entire traverser is replaceable, it's an
antipattern to make portions of the default traverser replaceable.  Doing
so is a &quot;knobs on knobs&quot; pattern, which is unfortunately somewhat endemic
in Zope.  In a &quot;knobs on knobs&quot; pattern, a replaceable subcomponent of a
larger component is made configurable using the same configuration
mechanism that can be used to replace the larger component.  For example,
in Zope, you can replace the default traverser by registering an adapter.
But you can also (or alternately) control how the default traverser
traverses by registering one or more adapters.  As a result of being able
to either replace the larger component entirely or turn knobs on the
default implementation of the larger component, no one understands when (or
whether) they should ever override the larger component entrirely.  This
results, over time, in a rusting together of the larger &quot;replaceable&quot;
component and the framework itself, because people come to depend on the
availability of the default component in order just to turn its knobs. The
default component effectively becomes part of the framework, which entirely
subverts the goal of making it replaceable.  In Pyramid, typically if a
component is replaceable, it will itself have no knobs (it will be solid
state).  If you want to influence behavior controlled by that component,
you will replace the component instead of turning knobs attached to the
component.</li>
</ul>
</div>
<div class="section" id="microframeworks-have-smaller-hello-world-programs">
<span id="microframeworks-smaller-hello-world"></span><h2>Microframeworks Have Smaller Hello World Programs<a class="headerlink" href="#microframeworks-have-smaller-hello-world-programs" title="Permalink to this headline">¶</a></h2>
<p>Self-described &quot;microframeworks&quot; exist: <a class="reference external" href="http://bottle.paws.de">Bottle</a> and
<a class="reference external" href="http://flask.pocoo.org/">Flask</a> are two that are becoming popular.  <a class="reference external" href="http://bobo.digicool.com/">Bobo</a> doesn't describe itself as a microframework,
but its intended userbase is much the same.  Many others exist.  We've
actually even (only as a teaching tool, not as any sort of official project)
<a class="reference external" href="http://bfg.repoze.org/videos#groundhog1">created one using Pyramid</a> (the
videos use BFG, a precursor to Pyramid, but the resulting code is <a class="reference external" href="https://github.com/Pylons/groundhog">available
for Pyramid too</a>). Microframeworks are
small frameworks with one common feature: each allows its users to create a
fully functional application that lives in a single Python file.</p>
<p>Some developers and microframework authors point out that Pyramid's &quot;hello
world&quot; single-file program is longer (by about five lines) than the
equivalent program in their favorite microframework.  Guilty as charged.</p>
<p>This loss isn't for lack of trying. Pyramid is useful in the same
circumstance in which microframeworks claim dominance: single-file
applications.  But Pyramid doesn't sacrifice its ability to credibly support
larger applications in order to achieve hello-world LoC parity with the
current crop of microframeworks.  Pyramid's design instead tries to avoid
some common pitfalls associated with naive declarative configuration schemes.
The subsections which follow explain the rationale.</p>
<div class="section" id="application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil">
<span id="you-dont-own-modulescope"></span><h3>Application Programmers Don't Control The Module-Scope Codepath (Import-Time Side-Effects Are Evil)<a class="headerlink" href="#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil" title="Permalink to this headline">¶</a></h3>
<p>Please imagine a directory structure with a set of Python files in it:</p>
<div class="highlight-text"><div class="highlight"><pre>.
|-- app.py
|-- app2.py
`-- config.py
</pre></div>
</div>
<p>The contents of <tt class="docutils literal"><span class="pre">app.py</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">decorator</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">L</span>
<span class="kn">import</span> <span class="nn">pprint</span>

<span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">app2</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The contents of <tt class="docutils literal"><span class="pre">app2.py</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">app</span>

<span class="nd">@app.decorator</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
<p>The contents of <tt class="docutils literal"><span class="pre">config.py</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>
</pre></div>
</td></tr></table></div>
<p>If we cd to the directory that holds these files and we run <tt class="docutils literal"><span class="pre">python</span> <span class="pre">app.py</span></tt>
given the directory structure and code above, what happens?  Presumably, our
<tt class="docutils literal"><span class="pre">decorator</span></tt> decorator will be used twice, once by the decorated function
<tt class="docutils literal"><span class="pre">foo</span></tt> in <tt class="docutils literal"><span class="pre">app.py</span></tt> and once by the decorated function <tt class="docutils literal"><span class="pre">bar</span></tt> in
<tt class="docutils literal"><span class="pre">app2.py</span></tt>.  Since each time the decorator is used, the list <tt class="docutils literal"><span class="pre">L</span></tt> in
<tt class="docutils literal"><span class="pre">config.py</span></tt> is appended to, we'd expect a list with two elements to be
printed, right?  Sadly, no:</p>
<div class="highlight-text"><div class="highlight"><pre>[chrism@thinko]$ python app.py
[&lt;function foo at 0x7f4ea41ab1b8&gt;,
 &lt;function foo at 0x7f4ea41ab230&gt;,
 &lt;function bar at 0x7f4ea41ab2a8&gt;]
</pre></div>
</div>
<p>By visual inspection, that outcome (three different functions in the list)
seems impossible.  We only defined two functions and we decorated each of
those functions only once, so we believe that the <tt class="docutils literal"><span class="pre">decorator</span></tt> decorator
will only run twice.  However, what we believe is wrong because the code at
module scope in our <tt class="docutils literal"><span class="pre">app.py</span></tt> module was <em>executed twice</em>.  The code is
executed once when the script is run as <tt class="docutils literal"><span class="pre">__main__</span></tt> (via <tt class="docutils literal"><span class="pre">python</span> <span class="pre">app.py</span></tt>),
and then it is executed again when <tt class="docutils literal"><span class="pre">app2.py</span></tt> imports the same file as
<tt class="docutils literal"><span class="pre">app</span></tt>.</p>
<p>What does this have to do with our comparison to microframeworks?  Many
microframeworks in the current crop (e.g. Bottle, Flask) encourage you to
attach configuration decorators to objects defined at module scope.  These
decorators execute arbitrarily complex registration code which populates a
singleton registry that is a global defined in external Python module.  This
is analogous to the above example: the &quot;global registry&quot; in the above example
is the list <tt class="docutils literal"><span class="pre">L</span></tt>.</p>
<p>Let's see what happens when we use the same pattern with the <a class="reference external" href="https://github.com/Pylons/groundhog">Groundhog</a> microframework.  Replace the contents
of <tt class="docutils literal"><span class="pre">app.py</span></tt> above with this:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">gh</span>

<span class="nd">@gh.route</span><span class="p">(</span><span class="s">&#39;/foo/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;foo&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">app2</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Replace the contents of <tt class="docutils literal"><span class="pre">app2.py</span></tt> above with this:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">app</span>

<span class="nd">@app.gh.route</span><span class="p">(</span><span class="s">&#39;/bar/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="s">&#39;return bar&#39;</span>
</pre></div>
</td></tr></table></div>
<p>Replace the contents of <tt class="docutils literal"><span class="pre">config.py</span></tt> above with this:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s">&#39;myapp&#39;</span><span class="p">,</span> <span class="s">&#39;seekrit&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>How many routes will be registered within the routing table of the &quot;gh&quot;
Groundhog application?  If you answered three, you are correct.  How many
would a casual reader (and any sane developer) expect to be registered?  If
you answered two, you are correct.  Will the double registration be a
problem?  With our Groundhog framework's <tt class="docutils literal"><span class="pre">route</span></tt> method backing this
application, not really.  It will slow the application down a little bit,
because it will need to miss twice for a route when it does not match.  Will
it be a problem with another framework, another application, or another
decorator?  Who knows.  You need to understand the application in its
totality, the framework in its totality, and the chronology of execution to
be able to predict what the impact of unintentional code double-execution
will be.</p>
<p>The encouragement to use decorators which perform population of an external
registry has an unintended consequence: the application developer now must
assert ownership of every codepath that executes Python module scope
code. Module-scope code is presumed by the current crop of decorator-based
microframeworks to execute once and only once; if it executes more than once,
weird things will start to happen.  It is up to the application developer to
maintain this invariant.  Unfortunately, however, in reality, this is an
impossible task, because, Python programmers <em>do not own the module scope
codepath, and never will</em>.  Anyone who tries to sell you on the idea that
they do is simply mistaken.  Test runners that you may want to use to run
your code's tests often perform imports of arbitrary code in strange orders
that manifest bugs like the one demonstrated above.  API documentation
generation tools do the same.  Some people even think it's safe to use the
Python <tt class="docutils literal"><span class="pre">reload</span></tt> command or delete objects from <tt class="docutils literal"><span class="pre">sys.modules</span></tt>, each of
which has hilarious effects when used against code that has import-time side
effects.</p>
<p>Global-registry-mutating microframework programmers therefore will at some
point need to start reading the tea leaves about what <em>might</em> happen if
module scope code gets executed more than once like we do in the previous
paragraph.  When Python programmers assume they can use the module-scope
codepath to run arbitrary code (especially code which populates an external
registry), and this assumption is challenged by reality, the application
developer is often required to undergo a painful, meticulous debugging
process to find the root cause of an inevitably obscure symptom.  The
solution is often to rearrange application import ordering or move an import
statement from module-scope into a function body.  The rationale for doing so
can never be expressed adequately in the checkin message which accompanies
the fix and can't be documented succinctly enough for the benefit of the rest
of the development team so that the problem never happens again.  It will
happen again, especially if you are working on a project with other people
who haven't yet internalized the lessons you learned while you stepped
through module-scope code using <tt class="docutils literal"><span class="pre">pdb</span></tt>.  This is a really pretty poor
situation to find yourself in as an application developer: you probably
didn't even know your or your team signed up for the job, because the
documentation offered by decorator-based microframeworks don't warn you about
it.</p>
<p>Folks who have a large investment in eager decorator-based configuration that
populates an external data structure (such as microframework authors) may
argue that the set of circumstances I outlined above is anomalous and
contrived.  They will argue that it just will never happen.  If you never
intend your application to grow beyond one or two or three modules, that's
probably true.  However, as your codebase grows, and becomes spread across a
greater number of modules, the circumstances in which module-scope code will
be executed multiple times will become more and more likely to occur and less
and less predictable.  It's not responsible to claim that double-execution of
module-scope code will never happen.  It will; it's just a matter of luck,
time, and application complexity.</p>
<p>If microframework authors do admit that the circumstance isn't contrived,
they might then argue that real damage will never happen as the result of the
double-execution (or triple-execution, etc) of module scope code.  You would
be wise to disbelieve this assertion.  The potential outcomes of multiple
execution are too numerous to predict because they involve delicate
relationships between application and framework code as well as chronology of
code execution.  It's literally impossible for a framework author to know
what will happen in all circumstances.  But even if given the gift of
omniscience for some limited set of circumstances, the framework author
almost certainly does not have the double-execution anomaly in mind when
coding new features.  He's thinking of adding a feature, not protecting
against problems that might be caused by the 1% multiple execution case.
However, any 1% case may cause 50% of your pain on a project, so it'd be nice
if it never occured.</p>
<p>Responsible microframeworks actually offer a back-door way around the
problem.  They allow you to disuse decorator based configuration entirely.
Instead of requiring you to do the following:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s">&#39;myapp&#39;</span><span class="p">,</span> <span class="s">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="nd">@gh.route</span><span class="p">(</span><span class="s">&#39;/foo/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;foo&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>They allow you to disuse the decorator syntax and go almost-all-imperative:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;foo&#39;</span>

<span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s">&#39;myapp&#39;</span><span class="p">,</span> <span class="s">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&#39;/foo/&#39;</span><span class="p">)</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>This is a generic mode of operation that is encouraged in the Pyramid
documentation. Some existing microframeworks (Flask, in particular) allow for
it as well.  None (other than Pyramid) <em>encourage</em> it.  If you never expect
your application to grow beyond two or three or four or ten modules, it
probably doesn't matter very much which mode you use.  If your application
grows large, however, imperative configuration can provide better
predictability.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Astute readers may notice that Pyramid has configuration decorators too.
Aha!  Don't these decorators have the same problems?  No.  These decorators
do not populate an external Python module when they are executed.  They
only mutate the functions (and classes and methods) they're attached to.
These mutations must later be found during a scan process that has a
predictable and structured import phase.  Module-localized mutation is
actually the best-case circumstance for double-imports; if a module only
mutates itself and its contents at import time, if it is imported twice,
that's OK, because each decorator invocation will always be mutating an
independent copy of the object it's attached to, not a shared resource like
a registry in another module.  This has the effect that
double-registrations will never be performed.</p>
</div>
</div>
<div class="section" id="routes-need-relative-ordering">
<span id="routes-need-ordering"></span><h3>Routes Need Relative Ordering<a class="headerlink" href="#routes-need-relative-ordering" title="Permalink to this headline">¶</a></h3>
<p>Consider the following simple <a class="reference external" href="https://github.com/Pylons/groundhog">Groundhog</a> application:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s">&#39;myapp&#39;</span><span class="p">,</span> <span class="s">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#39;/admin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;&lt;html&gt;admin page&lt;/html&gt;&#39;</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#39;/:action&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">action</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;add&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s">&#39;&lt;html&gt;add&lt;/html&gt;&#39;</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;delete&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s">&#39;&lt;html&gt;delete&lt;/html&gt;&#39;</span>
    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>If you run this application and visit the URL <tt class="docutils literal"><span class="pre">/admin</span></tt>, you will see the
&quot;admin&quot; page.  This is the intended result.  However, what if you rearrange
the order of the function definitions in the file?</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s">&#39;myapp&#39;</span><span class="p">,</span> <span class="s">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#39;/:action&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">action</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;add&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s">&#39;&lt;html&gt;add&lt;/html&gt;&#39;</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;delete&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s">&#39;&lt;html&gt;delete&lt;/html&gt;&#39;</span>
    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#39;/admin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;&lt;html&gt;admin page&lt;/html&gt;&#39;</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>If you run this application and visit the URL <tt class="docutils literal"><span class="pre">/admin</span></tt>, you will now be
returned a 404 error.  This is probably not what you intended.  The reason
you see a 404 error when you rearrange function definition ordering is that
routing declarations expressed via our microframework's routing decorators
have an <em>ordering</em>, and that ordering matters.</p>
<p>In the first case, where we achieved the expected result, we first added a
route with the pattern <tt class="docutils literal"><span class="pre">/admin</span></tt>, then we added a route with the pattern
<tt class="docutils literal"><span class="pre">/:action</span></tt> by virtue of adding routing patterns via decorators at module
scope.  When a request with a <tt class="docutils literal"><span class="pre">PATH_INFO</span></tt> of <tt class="docutils literal"><span class="pre">/admin</span></tt> enters our
application, the web framework loops over each of our application's route
patterns in the order in which they were defined in our module.  As a result,
the view associated with the <tt class="docutils literal"><span class="pre">/admin</span></tt> routing pattern will be invoked: it
matches first.  All is right with the world.</p>
<p>In the second case, where we did not achieve the expected result, we first
added a route with the pattern <tt class="docutils literal"><span class="pre">/:action</span></tt>, then we added a route with the
pattern <tt class="docutils literal"><span class="pre">/admin</span></tt>.  When a request with a <tt class="docutils literal"><span class="pre">PATH_INFO</span></tt> of <tt class="docutils literal"><span class="pre">/admin</span></tt> enters
our application, the web framework loops over each of our application's route
patterns in the order in which they were defined in our module.  As a result,
the view associated with the <tt class="docutils literal"><span class="pre">/:action</span></tt> routing pattern will be invoked: it
matches first.  A 404 error is raised.  This is not what we wanted; it just
happened due to the order in which we defined our view functions.</p>
<p>This is because Groundhog routes are added to the routing map in import
order, and matched in the same order when a request comes in.  Bottle, like
Groundhog, as of this writing, matches routes in the order in which they're
defined at Python execution time.  Flask, on the other hand, does not order
route matching based on import order; it reorders the routes you add to your
application based on their &quot;complexity&quot;.  Other microframeworks have varying
strategies to do route ordering.</p>
<p>Your application may be small enough where route ordering will never cause an
issue.  If your application becomes large enough, however, being able to
specify or predict that ordering as your application grows larger will be
difficult.  At some point, you will likely need to more explicitly start
controlling route ordering, especially in applications that require
extensibility.</p>
<p>If your microframework orders route matching based on complexity, you'll need
to understand what is meant by &quot;complexity&quot;, and you'll need to attempt to
inject a &quot;less complex&quot; route to have it get matched before any &quot;more
complex&quot; one to ensure that it's tried first.</p>
<p>If your microframework orders its route matching based on relative
import/execution of function decorator definitions, you will need to ensure
you execute all of these statements in the &quot;right&quot; order, and you'll need to
be cognizant of this import/execution ordering as you grow your application
or try to extend it.  This is a difficult invariant to maintain for all but
the smallest applications.</p>
<p>In either case, your application must import the non-<tt class="docutils literal"><span class="pre">__main__</span></tt> modules
which contain configuration decorations somehow for their configuration to be
executed.  Does that make you a little uncomfortable?  It should, because
<a class="reference internal" href="#you-dont-own-modulescope"><em>Application Programmers Don't Control The Module-Scope Codepath (Import-Time Side-Effects Are Evil)</em></a>.</p>
<p>Pyramid uses neither decorator import time ordering nor does it attempt to
divine the relative complexity of one route to another in order to define a
route match ordering.  In Pyramid, you have to maintain relative route
ordering imperatively via the chronology of multiple executions of the
<a class="reference internal" href="api/config.html#pyramid.config.Configurator.add_route" title="pyramid.config.Configurator.add_route"><tt class="xref py py-meth docutils literal"><span class="pre">pyramid.config.Configurator.add_route()</span></tt></a> method.  The order in which you
repeatedly call <tt class="docutils literal"><span class="pre">add_route</span></tt> becomes the order of route matching.</p>
<p>If needing to maintain this imperative ordering truly bugs you, you can use
<a class="reference internal" href="glossary.html#term-traversal"><em class="xref std std-term">traversal</em></a> instead of route matching, which is a completely
declarative (and completely predictable) mechanism to map code to URLs.
While URL dispatch is easier to understand for small non-extensible
applications, traversal is a great fit for very large applications and
applications that need to be arbitrarily extensible.</p>
</div>
<div class="section" id="stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance">
<h3>&quot;Stacked Object Proxies&quot; Are Too Clever / Thread Locals Are A Nuisance<a class="headerlink" href="#stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance" title="Permalink to this headline">¶</a></h3>
<p>Some microframeworks use the <tt class="docutils literal"><span class="pre">import</span></tt> statement to get a handle to an
object which <em>is not logically global</em>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">,</span> <span class="s">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">&#39;Invalid username/password&#39;</span>
    <span class="c"># this is executed if the request method was GET or the</span>
    <span class="c"># credentials were invalid</span>
</pre></div>
</td></tr></table></div>
<p>The <a class="reference external" href="http://pylonsproject.org">Pylons 1.X</a> web framework uses a similar
strategy.  It calls these things &quot;Stacked Object Proxies&quot;, so, for purposes
of this discussion, I'll do so as well.</p>
<p>Import statements in Python (<tt class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">from</span> <span class="pre">bar</span> <span class="pre">import</span> <span class="pre">baz</span></tt>) are
most frequently performed to obtain a reference to an object defined globally
within an external Python module.  However, in normal programs, they are
never used to obtain a reference to an object that has a lifetime measured by
the scope of the body of a function.  It would be absurd to try to import,
for example, a variable named <tt class="docutils literal"><span class="pre">i</span></tt> representing a loop counter defined in
the body of a function.  For example, we'd never try to import <tt class="docutils literal"><span class="pre">i</span></tt> from the
code below:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">afunc</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>By its nature, the <em>request</em> object created as the result of a WSGI server's
call into a long-lived web framework cannot be global, because the lifetime
of a single request will be much shorter than the lifetime of the process
running the framework.  A request object created by a web framework actually
has more similarity to the <tt class="docutils literal"><span class="pre">i</span></tt> loop counter in our example above than it
has to any comparable importable object defined in the Python standard
library or in normal library code.</p>
<p>However, systems which use stacked object proxies promote locally scoped
objects such as <tt class="docutils literal"><span class="pre">request</span></tt> out to module scope, for the purpose of being
able to offer users a nice spelling involving <tt class="docutils literal"><span class="pre">import</span></tt>.  They, for what I
consider dubious reasons, would rather present to their users the canonical
way of getting at a <tt class="docutils literal"><span class="pre">request</span></tt> as <tt class="docutils literal"><span class="pre">from</span> <span class="pre">framework</span> <span class="pre">import</span> <span class="pre">request</span></tt> instead
of a saner <tt class="docutils literal"><span class="pre">from</span> <span class="pre">myframework.threadlocals</span> <span class="pre">import</span> <span class="pre">get_request;</span> <span class="pre">request</span> <span class="pre">=</span>
<span class="pre">get_request()</span></tt> even though the latter is more explicit.</p>
<p>It would be <em>most</em> explicit if the microframeworks did not use thread local
variables at all.  Pyramid view functions are passed a request object; many
of Pyramid's APIs require that an explicit request object be passed to them.
It is <em>possible</em> to retrieve the current Pyramid request as a threadlocal
variable but it is a &quot;in case of emergency, break glass&quot; type of activity.
This explicitness makes Pyramid view functions more easily unit testable, as
you don't need to rely on the framework to manufacture suitable &quot;dummy&quot;
request (and other similarly-scoped) objects during test setup.  It also
makes them more likely to work on arbitrary systems, such as async servers
that do no monkeypatching.</p>
</div>
<div class="section" id="explicitly-wsgi">
<h3>Explicitly WSGI<a class="headerlink" href="#explicitly-wsgi" title="Permalink to this headline">¶</a></h3>
<p>Some microframeworks offer a <tt class="docutils literal"><span class="pre">run()</span></tt> method of an application object that
executes a default server configuration for easy execution.</p>
<p>Pyramid doesn't currently try to hide the fact that its router is a WSGI
application behind a convenience <tt class="docutils literal"><span class="pre">run()</span></tt> API.  It just tells people to
import a WSGI server and use it to serve up their Pyramid application as per
the documentation of that WSGI server.</p>
<p>The extra lines saved by abstracting away the serving step behind <tt class="docutils literal"><span class="pre">run()</span></tt>
seem to have driven dubious second-order decisions related to API in some
microframeworks.  For example, Bottle contains a <tt class="docutils literal"><span class="pre">ServerAdapter</span></tt> subclass
for each type of WSGI server it supports via its <tt class="docutils literal"><span class="pre">app.run()</span></tt> mechanism.
This means that there exists code in <tt class="docutils literal"><span class="pre">bottle.py</span></tt> that depends on the
following modules: <tt class="docutils literal"><span class="pre">wsgiref</span></tt>, <tt class="docutils literal"><span class="pre">flup</span></tt>, <tt class="docutils literal"><span class="pre">paste</span></tt>, <tt class="docutils literal"><span class="pre">cherrypy</span></tt>, <tt class="docutils literal"><span class="pre">fapws</span></tt>,
<tt class="docutils literal"><span class="pre">tornado</span></tt>, <tt class="docutils literal"><span class="pre">google.appengine</span></tt>, <tt class="docutils literal"><span class="pre">twisted.web</span></tt>, <tt class="docutils literal"><span class="pre">diesel</span></tt>, <tt class="docutils literal"><span class="pre">gevent</span></tt>,
<tt class="docutils literal"><span class="pre">gunicorn</span></tt>, <tt class="docutils literal"><span class="pre">eventlet</span></tt>, and <tt class="docutils literal"><span class="pre">rocket</span></tt>.  You choose the kind of server
you want to run by passing its name into the <tt class="docutils literal"><span class="pre">run</span></tt> method.  In theory, this
sounds great: I can try Bottle out on <tt class="docutils literal"><span class="pre">gunicorn</span></tt> just by passing in a name!
However, to fully test Bottle, all of these third-party systems must be
installed and functional; the Bottle developers must monitor changes to each
of these packages and make sure their code still interfaces properly with
them.  This expands the packages required for testing greatly; this is a
<em>lot</em> of requirements.  It is likely difficult to fully automate these tests
due to requirements conflicts and build issues.</p>
<p>As a result, for single-file apps, we currently don't bother to offer a
<tt class="docutils literal"><span class="pre">run()</span></tt> shortcut; we tell folks to import their WSGI server of choice and
run it by hand.  For the people who want a server abstraction layer, we
suggest that they use PasteDeploy.  In PasteDeploy-based systems, the onus
for making sure that the server can interface with a WSGI application is
placed on the server developer, not the web framework developer, making it
more likely to be timely and correct.</p>
</div>
<div class="section" id="wrapping-up">
<h3>Wrapping Up<a class="headerlink" href="#wrapping-up" title="Permalink to this headline">¶</a></h3>
<p>Here's a diagrammed version of the simplest pyramid application, where
comments take into account what we've discussed in the
<a class="reference internal" href="#microframeworks-smaller-hello-world"><em>Microframeworks Have Smaller Hello World Programs</em></a> section.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span> <span class="c"># explicit response, no thread local</span>
<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span> <span class="c"># explicitly WSGI</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>  <span class="c"># accepts a request; no request thread local reqd</span>
    <span class="c"># explicit response object means no response threadlocal</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>       <span class="c"># no global application object.</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">)</span>  <span class="c"># explicit non-decorator registration</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>  <span class="c"># explicitly WSGI</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>        <span class="c"># explicitly WSGI</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="pyramid-doesn-t-offer-pluggable-apps">
<h2>Pyramid Doesn't Offer Pluggable Apps<a class="headerlink" href="#pyramid-doesn-t-offer-pluggable-apps" title="Permalink to this headline">¶</a></h2>
<p>It is &quot;Pyramidic&quot; to compose multiple external sources into the same
configuration using <a class="reference internal" href="api/config.html#pyramid.config.Configurator.include" title="pyramid.config.Configurator.include"><tt class="xref py py-meth docutils literal"><span class="pre">include()</span></tt></a>.  Any
number of includes can be done to compose an application; includes can even
be done from within other includes.  Any directive can be used within an
include that can be used outside of one (such as
<a class="reference internal" href="api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><tt class="xref py py-meth docutils literal"><span class="pre">add_view()</span></tt></a>, etc).</p>
<p>Pyramid has a conflict detection system that will throw an error if two
included externals try to add the same configuration in a conflicting way
(such as both externals trying to add a route using the same name, or both
externals trying to add a view with the same set of predicates).  It's awful
tempting to call this set of features something that can be used to compose a
system out of &quot;pluggable applications&quot;.  But in reality, there are a number
of problems with claiming this:</p>
<ul class="simple">
<li>The terminology is strained. Pyramid really has no notion of a
plurality of &quot;applications&quot;, just a way to compose configuration
from multiple sources to create a single WSGI application.  That
WSGI application may gain behavior by including or disincluding
configuration, but once it's all composed together, Pyramid
doesn't really provide any machinery which can be used to demarcate
the boundaries of one &quot;application&quot; (in the sense of configuration
from an external that adds routes, views, etc) from another.</li>
<li>Pyramid doesn't provide enough &quot;rails&quot; to make it possible to integrate
truly honest-to-god, download-an-app-from-a-random-place
and-plug-it-in-to-create-a-system &quot;pluggable&quot; applications.  Because
Pyramid itself isn't opinionated (it doesn't mandate a particular kind of
database, it offers multiple ways to map URLs to code, etc), it's unlikely
that someone who creates something application-like will be able to
casually redistribute it to J. Random Pyramid User and have it just work by
asking him to config.include a function from the package.  This is
particularly true of very high level components such as blogs, wikis,
twitter clones, commenting systems, etc.  The integrator (the Pyramid
developer who has downloaded a package advertised as a &quot;pluggable app&quot;)
will almost certainly have made different choices about e.g. what type of
persistence system he's using, and for the integrator to appease the
requirements of the &quot;pluggable application&quot;, he may be required to set up a
different database, make changes to his own code to prevent his application
from shadowing the pluggable app (or vice versa), and any other number of
arbitrary changes.</li>
</ul>
<p>For this reason, we claim that Pyramid has &quot;extensible&quot; applications,
not pluggable applications.  Any Pyramid application can be extended
without forking it as long as its configuration statements have been
composed into things that can be pulled in via <tt class="docutils literal"><span class="pre">config.include</span></tt>.</p>
<p>It's also perfectly reasonable for a single developer or team to create a set
of interoperating components which can be enabled or disabled by using
config.include.  That developer or team will be able to provide the &quot;rails&quot;
(by way of making high-level choices about the technology used to create the
project, so there won't be any issues with plugging all of the components
together.  The problem only rears its head when the components need to be
distributed to <em>arbitrary</em> users.  Note that Django has a similar problem
with &quot;pluggable applications&quot; that need to work for arbitrary third parties,
even though they provide many, many more rails than does Pyramid.  Even the
rails they provide are not enough to make the &quot;pluggable application&quot; story
really work without local modification.</p>
<p>Truly pluggable applications need to be created at a much higher level than a
web framework, as no web framework can offer enough constraints to really
make them work out of the box.  They really need to plug into an application,
instead.  It would be a noble goal to build an application with Pyramid that
provides these constraints and which truly does offer a way to plug in
applications (Joomla, Plone, Drupal come to mind).</p>
</div>
<div class="section" id="pyramid-has-zope-things-in-it-so-it-s-too-complex">
<h2>Pyramid Has Zope Things In It, So It's Too Complex<a class="headerlink" href="#pyramid-has-zope-things-in-it-so-it-s-too-complex" title="Permalink to this headline">¶</a></h2>
<p>On occasion, someone will feel compelled to post a mailing list message that
reads something like this:</p>
<div class="highlight-text"><div class="highlight"><pre>had a quick look at pyramid ... too complex to me and not really
understand for which benefits.. I feel should consider whether it&#39;s time
for me to step back to django .. I always hated zope (useless ?)
complexity and I love simple way of thinking
</pre></div>
</div>
<p>(Paraphrased from a real email, actually.)</p>
<p>Let's take this criticism point-by-point.</p>
<div class="section" id="too-complex">
<h3>Too Complex<a class="headerlink" href="#too-complex" title="Permalink to this headline">¶</a></h3>
<p>If you can understand this hello world program, you can use Pyramid:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">)</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Pyramid has ~ 700 pages of documentation (printed), covering topics from the
very basic to the most advanced.  <em>Nothing</em> is left undocumented, quite
literally.  It also has an <em>awesome</em>, very helpful community.  Visit the
#pyramid IRC channel on freenode.net (<a class="reference external" href="irc://freenode.net#pyramid">irc://freenode.net#pyramid</a>) and see.</p>
</div>
<div class="section" id="hate-zope">
<h3>Hate Zope<a class="headerlink" href="#hate-zope" title="Permalink to this headline">¶</a></h3>
<p>I'm sorry you feel that way.  The Zope brand has certainly taken its share of
lumps over the years, and has a reputation for being insular and mysterious.
But the word &quot;Zope&quot; is literally quite meaningless without qualification.
What <em>part</em> of Zope do you hate?  &quot;Zope&quot; is a brand, not a technology.</p>
<p>If it's Zope2-the-web-framework, Pyramid is not that.  The primary designers
and developers of Pyramid, if anyone, should know.  We wrote Pyramid's
predecessor (<tt class="xref py py-mod docutils literal"><span class="pre">repoze.bfg</span></tt>), in part, because <em>we</em> knew that Zope 2 had
usability issues and limitations.  <tt class="xref py py-mod docutils literal"><span class="pre">repoze.bfg</span></tt> (and now <span>Pyramid</span>)
was written to address these issues.</p>
<p>If it's Zope3-the-web-framework, Pyramid is <em>definitely</em> not that.  Making
use of lots of Zope 3 technologies is territory already staked out by the
<a class="reference internal" href="glossary.html#term-grok"><em class="xref std std-term">Grok</em></a> project.  Save for the obvious fact that they're both web
frameworks, <span>Pyramid</span> is very, very different than Grok.  Grok exposes
lots of Zope technologies to end users.  On the other hand, if you need to
understand a Zope-only concept while using Pyramid, then we've failed on some
very basic axis.</p>
<p>If it's just the word Zope: this can only be guilt by association.  Because a
piece of software internally uses some package named <tt class="docutils literal"><span class="pre">zope.foo</span></tt>, it doesn't
turn the piece of software that uses it into &quot;Zope&quot;.  There is a lot of
<em>great</em> software written that has the word Zope in its name.  Zope is not
some sort of monolithic thing, and a lot of its software is usable
externally.  And while it's not really the job of this document to defend it,
Zope has been around for over 10 years and has an incredibly large, active
community.  If you don't believe this,
<a class="reference external" href="http://pypi-ranking.info/author">http://pypi-ranking.info/author</a> is an eye-opening reality
check.</p>
</div>
<div class="section" id="love-simplicity">
<h3>Love Simplicity<a class="headerlink" href="#love-simplicity" title="Permalink to this headline">¶</a></h3>
<p>Years of effort have gone into honing this package and its documentation to
make it as simple as humanly possible for developers to use.  Everything is a
tradeoff, of course, and people have their own ideas about what &quot;simple&quot; is.
You may have a style difference if you believe Pyramid is complex.  Its
developers obviously disagree.</p>
</div>
</div>
<div class="section" id="other-challenges">
<h2>Other Challenges<a class="headerlink" href="#other-challenges" title="Permalink to this headline">¶</a></h2>
<p>Other challenges are encouraged to be sent to the <a class="reference external" href="http://groups.google.com/group/pylons-devel">Pylons-devel</a> maillist.  We'll try to address
them by considering a design change, or at very least via exposition here.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Defending Pyramid's Design</a><ul>
<li><a class="reference internal" href="#pyramid-provides-more-than-one-way-to-do-it">Pyramid Provides More Than One Way to Do It</a></li>
<li><a class="reference internal" href="#pyramid-uses-a-zope-component-architecture-zca-registry">Pyramid Uses A Zope Component Architecture (&quot;ZCA&quot;) Registry</a><ul>
<li><a class="reference internal" href="#problems">Problems</a></li>
<li><a class="reference internal" href="#ameliorations">Ameliorations</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-encourages-use-of-zcml">Pyramid &quot;Encourages Use of ZCML&quot;</a></li>
<li><a class="reference internal" href="#pyramid-does-traversal-and-i-don-t-like-traversal">Pyramid Does Traversal, And I Don't Like Traversal</a></li>
<li><a class="reference internal" href="#pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch">Pyramid Does URL Dispatch, And I Don't Like URL Dispatch</a></li>
<li><a class="reference internal" href="#pyramid-views-do-not-accept-arbitrary-keyword-arguments">Pyramid Views Do Not Accept Arbitrary Keyword Arguments</a></li>
<li><a class="reference internal" href="#pyramid-provides-too-few-rails">Pyramid Provides Too Few &quot;Rails&quot;</a></li>
<li><a class="reference internal" href="#pyramid-provides-too-many-rails">Pyramid Provides Too Many &quot;Rails&quot;</a></li>
<li><a class="reference internal" href="#pyramid-is-too-big">Pyramid Is Too Big</a></li>
<li><a class="reference internal" href="#pyramid-has-too-many-dependencies">Pyramid Has Too Many Dependencies</a></li>
<li><a class="reference internal" href="#pyramid-cheats-to-obtain-speed">Pyramid &quot;Cheats&quot; To Obtain Speed</a></li>
<li><a class="reference internal" href="#pyramid-gets-its-terminology-wrong-mvc">Pyramid Gets Its Terminology Wrong (&quot;MVC&quot;)</a></li>
<li><a class="reference internal" href="#pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility">Pyramid Applications are Extensible; I Don't Believe In Application Extensibility</a></li>
<li><a class="reference internal" href="#zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not">Zope 3 Enforces &quot;TTW&quot; Authorization Checks By Default; Pyramid Does Not</a><ul>
<li><a class="reference internal" href="#challenge">Challenge</a></li>
<li><a class="reference internal" href="#defense">Defense</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc">Pyramid Uses its Own HTTP Exception Class Hierarchy Rather Than <tt class="docutils literal"><span class="pre">webob.exc</span></tt></a></li>
<li><a class="reference internal" href="#pyramid-has-simpler-traversal-machinery-than-does-zope">Pyramid has Simpler Traversal Machinery than Does Zope</a></li>
<li><a class="reference internal" href="#microframeworks-have-smaller-hello-world-programs">Microframeworks Have Smaller Hello World Programs</a><ul>
<li><a class="reference internal" href="#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil">Application Programmers Don't Control The Module-Scope Codepath (Import-Time Side-Effects Are Evil)</a></li>
<li><a class="reference internal" href="#routes-need-relative-ordering">Routes Need Relative Ordering</a></li>
<li><a class="reference internal" href="#stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance">&quot;Stacked Object Proxies&quot; Are Too Clever / Thread Locals Are A Nuisance</a></li>
<li><a class="reference internal" href="#explicitly-wsgi">Explicitly WSGI</a></li>
<li><a class="reference internal" href="#wrapping-up">Wrapping Up</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-doesn-t-offer-pluggable-apps">Pyramid Doesn't Offer Pluggable Apps</a></li>
<li><a class="reference internal" href="#pyramid-has-zope-things-in-it-so-it-s-too-complex">Pyramid Has Zope Things In It, So It's Too Complex</a><ul>
<li><a class="reference internal" href="#too-complex">Too Complex</a></li>
<li><a class="reference internal" href="#hate-zope">Hate Zope</a></li>
<li><a class="reference internal" href="#love-simplicity">Love Simplicity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-challenges">Other Challenges</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="changes.html"
                        title="previous chapter"><span>Pyramid</span> Change History</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="glossary.html"
                        title="next chapter">Glossary</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="glossary.html" title="Glossary"
             >next</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Pyramid Change History"
             >previous</a> |</li>
    	<li><a href="index.html">The Pyramid Web Framework v1.5</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 2008-2014, Agendaless Consulting.
      Last updated on Nov 09, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>