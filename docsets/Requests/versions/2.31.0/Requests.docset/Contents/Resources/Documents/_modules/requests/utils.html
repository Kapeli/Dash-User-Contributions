
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>requests.utils &#8212; Requests 2.31.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for requests.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">requests.utils</span>
<span class="sd">~~~~~~~~~~~~~~</span>

<span class="sd">This module provides utility functions that are used within Requests</span>
<span class="sd">that are also useful for external consumption.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">from</span> <span class="nn">urllib3.util</span> <span class="kn">import</span> <span class="n">make_headers</span><span class="p">,</span> <span class="n">parse_url</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">certs</span>
<span class="kn">from</span> <span class="nn">.__version__</span> <span class="kn">import</span> <span class="n">__version__</span>

<span class="c1"># to_native_string is unused here, but imported here for backwards compatibility</span>
<span class="kn">from</span> <span class="nn">._internal_utils</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa: F401</span>
    <span class="n">_HEADER_VALIDATORS_BYTE</span><span class="p">,</span>
    <span class="n">_HEADER_VALIDATORS_STR</span><span class="p">,</span>
    <span class="n">HEADER_VALIDATORS</span><span class="p">,</span>
    <span class="n">to_native_string</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.compat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">basestring</span><span class="p">,</span>
    <span class="nb">bytes</span><span class="p">,</span>
    <span class="n">getproxies</span><span class="p">,</span>
    <span class="n">getproxies_environment</span><span class="p">,</span>
    <span class="n">integer_types</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.compat</span> <span class="kn">import</span> <span class="n">parse_http_list</span> <span class="k">as</span> <span class="n">_parse_list_header</span>
<span class="kn">from</span> <span class="nn">.compat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">proxy_bypass</span><span class="p">,</span>
    <span class="n">proxy_bypass_environment</span><span class="p">,</span>
    <span class="n">quote</span><span class="p">,</span>
    <span class="nb">str</span><span class="p">,</span>
    <span class="n">unquote</span><span class="p">,</span>
    <span class="n">urlparse</span><span class="p">,</span>
    <span class="n">urlunparse</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.cookies</span> <span class="kn">import</span> <span class="n">cookiejar_from_dict</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">FileModeWarning</span><span class="p">,</span>
    <span class="n">InvalidHeader</span><span class="p">,</span>
    <span class="n">InvalidURL</span><span class="p">,</span>
    <span class="n">UnrewindableBodyError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.structures</span> <span class="kn">import</span> <span class="n">CaseInsensitiveDict</span>

<span class="n">NETRC_FILES</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;.netrc&quot;</span><span class="p">,</span> <span class="s2">&quot;_netrc&quot;</span><span class="p">)</span>

<span class="n">DEFAULT_CA_BUNDLE_PATH</span> <span class="o">=</span> <span class="n">certs</span><span class="o">.</span><span class="n">where</span><span class="p">()</span>

<span class="n">DEFAULT_PORTS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;http&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;https&quot;</span><span class="p">:</span> <span class="mi">443</span><span class="p">}</span>

<span class="c1"># Ensure that &#39;, &#39; is used to preserve previous delimiter behavior.</span>
<span class="n">DEFAULT_ACCEPT_ENCODING</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;,\s*&quot;</span><span class="p">,</span> <span class="n">make_headers</span><span class="p">(</span><span class="n">accept_encoding</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s2">&quot;accept-encoding&quot;</span><span class="p">])</span>
<span class="p">)</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
    <span class="c1"># provide a proxy_bypass version on Windows without DNS lookups</span>

    <span class="k">def</span> <span class="nf">proxy_bypass_registry</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">winreg</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">internetSettings</span> <span class="o">=</span> <span class="n">winreg</span><span class="o">.</span><span class="n">OpenKey</span><span class="p">(</span>
                <span class="n">winreg</span><span class="o">.</span><span class="n">HKEY_CURRENT_USER</span><span class="p">,</span>
                <span class="sa">r</span><span class="s2">&quot;Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># ProxyEnable could be REG_SZ or REG_DWORD, normalizing it</span>
            <span class="n">proxyEnable</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">winreg</span><span class="o">.</span><span class="n">QueryValueEx</span><span class="p">(</span><span class="n">internetSettings</span><span class="p">,</span> <span class="s2">&quot;ProxyEnable&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># ProxyOverride is almost always a string</span>
            <span class="n">proxyOverride</span> <span class="o">=</span> <span class="n">winreg</span><span class="o">.</span><span class="n">QueryValueEx</span><span class="p">(</span><span class="n">internetSettings</span><span class="p">,</span> <span class="s2">&quot;ProxyOverride&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">proxyEnable</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">proxyOverride</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># make a check value list from the registry entry: replace the</span>
        <span class="c1"># &#39;&lt;local&gt;&#39; string by the localhost entry and the corresponding</span>
        <span class="c1"># canonical entry.</span>
        <span class="n">proxyOverride</span> <span class="o">=</span> <span class="n">proxyOverride</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
        <span class="c1"># now check if we match one of the registry values.</span>
        <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">proxyOverride</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;&lt;local&gt;&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">host</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\.&quot;</span><span class="p">)</span>  <span class="c1"># mask dots</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;.*&quot;</span><span class="p">)</span>  <span class="c1"># change glob sequence</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>  <span class="c1"># change glob char</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">proxy_bypass</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>  <span class="c1"># noqa</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True, if the host should be bypassed.</span>

<span class="sd">        Checks proxy settings gathered from the environment, if specified,</span>
<span class="sd">        or the registry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">getproxies_environment</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">proxy_bypass_environment</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proxy_bypass_registry</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dict_to_sequence</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns an internal sequence dictionary update.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">super_len</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="n">total_length</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">current_position</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;len&quot;</span><span class="p">):</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">len</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;fileno&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fileno</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">UnsupportedOperation</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="c1"># AttributeError is a surprising exception, seeing as how we&#39;ve just checked</span>
            <span class="c1"># that `hasattr(o, &#39;fileno&#39;)`.  It happens for objects obtained via</span>
            <span class="c1"># `Tarfile.extractfile()`, per issue 5229.</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_length</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fstat</span><span class="p">(</span><span class="n">fileno</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>

            <span class="c1"># Having used fstat to determine the file length, we need to</span>
            <span class="c1"># confirm that this file was opened up in binary mode.</span>
            <span class="k">if</span> <span class="s2">&quot;b&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Requests has determined the content-length for this &quot;</span>
                        <span class="s2">&quot;request using the binary size of the file: however, the &quot;</span>
                        <span class="s2">&quot;file has been opened in text mode (i.e. without the &#39;b&#39; &quot;</span>
                        <span class="s2">&quot;flag in the mode). This may lead to an incorrect &quot;</span>
                        <span class="s2">&quot;content-length. In Requests 3.0, support will be removed &quot;</span>
                        <span class="s2">&quot;for files in text mode.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">FileModeWarning</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;tell&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">current_position</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="c1"># This can happen in some weird situations, such as when the file</span>
            <span class="c1"># is actually a special file descriptor like stdin. In this</span>
            <span class="c1"># instance, we don&#39;t know what the length is, so set it to zero and</span>
            <span class="c1"># let requests chunk it instead.</span>
            <span class="k">if</span> <span class="n">total_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_position</span> <span class="o">=</span> <span class="n">total_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;seek&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">total_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># StringIO and BytesIO have seek but no usable fileno</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># seek to end of file</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">total_length</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

                    <span class="c1"># seek back to current position to support</span>
                    <span class="c1"># partially read file-like objects</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">current_position</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="n">total_length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">total_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_length</span> <span class="o">-</span> <span class="n">current_position</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_netrc_auth</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">raise_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the Requests tuple auth for a given url from netrc.&quot;&quot;&quot;</span>

    <span class="n">netrc_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NETRC&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">netrc_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">netrc_locations</span> <span class="o">=</span> <span class="p">(</span><span class="n">netrc_file</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">netrc_locations</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;~/</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">NETRC_FILES</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">netrc</span> <span class="kn">import</span> <span class="n">NetrcParseError</span><span class="p">,</span> <span class="n">netrc</span>

        <span class="n">netrc_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">netrc_locations</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># os.path.expanduser can fail when $HOME is undefined and</span>
                <span class="c1"># getpwuid fails. See https://bugs.python.org/issue20164 &amp;</span>
                <span class="c1"># https://github.com/psf/requests/issues/1846</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">netrc_path</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="k">break</span>

        <span class="c1"># Abort early if there isn&#39;t one.</span>
        <span class="k">if</span> <span class="n">netrc_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">ri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># Strip port numbers from netloc. This weird `if...encode`` dance is</span>
        <span class="c1"># used for Python 3.2, which doesn&#39;t support unicode literals.</span>
        <span class="n">splitstr</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;:&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">splitstr</span> <span class="o">=</span> <span class="n">splitstr</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
        <span class="n">host</span> <span class="o">=</span> <span class="n">ri</span><span class="o">.</span><span class="n">netloc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">splitstr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">_netrc</span> <span class="o">=</span> <span class="n">netrc</span><span class="p">(</span><span class="n">netrc_path</span><span class="p">)</span><span class="o">.</span><span class="n">authenticators</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_netrc</span><span class="p">:</span>
                <span class="c1"># Return with login / password</span>
                <span class="n">login_i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">_netrc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">_netrc</span><span class="p">[</span><span class="n">login_i</span><span class="p">],</span> <span class="n">_netrc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">NetrcParseError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="c1"># If there was a parsing error or a permissions issue reading the file,</span>
            <span class="c1"># we&#39;ll just skip netrc auth unless explicitly asked to raise errors.</span>
            <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="c1"># App Engine hackiness.</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">def</span> <span class="nf">guess_filename</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tries to guess the filename of the given object.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extract_zipped_paths</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace nonexistent paths that look like they refer to a member of a zip</span>
<span class="sd">    archive with the location of an extracted copy of the target, or else</span>
<span class="sd">    just return the provided path unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="c1"># this is already a valid path, no need to do anything further</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="c1"># find the first valid part of the provided path and treat that as a zip archive</span>
    <span class="c1"># assume the rest of the path is the name of a member in the archive</span>
    <span class="n">archive</span><span class="p">,</span> <span class="n">member</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">archive</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">archive</span><span class="p">):</span>
        <span class="n">archive</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">archive</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="c1"># If we don&#39;t check for an empty prefix after the split (in other words, archive remains unchanged after the split),</span>
            <span class="c1"># we _can_ end up in an infinite loop on a rare corner case affecting a small number of users</span>
            <span class="k">break</span>
        <span class="n">member</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">member</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">is_zipfile</span><span class="p">(</span><span class="n">archive</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="n">zip_file</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">archive</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">member</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zip_file</span><span class="o">.</span><span class="n">namelist</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="c1"># we have a valid zip archive and a valid member of that archive</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>
    <span class="n">extracted_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">member</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">extracted_path</span><span class="p">):</span>
        <span class="c1"># use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition</span>
        <span class="k">with</span> <span class="n">atomic_open</span><span class="p">(</span><span class="n">extracted_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_handler</span><span class="p">:</span>
            <span class="n">file_handler</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">zip_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">member</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">extracted_path</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">atomic_open</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write a file to the disk in an atomic fashion&quot;&quot;&quot;</span>
    <span class="n">tmp_descriptor</span><span class="p">,</span> <span class="n">tmp_name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">tmp_descriptor</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp_handler</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tmp_handler</span>
        <span class="n">os</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tmp_name</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmp_name</span><span class="p">)</span>
        <span class="k">raise</span>


<span class="k">def</span> <span class="nf">from_key_val_list</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take an object and test to see if it can be represented as a</span>
<span class="sd">    dictionary. Unless it can not be represented as such, return an</span>
<span class="sd">    OrderedDict, e.g.,</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from_key_val_list([(&#39;key&#39;, &#39;val&#39;)])</span>
<span class="sd">        OrderedDict([(&#39;key&#39;, &#39;val&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; from_key_val_list(&#39;string&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: cannot encode objects that are not 2-tuples</span>
<span class="sd">        &gt;&gt;&gt; from_key_val_list({&#39;key&#39;: &#39;val&#39;})</span>
<span class="sd">        OrderedDict([(&#39;key&#39;, &#39;val&#39;)])</span>

<span class="sd">    :rtype: OrderedDict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot encode objects that are not 2-tuples&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_key_val_list</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take an object and test to see if it can be represented as a</span>
<span class="sd">    dictionary. If it can be, return a list of tuples, e.g.,</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; to_key_val_list([(&#39;key&#39;, &#39;val&#39;)])</span>
<span class="sd">        [(&#39;key&#39;, &#39;val&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; to_key_val_list({&#39;key&#39;: &#39;val&#39;})</span>
<span class="sd">        [(&#39;key&#39;, &#39;val&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; to_key_val_list(&#39;string&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: cannot encode objects that are not 2-tuples</span>

<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot encode objects that are not 2-tuples&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="c1"># From mitsuhiko/werkzeug (used with permission).</span>
<span class="k">def</span> <span class="nf">parse_list_header</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse lists as described by RFC 2068 Section 2.</span>

<span class="sd">    In particular, parse comma-separated lists where the elements of</span>
<span class="sd">    the list may include quoted-strings.  A quoted-string could</span>
<span class="sd">    contain a comma.  A non-quoted string could have quotes in the</span>
<span class="sd">    middle.  Quotes are removed automatically after parsing.</span>

<span class="sd">    It basically works like :func:`parse_set_header` just that items</span>
<span class="sd">    may appear multiple times and case sensitivity is preserved.</span>

<span class="sd">    The return value is a standard :class:`list`:</span>

<span class="sd">    &gt;&gt;&gt; parse_list_header(&#39;token, &quot;quoted value&quot;&#39;)</span>
<span class="sd">    [&#39;token&#39;, &#39;quoted value&#39;]</span>

<span class="sd">    To create a header from the :class:`list` again, use the</span>
<span class="sd">    :func:`dump_header` function.</span>

<span class="sd">    :param value: a string with a list header.</span>
<span class="sd">    :return: :class:`list`</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_parse_list_header</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">unquote_header_value</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># From mitsuhiko/werkzeug (used with permission).</span>
<span class="k">def</span> <span class="nf">parse_dict_header</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse lists of key, value pairs as described by RFC 2068 Section 2 and</span>
<span class="sd">    convert them into a python dict:</span>

<span class="sd">    &gt;&gt;&gt; d = parse_dict_header(&#39;foo=&quot;is a fish&quot;, bar=&quot;as well&quot;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; type(d) is dict</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; sorted(d.items())</span>
<span class="sd">    [(&#39;bar&#39;, &#39;as well&#39;), (&#39;foo&#39;, &#39;is a fish&#39;)]</span>

<span class="sd">    If there is no value for a key it will be `None`:</span>

<span class="sd">    &gt;&gt;&gt; parse_dict_header(&#39;key_without_value&#39;)</span>
<span class="sd">    {&#39;key_without_value&#39;: None}</span>

<span class="sd">    To create a header from the :class:`dict` again, use the</span>
<span class="sd">    :func:`dump_header` function.</span>

<span class="sd">    :param value: a string with a dict header.</span>
<span class="sd">    :return: :class:`dict`</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_parse_list_header</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;=&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">continue</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">unquote_header_value</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># From mitsuhiko/werkzeug (used with permission).</span>
<span class="k">def</span> <span class="nf">unquote_header_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">is_filename</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Unquotes a header value.  (Reversal of :func:`quote_header_value`).</span>
<span class="sd">    This does not use the real unquoting but what browsers are actually</span>
<span class="sd">    using for quoting.</span>

<span class="sd">    :param value: the header value to unquote.</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
        <span class="c1"># this is not the real unquoting, but fixing this so that the</span>
        <span class="c1"># RFC is met will result in bugs with internet explorer and</span>
        <span class="c1"># probably some other browsers as well.  IE for example is</span>
        <span class="c1"># uploading files with &quot;C:\foo\bar.txt&quot; as filename</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if this is a filename and the starting characters look like</span>
        <span class="c1"># a UNC path, then just return the value without quotes.  Using the</span>
        <span class="c1"># replace sequence below on a UNC path has the effect of turning</span>
        <span class="c1"># the leading double slash into a single slash and then</span>
        <span class="c1"># _fix_ie_filename() doesn&#39;t work correctly.  See #458.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_filename</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<div class="viewcode-block" id="dict_from_cookiejar"><a class="viewcode-back" href="../../api.html#requests.utils.dict_from_cookiejar">[docs]</a><span class="k">def</span> <span class="nf">dict_from_cookiejar</span><span class="p">(</span><span class="n">cj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a key/value dictionary from a CookieJar.</span>

<span class="sd">    :param cj: CookieJar object to extract cookies from.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cookie_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">cookie</span> <span class="ow">in</span> <span class="n">cj</span><span class="p">:</span>
        <span class="n">cookie_dict</span><span class="p">[</span><span class="n">cookie</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cookie</span><span class="o">.</span><span class="n">value</span>

    <span class="k">return</span> <span class="n">cookie_dict</span></div>


<div class="viewcode-block" id="add_dict_to_cookiejar"><a class="viewcode-back" href="../../api.html#requests.utils.add_dict_to_cookiejar">[docs]</a><span class="k">def</span> <span class="nf">add_dict_to_cookiejar</span><span class="p">(</span><span class="n">cj</span><span class="p">,</span> <span class="n">cookie_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a CookieJar from a key/value dictionary.</span>

<span class="sd">    :param cj: CookieJar to insert cookies into.</span>
<span class="sd">    :param cookie_dict: Dict of key/values to insert into CookieJar.</span>
<span class="sd">    :rtype: CookieJar</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">cookiejar_from_dict</span><span class="p">(</span><span class="n">cookie_dict</span><span class="p">,</span> <span class="n">cj</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_encodings_from_content"><a class="viewcode-back" href="../../api.html#requests.utils.get_encodings_from_content">[docs]</a><span class="k">def</span> <span class="nf">get_encodings_from_content</span><span class="p">(</span><span class="n">content</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns encodings from given content string.</span>

<span class="sd">    :param content: bytestring to extract encodings from.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="s2">&quot;In requests 3.0, get_encodings_from_content will be removed. For &quot;</span>
            <span class="s2">&quot;more information, please see the discussion on issue #2266. (This&quot;</span>
            <span class="s2">&quot; warning should only appear once.)&quot;</span>
        <span class="p">),</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">charset_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;meta.*?charset=[&quot;</span><span class="se">\&#39;</span><span class="s1">]*(.+?)[&quot;</span><span class="se">\&#39;</span><span class="s1">&gt;]&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
    <span class="n">pragma_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;meta.*?content=[&quot;</span><span class="se">\&#39;</span><span class="s1">]*;?charset=(.+?)[&quot;</span><span class="se">\&#39;</span><span class="s1">&gt;]&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
    <span class="n">xml_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^&lt;\?xml.*?encoding=[&quot;</span><span class="se">\&#39;</span><span class="s1">]*(.+?)[&quot;</span><span class="se">\&#39;</span><span class="s1">&gt;]&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">charset_re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">pragma_re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">xml_re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_parse_content_type_header</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns content type and parameters from given header</span>

<span class="sd">    :param header: string</span>
<span class="sd">    :return: tuple containing content type and dictionary of</span>
<span class="sd">         parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tokens</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
    <span class="n">content_type</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">params_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">items_to_strip</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&#39; &quot;</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">param</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="p">,</span> <span class="kc">True</span>
            <span class="n">index_of_equals</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index_of_equals</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">param</span><span class="p">[:</span><span class="n">index_of_equals</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">items_to_strip</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="n">index_of_equals</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">items_to_strip</span><span class="p">)</span>
            <span class="n">params_dict</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">content_type</span><span class="p">,</span> <span class="n">params_dict</span>


<div class="viewcode-block" id="get_encoding_from_headers"><a class="viewcode-back" href="../../api.html#requests.utils.get_encoding_from_headers">[docs]</a><span class="k">def</span> <span class="nf">get_encoding_from_headers</span><span class="p">(</span><span class="n">headers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns encodings from given HTTP Header Dict.</span>

<span class="sd">    :param headers: dictionary to extract encoding from.</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">content_type</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;content-type&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">content_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">content_type</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">_parse_content_type_header</span><span class="p">(</span><span class="n">content_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;charset&quot;</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;charset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;text&quot;</span> <span class="ow">in</span> <span class="n">content_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;ISO-8859-1&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;application/json&quot;</span> <span class="ow">in</span> <span class="n">content_type</span><span class="p">:</span>
        <span class="c1"># Assume UTF-8 based on RFC 4627: https://www.ietf.org/rfc/rfc4627.txt since the charset was unset</span>
        <span class="k">return</span> <span class="s2">&quot;utf-8&quot;</span></div>


<span class="k">def</span> <span class="nf">stream_decode_response_unicode</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stream decodes an iterator.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">iterator</span>
        <span class="k">return</span>

    <span class="n">decoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getincrementaldecoder</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">encoding</span><span class="p">)(</span><span class="n">errors</span><span class="o">=</span><span class="s2">&quot;replace&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">rv</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rv</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">rv</span>


<span class="k">def</span> <span class="nf">iter_slices</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">slice_length</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over slices of a string.&quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">slice_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">slice_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">slice_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">string</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">slice_length</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">slice_length</span>


<div class="viewcode-block" id="get_unicode_from_response"><a class="viewcode-back" href="../../api.html#requests.utils.get_unicode_from_response">[docs]</a><span class="k">def</span> <span class="nf">get_unicode_from_response</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the requested content back in unicode.</span>

<span class="sd">    :param r: Response object to get unicode content from.</span>

<span class="sd">    Tried:</span>

<span class="sd">    1. charset from content-type</span>
<span class="sd">    2. fall back and replace all unicode characters</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="s2">&quot;In requests 3.0, get_unicode_from_response will be removed. For &quot;</span>
            <span class="s2">&quot;more information, please see the discussion on issue #2266. (This&quot;</span>
            <span class="s2">&quot; warning should only appear once.)&quot;</span>
        <span class="p">),</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">tried_encodings</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Try charset from content-type</span>
    <span class="n">encoding</span> <span class="o">=</span> <span class="n">get_encoding_from_headers</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
            <span class="n">tried_encodings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

    <span class="c1"># Fall back:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;replace&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">content</span></div>


<span class="c1"># The unreserved URI characters (RFC 3986)</span>
<span class="n">UNRESERVED_SET</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
    <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span> <span class="o">+</span> <span class="s2">&quot;0123456789-._~&quot;</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">unquote_unreserved</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Un-escape any percent-escape sequences in a URI that are unreserved</span>
<span class="sd">    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">uri</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidURL</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid percent-escape sequence: &#39;</span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">UNRESERVED_SET</span><span class="p">:</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">requote_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Re-quote the given URI.</span>

<span class="sd">    This function passes the given URI through an unquote/quote cycle to</span>
<span class="sd">    ensure that it is fully and consistently quoted.</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">safe_with_percent</span> <span class="o">=</span> <span class="s2">&quot;!#$%&amp;&#39;()*+,/:;=?@[]~&quot;</span>
    <span class="n">safe_without_percent</span> <span class="o">=</span> <span class="s2">&quot;!#$&amp;&#39;()*+,/:;=?@[]~&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Unquote only the unreserved characters</span>
        <span class="c1"># Then quote only illegal characters (do not quote reserved,</span>
        <span class="c1"># unreserved, or &#39;%&#39;)</span>
        <span class="k">return</span> <span class="n">quote</span><span class="p">(</span><span class="n">unquote_unreserved</span><span class="p">(</span><span class="n">uri</span><span class="p">),</span> <span class="n">safe</span><span class="o">=</span><span class="n">safe_with_percent</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">InvalidURL</span><span class="p">:</span>
        <span class="c1"># We couldn&#39;t unquote the given URI, so let&#39;s try quoting it, but</span>
        <span class="c1"># there may be unquoted &#39;%&#39;s in the URI. We need to make sure they&#39;re</span>
        <span class="c1"># properly quoted so they do not cause issues elsewhere.</span>
        <span class="k">return</span> <span class="n">quote</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">safe</span><span class="o">=</span><span class="n">safe_without_percent</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">address_in_network</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">net</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function allows you to check if an IP belongs to a network subnet</span>

<span class="sd">    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24</span>
<span class="sd">             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ipaddr</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;=L&quot;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">ip</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">netaddr</span><span class="p">,</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="n">netmask</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;=L&quot;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">dotted_netmask</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bits</span><span class="p">))))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;=L&quot;</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">netaddr</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">netmask</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ipaddr</span> <span class="o">&amp;</span> <span class="n">netmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">network</span> <span class="o">&amp;</span> <span class="n">netmask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dotted_netmask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts mask from /xx format to xxx.xxx.xxx.xxx</span>

<span class="sd">    Example: if mask is 24 function returns 255.255.255.0</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;I&quot;</span><span class="p">,</span> <span class="n">bits</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_ipv4_address</span><span class="p">(</span><span class="n">string_ip</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">string_ip</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">is_valid_cidr</span><span class="p">(</span><span class="n">string_network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Very simple check of the cidr format in no_proxy variable.</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">string_network</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">string_network</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">string_network</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">set_environ</span><span class="p">(</span><span class="n">env_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the environment variable &#39;env_name&#39; to &#39;value&#39;</span>

<span class="sd">    Save previous value, yield, and then restore the previous value stored in</span>
<span class="sd">    the environment variable &#39;env_name&#39;.</span>

<span class="sd">    If &#39;value&#39; is None, do nothing&quot;&quot;&quot;</span>
    <span class="n">value_changed</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">value_changed</span><span class="p">:</span>
        <span class="n">old_value</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">env_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">env_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value_changed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">env_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">env_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_value</span>


<span class="k">def</span> <span class="nf">should_bypass_proxies</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">no_proxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether we should bypass proxies or not.</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prioritize lowercase environment variables over uppercase</span>
    <span class="c1"># to keep a consistent behaviour with other http projects (curl, wget).</span>
    <span class="k">def</span> <span class="nf">get_proxy</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="c1"># First check whether no_proxy is defined. If it is, check that the URL</span>
    <span class="c1"># we&#39;re getting isn&#39;t in the no_proxy list.</span>
    <span class="n">no_proxy_arg</span> <span class="o">=</span> <span class="n">no_proxy</span>
    <span class="k">if</span> <span class="n">no_proxy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">no_proxy</span> <span class="o">=</span> <span class="n">get_proxy</span><span class="p">(</span><span class="s2">&quot;no_proxy&quot;</span><span class="p">)</span>
    <span class="n">parsed</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># URLs don&#39;t always have hostnames, e.g. file:/// urls.</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">no_proxy</span><span class="p">:</span>
        <span class="c1"># We need to check whether we match here. We need to see if we match</span>
        <span class="c1"># the end of the hostname, both with and without the port.</span>
        <span class="n">no_proxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">host</span> <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="n">no_proxy</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">host</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_ipv4_address</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">proxy_ip</span> <span class="ow">in</span> <span class="n">no_proxy</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_valid_cidr</span><span class="p">(</span><span class="n">proxy_ip</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">address_in_network</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="n">proxy_ip</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span> <span class="o">==</span> <span class="n">proxy_ip</span><span class="p">:</span>
                    <span class="c1"># If no_proxy ip was defined in plain IP notation instead of cidr notation &amp;</span>
                    <span class="c1"># matches the IP of the index</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">host_with_port</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span>
            <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">port</span><span class="p">:</span>
                <span class="n">host_with_port</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">parsed</span><span class="o">.</span><span class="n">port</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="n">no_proxy</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="ow">or</span> <span class="n">host_with_port</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
                    <span class="c1"># The URL does match something in no_proxy, so we don&#39;t want</span>
                    <span class="c1"># to apply the proxies on this URL.</span>
                    <span class="k">return</span> <span class="kc">True</span>

    <span class="k">with</span> <span class="n">set_environ</span><span class="p">(</span><span class="s2">&quot;no_proxy&quot;</span><span class="p">,</span> <span class="n">no_proxy_arg</span><span class="p">):</span>
        <span class="c1"># parsed.hostname can be `None` in cases such as a file URI.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bypass</span> <span class="o">=</span> <span class="n">proxy_bypass</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">gaierror</span><span class="p">):</span>
            <span class="n">bypass</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">bypass</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">get_environ_proxies</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">no_proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a dict of environment proxies.</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">should_bypass_proxies</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">no_proxy</span><span class="o">=</span><span class="n">no_proxy</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">getproxies</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">select_proxy</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">proxies</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select a proxy for the url, if applicable.</span>

<span class="sd">    :param url: The url being for the request</span>
<span class="sd">    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">proxies</span> <span class="o">=</span> <span class="n">proxies</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">urlparts</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">urlparts</span><span class="o">.</span><span class="n">hostname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">proxies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">urlparts</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span> <span class="n">proxies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">))</span>

    <span class="n">proxy_keys</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">urlparts</span><span class="o">.</span><span class="n">scheme</span> <span class="o">+</span> <span class="s2">&quot;://&quot;</span> <span class="o">+</span> <span class="n">urlparts</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span>
        <span class="n">urlparts</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span>
        <span class="s2">&quot;all://&quot;</span> <span class="o">+</span> <span class="n">urlparts</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span>
        <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">proxy_key</span> <span class="ow">in</span> <span class="n">proxy_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">proxy_key</span> <span class="ow">in</span> <span class="n">proxies</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">proxies</span><span class="p">[</span><span class="n">proxy_key</span><span class="p">]</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">proxy</span>


<span class="k">def</span> <span class="nf">resolve_proxies</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">proxies</span><span class="p">,</span> <span class="n">trust_env</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This method takes proxy information from a request and configuration</span>
<span class="sd">    input to resolve a mapping of target proxies. This will consider settings</span>
<span class="sd">    such a NO_PROXY to strip proxy configurations.</span>

<span class="sd">    :param request: Request or PreparedRequest</span>
<span class="sd">    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs</span>
<span class="sd">    :param trust_env: Boolean declaring whether to trust environment configs</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">proxies</span> <span class="o">=</span> <span class="n">proxies</span> <span class="k">if</span> <span class="n">proxies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">url</span>
    <span class="n">scheme</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">scheme</span>
    <span class="n">no_proxy</span> <span class="o">=</span> <span class="n">proxies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no_proxy&quot;</span><span class="p">)</span>
    <span class="n">new_proxies</span> <span class="o">=</span> <span class="n">proxies</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">trust_env</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">should_bypass_proxies</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">no_proxy</span><span class="o">=</span><span class="n">no_proxy</span><span class="p">):</span>
        <span class="n">environ_proxies</span> <span class="o">=</span> <span class="n">get_environ_proxies</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">no_proxy</span><span class="o">=</span><span class="n">no_proxy</span><span class="p">)</span>

        <span class="n">proxy</span> <span class="o">=</span> <span class="n">environ_proxies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">environ_proxies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">proxy</span><span class="p">:</span>
            <span class="n">new_proxies</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_proxies</span>


<span class="k">def</span> <span class="nf">default_user_agent</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;python-requests&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representing the default user agent.</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">def</span> <span class="nf">default_headers</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :rtype: requests.structures.CaseInsensitiveDict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CaseInsensitiveDict</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;User-Agent&quot;</span><span class="p">:</span> <span class="n">default_user_agent</span><span class="p">(),</span>
            <span class="s2">&quot;Accept-Encoding&quot;</span><span class="p">:</span> <span class="n">DEFAULT_ACCEPT_ENCODING</span><span class="p">,</span>
            <span class="s2">&quot;Accept&quot;</span><span class="p">:</span> <span class="s2">&quot;*/*&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Connection&quot;</span><span class="p">:</span> <span class="s2">&quot;keep-alive&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_header_links</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of parsed link headers proxies.</span>

<span class="sd">    i.e. Link: &lt;http:/.../front.jpeg&gt;; rel=front; type=&quot;image/jpeg&quot;,&lt;http://.../back.jpeg&gt;; rel=back;type=&quot;image/jpeg&quot;</span>

<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">replace_chars</span> <span class="o">=</span> <span class="s2">&quot; &#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">replace_chars</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">links</span>

    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, *&lt;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

        <span class="n">link</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="n">url</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&lt;&gt; &#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">link</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">replace_chars</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">replace_chars</span><span class="p">)</span>

        <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">links</span>


<span class="c1"># Null bytes; no need to recreate these on each call to guess_json_utf</span>
<span class="n">_null</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>  <span class="c1"># encoding to ASCII for Python 3</span>
<span class="n">_null2</span> <span class="o">=</span> <span class="n">_null</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">_null3</span> <span class="o">=</span> <span class="n">_null</span> <span class="o">*</span> <span class="mi">3</span>


<span class="k">def</span> <span class="nf">guess_json_utf</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># JSON always starts with two ASCII characters, so detection is as</span>
    <span class="c1"># easy as counting the nulls and from their location and count</span>
    <span class="c1"># determine the encoding. Also detect a BOM, if present.</span>
    <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sample</span> <span class="ow">in</span> <span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_LE</span><span class="p">,</span> <span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_BE</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;utf-32&quot;</span>  <span class="c1"># BOM included</span>
    <span class="k">if</span> <span class="n">sample</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF8</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;utf-8-sig&quot;</span>  <span class="c1"># BOM included, MS style (discouraged)</span>
    <span class="k">if</span> <span class="n">sample</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_LE</span><span class="p">,</span> <span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_BE</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;utf-16&quot;</span>  <span class="c1"># BOM included</span>
    <span class="n">nullcount</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">_null</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nullcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;utf-8&quot;</span>
    <span class="k">if</span> <span class="n">nullcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sample</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">_null2</span><span class="p">:</span>  <span class="c1"># 1st and 3rd are null</span>
            <span class="k">return</span> <span class="s2">&quot;utf-16-be&quot;</span>
        <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">_null2</span><span class="p">:</span>  <span class="c1"># 2nd and 4th are null</span>
            <span class="k">return</span> <span class="s2">&quot;utf-16-le&quot;</span>
        <span class="c1"># Did not detect 2 valid UTF-16 ascii-range characters</span>
    <span class="k">if</span> <span class="n">nullcount</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sample</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">_null3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;utf-32-be&quot;</span>
        <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">_null3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;utf-32-le&quot;</span>
        <span class="c1"># Did not detect a valid UTF-32 ascii-range character</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">prepend_scheme_if_needed</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">new_scheme</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a URL that may or may not have a scheme, prepend the given scheme.</span>
<span class="sd">    Does not replace a present scheme with the one provided as an argument.</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parsed</span> <span class="o">=</span> <span class="n">parse_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">scheme</span><span class="p">,</span> <span class="n">auth</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="o">=</span> <span class="n">parsed</span>

    <span class="c1"># A defect in urlparse determines that there isn&#39;t a netloc present in some</span>
    <span class="c1"># urls. We previously assumed parsing was overly cautious, and swapped the</span>
    <span class="c1"># netloc and path. Due to a lack of tests on the original defect, this is</span>
    <span class="c1"># maintained with parse_url for backwards compatibility.</span>
    <span class="n">netloc</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="n">netloc</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">netloc</span><span class="p">:</span>
        <span class="n">netloc</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="n">netloc</span>

    <span class="k">if</span> <span class="n">auth</span><span class="p">:</span>
        <span class="c1"># parse_url doesn&#39;t provide the netloc with auth</span>
        <span class="c1"># so we&#39;ll add it ourselves.</span>
        <span class="n">netloc</span> <span class="o">=</span> <span class="s2">&quot;@&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">auth</span><span class="p">,</span> <span class="n">netloc</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scheme</span> <span class="o">=</span> <span class="n">new_scheme</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">return</span> <span class="n">urlunparse</span><span class="p">((</span><span class="n">scheme</span><span class="p">,</span> <span class="n">netloc</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_auth_from_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a url with authentication components, extract them into a tuple of</span>
<span class="sd">    username,password.</span>

<span class="sd">    :rtype: (str,str)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parsed</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">auth</span> <span class="o">=</span> <span class="p">(</span><span class="n">unquote</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">username</span><span class="p">),</span> <span class="n">unquote</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">password</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="n">auth</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">auth</span>


<span class="k">def</span> <span class="nf">check_header_validity</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verifies that header parts don&#39;t contain leading whitespace</span>
<span class="sd">    reserved characters, or return characters.</span>

<span class="sd">    :param header: tuple, in the format (name, value).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">header</span>
    <span class="n">_validate_header_part</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">_validate_header_part</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_header_part</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">header_part</span><span class="p">,</span> <span class="n">header_validator_index</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_part</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">validator</span> <span class="o">=</span> <span class="n">_HEADER_VALIDATORS_STR</span><span class="p">[</span><span class="n">header_validator_index</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_part</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">validator</span> <span class="o">=</span> <span class="n">_HEADER_VALIDATORS_BYTE</span><span class="p">[</span><span class="n">header_validator_index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InvalidHeader</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Header part (</span><span class="si">{</span><span class="n">header_part</span><span class="si">!r}</span><span class="s2">) from </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;must be of type str or bytes, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">header_part</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">validator</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">header_part</span><span class="p">):</span>
        <span class="n">header_kind</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span> <span class="k">if</span> <span class="n">header_validator_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;value&quot;</span>
        <span class="k">raise</span> <span class="n">InvalidHeader</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid leading whitespace, reserved character(s), or return&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;character(s) in header </span><span class="si">{</span><span class="n">header_kind</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">header_part</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">urldefragauth</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a url remove the fragment and the authentication part.</span>

<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scheme</span><span class="p">,</span> <span class="n">netloc</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="c1"># see func:`prepend_scheme_if_needed`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">netloc</span><span class="p">:</span>
        <span class="n">netloc</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="n">netloc</span>

    <span class="n">netloc</span> <span class="o">=</span> <span class="n">netloc</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">urlunparse</span><span class="p">((</span><span class="n">scheme</span><span class="p">,</span> <span class="n">netloc</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">rewind_body</span><span class="p">(</span><span class="n">prepared_request</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move file pointer back to its recorded starting position</span>
<span class="sd">    so it can be read again on redirect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">body_seek</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">prepared_request</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="s2">&quot;seek&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">body_seek</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">prepared_request</span><span class="o">.</span><span class="n">_body_position</span><span class="p">,</span> <span class="n">integer_types</span>
    <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">body_seek</span><span class="p">(</span><span class="n">prepared_request</span><span class="o">.</span><span class="n">_body_position</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnrewindableBodyError</span><span class="p">(</span>
                <span class="s2">&quot;An error occurred when rewinding request body for redirect.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnrewindableBodyError</span><span class="p">(</span><span class="s2">&quot;Unable to rewind request body for redirect.&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p>
  <iframe src="https://ghbtns.com/github-btn.html?user=psf&repo=requests&type=watch&count=true&size=large"
    allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>

<p>
  Requests is an elegant and simple HTTP library for Python, built for
  human beings. You are currently looking at the documentation of the
  development release.
</p>

<h3>Useful Links</h3>
<ul>
  <li><a href="https://requests.readthedocs.io/en/latest/user/quickstart/">Quickstart</a></li>
  <li><a href="https://requests.readthedocs.io/en/latest/user/advanced/">Advanced Usage</a></li>
  <li><a href="https://requests.readthedocs.io/en/latest/api/">API Reference</a></li>
  <li><a href="https://requests.readthedocs.io/en/latest/community/updates/#release-history">Release History</a></li>
  <li><a href="https://requests.readthedocs.io/en/latest/dev/contributing/">Contributors Guide</a></li>

  <p></p>

  <li><a href="https://requests.readthedocs.io/en/latest/community/recommended/">Recommended Packages and Extensions</a></li>

  <p></p>

  <li><a href="https://github.com/psf/requests">Requests @ GitHub</a></li>
  <li><a href="https://pypi.org/project/requests/">Requests @ PyPI</a></li>
  <li><a href="https://github.com/psf/requests/issues">Issue Tracker</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Alabaster (krTheme++) Hacks -->

<!-- CSS Adjustments (I'm very picky.) -->
<style type="text/css">

  /* Rezzy requires precise alignment. */
  img.logo {margin-left: -20px!important;}

  /* "Quick Search" should be capitalized. */
  div#searchbox h3 {text-transform: capitalize;}

  /* Make the document a little wider, less code is cut-off. */
  div.document {width: 1008px;}

  /* Much-improved spacing around code blocks. */
  div.highlight pre {padding: 11px 14px;}

  /* Remain Responsive! */
  @media screen and (max-width: 1008px) {
    div.sphinxsidebar {display: none;}
    div.document {width: 100%!important;}

    /* Have code blocks escape the document right-margin. */
    div.highlight pre {margin-right: -30px;}
  }
</style>

<!-- Native CPC by BuySellAds -->

<script type="text/javascript" src="//m.servedby-buysellads.com/monetization.js"></script>

<div id="native-ribbon">
</div>

<script>
_bsa.init('custom', 'CK7D62JU', 'placement:pythonrequestsorg',
    {
      target: '#native-ribbon',
      template: `
<div class="native-sponsor">Sponsored by ##company##  Learn More</div>
  <a href="##link##" class="native-flex">
    <style>
    #native-ribbon #_custom_ {
      background: linear-gradient(-30deg, ##backgroundColor##E5, ##backgroundColor##E5 45%, ##backgroundColor## 45%) #fff;
    }

    .native-details,
    .native-sponsor,
    .native-bsa {
      color: ##textColor## !important;
    }

    .native-details:hover {
      color: ##textColorHover## !important;
    }

    .native-cta {
      color: ##ctaTextColor##;
      background-color: ##ctaBackgroundColor##;
    }

    .native-cta:hover {
      color: ##ctaTextColorHover##;
      background-color: ##ctaBackgroundColorHover##;
    }
    </style>
    <div class="native-main">
      <img class="native-img" src="##logo##">
      <div class="native-details">
        <span class="native-company">##title##</span>
        <span class="native-desc">##description##</span>
      </div>
    </div>
    <span class="native-cta">##callToAction##</span>
  </a>
</div>
`
    }
  );
</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;MMXVIX. A <a href="https://kenreitz.org/projects">Kenneth Reitz</a> Project.
      
    </div>

    
    <a href="https://github.com/requests/requests" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>