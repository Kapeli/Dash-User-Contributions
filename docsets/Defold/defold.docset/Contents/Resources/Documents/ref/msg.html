<h1><a name='//apple_ref/cpp/Function/msg.post' class='dashAnchor'></a><a name='msg.post'>msg.post()</a></h1><p>posts a message to a receiving URL</p><h3>PARAMETERS</h3><p>receiver - The receiver must be a string in URL-format, a URL object, a hashed string or nil. Nil is a short way of sending the message back to the calling script. (string|url|hash|nil)</p><p>message_id - The id must be a string or a hashed string. (string|hash)</p><p>[message] - lua table message to send (table)</p><h3>EXAMPLES</h3><p><pre>
msg.post(my_url, "my_message", {my_parameter = "my_value"})
</pre></p><h1><a name='//apple_ref/cpp/Function/msg.url' class='dashAnchor'></a><a name='msg.url'>msg.url()</a></h1><p>creates a new URL</p><p>This is equivalent to msg.url("").</p><h3>RETURN</h3><p>a new URL (url)</p><h1><a name='//apple_ref/cpp/Function/msg.url' class='dashAnchor'></a><a name='msg.url'>msg.url()</a></h1><p>creates a new URL from a string</p><p>The format of the string must be <code>"[socket:][path][#fragment]"</code>, which is similar to a http URL.
When addressing instances, <code>socket</code> is the name of the collection. <code>path</code> is the id of the instance,
which can either be relative the instance of the calling script or global. <code>fragment</code> would be the id of the desired component.</p><h3>PARAMETERS</h3><p>urlstring - string to create the url from (string)</p><h3>RETURN</h3><p>a new URL (url)</p><h3>EXAMPLES</h3><p><pre>
local my_url = msg.url("#my_component")
local my_url = msg.url("my_collection:/my_sub_collection/my_instance#my_component")
local my_url = msg.url("my_socket:")
</pre></p><h1><a name='//apple_ref/cpp/Function/msg.url' class='dashAnchor'></a><a name='msg.url'>msg.url()</a></h1><p>creates a new URL from separate arguments</p><h3>PARAMETERS</h3><p>[socket] - socket of the URL (string|socket)</p><p>[path] - path of the URL (string|hash)</p><p>[fragment] - fragment of the URL (string|hash)</p><h3>RETURN</h3><p>a new URL (url)</p>