<h1><a name='//apple_ref/cpp/Command/exit' class='dashAnchor'></a><a name='exit'>exit</a></h1><p>exits application</p><p>Terminates the game application and reports the specified <code>code</code> to the OS.
This message can only be sent to the designated <code>@system</code> socket.</p><h3>PARAMETERS</h3><p>code - exit code to report to the OS, 0 means clean exit (number)</p><h3>EXAMPLES</h3><p><p>
This examples demonstrates how to exit the application when some kind of quit messages is received (maybe from gui or similar):
</p>
<pre>
function on_message(self, message_id, message, sender)
    if message_id == hash("quit") then
        msg.post("@system:", "exit", {code = 0})
    end
end
</pre></p><h1><a name='//apple_ref/cpp/Command/reboot' class='dashAnchor'></a><a name='reboot'>reboot</a></h1><p>reboot engine with arguments</p><p>Arguments will be translated into command line arguments. Sending the reboot
command is equivalent to starting the engine with the same arguments.</p><h3>PARAMETERS</h3><p>arg1 - argument 1</p><p>arg2 - argument 2</p><p>arg3 - argument 3</p><p>arg4 - argument 4</p><p>arg5 - argument 5</p><p>arg6 - argument 6</p><h3>EXAMPLES</h3><p><pre>
-- Reboot engine with a specific bootstrap collection.
local arg1 = '--config=bootstrap.main_collection=/my.collectionc'
local arg2 = 'build/default/game.projectc'
msg.post("@system:", "reboot", {arg1 = arg1, arg2 = arg2})
</pre></p><h1><a name='//apple_ref/cpp/Command/set_update_frequency' class='dashAnchor'></a><a name='set_update_frequency'>set_update_frequency</a></h1><p>set update frequency</p><p>Set game update-frequency. This option is equivalent to display.update_frequency but
set in run-time</p><h3>PARAMETERS</h3><p>frequency - target frequency. 60 for 60 fps</p><h3>EXAMPLES</h3><p><pre>
msg.post("@system:", "set_update_frequency", { frequency = 60 } )
</pre></p><h1><a name='//apple_ref/cpp/Command/start_record' class='dashAnchor'></a><a name='start_record'>start_record</a></h1><p>starts video recording</p><p>Starts video recording of the game frame-buffer to file. Current video format is the
open vp8 codec in the ivf container. It's possible to upload this format directly
to YouTube. The VLC video player has native support but with the known issue that
not the entirely files is played back. It's probably an issue with VLC.
The Miro Video Converter has support for vp8/ivf.
NOTE: Audio is currently not supported</p><h3>PARAMETERS</h3><p>file_name - file name to write the video to</p><p>frame_period - frame period to record, ie write every nth frame. Default value is 2</p><p>fps - frames per second. Playback speed for the video. Default value is 30. The fps value doens't affect the recording. It's only meta-data in the written video file.</p><h3>EXAMPLES</h3><p><pre>
Record a video in 30 fps given that the native game fps is 60:
msg.post("@system:", "start_record", { file_name = "test_rec.ivf" } )

To write a video in 60 fps given that the native game fps is 60:
msg.post("@system:", "start_record", { file_name = "test_rec.ivf", frame_period = 1, fps = 60 } )

</pre></p><h1><a name='//apple_ref/cpp/Command/stop_record' class='dashAnchor'></a><a name='stop_record'>stop_record</a></h1><p>stop current video recording</p><h3>EXAMPLES</h3><p><pre>
msg.post("@system:", "stop_record")
</pre></p><h1><a name='//apple_ref/cpp/Command/toggle_profile' class='dashAnchor'></a><a name='toggle_profile'>toggle_profile</a></h1><p>shows/hides the on-screen profiler</p><p>This message can only be sent to the designated <code>@system</code> socket.</p><h3>EXAMPLES</h3><p><pre>
msg.post("@system:", "toggle_profile")
</pre></p>