

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>transformers.models.tapas.tokenization_tapas &mdash; transformers 4.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/huggingface.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/code-snippets.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/hidesidebar.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script src="../../../../_static/js/custom.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> transformers
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Get started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../quicktour.html">Quick tour</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../philosophy.html">Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
</ul>
<p class="caption"><span class="caption-text">Using ðŸ¤— Transformers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../task_summary.html">Summary of the tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_summary.html">Summary of the models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../preprocessing.html">Preprocessing data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../training.html">Training and fine-tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_sharing.html">Model sharing and uploading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tokenizer_summary.html">Summary of the tokenizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../multilingual.html">Multi-lingual models</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../pretrained_models.html">Pretrained models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../custom_datasets.html">Fine-tuning with custom datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks.html">ðŸ¤— Transformers Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../converting_tensorflow_models.html">Converting Tensorflow Checkpoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../migration.html">Migrating from previous packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing.html">How to contribute to transformers?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../serialization.html">Exporting transformers models</a></li>
</ul>
<p class="caption"><span class="caption-text">Research</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../bertology.html">BERTology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../perplexity.html">Perplexity of fixed-length models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption"><span class="caption-text">Main Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/callback.html">Callbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/model.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/optimizer_schedules.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/output.html">Model outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/pipelines.html">Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/processors.html">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/tokenizer.html">Tokenizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../main_classes/trainer.html">Trainer</a></li>
</ul>
<p class="caption"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/albert.html">ALBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/auto.html">Auto Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/bart.html">BART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/barthez.html">BARThez</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/bert.html">BERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/bertweet.html">Bertweet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/bertgeneration.html">BertGeneration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/blenderbot.html">Blenderbot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/blenderbot_small.html">Blenderbot Small</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/camembert.html">CamemBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/ctrl.html">CTRL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/deberta.html">DeBERTa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/dialogpt.html">DialoGPT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/distilbert.html">DistilBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/dpr.html">DPR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/electra.html">ELECTRA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/encoderdecoder.html">Encoder Decoder Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/flaubert.html">FlauBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/fsmt.html">FSMT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/funnel.html">Funnel Transformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/herbert.html">herBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/layoutlm.html">LayoutLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/led.html">LED</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/longformer.html">Longformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/lxmert.html">LXMERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/marian.html">MarianMT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/mbart.html">MBart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/mobilebert.html">MobileBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/mpnet.html">MPNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/mt5.html">MT5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/gpt.html">OpenAI GPT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/gpt2.html">OpenAI GPT2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/pegasus.html">Pegasus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/phobert.html">PhoBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/prophetnet.html">ProphetNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/rag.html">RAG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/reformer.html">Reformer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/retribert.html">RetriBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/roberta.html">RoBERTa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/squeezebert.html">SqueezeBERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/t5.html">T5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/tapas.html">TAPAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/transformerxl.html">Transformer XL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/xlm.html">XLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/xlmprophetnet.html">XLM-ProphetNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/xlmroberta.html">XLM-RoBERTa</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_doc/xlnet.html">XLNet</a></li>
</ul>
<p class="caption"><span class="caption-text">Internal Helpers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../internal/modeling_utils.html">Custom Layers and Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internal/pipelines_utils.html">Utilities for pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internal/tokenization_utils.html">Utilities for Tokenizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internal/trainer_utils.html">Utilities for Trainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../internal/generation_utils.html">Utilities for Generation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">transformers</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>transformers.models.tapas.tokenization_tapas</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for transformers.models.tapas.tokenization_tapas</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="c1"># Copyright 2020 Google Research and The HuggingFace Inc. team.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot; Tokenization class for TAPAS model.&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">...file_utils</span> <span class="kn">import</span> <span class="n">add_end_docstrings</span><span class="p">,</span> <span class="n">is_pandas_available</span>
<span class="kn">from</span> <span class="nn">...tokenization_utils</span> <span class="kn">import</span> <span class="n">PreTrainedTokenizer</span><span class="p">,</span> <span class="n">_is_control</span><span class="p">,</span> <span class="n">_is_punctuation</span><span class="p">,</span> <span class="n">_is_whitespace</span>
<span class="kn">from</span> <span class="nn">...tokenization_utils_base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ENCODE_KWARGS_DOCSTRING</span><span class="p">,</span>
    <span class="n">BatchEncoding</span><span class="p">,</span>
    <span class="n">EncodedInput</span><span class="p">,</span>
    <span class="n">ExplicitEnum</span><span class="p">,</span>
    <span class="n">PaddingStrategy</span><span class="p">,</span>
    <span class="n">PreTokenizedInput</span><span class="p">,</span>
    <span class="n">TensorType</span><span class="p">,</span>
    <span class="n">TextInput</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">...utils</span> <span class="kn">import</span> <span class="n">logging</span>


<span class="k">if</span> <span class="n">is_pandas_available</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">VOCAB_FILES_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;vocab_file&quot;</span><span class="p">:</span> <span class="s2">&quot;vocab.txt&quot;</span><span class="p">}</span>

<span class="n">PRETRAINED_VOCAB_FILES_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;vocab_file&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="c1"># large models</span>
        <span class="s2">&quot;google/tapas-large-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-large-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-large-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-large-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-large-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-large-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-large-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-large-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="c1"># base models</span>
        <span class="s2">&quot;google/tapas-base-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-base-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-base-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-base-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-base-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-base-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-base-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-base-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="c1"># medium models</span>
        <span class="s2">&quot;google/tapas-medium-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-medium-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-medium-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-medium-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-medium-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-medium-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-medium-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-medium-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="c1"># small models</span>
        <span class="s2">&quot;google/tapas-small-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-small-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-small-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-small-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-small-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-small-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-small-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-small-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="c1"># tiny models</span>
        <span class="s2">&quot;google/tapas-tiny-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-tiny-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-tiny-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-tiny-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-tiny-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-tiny-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-tiny-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-tiny-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="c1"># mini models</span>
        <span class="s2">&quot;google/tapas-mini-finetuned-sqa&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-mini-finetuned-sqa/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-mini-finetuned-wtq&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-mini-finetuned-wtq/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-mini-finetuned-wikisql-supervised&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-mini-finetuned-wikisql-supervised/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;google/tapas-mini-finetuned-tabfact&quot;</span><span class="p">:</span> <span class="s2">&quot;https://huggingface.co/google/tapas-mini-finetuned-tabfact/resolve/main/vocab.txt&quot;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="mi">512</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">PRETRAINED_VOCAB_FILES_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
<span class="n">PRETRAINED_INIT_CONFIGURATION</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;do_lower_case&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">PRETRAINED_VOCAB_FILES_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>


<span class="k">class</span> <span class="nc">TapasTruncationStrategy</span><span class="p">(</span><span class="n">ExplicitEnum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Possible values for the ``truncation`` argument in :meth:`~transformers.TapasTokenizer.__call__`. Useful for</span>
<span class="sd">    tab-completion in an IDE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DROP_ROWS_TO_FIT</span> <span class="o">=</span> <span class="s2">&quot;drop_rows_to_fit&quot;</span>
    <span class="n">DO_NOT_TRUNCATE</span> <span class="o">=</span> <span class="s2">&quot;do_not_truncate&quot;</span>


<span class="n">TableValue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;TokenValue&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;token&quot;</span><span class="p">,</span> <span class="s2">&quot;column_id&quot;</span><span class="p">,</span> <span class="s2">&quot;row_id&quot;</span><span class="p">])</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TokenCoordinates</span><span class="p">:</span>
    <span class="n">column_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">row_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">token_index</span><span class="p">:</span> <span class="nb">int</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TokenizedTable</span><span class="p">:</span>
    <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]]]</span>
    <span class="n">selected_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TokenCoordinates</span><span class="p">]</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SerializedExample</span><span class="p">:</span>
    <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="n">column_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">row_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">segment_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_is_inner_wordpiece</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="n">Text</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">token</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_vocab</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads a vocabulary file into a dictionary.&quot;&quot;&quot;</span>
    <span class="n">vocab</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">vocab</span><span class="p">[</span><span class="n">token</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">return</span> <span class="n">vocab</span>


<span class="k">def</span> <span class="nf">whitespace_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs basic whitespace cleaning and splitting on a piece of text.&quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tokens</span>


<span class="n">TAPAS_ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            add_special_tokens (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="s2">                Whether or not to encode the sequences with the special tokens relative to their model.</span>
<span class="s2">            padding (:obj:`bool`, :obj:`str` or :class:`~transformers.tokenization_utils_base.PaddingStrategy`, `optional`, defaults to :obj:`False`):</span>
<span class="s2">                Activates and controls padding. Accepts the following values:</span>

<span class="s2">                * :obj:`True` or :obj:`&#39;longest&#39;`: Pad to the longest sequence in the batch (or no padding if only a</span>
<span class="s2">                  single sequence if provided).</span>
<span class="s2">                * :obj:`&#39;max_length&#39;`: Pad to a maximum length specified with the argument :obj:`max_length` or to the</span>
<span class="s2">                  maximum acceptable input length for the model if that argument is not provided.</span>
<span class="s2">                * :obj:`False` or :obj:`&#39;do_not_pad&#39;` (default): No padding (i.e., can output a batch with sequences of</span>
<span class="s2">                  different lengths).</span>
<span class="s2">            truncation (:obj:`bool`, :obj:`str` or :class:`~transformers.TapasTruncationStrategy`, `optional`, defaults to :obj:`False`):</span>
<span class="s2">                Activates and controls truncation. Accepts the following values:</span>

<span class="s2">                * :obj:`True` or :obj:`&#39;drop_rows_to_fit&#39;`: Truncate to a maximum length specified with the argument</span>
<span class="s2">                  :obj:`max_length` or to the maximum acceptable input length for the model if that argument is not</span>
<span class="s2">                  provided. This will truncate row by row, removing rows from the table.</span>
<span class="s2">                * :obj:`False` or :obj:`&#39;do_not_truncate&#39;` (default): No truncation (i.e., can output batch with</span>
<span class="s2">                  sequence lengths greater than the model maximum admissible input size).</span>
<span class="s2">            max_length (:obj:`int`, `optional`):</span>
<span class="s2">                Controls the maximum length to use by one of the truncation/padding parameters.</span>

<span class="s2">                If left unset or set to :obj:`None`, this will use the predefined model maximum length if a maximum</span>
<span class="s2">                length is required by one of the truncation/padding parameters. If the model has no specific maximum</span>
<span class="s2">                input length (like XLNet) truncation/padding to a maximum length will be deactivated.</span>
<span class="s2">            is_split_into_words (:obj:`bool`, `optional`, defaults to :obj:`False`):</span>
<span class="s2">                Whether or not the input is already pre-tokenized (e.g., split into words), in which case the tokenizer</span>
<span class="s2">                will skip the pre-tokenization step. This is useful for NER or token classification.</span>
<span class="s2">            pad_to_multiple_of (:obj:`int`, `optional`):</span>
<span class="s2">                If set will pad the sequence to a multiple of the provided value. This is especially useful to enable</span>
<span class="s2">                the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).</span>
<span class="s2">            return_tensors (:obj:`str` or :class:`~transformers.tokenization_utils_base.TensorType`, `optional`):</span>
<span class="s2">                If set, will return tensors instead of list of python integers. Acceptable values are:</span>

<span class="s2">                * :obj:`&#39;tf&#39;`: Return TensorFlow :obj:`tf.constant` objects.</span>
<span class="s2">                * :obj:`&#39;pt&#39;`: Return PyTorch :obj:`torch.Tensor` objects.</span>
<span class="s2">                * :obj:`&#39;np&#39;`: Return Numpy :obj:`np.ndarray` objects.</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="TapasTokenizer"><a class="viewcode-back" href="../../../../model_doc/tapas.html#transformers.TapasTokenizer">[docs]</a><span class="k">class</span> <span class="nc">TapasTokenizer</span><span class="p">(</span><span class="n">PreTrainedTokenizer</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a TAPAS tokenizer. Based on WordPiece. Flattens a table and one or more related sentences to be used by</span>
<span class="sd">    TAPAS models.</span>

<span class="sd">    This tokenizer inherits from :class:`~transformers.PreTrainedTokenizer` which contains most of the main methods.</span>
<span class="sd">    Users should refer to this superclass for more information regarding those methods.</span>
<span class="sd">    :class:`~transformers.TapasTokenizer` creates several token type ids to encode tabular structure. To be more</span>
<span class="sd">    precise, it adds 7 token type ids, in the following order: :obj:`segment_ids`, :obj:`column_ids`, :obj:`row_ids`,</span>
<span class="sd">    :obj:`prev_labels`, :obj:`column_ranks`, :obj:`inv_column_ranks` and :obj:`numeric_relations`:</span>

<span class="sd">    - segment_ids: indicate whether a token belongs to the question (0) or the table (1). 0 for special tokens and</span>
<span class="sd">      padding.</span>
<span class="sd">    - column_ids: indicate to which column of the table a token belongs (starting from 1). Is 0 for all question</span>
<span class="sd">      tokens, special tokens and padding.</span>
<span class="sd">    - row_ids: indicate to which row of the table a token belongs (starting from 1). Is 0 for all question tokens,</span>
<span class="sd">      special tokens and padding. Tokens of column headers are also 0.</span>
<span class="sd">    - prev_labels: indicate whether a token was (part of) an answer to the previous question (1) or not (0). Useful in</span>
<span class="sd">      a conversational setup (such as SQA).</span>
<span class="sd">    - column_ranks: indicate the rank of a table token relative to a column, if applicable. For example, if you have a</span>
<span class="sd">      column &quot;number of movies&quot; with values 87, 53 and 69, then the column ranks of these tokens are 3, 1 and 2</span>
<span class="sd">      respectively. 0 for all question tokens, special tokens and padding.</span>
<span class="sd">    - inv_column_ranks: indicate the inverse rank of a table token relative to a column, if applicable. For example, if</span>
<span class="sd">      you have a column &quot;number of movies&quot; with values 87, 53 and 69, then the inverse column ranks of these tokens are</span>
<span class="sd">      1, 3 and 2 respectively. 0 for all question tokens, special tokens and padding.</span>
<span class="sd">    - numeric_relations: indicate numeric relations between the question and the tokens of the table. 0 for all</span>
<span class="sd">      question tokens, special tokens and padding.</span>

<span class="sd">    :class:`~transformers.TapasTokenizer` runs end-to-end tokenization on a table and associated sentences: punctuation</span>
<span class="sd">    splitting and wordpiece.</span>

<span class="sd">    Args:</span>
<span class="sd">        vocab_file (:obj:`str`):</span>
<span class="sd">            File containing the vocabulary.</span>
<span class="sd">        do_lower_case (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="sd">            Whether or not to lowercase the input when tokenizing.</span>
<span class="sd">        do_basic_tokenize (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="sd">            Whether or not to do basic tokenization before WordPiece.</span>
<span class="sd">        never_split (:obj:`Iterable`, `optional`):</span>
<span class="sd">            Collection of tokens which will never be split during tokenization. Only has an effect when</span>
<span class="sd">            :obj:`do_basic_tokenize=True`</span>
<span class="sd">        unk_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[UNK]&quot;`):</span>
<span class="sd">            The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this</span>
<span class="sd">            token instead.</span>
<span class="sd">        sep_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[SEP]&quot;`):</span>
<span class="sd">            The separator token, which is used when building a sequence from multiple sequences, e.g. two sequences for</span>
<span class="sd">            sequence classification or for a text and a question for question answering. It is also used as the last</span>
<span class="sd">            token of a sequence built with special tokens.</span>
<span class="sd">        pad_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[PAD]&quot;`):</span>
<span class="sd">            The token used for padding, for example when batching sequences of different lengths.</span>
<span class="sd">        cls_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[CLS]&quot;`):</span>
<span class="sd">            The classifier token which is used when doing sequence classification (classification of the whole sequence</span>
<span class="sd">            instead of per-token classification). It is the first token of the sequence when built with special tokens.</span>
<span class="sd">        mask_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[MASK]&quot;`):</span>
<span class="sd">            The token used for masking values. This is the token used when training this model with masked language</span>
<span class="sd">            modeling. This is the token which the model will try to predict.</span>
<span class="sd">        empty_token (:obj:`str`, `optional`, defaults to :obj:`&quot;[EMPTY]&quot;`):</span>
<span class="sd">            The token used for empty cell values in a table. Empty cell values include &quot;&quot;, &quot;n/a&quot;, &quot;nan&quot; and &quot;?&quot;.</span>
<span class="sd">        tokenize_chinese_chars (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="sd">            Whether or not to tokenize Chinese characters. This should likely be deactivated for Japanese (see this</span>
<span class="sd">            `issue &lt;https://github.com/huggingface/transformers/issues/328&gt;`__).</span>
<span class="sd">        strip_accents: (:obj:`bool`, `optional`):</span>
<span class="sd">            Whether or not to strip all accents. If this option is not specified, then it will be determined by the</span>
<span class="sd">            value for :obj:`lowercase` (as in the original BERT).</span>
<span class="sd">        cell_trim_length (:obj:`int`, `optional`, defaults to -1):</span>
<span class="sd">            If &gt; 0: Trim cells so that the length is &lt;= this value. Also disables further cell trimming, should thus be</span>
<span class="sd">            used with :obj:`truncation` set to :obj:`True`.</span>
<span class="sd">        max_column_id (:obj:`int`, `optional`):</span>
<span class="sd">            Max column id to extract.</span>
<span class="sd">        max_row_id (:obj:`int`, `optional`):</span>
<span class="sd">            Max row id to extract.</span>
<span class="sd">        strip_column_names (:obj:`bool`, `optional`, defaults to :obj:`False`):</span>
<span class="sd">            Whether to add empty strings instead of column names.</span>
<span class="sd">        update_answer_coordinates (:obj:`bool`, `optional`, defaults to :obj:`False`):</span>
<span class="sd">            Whether to recompute the answer coordinates from the answer text.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vocab_files_names</span> <span class="o">=</span> <span class="n">VOCAB_FILES_NAMES</span>
    <span class="n">pretrained_vocab_files_map</span> <span class="o">=</span> <span class="n">PRETRAINED_VOCAB_FILES_MAP</span>
    <span class="n">max_model_input_sizes</span> <span class="o">=</span> <span class="n">PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vocab_file</span><span class="p">,</span>
        <span class="n">do_lower_case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">do_basic_tokenize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">never_split</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unk_token</span><span class="o">=</span><span class="s2">&quot;[UNK]&quot;</span><span class="p">,</span>
        <span class="n">sep_token</span><span class="o">=</span><span class="s2">&quot;[SEP]&quot;</span><span class="p">,</span>
        <span class="n">pad_token</span><span class="o">=</span><span class="s2">&quot;[PAD]&quot;</span><span class="p">,</span>
        <span class="n">cls_token</span><span class="o">=</span><span class="s2">&quot;[CLS]&quot;</span><span class="p">,</span>
        <span class="n">mask_token</span><span class="o">=</span><span class="s2">&quot;[MASK]&quot;</span><span class="p">,</span>
        <span class="n">empty_token</span><span class="o">=</span><span class="s2">&quot;[EMPTY]&quot;</span><span class="p">,</span>
        <span class="n">tokenize_chinese_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strip_accents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cell_trim_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_column_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_row_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strip_column_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">update_answer_coordinates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">model_max_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">additional_special_tokens</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_pandas_available</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Pandas is required for the TAPAS tokenizer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">additional_special_tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">empty_token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">additional_special_tokens</span><span class="p">:</span>
                <span class="n">additional_special_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">empty_token</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_special_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">empty_token</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">do_lower_case</span><span class="o">=</span><span class="n">do_lower_case</span><span class="p">,</span>
            <span class="n">do_basic_tokenize</span><span class="o">=</span><span class="n">do_basic_tokenize</span><span class="p">,</span>
            <span class="n">never_split</span><span class="o">=</span><span class="n">never_split</span><span class="p">,</span>
            <span class="n">unk_token</span><span class="o">=</span><span class="n">unk_token</span><span class="p">,</span>
            <span class="n">sep_token</span><span class="o">=</span><span class="n">sep_token</span><span class="p">,</span>
            <span class="n">pad_token</span><span class="o">=</span><span class="n">pad_token</span><span class="p">,</span>
            <span class="n">cls_token</span><span class="o">=</span><span class="n">cls_token</span><span class="p">,</span>
            <span class="n">mask_token</span><span class="o">=</span><span class="n">mask_token</span><span class="p">,</span>
            <span class="n">empty_token</span><span class="o">=</span><span class="n">empty_token</span><span class="p">,</span>
            <span class="n">tokenize_chinese_chars</span><span class="o">=</span><span class="n">tokenize_chinese_chars</span><span class="p">,</span>
            <span class="n">strip_accents</span><span class="o">=</span><span class="n">strip_accents</span><span class="p">,</span>
            <span class="n">cell_trim_length</span><span class="o">=</span><span class="n">cell_trim_length</span><span class="p">,</span>
            <span class="n">max_column_id</span><span class="o">=</span><span class="n">max_column_id</span><span class="p">,</span>
            <span class="n">max_row_id</span><span class="o">=</span><span class="n">max_row_id</span><span class="p">,</span>
            <span class="n">strip_column_names</span><span class="o">=</span><span class="n">strip_column_names</span><span class="p">,</span>
            <span class="n">update_answer_coordinates</span><span class="o">=</span><span class="n">update_answer_coordinates</span><span class="p">,</span>
            <span class="n">model_max_length</span><span class="o">=</span><span class="n">model_max_length</span><span class="p">,</span>
            <span class="n">additional_special_tokens</span><span class="o">=</span><span class="n">additional_special_tokens</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t find a vocabulary file at path &#39;</span><span class="si">{}</span><span class="s2">&#39;. To load the vocabulary from a Google pretrained &quot;</span>
                <span class="s2">&quot;model use `tokenizer = BertTokenizer.from_pretrained(PRETRAINED_MODEL_NAME)`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="n">load_vocab</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ids_to_tokens</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">ids</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span> <span class="k">for</span> <span class="n">tok</span><span class="p">,</span> <span class="n">ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_basic_tokenize</span> <span class="o">=</span> <span class="n">do_basic_tokenize</span>
        <span class="k">if</span> <span class="n">do_basic_tokenize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basic_tokenizer</span> <span class="o">=</span> <span class="n">BasicTokenizer</span><span class="p">(</span>
                <span class="n">do_lower_case</span><span class="o">=</span><span class="n">do_lower_case</span><span class="p">,</span>
                <span class="n">never_split</span><span class="o">=</span><span class="n">never_split</span><span class="p">,</span>
                <span class="n">tokenize_chinese_chars</span><span class="o">=</span><span class="n">tokenize_chinese_chars</span><span class="p">,</span>
                <span class="n">strip_accents</span><span class="o">=</span><span class="n">strip_accents</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordpiece_tokenizer</span> <span class="o">=</span> <span class="n">WordpieceTokenizer</span><span class="p">(</span><span class="n">vocab</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">unk_token</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span><span class="p">)</span>

        <span class="c1"># Additional properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_trim_length</span> <span class="o">=</span> <span class="n">cell_trim_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_column_id</span> <span class="o">=</span> <span class="n">max_column_id</span> <span class="k">if</span> <span class="n">max_column_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_row_id</span> <span class="o">=</span> <span class="n">max_row_id</span> <span class="k">if</span> <span class="n">max_row_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_column_names</span> <span class="o">=</span> <span class="n">strip_column_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_answer_coordinates</span> <span class="o">=</span> <span class="n">update_answer_coordinates</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">do_lower_case</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_tokenizer</span><span class="o">.</span><span class="n">do_lower_case</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vocab_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">added_tokens_encoder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">format_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMPTY_TEXT</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">additional_special_tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">split_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_basic_tokenize</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">never_split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_special_tokens</span><span class="p">):</span>

                <span class="c1"># If the token is part of the never_split set</span>
                <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_tokenizer</span><span class="o">.</span><span class="n">never_split</span><span class="p">:</span>
                    <span class="n">split_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">split_tokens</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordpiece_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">split_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordpiece_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">split_tokens</span>

    <span class="k">def</span> <span class="nf">_convert_token_to_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Converts a token (str) in an id using the vocab. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_convert_id_to_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts an index (integer) in a token (str) using the vocab.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ids_to_tokens</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_tokens_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Converts a sequence of tokens (string) in a single string. &quot;&quot;&quot;</span>
        <span class="n">out_string</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; ##&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out_string</span>

<div class="viewcode-block" id="TapasTokenizer.save_vocabulary"><a class="viewcode-back" href="../../../../model_doc/tapas.html#transformers.TapasTokenizer.save_vocabulary">[docs]</a>    <span class="k">def</span> <span class="nf">save_vocabulary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">save_directory</span><span class="p">):</span>
            <span class="n">vocab_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">save_directory</span><span class="p">,</span> <span class="p">(</span><span class="n">filename_prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="n">filename_prefix</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">VOCAB_FILES_NAMES</span><span class="p">[</span><span class="s2">&quot;vocab_file&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vocab_file</span> <span class="o">=</span> <span class="p">(</span><span class="n">filename_prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="n">filename_prefix</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">save_directory</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">vocab_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">token</span><span class="p">,</span> <span class="n">token_index</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">token_index</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Saving vocabulary to </span><span class="si">{</span><span class="n">vocab_file</span><span class="si">}</span><span class="s2">: vocabulary indices are not consecutive.&quot;</span>
                        <span class="s2">&quot; Please check that the vocabulary is not corrupted!&quot;</span>
                    <span class="p">)</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">token_index</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">token</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">vocab_file</span><span class="p">,)</span></div>

    <span class="k">def</span> <span class="nf">create_attention_mask_from_sequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">table_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TableValue</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the attention mask according to the query token IDs and a list of table values.</span>

<span class="sd">        Args:</span>
<span class="sd">            query_ids (:obj:`List[int]`): list of token IDs corresponding to the ID.</span>
<span class="sd">            table_values (:obj:`List[TableValue]`): lift of table values, which are named tuples containing the</span>
<span class="sd">                token value, the column ID and the row ID of said token.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: List of ints containing the attention mask values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">table_values</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">create_segment_token_type_ids_from_sequences</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">table_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TableValue</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the segment token type IDs according to the query token IDs and a list of table values.</span>

<span class="sd">        Args:</span>
<span class="sd">            query_ids (:obj:`List[int]`): list of token IDs corresponding to the ID.</span>
<span class="sd">            table_values (:obj:`List[TableValue]`): lift of table values, which are named tuples containing the</span>
<span class="sd">                token value, the column ID and the row ID of said token.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: List of ints containing the segment token type IDs values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">table_values</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">table_values</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">table_ids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_column_token_type_ids_from_sequences</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">table_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TableValue</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the column token type IDs according to the query token IDs and a list of table values.</span>

<span class="sd">        Args:</span>
<span class="sd">            query_ids (:obj:`List[int]`): list of token IDs corresponding to the ID.</span>
<span class="sd">            table_values (:obj:`List[TableValue]`): lift of table values, which are named tuples containing the</span>
<span class="sd">                token value, the column ID and the row ID of said token.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: List of ints containing the column token type IDs values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table_column_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">table_values</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">table_values</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">table_column_ids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_row_token_type_ids_from_sequences</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">table_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TableValue</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the row token type IDs according to the query token IDs and a list of table values.</span>

<span class="sd">        Args:</span>
<span class="sd">            query_ids (:obj:`List[int]`): list of token IDs corresponding to the ID.</span>
<span class="sd">            table_values (:obj:`List[TableValue]`): lift of table values, which are named tuples containing the</span>
<span class="sd">                token value, the column ID and the row ID of said token.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: List of ints containing the row token type IDs values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table_row_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">table_values</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">table_values</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">table_row_ids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_inputs_with_special_tokens</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">token_ids_0</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">token_ids_1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build model inputs from a question and flattened table for question answering or sequence classification tasks</span>
<span class="sd">        by concatenating and adding special tokens.</span>

<span class="sd">        Args:</span>
<span class="sd">            token_ids_0 (:obj:`List[int]`): The ids of the question.</span>
<span class="sd">            token_ids_1 (:obj:`List[int]`, `optional`): The ids of the flattened table.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: The model input with special tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">token_ids_1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With TAPAS, you must provide both question IDs and table IDs.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_token_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">token_ids_0</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sep_token_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">token_ids_1</span>

    <span class="k">def</span> <span class="nf">get_special_tokens_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">token_ids_0</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">token_ids_1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">already_has_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding</span>
<span class="sd">        special tokens using the tokenizer ``prepare_for_model`` method.</span>

<span class="sd">        Args:</span>
<span class="sd">            token_ids_0 (:obj:`List[int]`):</span>
<span class="sd">                List of question IDs.</span>
<span class="sd">            token_ids_1 (:obj:`List[int]`, `optional`):</span>
<span class="sd">                List of flattened table IDs.</span>
<span class="sd">            already_has_special_tokens (:obj:`bool`, `optional`, defaults to :obj:`False`):</span>
<span class="sd">                Whether or not the token list is already formatted with special tokens for the model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">already_has_special_tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">token_ids_1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;You should not supply a second sequence if the provided sequence of &quot;</span>
                    <span class="s2">&quot;ids is already formatted with special tokens for the model.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sep_token_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_token_id</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">token_ids_0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">token_ids_1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_ids_0</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_ids_1</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_ids_0</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="TapasTokenizer.__call__"><a class="viewcode-back" href="../../../../model_doc/tapas.html#transformers.TapasTokenizer.__call__">[docs]</a>    <span class="nd">@add_end_docstrings</span><span class="p">(</span><span class="n">TAPAS_ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">queries</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">TextInput</span><span class="p">,</span>
                <span class="n">PreTokenizedInput</span><span class="p">,</span>
                <span class="n">EncodedInput</span><span class="p">,</span>
                <span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">],</span>
                <span class="n">List</span><span class="p">[</span><span class="n">PreTokenizedInput</span><span class="p">],</span>
                <span class="n">List</span><span class="p">[</span><span class="n">EncodedInput</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_overflowing_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main method to tokenize and prepare for the model one or several sequence(s) related to a table.</span>

<span class="sd">        Args:</span>
<span class="sd">            table (:obj:`pd.DataFrame`):</span>
<span class="sd">                Table containing tabular data. Note that all cell values must be text. Use `.astype(str)` on a Pandas</span>
<span class="sd">                dataframe to convert it to string.</span>
<span class="sd">            queries (:obj:`str` or :obj:`List[str]`):</span>
<span class="sd">                Question or batch of questions related to a table to be encoded. Note that in case of a batch, all</span>
<span class="sd">                questions must refer to the **same** table.</span>
<span class="sd">            answer_coordinates (:obj:`List[Tuple]` or :obj:`List[List[Tuple]]`, `optional`):</span>
<span class="sd">                Answer coordinates of each table-question pair in the batch. In case only a single table-question pair</span>
<span class="sd">                is provided, then the answer_coordinates must be a single list of one or more tuples. Each tuple must</span>
<span class="sd">                be a (row_index, column_index) pair. The first data row (not the column header row) has index 0. The</span>
<span class="sd">                first column has index 0. In case a batch of table-question pairs is provided, then the</span>
<span class="sd">                answer_coordinates must be a list of lists of tuples (each list corresponding to a single</span>
<span class="sd">                table-question pair).</span>
<span class="sd">            answer_text (:obj:`List[str]` or :obj:`List[List[str]]`, `optional`):</span>
<span class="sd">                Answer text of each table-question pair in the batch. In case only a single table-question pair is</span>
<span class="sd">                provided, then the answer_text must be a single list of one or more strings. Each string must be the</span>
<span class="sd">                answer text of a corresponding answer coordinate. In case a batch of table-question pairs is provided,</span>
<span class="sd">                then the answer_coordinates must be a list of lists of strings (each list corresponding to a single</span>
<span class="sd">                table-question pair).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;Table must be of type pd.DataFrame&quot;</span>

        <span class="c1"># Input type checking for clearer error</span>
        <span class="n">valid_query</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check that query has a valid type</span>
        <span class="k">if</span> <span class="n">queries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">valid_query</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">valid_query</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_query</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;queries input must of type `str` (single example), `List[str]` (batch or single pretokenized example). &quot;</span>
            <span class="p">)</span>
        <span class="n">is_batched</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_batched</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_encode_plus</span><span class="p">(</span>
                <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span>
                <span class="n">queries</span><span class="o">=</span><span class="n">queries</span><span class="p">,</span>
                <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
                <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
                <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
                <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
                <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
                <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
                <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
                <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
                <span class="n">return_overflowing_tokens</span><span class="o">=</span><span class="n">return_overflowing_tokens</span><span class="p">,</span>
                <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
                <span class="n">return_offsets_mapping</span><span class="o">=</span><span class="n">return_offsets_mapping</span><span class="p">,</span>
                <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_plus</span><span class="p">(</span>
                <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span>
                <span class="n">query</span><span class="o">=</span><span class="n">queries</span><span class="p">,</span>
                <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
                <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
                <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
                <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
                <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
                <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
                <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
                <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
                <span class="n">return_overflowing_tokens</span><span class="o">=</span><span class="n">return_overflowing_tokens</span><span class="p">,</span>
                <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
                <span class="n">return_offsets_mapping</span><span class="o">=</span><span class="n">return_offsets_mapping</span><span class="p">,</span>
                <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="nd">@add_end_docstrings</span><span class="p">(</span><span class="n">ENCODE_KWARGS_DOCSTRING</span><span class="p">,</span> <span class="n">TAPAS_ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">batch_encode_plus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">queries</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">],</span>
                <span class="n">List</span><span class="p">[</span><span class="n">PreTokenizedInput</span><span class="p">],</span>
                <span class="n">List</span><span class="p">[</span><span class="n">EncodedInput</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_overflowing_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a table and a list of strings for the model.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is deprecated, ``__call__`` should be used instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            table (:obj:`pd.DataFrame`):</span>
<span class="sd">                Table containing tabular data. Note that all cell values must be text. Use `.astype(str)` on a Pandas</span>
<span class="sd">                dataframe to convert it to string.</span>
<span class="sd">            queries (:obj:`List[str]`):</span>
<span class="sd">                Batch of questions related to a table to be encoded. Note that all questions must refer to the **same**</span>
<span class="sd">                table.</span>
<span class="sd">            answer_coordinates (:obj:`List[Tuple]` or :obj:`List[List[Tuple]]`, `optional`):</span>
<span class="sd">                Answer coordinates of each table-question pair in the batch. Each tuple must be a (row_index,</span>
<span class="sd">                column_index) pair. The first data row (not the column header row) has index 0. The first column has</span>
<span class="sd">                index 0. The answer_coordinates must be a list of lists of tuples (each list corresponding to a single</span>
<span class="sd">                table-question pair).</span>
<span class="sd">            answer_text (:obj:`List[str]` or :obj:`List[List[str]]`, `optional`):</span>
<span class="sd">                Answer text of each table-question pair in the batch. In case a batch of table-question pairs is</span>
<span class="sd">                provided, then the answer_coordinates must be a list of lists of strings (each list corresponding to a</span>
<span class="sd">                single table-question pair). Each string must be the answer text of a corresponding answer coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">return_token_type_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">add_special_tokens</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Asking to return token_type_ids while setting add_special_tokens to False &quot;</span>
                <span class="s2">&quot;results in an undefined behavior. Please set add_special_tokens to True or &quot;</span>
                <span class="s2">&quot;set return_token_type_ids to None.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">answer_coordinates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">answer_text</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">answer_coordinates</span> <span class="ow">and</span> <span class="n">answer_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In case you provide answers, both answer_coordinates and answer_text should be provided&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">answer_coordinates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">answer_text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">answer_coordinates</span> <span class="o">=</span> <span class="n">answer_text</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;is_split_into_words&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently TapasTokenizer only supports questions as strings.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_offsets_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;return_offset_mapping is not available when using Python tokenizers.&quot;</span>
                <span class="s2">&quot;To use this feature, change your tokenizer to one deriving from &quot;</span>
                <span class="s2">&quot;transformers.PreTrainedTokenizerFast.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_encode_plus</span><span class="p">(</span>
            <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span>
            <span class="n">queries</span><span class="o">=</span><span class="n">queries</span><span class="p">,</span>
            <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
            <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
            <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
            <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
            <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
            <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
            <span class="n">return_overflowing_tokens</span><span class="o">=</span><span class="n">return_overflowing_tokens</span><span class="p">,</span>
            <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
            <span class="n">return_offsets_mapping</span><span class="o">=</span><span class="n">return_offsets_mapping</span><span class="p">,</span>
            <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_batch_encode_plus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">,</span>
        <span class="n">queries</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">PreTokenizedInput</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">EncodedInput</span><span class="p">],</span>
        <span class="p">],</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_overflowing_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="n">table_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_table</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="n">queries_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="n">query_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="n">queries_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_tokens</span><span class="p">)</span>

        <span class="n">batch_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_prepare_for_model</span><span class="p">(</span>
            <span class="n">table</span><span class="p">,</span>
            <span class="n">queries</span><span class="p">,</span>
            <span class="n">tokenized_table</span><span class="o">=</span><span class="n">table_tokens</span><span class="p">,</span>
            <span class="n">queries_tokens</span><span class="o">=</span><span class="n">queries_tokens</span><span class="p">,</span>
            <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
            <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
            <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
            <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
            <span class="n">prepend_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
            <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
            <span class="n">return_overflowing_tokens</span><span class="o">=</span><span class="n">return_overflowing_tokens</span><span class="p">,</span>
            <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
            <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">BatchEncoding</span><span class="p">(</span><span class="n">batch_outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_batch_prepare_for_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raw_table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">raw_queries</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">PreTokenizedInput</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">EncodedInput</span><span class="p">],</span>
        <span class="p">],</span>
        <span class="n">tokenized_table</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TokenizedTable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">queries_tokens</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prepend_batch_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="n">batch_outputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">example</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">raw_queries</span><span class="p">,</span> <span class="n">queries_tokens</span><span class="p">,</span> <span class="n">answer_coordinates</span><span class="p">,</span> <span class="n">answer_text</span><span class="p">)):</span>
            <span class="n">raw_query</span><span class="p">,</span> <span class="n">query_tokens</span><span class="p">,</span> <span class="n">answer_coords</span><span class="p">,</span> <span class="n">answer_txt</span> <span class="o">=</span> <span class="n">example</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_model</span><span class="p">(</span>
                <span class="n">raw_table</span><span class="p">,</span>
                <span class="n">raw_query</span><span class="p">,</span>
                <span class="n">tokenized_table</span><span class="o">=</span><span class="n">tokenized_table</span><span class="p">,</span>
                <span class="n">query_tokens</span><span class="o">=</span><span class="n">query_tokens</span><span class="p">,</span>
                <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coords</span><span class="p">,</span>
                <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_txt</span><span class="p">,</span>
                <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">DO_NOT_PAD</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>  <span class="c1"># we pad in batch afterwards</span>
                <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
                <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
                <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># we pad in batch afterwards</span>
                <span class="n">return_attention_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># we pad in batch afterwards</span>
                <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
                <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
                <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
                <span class="n">return_tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># We convert the whole batch to tensors at the end</span>
                <span class="n">prepend_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">prev_answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">prev_answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">batch_outputs</span><span class="p">:</span>
                    <span class="n">batch_outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">batch_outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">batch_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
            <span class="n">batch_outputs</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
            <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">batch_outputs</span> <span class="o">=</span> <span class="n">BatchEncoding</span><span class="p">(</span><span class="n">batch_outputs</span><span class="p">,</span> <span class="n">tensor_type</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">batch_outputs</span>

    <span class="nd">@add_end_docstrings</span><span class="p">(</span><span class="n">ENCODE_KWARGS_DOCSTRING</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">TextInput</span><span class="p">,</span>
                <span class="n">PreTokenizedInput</span><span class="p">,</span>
                <span class="n">EncodedInput</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a table and a string for the model. This method does not return token type IDs, attention masks, etc.</span>
<span class="sd">        which are necessary for the model to work correctly. Use that method if you want to build your processing on</span>
<span class="sd">        your own, otherwise refer to ``__call__``.</span>

<span class="sd">        Args:</span>
<span class="sd">            table (:obj:`pd.DataFrame`):</span>
<span class="sd">                Table containing tabular data. Note that all cell values must be text. Use `.astype(str)` on a Pandas</span>
<span class="sd">                dataframe to convert it to string.</span>
<span class="sd">            query (:obj:`str` or :obj:`List[str]`):</span>
<span class="sd">                Question related to a table to be encoded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_plus</span><span class="p">(</span>
            <span class="n">table</span><span class="p">,</span>
            <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
            <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span>

    <span class="nd">@add_end_docstrings</span><span class="p">(</span><span class="n">ENCODE_KWARGS_DOCSTRING</span><span class="p">,</span> <span class="n">TAPAS_ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">encode_plus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">TextInput</span><span class="p">,</span>
                <span class="n">PreTokenizedInput</span><span class="p">,</span>
                <span class="n">EncodedInput</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a table and a string for the model.</span>

<span class="sd">        Args:</span>
<span class="sd">            table (:obj:`pd.DataFrame`):</span>
<span class="sd">                Table containing tabular data. Note that all cell values must be text. Use `.astype(str)` on a Pandas</span>
<span class="sd">                dataframe to convert it to string.</span>
<span class="sd">            query (:obj:`str` or :obj:`List[str]`):</span>
<span class="sd">                Question related to a table to be encoded.</span>
<span class="sd">            answer_coordinates (:obj:`List[Tuple]` or :obj:`List[List[Tuple]]`, `optional`):</span>
<span class="sd">                Answer coordinates of each table-question pair in the batch. The answer_coordinates must be a single</span>
<span class="sd">                list of one or more tuples. Each tuple must be a (row_index, column_index) pair. The first data row</span>
<span class="sd">                (not the column header row) has index 0. The first column has index 0.</span>
<span class="sd">            answer_text (:obj:`List[str]` or :obj:`List[List[str]]`, `optional`):</span>
<span class="sd">                Answer text of each table-question pair in the batch. The answer_text must be a single list of one or</span>
<span class="sd">                more strings. Each string must be the answer text of a corresponding answer coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">return_token_type_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">add_special_tokens</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Asking to return token_type_ids while setting add_special_tokens to False &quot;</span>
                <span class="s2">&quot;results in an undefined behavior. Please set add_special_tokens to True or &quot;</span>
                <span class="s2">&quot;set return_token_type_ids to None.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">answer_coordinates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">answer_text</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">answer_coordinates</span> <span class="ow">and</span> <span class="n">answer_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In case you provide answers, both answer_coordinates and answer_text should be provided&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;is_split_into_words&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently TapasTokenizer only supports questions as strings.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_offsets_mapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;return_offset_mapping is not available when using Python tokenizers.&quot;</span>
                <span class="s2">&quot;To use this feature, change your tokenizer to one deriving from &quot;</span>
                <span class="s2">&quot;transformers.PreTrainedTokenizerFast.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_plus</span><span class="p">(</span>
            <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span>
            <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
            <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
            <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
            <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
            <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
            <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
            <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
            <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
            <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
            <span class="n">return_offsets_mapping</span><span class="o">=</span><span class="n">return_offsets_mapping</span><span class="p">,</span>
            <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_encode_plus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">TextInput</span><span class="p">,</span>
            <span class="n">PreTokenizedInput</span><span class="p">,</span>
            <span class="n">EncodedInput</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;TAPAS is a question answering model but you have not passed a query. Please be aware that the &quot;</span>
                <span class="s2">&quot;model will probably not behave correctly.&quot;</span>
            <span class="p">)</span>

        <span class="n">table_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_table</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
        <span class="n">query_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_model</span><span class="p">(</span>
            <span class="n">table</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">tokenized_table</span><span class="o">=</span><span class="n">table_tokens</span><span class="p">,</span>
            <span class="n">query_tokens</span><span class="o">=</span><span class="n">query_tokens</span><span class="p">,</span>
            <span class="n">answer_coordinates</span><span class="o">=</span><span class="n">answer_coordinates</span><span class="p">,</span>
            <span class="n">answer_text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">,</span>
            <span class="n">add_special_tokens</span><span class="o">=</span><span class="n">add_special_tokens</span><span class="p">,</span>
            <span class="n">truncation</span><span class="o">=</span><span class="n">truncation</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
            <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
            <span class="n">return_tensors</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span>
            <span class="n">prepend_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
            <span class="n">return_token_type_ids</span><span class="o">=</span><span class="n">return_token_type_ids</span><span class="p">,</span>
            <span class="n">return_special_tokens_mask</span><span class="o">=</span><span class="n">return_special_tokens_mask</span><span class="p">,</span>
            <span class="n">return_length</span><span class="o">=</span><span class="n">return_length</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@add_end_docstrings</span><span class="p">(</span><span class="n">ENCODE_KWARGS_DOCSTRING</span><span class="p">,</span> <span class="n">TAPAS_ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">prepare_for_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raw_table</span><span class="p">:</span> <span class="s2">&quot;pd.DataFrame&quot;</span><span class="p">,</span>
        <span class="n">raw_query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">TextInput</span><span class="p">,</span>
            <span class="n">PreTokenizedInput</span><span class="p">,</span>
            <span class="n">EncodedInput</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">tokenized_table</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TokenizedTable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">query_tokens</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TokenizedTable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_coordinates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TextInput</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_special_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">truncation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_token_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_special_tokens_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_offsets_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_length</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prepend_batch_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchEncoding</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepares a sequence of input id so that it can be used by the model. It adds special tokens, truncates</span>
<span class="sd">        sequences if overflowing while taking into account the special tokens.</span>

<span class="sd">        Args:</span>
<span class="sd">            raw_table (:obj:`pd.DataFrame`):</span>
<span class="sd">                The original table before any transformation (like tokenization) was applied to it.</span>
<span class="sd">            raw_query (:obj:`TextInput` or :obj:`PreTokenizedInput` or :obj:`EncodedInput`):</span>
<span class="sd">                The original query before any transformation (like tokenization) was applied to it.</span>
<span class="sd">            tokenized_table (:obj:`TokenizedTable`):</span>
<span class="sd">                The table after tokenization.</span>
<span class="sd">            query_tokens (:obj:`List[str]`):</span>
<span class="sd">                The query after tokenization.</span>
<span class="sd">            answer_coordinates (:obj:`List[Tuple]` or :obj:`List[List[Tuple]]`, `optional`):</span>
<span class="sd">                Answer coordinates of each table-question pair in the batch. The answer_coordinates must be a single</span>
<span class="sd">                list of one or more tuples. Each tuple must be a (row_index, column_index) pair. The first data row</span>
<span class="sd">                (not the column header row) has index 0. The first column has index 0.</span>
<span class="sd">            answer_text (:obj:`List[str]` or :obj:`List[List[str]]`, `optional`):</span>
<span class="sd">                Answer text of each table-question pair in the batch. The answer_text must be a single list of one or</span>
<span class="sd">                more strings. Each string must be the answer text of a corresponding answer coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">padding</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pad_to_multiple_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">padding</span> <span class="o">=</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">MAX_LENGTH</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">padding</span> <span class="o">=</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">DO_NOT_PAD</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">PaddingStrategy</span><span class="p">):</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">PaddingStrategy</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truncation</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">truncation</span><span class="p">:</span>
                <span class="n">truncation</span> <span class="o">=</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DROP_ROWS_TO_FIT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">truncation</span> <span class="o">=</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DO_NOT_TRUNCATE</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truncation</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">):</span>
            <span class="n">truncation</span> <span class="o">=</span> <span class="n">TapasTruncationStrategy</span><span class="p">(</span><span class="n">truncation</span><span class="p">)</span>

        <span class="n">encoded_inputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">is_part_of_batch</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">prev_answer_coordinates</span><span class="p">,</span> <span class="n">prev_answer_text</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;prev_answer_coordinates&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;prev_answer_text&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">is_part_of_batch</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">prev_answer_coordinates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;prev_answer_coordinates&quot;</span><span class="p">]</span>
            <span class="n">prev_answer_text</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;prev_answer_text&quot;</span><span class="p">]</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_num_rows</span><span class="p">(</span><span class="n">raw_table</span><span class="p">,</span> <span class="n">truncation</span> <span class="o">!=</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DO_NOT_TRUNCATE</span><span class="p">)</span>
        <span class="n">num_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_num_columns</span><span class="p">(</span><span class="n">raw_table</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_table_boundaries</span><span class="p">(</span><span class="n">tokenized_table</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">truncation</span> <span class="o">!=</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DO_NOT_TRUNCATE</span><span class="p">:</span>
            <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_truncated_table_rows</span><span class="p">(</span>
                <span class="n">query_tokens</span><span class="p">,</span> <span class="n">tokenized_table</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">truncation_strategy</span><span class="o">=</span><span class="n">truncation</span>
            <span class="p">)</span>
        <span class="n">table_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_table_values</span><span class="p">(</span><span class="n">tokenized_table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span><span class="p">))</span>

        <span class="n">query_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="n">query_tokens</span><span class="p">)</span>
        <span class="n">table_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">table_data</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">table_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">table_data</span><span class="p">))</span>
        <span class="n">table_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">table_ids</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;return_overflowing_tokens&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;return_overflowing_tokens&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;TAPAS does not return overflowing tokens as it works on tables.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">add_special_tokens</span><span class="p">:</span>
            <span class="n">input_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_inputs_with_special_tokens</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_ids</span> <span class="o">=</span> <span class="n">query_ids</span> <span class="o">+</span> <span class="n">table_ids</span>

        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not encode the query and table header given the maximum length. Encoding the query and table&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;header results in a length of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> which is higher than the max_length of </span><span class="si">{</span><span class="n">max_length</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_ids</span>

        <span class="n">segment_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_segment_token_type_ids_from_sequences</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">)</span>
        <span class="n">column_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_column_token_type_ids_from_sequences</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">)</span>
        <span class="n">row_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_row_token_type_ids_from_sequences</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_part_of_batch</span> <span class="ow">or</span> <span class="p">(</span><span class="n">prev_answer_coordinates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prev_answer_text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># simply set the prev_labels to zeros</span>
            <span class="n">prev_labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_answer_ids</span><span class="p">(</span>
                <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">,</span> <span class="n">prev_answer_text</span><span class="p">,</span> <span class="n">prev_answer_coordinates</span>
            <span class="p">)</span>

        <span class="c1"># FIRST: parse both the table and question in terms of numeric values</span>

        <span class="n">raw_table</span> <span class="o">=</span> <span class="n">add_numeric_table_values</span><span class="p">(</span><span class="n">raw_table</span><span class="p">)</span>
        <span class="n">raw_query</span> <span class="o">=</span> <span class="n">add_numeric_values_to_question</span><span class="p">(</span><span class="n">raw_query</span><span class="p">)</span>

        <span class="c1"># SECOND: add numeric-related features (and not parse them in these functions):</span>

        <span class="n">column_ranks</span><span class="p">,</span> <span class="n">inv_column_ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_column_ranks</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">raw_table</span><span class="p">)</span>
        <span class="n">numeric_relations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_relations</span><span class="p">(</span><span class="n">raw_query</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">raw_table</span><span class="p">)</span>

        <span class="c1"># Load from model defaults</span>
        <span class="k">if</span> <span class="n">return_token_type_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_token_type_ids</span> <span class="o">=</span> <span class="s2">&quot;token_type_ids&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_input_names</span>
        <span class="k">if</span> <span class="n">return_attention_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_attention_mask</span> <span class="o">=</span> <span class="s2">&quot;attention_mask&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_input_names</span>

        <span class="k">if</span> <span class="n">return_attention_mask</span><span class="p">:</span>
            <span class="n">attention_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_attention_mask_from_sequences</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">)</span>
            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;attention_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attention_mask</span>

        <span class="k">if</span> <span class="n">answer_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">answer_text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_answer_ids</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">table_data</span><span class="p">,</span> <span class="n">answer_text</span><span class="p">,</span> <span class="n">answer_coordinates</span><span class="p">)</span>
            <span class="n">numeric_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_values</span><span class="p">(</span><span class="n">raw_table</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">)</span>
            <span class="n">numeric_values_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_values_scale</span><span class="p">(</span><span class="n">raw_table</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">)</span>

            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_values</span>
            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values_scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_values_scale</span>

        <span class="k">if</span> <span class="n">return_token_type_ids</span><span class="p">:</span>
            <span class="n">token_type_ids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">segment_ids</span><span class="p">,</span>
                <span class="n">column_ids</span><span class="p">,</span>
                <span class="n">row_ids</span><span class="p">,</span>
                <span class="n">prev_labels</span><span class="p">,</span>
                <span class="n">column_ranks</span><span class="p">,</span>
                <span class="n">inv_column_ranks</span><span class="p">,</span>
                <span class="n">numeric_relations</span><span class="p">,</span>
            <span class="p">]</span>

            <span class="n">token_type_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">token_type_ids</span><span class="p">))]</span>
            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">token_type_ids</span>

        <span class="k">if</span> <span class="n">return_special_tokens_mask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">add_special_tokens</span><span class="p">:</span>
                <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_special_tokens_mask</span><span class="p">(</span><span class="n">query_ids</span><span class="p">,</span> <span class="n">table_ids</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span>

        <span class="c1"># Check lengths</span>
        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deprecation_warnings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sequence-length-is-longer-than-the-specified-maximum&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Token indices sequence length is longer than the specified maximum sequence length &quot;</span>
                    <span class="s2">&quot;for this model (</span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">). Running this sequence through the model will result in &quot;</span>
                    <span class="s2">&quot;indexing errors&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deprecation_warnings</span><span class="p">[</span><span class="s2">&quot;sequence-length-is-longer-than-the-specified-maximum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Padding</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="o">!=</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">DO_NOT_PAD</span> <span class="ow">or</span> <span class="n">return_attention_mask</span><span class="p">:</span>
            <span class="n">encoded_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">encoded_inputs</span><span class="p">,</span>
                <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">pad_to_multiple_of</span><span class="o">=</span><span class="n">pad_to_multiple_of</span><span class="p">,</span>
                <span class="n">return_attention_mask</span><span class="o">=</span><span class="n">return_attention_mask</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_length</span><span class="p">:</span>
            <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span>

        <span class="n">batch_outputs</span> <span class="o">=</span> <span class="n">BatchEncoding</span><span class="p">(</span>
            <span class="n">encoded_inputs</span><span class="p">,</span> <span class="n">tensor_type</span><span class="o">=</span><span class="n">return_tensors</span><span class="p">,</span> <span class="n">prepend_batch_axis</span><span class="o">=</span><span class="n">prepend_batch_axis</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">batch_outputs</span>

    <span class="k">def</span> <span class="nf">_get_truncated_table_rows</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">query_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">tokenized_table</span><span class="p">:</span> <span class="n">TokenizedTable</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_columns</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">truncation_strategy</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncates a sequence pair in-place following the strategy.</span>

<span class="sd">        Args:</span>
<span class="sd">            query_tokens (:obj:`List[str]`):</span>
<span class="sd">                List of strings corresponding to the tokenized query.</span>
<span class="sd">            tokenized_table (:obj:`TokenizedTable`):</span>
<span class="sd">                Tokenized table</span>
<span class="sd">            num_rows (:obj:`int`):</span>
<span class="sd">                Total number of table rows</span>
<span class="sd">            num_columns (:obj:`int`):</span>
<span class="sd">                Total number of table columns</span>
<span class="sd">            max_length (:obj:`int`):</span>
<span class="sd">                Total maximum length.</span>
<span class="sd">            truncation_strategy (:obj:`str` or :obj:`~transformers.TapasTruncationStrategy`):</span>
<span class="sd">                Truncation strategy to use. Seeing as this method should only be called when truncating, the only</span>
<span class="sd">                available strategy is the :obj:`&quot;drop_rows_to_fit&quot;` strategy.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`Tuple(int, int)`: tuple containing the number of rows after truncation, and the number of tokens</span>
<span class="sd">            available for each table element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truncation_strategy</span><span class="p">,</span> <span class="n">TapasTruncationStrategy</span><span class="p">):</span>
            <span class="n">truncation_strategy</span> <span class="o">=</span> <span class="n">TapasTruncationStrategy</span><span class="p">(</span><span class="n">truncation_strategy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span>

        <span class="k">if</span> <span class="n">truncation_strategy</span> <span class="o">==</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DROP_ROWS_TO_FIT</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">num_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_max_num_tokens</span><span class="p">(</span>
                    <span class="n">query_tokens</span><span class="p">,</span> <span class="n">tokenized_table</span><span class="p">,</span> <span class="n">num_rows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_columns</span><span class="o">=</span><span class="n">num_columns</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">num_tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># We could fit the table.</span>
                    <span class="k">break</span>

                <span class="c1"># Try to drop a row to fit the table.</span>
                <span class="n">num_rows</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">num_rows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">elif</span> <span class="n">truncation_strategy</span> <span class="o">!=</span> <span class="n">TapasTruncationStrategy</span><span class="o">.</span><span class="n">DO_NOT_TRUNCATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown truncation strategy </span><span class="si">{</span><span class="n">truncation_strategy</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span> <span class="ow">or</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_tokenize_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tokenizes column headers and cell texts of a table.</span>

<span class="sd">        Args:</span>
<span class="sd">            table (:obj:`pd.Dataframe`):</span>
<span class="sd">                Table. Returns: :obj:`TokenizedTable`: TokenizedTable object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokenized_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tokenized_row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># tokenize column headers</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_column_names</span><span class="p">:</span>
                <span class="n">tokenized_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tokenized_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
        <span class="n">tokenized_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tokenized_row</span><span class="p">)</span>

        <span class="c1"># tokenize cell values</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">tokenized_row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="n">tokenized_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
            <span class="n">tokenized_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tokenized_row</span><span class="p">)</span>

        <span class="n">token_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokenized_rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">column_index</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">token_index</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
                    <span class="n">token_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">TokenCoordinates</span><span class="p">(</span>
                            <span class="n">row_index</span><span class="o">=</span><span class="n">row_index</span><span class="p">,</span>
                            <span class="n">column_index</span><span class="o">=</span><span class="n">column_index</span><span class="p">,</span>
                            <span class="n">token_index</span><span class="o">=</span><span class="n">token_index</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">TokenizedTable</span><span class="p">(</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">tokenized_rows</span><span class="p">,</span>
            <span class="n">selected_tokens</span><span class="o">=</span><span class="n">token_coordinates</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_question_encoding_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question_tokens</span><span class="p">):</span>
        <span class="c1"># Two extra spots of SEP and CLS.</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">question_tokens</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_get_token_budget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question_tokens</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the number of tokens left for the table after tokenizing a question, taking into account the max</span>
<span class="sd">        sequence length of the model.</span>

<span class="sd">        Args:</span>
<span class="sd">            question_tokens (:obj:`List[String]`):</span>
<span class="sd">                List of question tokens. Returns: :obj:`int`: the number of tokens left for the table, given the model</span>
<span class="sd">                max length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">max_length</span> <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_question_encoding_cost</span><span class="p">(</span>
            <span class="n">question_tokens</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_table_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">TableValue</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterates over partial table and returns token, column and row indexes.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">selected_tokens</span><span class="p">:</span>
            <span class="c1"># First row is header row.</span>
            <span class="k">if</span> <span class="n">tc</span><span class="o">.</span><span class="n">row_index</span> <span class="o">&gt;=</span> <span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">tc</span><span class="o">.</span><span class="n">column_index</span> <span class="o">&gt;=</span> <span class="n">num_columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">tc</span><span class="o">.</span><span class="n">row_index</span><span class="p">][</span><span class="n">tc</span><span class="o">.</span><span class="n">column_index</span><span class="p">]</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">tc</span><span class="o">.</span><span class="n">token_index</span><span class="p">]</span>
            <span class="n">word_begin_index</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">token_index</span>
            <span class="c1"># Don&#39;t add partial words. Find the starting word piece and check if it</span>
            <span class="c1"># fits in the token budget.</span>
            <span class="k">while</span> <span class="n">word_begin_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_is_inner_wordpiece</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">word_begin_index</span><span class="p">]):</span>
                <span class="n">word_begin_index</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">word_begin_index</span> <span class="o">&gt;=</span> <span class="n">num_tokens</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">TableValue</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">column_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">row_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_table_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return maximal number of rows, columns and tokens.&quot;&quot;&quot;</span>
        <span class="n">max_num_tokens</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_num_columns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_num_rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">selected_tokens</span><span class="p">:</span>
            <span class="n">max_num_columns</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_num_columns</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">column_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">max_num_rows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_num_rows</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">row_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">max_num_tokens</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_num_tokens</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">token_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">max_num_columns</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_column_id</span><span class="p">,</span> <span class="n">max_num_columns</span><span class="p">)</span>
            <span class="n">max_num_rows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_row_id</span><span class="p">,</span> <span class="n">max_num_rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_num_rows</span><span class="p">,</span> <span class="n">max_num_columns</span><span class="p">,</span> <span class="n">max_num_tokens</span>

    <span class="k">def</span> <span class="nf">_get_table_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_table_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_max_num_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question_tokens</span><span class="p">,</span> <span class="n">tokenized_table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">max_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes max number of tokens that can be squeezed into the budget.&quot;&quot;&quot;</span>
        <span class="n">token_budget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_token_budget</span><span class="p">(</span><span class="n">question_tokens</span><span class="p">,</span> <span class="n">max_length</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">max_num_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_table_boundaries</span><span class="p">(</span><span class="n">tokenized_table</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_trim_length</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_num_tokens</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_trim_length</span><span class="p">:</span>
            <span class="n">max_num_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_trim_length</span>
        <span class="n">num_tokens</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num_tokens</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_num_tokens</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_table_cost</span><span class="p">(</span><span class="n">tokenized_table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&gt;</span> <span class="n">token_budget</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">num_tokens</span> <span class="o">&lt;</span> <span class="n">max_num_tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_trim_length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We don&#39;t allow dynamic trimming if a cell_trim_length is set.</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">num_tokens</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">num_tokens</span>

    <span class="k">def</span> <span class="nf">_get_num_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="n">num_columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">num_columns</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_column_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many columns&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_columns</span>

    <span class="k">def</span> <span class="nf">_get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">drop_rows_to_fit</span><span class="p">):</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">num_rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_row_id</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_rows_to_fit</span><span class="p">:</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_row_id</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many rows&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_rows</span>

    <span class="k">def</span> <span class="nf">_serialize_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question_tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serializes texts in index arrays.&quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">segment_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">column_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">row_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># add [CLS] token at the beginning</span>
        <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_token</span><span class="p">)</span>
        <span class="n">segment_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">column_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">row_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question_tokens</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="n">segment_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">column_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">row_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">segment_ids</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span>

    <span class="k">def</span> <span class="nf">_serialize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">question_tokens</span><span class="p">,</span>
        <span class="n">table</span><span class="p">,</span>
        <span class="n">num_columns</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="p">,</span>
        <span class="n">num_tokens</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serializes table and text.&quot;&quot;&quot;</span>
        <span class="n">tokens</span><span class="p">,</span> <span class="n">segment_ids</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_text</span><span class="p">(</span><span class="n">question_tokens</span><span class="p">)</span>

        <span class="c1"># add [SEP] token between question and table tokens</span>
        <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sep_token</span><span class="p">)</span>
        <span class="n">segment_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">column_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">row_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">token</span><span class="p">,</span> <span class="n">column_id</span><span class="p">,</span> <span class="n">row_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_table_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">num_columns</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_tokens</span><span class="p">):</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="n">segment_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">column_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column_id</span><span class="p">)</span>
            <span class="n">row_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SerializedExample</span><span class="p">(</span>
            <span class="n">tokens</span><span class="o">=</span><span class="n">tokens</span><span class="p">,</span>
            <span class="n">segment_ids</span><span class="o">=</span><span class="n">segment_ids</span><span class="p">,</span>
            <span class="n">column_ids</span><span class="o">=</span><span class="n">column_ids</span><span class="p">,</span>
            <span class="n">row_ids</span><span class="o">=</span><span class="n">row_ids</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_column_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">col_index</span><span class="p">):</span>
        <span class="n">table_numeric_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">col_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">numeric_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">table_numeric_values</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">numeric_value</span>
        <span class="k">return</span> <span class="n">table_numeric_values</span>

    <span class="k">def</span> <span class="nf">_get_cell_token_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_id</span><span class="p">,</span> <span class="n">row_id</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">column_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">column_id</span> <span class="ow">and</span> <span class="n">row_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">row_id</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_get_numeric_column_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns column ranks for all numeric columns.&quot;&quot;&quot;</span>

        <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>
        <span class="n">inv_ranks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>

        <span class="c1"># original code from tf_example_utils.py of the original implementation</span>
        <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                <span class="n">table_numeric_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">col_index</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">table_numeric_values</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key_fn</span> <span class="o">=</span> <span class="n">get_numeric_sort_key_fn</span><span class="p">(</span><span class="n">table_numeric_values</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">table_numeric_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">row_index</span><span class="p">:</span> <span class="n">key_fn</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">table_numeric_values</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

                <span class="n">table_numeric_values_inv</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">table_numeric_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">table_numeric_values_inv</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_index</span><span class="p">)</span>

                <span class="n">unique_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table_numeric_values_inv</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_values</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">row_index</span> <span class="ow">in</span> <span class="n">table_numeric_values_inv</span><span class="p">[</span><span class="n">value</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
                            <span class="n">ranks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">inv_ranks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">rank</span>

        <span class="k">return</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">inv_ranks</span>

    <span class="k">def</span> <span class="nf">_get_numeric_sort_key_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_numeric_values</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sort key function for comparing value to table values. The function returned will be a suitable</span>
<span class="sd">        input for the key param of the sort(). See number_annotation_utils._get_numeric_sort_key_fn for details</span>

<span class="sd">        Args:</span>
<span class="sd">            table_numeric_values: Numeric values of a column</span>
<span class="sd">            value: Numeric value in the question</span>

<span class="sd">        Returns:</span>
<span class="sd">            A function key function to compare column and question values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">table_numeric_values</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">table_numeric_values</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">all_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_numeric_sort_key_fn</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_numeric_relations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns numeric relations embeddings</span>

<span class="sd">        Args:</span>
<span class="sd">            question: Question object.</span>
<span class="sd">            column_ids: Maps word piece position to column id.</span>
<span class="sd">            row_ids: Maps word piece position to row id.</span>
<span class="sd">            table: The table containing the numeric cell values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numeric_relations</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>

        <span class="c1"># first, we add any numeric value spans to the question:</span>
        <span class="c1"># Create a dictionary that maps a table cell to the set of all relations</span>
        <span class="c1"># this cell has with any value in the question.</span>
        <span class="n">cell_indices_to_relations</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">question</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">numeric_value_span</span> <span class="ow">in</span> <span class="n">question</span><span class="o">.</span><span class="n">numeric_spans</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numeric_value_span</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">column_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                        <span class="n">table_numeric_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column_index</span><span class="p">)</span>
                        <span class="n">sort_key_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_sort_key_fn</span><span class="p">(</span><span class="n">table_numeric_values</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sort_key_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">cell_value</span> <span class="ow">in</span> <span class="n">table_numeric_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">relation</span> <span class="o">=</span> <span class="n">get_numeric_relation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cell_value</span><span class="p">,</span> <span class="n">sort_key_fn</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">relation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">cell_indices_to_relations</span><span class="p">[</span><span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">relation</span><span class="p">)</span>

        <span class="c1"># For each cell add a special feature for all its word pieces.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">),</span> <span class="n">relations</span> <span class="ow">in</span> <span class="n">cell_indices_to_relations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">relation_set_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">relations</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">relation</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">Relation</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">value</span>
                <span class="n">relation_set_index</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">relation</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">Relation</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cell_token_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
                <span class="n">numeric_relations</span><span class="p">[</span><span class="n">cell_token_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">relation_set_index</span>

        <span class="k">return</span> <span class="n">numeric_relations</span>

    <span class="k">def</span> <span class="nf">_get_numeric_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns numeric values for computation of answer loss.&quot;&quot;&quot;</span>

        <span class="n">numeric_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">num_columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">col_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_columns</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">row_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
                    <span class="n">numeric_value</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_index</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">numeric_value</span>
                    <span class="k">if</span> <span class="n">numeric_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">float_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">float_value</span> <span class="o">=</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">float_value</span>
                        <span class="k">if</span> <span class="n">float_value</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
                            <span class="n">numeric_values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_value</span>

        <span class="k">return</span> <span class="n">numeric_values</span>

    <span class="k">def</span> <span class="nf">_get_numeric_values_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a scale to each token to down weigh the value of long words.&quot;&quot;&quot;</span>

        <span class="n">numeric_values_scale</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numeric_values_scale</span>

        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">col_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_columns</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">row_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">)]</span>
                <span class="n">num_indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_indices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                        <span class="n">numeric_values_scale</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_indices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">numeric_values_scale</span>

    <span class="k">def</span> <span class="nf">_pad_to_seq_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span><span class="p">:</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_max_length</span><span class="p">:</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_all_answer_ids_from_coordinates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">column_ids</span><span class="p">,</span>
        <span class="n">row_ids</span><span class="p">,</span>
        <span class="n">answers_list</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps lists of answer coordinates to token indexes.&quot;&quot;&quot;</span>
        <span class="n">answer_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>
        <span class="n">found_answers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">all_answers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">answers</span> <span class="ow">in</span> <span class="n">answers_list</span><span class="p">:</span>
            <span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span> <span class="o">=</span> <span class="n">answers</span>
            <span class="n">all_answers</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
                <span class="n">found_answers</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">column_index</span><span class="p">,</span> <span class="n">row_index</span><span class="p">))</span>
                <span class="n">answer_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">missing_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_answers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">found_answers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">answer_ids</span><span class="p">,</span> <span class="n">missing_count</span>

    <span class="k">def</span> <span class="nf">_get_all_answer_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">answer_coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps answer coordinates of a question to token indexes.</span>

<span class="sd">        In the SQA format (TSV), the coordinates are given as (row, column) tuples. Here, we first swap them to</span>
<span class="sd">        (column, row) format before calling _get_all_answer_ids_from_coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_to_coordinates</span><span class="p">(</span><span class="n">answer_coordinates_question</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">answer_coordinates_question</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_all_answer_ids_from_coordinates</span><span class="p">(</span>
            <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">answers_list</span><span class="o">=</span><span class="p">(</span><span class="n">_to_coordinates</span><span class="p">(</span><span class="n">answer_coordinates</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return start index of segment in text or None.&quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;text: </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">seg_index</span><span class="p">,</span> <span class="n">seg_token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">seg_index</span><span class="p">]</span><span class="o">.</span><span class="n">piece</span> <span class="o">!=</span> <span class="n">seg_token</span><span class="o">.</span><span class="n">piece</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">index</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_find_answer_coordinates_from_answer_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tokenized_table</span><span class="p">,</span>
        <span class="n">answer_text</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all occurrences of answer_text in the table.&quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;answer text: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">answer_text</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokenized_table</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We don&#39;t search for answers in the header.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">token_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_tokens</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">answer_text</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">token_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">TokenCoordinates</span><span class="p">(</span>
                        <span class="n">row_index</span><span class="o">=</span><span class="n">row_index</span><span class="p">,</span>
                        <span class="n">column_index</span><span class="o">=</span><span class="n">col_index</span><span class="p">,</span>
                        <span class="n">token_index</span><span class="o">=</span><span class="n">token_index</span><span class="p">,</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_answer_ids_from_answer_texts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">column_ids</span><span class="p">,</span>
        <span class="n">row_ids</span><span class="p">,</span>
        <span class="n">tokenized_table</span><span class="p">,</span>
        <span class="n">answer_texts</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps question with answer texts to the first matching token indexes.&quot;&quot;&quot;</span>
        <span class="n">answer_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ids</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">answer_text</span> <span class="ow">in</span> <span class="n">answer_texts</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coordinates</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_answer_coordinates_from_answer_text</span><span class="p">(</span>
                <span class="n">tokenized_table</span><span class="p">,</span>
                <span class="n">answer_text</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Maps answer coordinates to indexes this can fail if tokens / rows have</span>
                <span class="c1"># been pruned.</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_indexes</span><span class="p">(</span>
                        <span class="n">column_ids</span><span class="p">,</span>
                        <span class="n">row_ids</span><span class="p">,</span>
                        <span class="n">column_id</span><span class="o">=</span><span class="n">coordinates</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                        <span class="n">row_id</span><span class="o">=</span><span class="n">coordinates</span><span class="o">.</span><span class="n">row_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">coordinate_answer_ids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">begin_index</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">token_index</span> <span class="o">+</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">end_index</span> <span class="o">=</span> <span class="n">begin_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">answer_text</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">begin_index</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">:</span>
                            <span class="n">coordinate_answer_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate_answer_ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">answer_text</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">coordinate_answer_ids</span><span class="p">:</span>
                        <span class="n">answer_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">answer_ids</span>

    <span class="k">def</span> <span class="nf">_get_answer_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">answer_coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maps answer coordinates of a question to token indexes.&quot;&quot;&quot;</span>
        <span class="n">answer_ids</span><span class="p">,</span> <span class="n">missing_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_all_answer_ids</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">answer_coordinates</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t find all answers&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">answer_ids</span>

    <span class="k">def</span> <span class="nf">get_answer_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">tokenized_table</span><span class="p">,</span> <span class="n">answer_texts_question</span><span class="p">,</span> <span class="n">answer_coordinates_question</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_answer_coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_answer_ids_from_answer_texts</span><span class="p">(</span>
                <span class="n">column_ids</span><span class="p">,</span>
                <span class="n">row_ids</span><span class="p">,</span>
                <span class="n">tokenized_table</span><span class="p">,</span>
                <span class="n">answer_texts</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">answer_texts_question</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_answer_ids</span><span class="p">(</span><span class="n">column_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">answer_coordinates_question</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pad</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">encoded_inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">EncodedInput</span><span class="p">],</span> <span class="n">BatchEncoding</span><span class="p">],</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_strategy</span><span class="p">:</span> <span class="n">PaddingStrategy</span> <span class="o">=</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">DO_NOT_PAD</span><span class="p">,</span>
        <span class="n">pad_to_multiple_of</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_attention_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad encoded inputs (on left/right and up to predefined length or max length in the batch)</span>

<span class="sd">        Args:</span>
<span class="sd">            encoded_inputs: Dictionary of tokenized inputs (`List[int]`) or batch of tokenized inputs (`List[List[int]]`).</span>
<span class="sd">            max_length: maximum length of the returned list and optionally padding length (see below).</span>
<span class="sd">                Will truncate by taking into account the special tokens.</span>
<span class="sd">            padding_strategy: PaddingStrategy to use for padding.</span>

<span class="sd">                - PaddingStrategy.LONGEST Pad to the longest sequence in the batch</span>
<span class="sd">                - PaddingStrategy.MAX_LENGTH: Pad to the max length (default)</span>
<span class="sd">                - PaddingStrategy.DO_NOT_PAD: Do not pad</span>
<span class="sd">                The tokenizer padding sides are defined in self.padding_side:</span>

<span class="sd">                    - &#39;left&#39;: pads on the left of the sequences</span>
<span class="sd">                    - &#39;right&#39;: pads on the right of the sequences</span>
<span class="sd">            pad_to_multiple_of: (optional) Integer if set will pad the sequence to a multiple of the provided value.</span>
<span class="sd">                This is especially useful to enable the use of Tensor Core on NVIDIA hardware with compute capability</span>
<span class="sd">                &gt;= 7.5 (Volta).</span>
<span class="sd">            return_attention_mask: (optional) Set to False to avoid returning attention mask (default: set to model specifics)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load from model defaults</span>
        <span class="k">if</span> <span class="n">return_attention_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_attention_mask</span> <span class="o">=</span> <span class="s2">&quot;attention_mask&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_input_names</span>

        <span class="k">if</span> <span class="n">padding_strategy</span> <span class="o">==</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">LONGEST</span><span class="p">:</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pad_to_multiple_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_length</span> <span class="o">%</span> <span class="n">pad_to_multiple_of</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">max_length</span> <span class="o">//</span> <span class="n">pad_to_multiple_of</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pad_to_multiple_of</span>

        <span class="n">needs_to_be_padded</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">padding_strategy</span> <span class="o">!=</span> <span class="n">PaddingStrategy</span><span class="o">.</span><span class="n">DO_NOT_PAD</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">max_length</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">needs_to_be_padded</span><span class="p">:</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">max_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_side</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_attention_mask</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;attention_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
                <span class="k">if</span> <span class="s2">&quot;token_type_ids&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_token_type_id</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
                <span class="k">if</span> <span class="s2">&quot;numeric_values&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">difference</span>
                <span class="k">if</span> <span class="s2">&quot;numeric_values_scale&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values_scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values_scale&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;special_tokens_mask&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
                <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_token_id</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_attention_mask</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;attention_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;token_type_ids&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_token_type_id</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span>
                        <span class="s2">&quot;token_type_ids&quot;</span>
                    <span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;numeric_values&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;numeric_values_scale&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;numeric_values_scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span>
                        <span class="s2">&quot;numeric_values_scale&quot;</span>
                    <span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;special_tokens_mask&quot;</span> <span class="ow">in</span> <span class="n">encoded_inputs</span><span class="p">:</span>
                    <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;special_tokens_mask&quot;</span><span class="p">]</span>
                <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_token_id</span><span class="p">]</span> <span class="o">*</span> <span class="n">difference</span> <span class="o">+</span> <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid padding strategy:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_side</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_attention_mask</span><span class="p">:</span>
                <span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;attention_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_inputs</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">encoded_inputs</span>

    <span class="c1"># Everything related to converting logits to predictions</span>

    <span class="k">def</span> <span class="nf">_get_cell_token_probs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">segment_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">probabilities</span><span class="p">):</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">column_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">segment_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">_get_mean_cell_probs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">segment_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes average probability per cell, aggregating over tokens.&quot;&quot;&quot;</span>
        <span class="n">coords_to_probs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cell_token_probs</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">segment_ids</span><span class="p">,</span> <span class="n">row_ids</span><span class="p">,</span> <span class="n">column_ids</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">column_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">coords_to_probs</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_probs</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">coords</span><span class="p">,</span> <span class="n">cell_probs</span> <span class="ow">in</span> <span class="n">coords_to_probs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<div class="viewcode-block" id="TapasTokenizer.convert_logits_to_predictions"><a class="viewcode-back" href="../../../../model_doc/tapas.html#transformers.TapasTokenizer.convert_logits_to_predictions">[docs]</a>    <span class="k">def</span> <span class="nf">convert_logits_to_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">logits_agg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_classification_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts logits of :class:`~transformers.TapasForQuestionAnswering` to actual predicted answer coordinates and</span>
<span class="sd">        optional aggregation indices.</span>

<span class="sd">        The original implementation, on which this function is based, can be found `here</span>
<span class="sd">        &lt;https://github.com/google-research/tapas/blob/4908213eb4df7aa988573350278b44c4dbe3f71b/tapas/experiments/prediction_utils.py#L288&gt;`__.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (:obj:`dict`):</span>
<span class="sd">                Dictionary mapping features to actual values. Should be created using</span>
<span class="sd">                :class:`~transformers.TapasTokenizer`.</span>
<span class="sd">            logits (:obj:`np.ndarray` of shape ``(batch_size, sequence_length)``):</span>
<span class="sd">                Tensor containing the logits at the token level.</span>
<span class="sd">            logits_agg (:obj:`np.ndarray` of shape ``(batch_size, num_aggregation_labels)``, `optional`):</span>
<span class="sd">                Tensor containing the aggregation logits.</span>
<span class="sd">            cell_classification_threshold (:obj:`float`, `optional`, defaults to 0.5):</span>
<span class="sd">                Threshold to be used for cell selection. All table cells for which their probability is larger than</span>
<span class="sd">                this threshold will be selected.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`tuple` comprising various elements depending on the inputs:</span>

<span class="sd">            - predicted_answer_coordinates (``List[List[[tuple]]`` of length ``batch_size``): Predicted answer</span>
<span class="sd">              coordinates as a list of lists of tuples. Each element in the list contains the predicted answer</span>
<span class="sd">              coordinates of a single example in the batch, as a list of tuples. Each tuple is a cell, i.e. (row index,</span>
<span class="sd">              column index).</span>
<span class="sd">            - predicted_aggregation_indices (``List[int]``of length ``batch_size``, `optional`, returned when</span>
<span class="sd">              ``logits_aggregation`` is provided): Predicted aggregation operator indices of the aggregation head.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># input data is of type float32</span>
        <span class="c1"># np.log(np.finfo(np.float32).max) = 88.72284</span>
        <span class="c1"># Any value over 88.72284 will overflow when passed through the exponential, sending a warning</span>
        <span class="c1"># We disable this warning by truncating the logits.</span>
        <span class="n">logits</span><span class="p">[</span><span class="n">logits</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">88.7</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">88.7</span>

        <span class="c1"># Compute probabilities from token logits</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">logits</span><span class="p">))</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;attention_mask&quot;</span><span class="p">]</span>
        <span class="n">token_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;segment_ids&quot;</span><span class="p">,</span>
            <span class="s2">&quot;column_ids&quot;</span><span class="p">,</span>
            <span class="s2">&quot;row_ids&quot;</span><span class="p">,</span>
            <span class="s2">&quot;prev_labels&quot;</span><span class="p">,</span>
            <span class="s2">&quot;column_ranks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;inv_column_ranks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;numeric_relations&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># collect input_ids, segment ids, row ids and column ids of batch. Shape (batch_size, seq_len)</span>
        <span class="n">input_ids</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">]</span>
        <span class="n">segment_ids</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">token_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;segment_ids&quot;</span><span class="p">)]</span>
        <span class="n">row_ids</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">token_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;row_ids&quot;</span><span class="p">)]</span>
        <span class="n">column_ids</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;token_type_ids&quot;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">token_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;column_ids&quot;</span><span class="p">)]</span>

        <span class="c1"># next, get answer coordinates for every example in the batch</span>
        <span class="n">num_batch</span> <span class="o">=</span> <span class="n">input_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">predicted_answer_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_batch</span><span class="p">):</span>
            <span class="n">probabilities_example</span> <span class="o">=</span> <span class="n">probabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">segment_ids_example</span> <span class="o">=</span> <span class="n">segment_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">row_ids_example</span> <span class="o">=</span> <span class="n">row_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">column_ids_example</span> <span class="o">=</span> <span class="n">column_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">max_width</span> <span class="o">=</span> <span class="n">column_ids_example</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">max_height</span> <span class="o">=</span> <span class="n">row_ids_example</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">max_width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">cell_coords_to_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mean_cell_probs</span><span class="p">(</span>
                <span class="n">probabilities_example</span><span class="p">,</span>
                <span class="n">segment_ids_example</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">row_ids_example</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="n">column_ids_example</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="p">)</span>

            <span class="c1"># Select the answers above the classification threshold.</span>
            <span class="n">answer_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_width</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_height</span><span class="p">):</span>
                    <span class="n">cell_prob</span> <span class="o">=</span> <span class="n">cell_coords_to_prob</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cell_prob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cell_prob</span> <span class="o">&gt;</span> <span class="n">cell_classification_threshold</span><span class="p">:</span>
                            <span class="n">answer_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
            <span class="n">answer_coordinates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">answer_coordinates</span><span class="p">)</span>
            <span class="n">predicted_answer_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">answer_coordinates</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">predicted_answer_coordinates</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">logits_agg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">predicted_aggregation_indices</span> <span class="o">=</span> <span class="n">logits_agg</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">predicted_answer_coordinates</span><span class="p">,</span> <span class="n">predicted_aggregation_indices</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">output</span></div></div>

    <span class="c1"># End of everything related to converting logits to predictions</span>


<span class="c1"># Copied from transformers.models.bert.tokenization_bert.BasicTokenizer</span>
<span class="k">class</span> <span class="nc">BasicTokenizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a BasicTokenizer that will run basic tokenization (punctuation splitting, lower casing, etc.).</span>

<span class="sd">    Args:</span>
<span class="sd">        do_lower_case (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="sd">            Whether or not to lowercase the input when tokenizing.</span>
<span class="sd">        never_split (:obj:`Iterable`, `optional`):</span>
<span class="sd">            Collection of tokens which will never be split during tokenization. Only has an effect when</span>
<span class="sd">            :obj:`do_basic_tokenize=True`</span>
<span class="sd">        tokenize_chinese_chars (:obj:`bool`, `optional`, defaults to :obj:`True`):</span>
<span class="sd">            Whether or not to tokenize Chinese characters.</span>

<span class="sd">            This should likely be deactivated for Japanese (see this `issue</span>
<span class="sd">            &lt;https://github.com/huggingface/transformers/issues/328&gt;`__).</span>
<span class="sd">        strip_accents: (:obj:`bool`, `optional`):</span>
<span class="sd">            Whether or not to strip all accents. If this option is not specified, then it will be determined by the</span>
<span class="sd">            value for :obj:`lowercase` (as in the original BERT).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_lower_case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">never_split</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tokenize_chinese_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strip_accents</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">never_split</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">never_split</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_lower_case</span> <span class="o">=</span> <span class="n">do_lower_case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">never_split</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">never_split</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_chinese_chars</span> <span class="o">=</span> <span class="n">tokenize_chinese_chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_accents</span> <span class="o">=</span> <span class="n">strip_accents</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">never_split</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Basic Tokenization of a piece of text. Split on &quot;white spaces&quot; only, for sub-word tokenization, see</span>
<span class="sd">        WordPieceTokenizer.</span>

<span class="sd">        Args:</span>
<span class="sd">            **never_split**: (`optional`) list of str</span>
<span class="sd">                Kept for backward compatibility purposes. Now implemented directly at the base class level (see</span>
<span class="sd">                :func:`PreTrainedTokenizer.tokenize`) List of token not to split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># union() returns a new set by concatenating the two sets.</span>
        <span class="n">never_split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">never_split</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">never_split</span><span class="p">))</span> <span class="k">if</span> <span class="n">never_split</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">never_split</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># This was added on November 1st, 2018 for the multilingual and Chinese</span>
        <span class="c1"># models. This is also applied to the English models now, but it doesn&#39;t</span>
        <span class="c1"># matter since the English models were not trained on any Chinese data</span>
        <span class="c1"># and generally don&#39;t have any Chinese data in them (there are Chinese</span>
        <span class="c1"># characters in the vocabulary because Wikipedia does have some Chinese</span>
        <span class="c1"># words in the English Wikipedia.).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_chinese_chars</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_chinese_chars</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">orig_tokens</span> <span class="o">=</span> <span class="n">whitespace_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">split_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">orig_tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">never_split</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_lower_case</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_accents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_strip_accents</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip_accents</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_strip_accents</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="n">split_tokens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_run_split_on_punc</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">never_split</span><span class="p">))</span>

        <span class="n">output_tokens</span> <span class="o">=</span> <span class="n">whitespace_tokenize</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">split_tokens</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output_tokens</span>

    <span class="k">def</span> <span class="nf">_run_strip_accents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Strips accents from a piece of text.&quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;NFD&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">category</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;Mn&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_split_on_punc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">never_split</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits punctuation on a piece of text.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">never_split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">never_split</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">text</span><span class="p">]</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_new_word</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">chars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_is_punctuation</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">char</span><span class="p">])</span>
                <span class="n">start_new_word</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start_new_word</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">start_new_word</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_tokenize_chinese_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds whitespace around any CJK character.&quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_chinese_char</span><span class="p">(</span><span class="n">cp</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_chinese_char</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether CP is the codepoint of a CJK character.&quot;&quot;&quot;</span>
        <span class="c1"># This defines a &quot;chinese character&quot; as anything in the CJK Unicode block:</span>
        <span class="c1">#   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)</span>
        <span class="c1">#</span>
        <span class="c1"># Note that the CJK Unicode block is NOT all Japanese and Korean characters,</span>
        <span class="c1"># despite its name. The modern Korean Hangul alphabet is a different block,</span>
        <span class="c1"># as is Japanese Hiragana and Katakana. Those alphabets are used to write</span>
        <span class="c1"># space-separated words, so they are not treated specially and handled</span>
        <span class="c1"># like the all of the other languages.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x4E00</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x9FFF</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x3400</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x4DBF</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x20000</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x2A6DF</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x2A700</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x2B73F</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x2B740</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x2B81F</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x2B820</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x2CEAF</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0xF900</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0xFAFF</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&gt;=</span> <span class="mh">0x2F800</span> <span class="ow">and</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="mh">0x2FA1F</span><span class="p">)</span>  <span class="c1">#</span>
        <span class="p">):</span>  <span class="c1">#</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_clean_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs invalid character removal and whitespace cleanup on text.&quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cp</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cp</span> <span class="o">==</span> <span class="mh">0xFFFD</span> <span class="ow">or</span> <span class="n">_is_control</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">_is_whitespace</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


<span class="c1"># Copied from transformers.models.bert.tokenization_bert.WordpieceTokenizer</span>
<span class="k">class</span> <span class="nc">WordpieceTokenizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs WordPiece tokenization.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">unk_token</span><span class="p">,</span> <span class="n">max_input_chars_per_word</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="n">vocab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span> <span class="o">=</span> <span class="n">unk_token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_input_chars_per_word</span> <span class="o">=</span> <span class="n">max_input_chars_per_word</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tokenizes a piece of text into its word pieces. This uses a greedy longest-match-first algorithm to perform</span>
<span class="sd">        tokenization using the given vocabulary.</span>

<span class="sd">        For example, :obj:`input = &quot;unaffable&quot;` wil return as output :obj:`[&quot;un&quot;, &quot;##aff&quot;, &quot;##able&quot;]`.</span>

<span class="sd">        Args:</span>
<span class="sd">          text: A single token or whitespace separated tokens. This should have</span>
<span class="sd">            already been passed through `BasicTokenizer`.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A list of wordpiece tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">output_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">whitespace_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_input_chars_per_word</span><span class="p">:</span>
                <span class="n">output_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">is_bad</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sub_tokens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
                <span class="n">cur_substr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
                    <span class="n">substr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">substr</span> <span class="o">=</span> <span class="s2">&quot;##&quot;</span> <span class="o">+</span> <span class="n">substr</span>
                    <span class="k">if</span> <span class="n">substr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span>
                        <span class="n">cur_substr</span> <span class="o">=</span> <span class="n">substr</span>
                        <span class="k">break</span>
                    <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cur_substr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">is_bad</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="n">sub_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_substr</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>

            <span class="k">if</span> <span class="n">is_bad</span><span class="p">:</span>
                <span class="n">output_tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unk_token</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_tokens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_tokens</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_tokens</span>


<span class="c1"># Below: utilities for TAPAS tokenizer (independent from PyTorch/Tensorflow).</span>
<span class="c1"># This includes functions to parse numeric values (dates and numbers) from both the table and questions in order</span>
<span class="c1"># to create the column_ranks, inv_column_ranks, numeric_values, numeric values_scale and numeric_relations in</span>
<span class="c1"># prepare_for_model of TapasTokenizer.</span>
<span class="c1"># These are meant to be used in an academic setup, for production use cases Gold mine or Aqua should be used.</span>


<span class="c1"># taken from constants.py of the original implementation</span>
<span class="c1"># URL: https://github.com/google-research/tapas/blob/master/tapas/utils/constants.py</span>
<span class="k">class</span> <span class="nc">Relation</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">HEADER_TO_CELL</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Connects header to cell.</span>
    <span class="n">CELL_TO_HEADER</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Connects cell to header.</span>
    <span class="n">QUERY_TO_HEADER</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Connects query to headers.</span>
    <span class="n">QUERY_TO_CELL</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># Connects query to cells.</span>
    <span class="n">ROW_TO_CELL</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># Connects row to cells.</span>
    <span class="n">CELL_TO_ROW</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Connects cells to row.</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="mi">7</span>  <span class="c1"># Annotation value is same as cell value</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># Annotation value is less than cell value</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="mi">9</span>  <span class="c1"># Annotation value is greater than cell value</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="n">year</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">month</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">day</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">NumericValue</span><span class="p">:</span>
    <span class="n">float_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">NumericValueSpan</span><span class="p">:</span>
    <span class="n">begin_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">end_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NumericValue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Cell</span><span class="p">:</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">Text</span>
    <span class="n">numeric_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NumericValue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Question</span><span class="p">:</span>
    <span class="n">original_text</span><span class="p">:</span> <span class="n">Text</span>  <span class="c1"># The original raw question string.</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">Text</span>  <span class="c1"># The question string after normalization.</span>
    <span class="n">numeric_spans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">NumericValueSpan</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># Below: all functions from number_utils.py as well as 2 functions (namely get_all_spans and normalize_for_match)</span>
<span class="c1"># from text_utils.py of the original implementation. URL&#39;s:</span>
<span class="c1"># - https://github.com/google-research/tapas/blob/master/tapas/utils/number_utils.py</span>
<span class="c1"># - https://github.com/google-research/tapas/blob/master/tapas/utils/text_utils.py</span>


<span class="c1"># Constants for parsing date expressions.</span>
<span class="c1"># Masks that specify (by a bool) which of (year, month, day) will be populated.</span>
<span class="n">_DateMask</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;_DateMask&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">])</span>

<span class="n">_YEAR</span> <span class="o">=</span> <span class="n">_DateMask</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">_YEAR_MONTH</span> <span class="o">=</span> <span class="n">_DateMask</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">_YEAR_MONTH_DAY</span> <span class="o">=</span> <span class="n">_DateMask</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">_MONTH</span> <span class="o">=</span> <span class="n">_DateMask</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">_MONTH_DAY</span> <span class="o">=</span> <span class="n">_DateMask</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Pairs of patterns to pass to &#39;datetime.strptime&#39; and masks specifying which</span>
<span class="c1"># fields will be set by the corresponding pattern.</span>
<span class="n">_DATE_PATTERNS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s2">&quot;%B&quot;</span><span class="p">,</span> <span class="n">_MONTH</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%Y&quot;</span><span class="p">,</span> <span class="n">_YEAR</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%Ys&quot;</span><span class="p">,</span> <span class="n">_YEAR</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%b %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%B %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%B </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%b </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %b&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %B&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%B </span><span class="si">%d</span><span class="s2">, %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %B %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2">-%Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%Y-%m&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%B %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %b %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%b </span><span class="si">%d</span><span class="s2">, %Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.%m.%Y&quot;</span><span class="p">,</span> <span class="n">_YEAR_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%A, %b </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;%A, %B </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_MONTH_DAY</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1"># This mapping is used to convert date patterns to regex patterns.</span>
<span class="n">_FIELD_TO_REGEX</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s2">&quot;%A&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\w+&quot;</span><span class="p">),</span>  <span class="c1"># Weekday as localeâ€™s full name.</span>
    <span class="p">(</span><span class="s2">&quot;%B&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\w+&quot;</span><span class="p">),</span>  <span class="c1"># Month as localeâ€™s full name.</span>
    <span class="p">(</span><span class="s2">&quot;%Y&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\d</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">),</span>  <span class="c1"># Year with century as a decimal number.</span>
    <span class="p">(</span><span class="s2">&quot;%b&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\w</span><span class="si">{3}</span><span class="s2">&quot;</span><span class="p">),</span>  <span class="c1"># Month as localeâ€™s abbreviated name.</span>
    <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\d{1,2}&quot;</span><span class="p">),</span>  <span class="c1"># Day of the month as a zero-padded decimal number.</span>
    <span class="p">(</span><span class="s2">&quot;%m&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\d{1,2}&quot;</span><span class="p">),</span>  <span class="c1"># Month as a zero-padded decimal number.</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_process_date_pattern</span><span class="p">(</span><span class="n">dp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a regex for each date pattern to use as a prefilter.&quot;&quot;&quot;</span>
    <span class="n">pattern</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">dp</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">pattern</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">field_regex</span> <span class="ow">in</span> <span class="n">_FIELD_TO_REGEX</span><span class="p">:</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">field_regex</span><span class="p">)</span>
    <span class="c1"># Make sure we didn&#39;t miss any of the fields.</span>
    <span class="k">assert</span> <span class="s2">&quot;%&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">regex</span><span class="p">,</span> <span class="n">regex</span>
    <span class="k">return</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="n">regex</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_process_date_patterns</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_process_date_pattern</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">_DATE_PATTERNS</span><span class="p">)</span>


<span class="n">_PROCESSED_DATE_PATTERNS</span> <span class="o">=</span> <span class="n">_process_date_patterns</span><span class="p">()</span>

<span class="n">_MAX_DATE_NGRAM_SIZE</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Following DynSp:</span>
<span class="c1"># https://github.com/Microsoft/DynSP/blob/master/util.py#L414.</span>
<span class="n">_NUMBER_WORDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;zero&quot;</span><span class="p">,</span>
    <span class="s2">&quot;one&quot;</span><span class="p">,</span>
    <span class="s2">&quot;two&quot;</span><span class="p">,</span>
    <span class="s2">&quot;three&quot;</span><span class="p">,</span>
    <span class="s2">&quot;four&quot;</span><span class="p">,</span>
    <span class="s2">&quot;five&quot;</span><span class="p">,</span>
    <span class="s2">&quot;six&quot;</span><span class="p">,</span>
    <span class="s2">&quot;seven&quot;</span><span class="p">,</span>
    <span class="s2">&quot;eight&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ten&quot;</span><span class="p">,</span>
    <span class="s2">&quot;eleven&quot;</span><span class="p">,</span>
    <span class="s2">&quot;twelve&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_ORDINAL_WORDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;zeroth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="s2">&quot;second&quot;</span><span class="p">,</span>
    <span class="s2">&quot;third&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fourth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fith&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sixth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;seventh&quot;</span><span class="p">,</span>
    <span class="s2">&quot;eighth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ninth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tenth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;eleventh&quot;</span><span class="p">,</span>
    <span class="s2">&quot;twelfth&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_ORDINAL_SUFFIXES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;st&quot;</span><span class="p">,</span> <span class="s2">&quot;nd&quot;</span><span class="p">,</span> <span class="s2">&quot;rd&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">]</span>

<span class="n">_NUMBER_PATTERN</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;((^|\s)[+-])?((\.\d+)|(\d+(,\d\d\d)*(\.\d*)?))&quot;</span><span class="p">)</span>

<span class="c1"># Following DynSp:</span>
<span class="c1"># https://github.com/Microsoft/DynSP/blob/master/util.py#L293.</span>
<span class="n">_MIN_YEAR</span> <span class="o">=</span> <span class="mi">1700</span>
<span class="n">_MAX_YEAR</span> <span class="o">=</span> <span class="mi">2016</span>

<span class="n">_INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;INF&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_numeric_value_from_date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts date (datetime Python object) to a NumericValue object with a Date object value.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="n">_MIN_YEAR</span> <span class="ow">or</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;</span> <span class="n">_MAX_YEAR</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid year: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>

    <span class="n">new_date</span> <span class="o">=</span> <span class="n">Date</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">year</span><span class="p">:</span>
        <span class="n">new_date</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">month</span><span class="p">:</span>
        <span class="n">new_date</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">month</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">day</span><span class="p">:</span>
        <span class="n">new_date</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">day</span>
    <span class="k">return</span> <span class="n">NumericValue</span><span class="p">(</span><span class="n">date</span><span class="o">=</span><span class="n">new_date</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_span_length_key</span><span class="p">(</span><span class="n">span</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sorts span by decreasing length first and incresing first index second.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_numeric_value_from_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts float (Python) to a NumericValue object with a float value.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">NumericValue</span><span class="p">(</span><span class="n">float_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>


<span class="c1"># Doesn&#39;t parse ordinal expressions such as &#39;18th of february 1655&#39;.</span>
<span class="k">def</span> <span class="nf">_parse_date</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attempts to format a text as a standard date string (yyyy-mm-dd).&quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Sept\b&quot;</span><span class="p">,</span> <span class="s2">&quot;Sep&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">in_pattern</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">_PROCESSED_DATE_PATTERNS</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">in_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_numeric_value_from_date</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_parse_number</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses simple cardinal and ordinals numbers.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">_ORDINAL_SUFFIXES</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)]</span>
            <span class="k">break</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">_INF</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">get_all_spans</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">max_ngram_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a text into all possible ngrams up to &#39;max_ngram_length&#39;. Split points are white space and punctuation.</span>

<span class="sd">    Args:</span>
<span class="sd">      text: Text to split.</span>
<span class="sd">      max_ngram_length: maximal ngram length.</span>
<span class="sd">    Yields:</span>
<span class="sd">      Spans, tuples of begin-end index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">char</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">text</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="n">start_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">text</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">start_index</span> <span class="ow">in</span> <span class="n">start_indexes</span><span class="p">[</span><span class="o">-</span><span class="n">max_ngram_length</span><span class="p">:]:</span>
                <span class="k">yield</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">normalize_for_match</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">format_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lowercases and strips punctuation.&quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;n/a&quot;</span> <span class="ow">or</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;?&quot;</span> <span class="ow">or</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;nan&quot;</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">EMPTY_TEXT</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\w\d]+&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">text</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">text</span>
    <span class="k">return</span> <span class="n">EMPTY_TEXT</span>


<span class="k">def</span> <span class="nf">parse_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts longest number and date spans.</span>

<span class="sd">    Args:</span>
<span class="sd">      text: text to annotate</span>

<span class="sd">    Returns:</span>
<span class="sd">      List of longest numeric value spans.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">span_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">_NUMBER_PATTERN</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="n">span_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()]</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">_parse_number</span><span class="p">(</span><span class="n">span_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">span_dict</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_numeric_value_from_float</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span> <span class="ow">in</span> <span class="n">get_all_spans</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">max_ngram_length</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">span_dict</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">span_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">begin_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>

        <span class="n">number</span> <span class="o">=</span> <span class="n">_parse_number</span><span class="p">(</span><span class="n">span_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">span_dict</span><span class="p">[</span><span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_numeric_value_from_float</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">number</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_NUMBER_WORDS</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">span_text</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">span_dict</span><span class="p">[</span><span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_numeric_value_from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">number</span><span class="p">)))</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">number</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ORDINAL_WORDS</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">span_text</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">span_dict</span><span class="p">[</span><span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_numeric_value_from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">number</span><span class="p">)))</span>
                <span class="k">break</span>

    <span class="k">for</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span> <span class="ow">in</span> <span class="n">get_all_spans</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">max_ngram_length</span><span class="o">=</span><span class="n">_MAX_DATE_NGRAM_SIZE</span><span class="p">):</span>
        <span class="n">span_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">begin_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">_parse_date</span><span class="p">(</span><span class="n">span_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">span_dict</span><span class="p">[</span><span class="n">begin_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

    <span class="n">spans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">span_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">span_value</span><span class="p">:</span> <span class="n">_get_span_length_key</span><span class="p">(</span><span class="n">span_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">selected_spans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">span</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">spans</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">selected_span</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">selected_spans</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">selected_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">selected_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selected_spans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">span</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

    <span class="n">selected_spans</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">span_value</span><span class="p">:</span> <span class="n">span_value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">numeric_value_spans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">span</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">selected_spans</span><span class="p">:</span>
        <span class="n">numeric_value_spans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NumericValueSpan</span><span class="p">(</span><span class="n">begin_index</span><span class="o">=</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_index</span><span class="o">=</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">numeric_value_spans</span>


<span class="c1"># Below: all functions from number_annotation_utils.py and 2 functions (namely filter_invalid_unicode</span>
<span class="c1"># and filter_invalid_unicode_from_table) from text_utils.py of the original implementation. URL&#39;s:</span>
<span class="c1"># - https://github.com/google-research/tapas/blob/master/tapas/utils/number_annotation_utils.py</span>
<span class="c1"># - https://github.com/google-research/tapas/blob/master/tapas/utils/text_utils.py</span>


<span class="n">_PrimitiveNumericValue</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span>
<span class="n">_SortKeyFn</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">NumericValue</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">]]</span>

<span class="n">_DATE_TUPLE_SIZE</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">EMPTY_TEXT</span> <span class="o">=</span> <span class="s2">&quot;EMPTY&quot;</span>

<span class="n">NUMBER_TYPE</span> <span class="o">=</span> <span class="s2">&quot;number&quot;</span>
<span class="n">DATE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;date&quot;</span>


<span class="k">def</span> <span class="nf">_get_value_type</span><span class="p">(</span><span class="n">numeric_value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">float_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NUMBER_TYPE</span>
    <span class="k">elif</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DATE_TYPE</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numeric_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_value_as_primitive_value</span><span class="p">(</span><span class="n">numeric_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maps a NumericValue proto to a float or tuple of float.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">float_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">float_value</span>
    <span class="k">if</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">numeric_value</span><span class="o">.</span><span class="n">date</span>
        <span class="n">value_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="c1"># All dates fields are cased to float to produce a simple primitive value.</span>
        <span class="k">if</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date</span><span class="o">.</span><span class="n">month</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date</span><span class="o">.</span><span class="n">day</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value_tuple</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numeric_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_all_types</span><span class="p">(</span><span class="n">numeric_values</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">_get_value_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numeric_values</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">get_numeric_sort_key_fn</span><span class="p">(</span><span class="n">numeric_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a function that can be used as a sort key or to compare the values. Maps to primitive types and finds the</span>
<span class="sd">    biggest common subset. Consider the values &quot;05/05/2010&quot; and &quot;August 2007&quot;. With the corresponding primitive values</span>
<span class="sd">    (2010.,5.,5.) and (2007.,8., None). These values can be compared by year and date so we map to the sequence (2010.,</span>
<span class="sd">    5.), (2007., 8.). If we added a third value &quot;2006&quot; with primitive value (2006., None, None), we could only compare</span>
<span class="sd">    by the year so we would map to (2010.,), (2007.,) and (2006.,).</span>

<span class="sd">    Args:</span>
<span class="sd">     numeric_values: Values to compare</span>

<span class="sd">    Returns:</span>
<span class="sd">     A function that can be used as a sort key function (mapping numeric values to a comparable tuple)</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError if values don&#39;t have a common type or are not comparable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value_types</span> <span class="o">=</span> <span class="n">_get_all_types</span><span class="p">(</span><span class="n">numeric_values</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_types</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No common value type in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numeric_values</span><span class="p">)</span>

    <span class="n">value_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">value_types</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">value_type</span> <span class="o">==</span> <span class="n">NUMBER_TYPE</span><span class="p">:</span>
        <span class="c1"># Primitive values are simple floats, nothing to do here.</span>
        <span class="k">return</span> <span class="n">_get_value_as_primitive_value</span>

    <span class="c1"># The type can only be Date at this point which means the primitive type</span>
    <span class="c1"># is a float triple.</span>
    <span class="n">valid_indexes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">_DATE_TUPLE_SIZE</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">numeric_value</span> <span class="ow">in</span> <span class="n">numeric_values</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_get_value_as_primitive_value</span><span class="p">(</span><span class="n">numeric_value</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tuple_index</span><span class="p">,</span> <span class="n">inner_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inner_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">valid_indexes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">tuple_index</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_indexes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No common value in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numeric_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sort_key_fn</span><span class="p">(</span><span class="n">numeric_value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_get_value_as_primitive_value</span><span class="p">(</span><span class="n">numeric_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">valid_indexes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_sort_key_fn</span>


<span class="k">def</span> <span class="nf">_consolidate_numeric_values</span><span class="p">(</span><span class="n">row_index_to_values</span><span class="p">,</span> <span class="n">min_consolidation_fraction</span><span class="p">,</span> <span class="n">debug_info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the most common numeric values in a column and returns them</span>

<span class="sd">    Args:</span>
<span class="sd">        row_index_to_values:</span>
<span class="sd">            For each row index all the values in that cell.</span>
<span class="sd">        min_consolidation_fraction:</span>
<span class="sd">            Fraction of cells that need to have consolidated value.</span>
<span class="sd">        debug_info:</span>
<span class="sd">            Additional information only used for logging</span>

<span class="sd">    Returns:</span>
<span class="sd">        For each row index the first value that matches the most common value. Rows that don&#39;t have a matching value</span>
<span class="sd">        are dropped. Empty list if values can&#39;t be consolidated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">numeric_values</span> <span class="ow">in</span> <span class="n">row_index_to_values</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">type_counts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_get_all_types</span><span class="p">(</span><span class="n">numeric_values</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">type_counts</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">type_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">max_count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_index_to_values</span><span class="p">)</span> <span class="o">*</span> <span class="n">min_consolidation_fraction</span><span class="p">:</span>
        <span class="c1"># logging.log_every_n(logging.INFO, &#39;Can\&#39;t consolidate types: %s %s %d&#39;, 100,</span>
        <span class="c1">#                     debug_info, row_index_to_values, max_count)</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="n">valid_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">type_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">max_count</span><span class="p">:</span>
            <span class="n">valid_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">DATE_TYPE</span> <span class="ow">in</span> <span class="n">valid_types</span>
        <span class="n">max_type</span> <span class="o">=</span> <span class="n">DATE_TYPE</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">valid_types</span><span class="p">))</span>

    <span class="n">new_row_index_to_value</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">row_index_to_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Extract the first matching value.</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_get_value_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_type</span><span class="p">:</span>
                <span class="n">new_row_index_to_value</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">new_row_index_to_value</span>


<span class="k">def</span> <span class="nf">_get_numeric_values</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses text and returns numeric values.&quot;&quot;&quot;</span>
    <span class="n">numeric_spans</span> <span class="o">=</span> <span class="n">parse_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">span</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">span</span> <span class="ow">in</span> <span class="n">numeric_spans</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_get_column_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">col_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses text in column and returns a dict mapping row_index to values. This is the _get_column_values function from</span>
<span class="sd">    number_annotation_utils.py of the original implementation</span>

<span class="sd">    Args:</span>
<span class="sd">      table: Pandas dataframe</span>
<span class="sd">      col_index: integer, indicating the index of the column to get the numeric values of</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index_to_values</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">normalize_for_match</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">index_to_values</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_get_numeric_values</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">index_to_values</span>


<span class="k">def</span> <span class="nf">get_numeric_relation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other_value</span><span class="p">,</span> <span class="n">sort_key_fn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compares two values and returns their relation or None.&quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">sort_key_fn</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">other_value</span> <span class="o">=</span> <span class="n">sort_key_fn</span><span class="p">(</span><span class="n">other_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">other_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Relation</span><span class="o">.</span><span class="n">EQ</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">other_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Relation</span><span class="o">.</span><span class="n">LT</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">other_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Relation</span><span class="o">.</span><span class="n">GT</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">add_numeric_values_to_question</span><span class="p">(</span><span class="n">question</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds numeric value spans to a question.&quot;&quot;&quot;</span>
    <span class="n">original_text</span> <span class="o">=</span> <span class="n">question</span>
    <span class="n">question</span> <span class="o">=</span> <span class="n">normalize_for_match</span><span class="p">(</span><span class="n">question</span><span class="p">)</span>
    <span class="n">numeric_spans</span> <span class="o">=</span> <span class="n">parse_text</span><span class="p">(</span><span class="n">question</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Question</span><span class="p">(</span><span class="n">original_text</span><span class="o">=</span><span class="n">original_text</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">question</span><span class="p">,</span> <span class="n">numeric_spans</span><span class="o">=</span><span class="n">numeric_spans</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">filter_invalid_unicode</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an empty string and True if &#39;text&#39; is in invalid unicode.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">filter_invalid_unicode_from_table</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes invalid unicode from table. Checks whether a table cell text contains an invalid unicode encoding. If yes,</span>
<span class="sd">    reset the table cell text to an empty str and log a warning for each invalid cell</span>

<span class="sd">    Args:</span>
<span class="sd">        table: table to clean.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># to do: add table id support</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;table_id&quot;</span><span class="p">):</span>
        <span class="n">table</span><span class="o">.</span><span class="n">table_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">cell</span><span class="p">,</span> <span class="n">is_invalid</span> <span class="o">=</span> <span class="n">filter_invalid_unicode</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_invalid</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Scrub an invalid table body @ table_id: </span><span class="si">%s</span><span class="s2">, row_index: </span><span class="si">%d</span><span class="s2">, &quot;</span> <span class="s2">&quot;col_index: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">table</span><span class="o">.</span><span class="n">table_id</span><span class="p">,</span>
                    <span class="n">row_index</span><span class="p">,</span>
                    <span class="n">col_index</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">column</span><span class="p">,</span> <span class="n">is_invalid</span> <span class="o">=</span> <span class="n">filter_invalid_unicode</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_invalid</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Scrub an invalid table header @ table_id: </span><span class="si">%s</span><span class="s2">, col_index: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">table_id</span><span class="p">,</span> <span class="n">col_index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_numeric_table_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">min_consolidation_fraction</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses text in table column-wise and adds the consolidated values. Consolidation refers to finding values with a</span>
<span class="sd">    common types (date or number)</span>

<span class="sd">    Args:</span>
<span class="sd">        table:</span>
<span class="sd">            Table to annotate.</span>
<span class="sd">        min_consolidation_fraction:</span>
<span class="sd">            Fraction of cells in a column that need to have consolidated value.</span>
<span class="sd">        debug_info:</span>
<span class="sd">            Additional information used for logging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># First, filter table on invalid unicode</span>
    <span class="n">filter_invalid_unicode_from_table</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="c1"># Second, replace cell values by Cell objects</span>
    <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_index</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>

    <span class="c1"># Third, add numeric_value attributes to these Cell objects</span>
    <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">column_values</span> <span class="o">=</span> <span class="n">_consolidate_numeric_values</span><span class="p">(</span>
            <span class="n">_get_column_values</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">col_index</span><span class="p">),</span>
            <span class="n">min_consolidation_fraction</span><span class="o">=</span><span class="n">min_consolidation_fraction</span><span class="p">,</span>
            <span class="n">debug_info</span><span class="o">=</span><span class="p">(</span><span class="n">debug_info</span><span class="p">,</span> <span class="n">column</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">numeric_value</span> <span class="ow">in</span> <span class="n">column_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_index</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span><span class="o">.</span><span class="n">numeric_value</span> <span class="o">=</span> <span class="n">numeric_value</span>

    <span class="k">return</span> <span class="n">table</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, The Hugging Face Team, Licenced under the Apache License, Version 2.0.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-83738774-2', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>