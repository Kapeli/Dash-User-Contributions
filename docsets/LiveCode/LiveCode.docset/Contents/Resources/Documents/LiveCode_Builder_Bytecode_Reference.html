<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>LiveCode Builder Bytecode Reference</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: reference</h2><h1>LiveCode Builder Bytecode Reference</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>The LiveCode Builder Virtual Machine is a infinite register machine with ahigh-level and verifiable bytecode.</p><p>All bytecode runs in the context of a module instance with executing handlersforming a stack of activation frames. Each frame contains an array of registers,the first part of which are parameters followed by handler-local variables andbytecode block registers.</p><p>Most bytecode operations operate directly on registers, access to module leveldefinitions (handlers, constants, variables) are indirected through the fetchand store operations.</p><p>Each bytecode operation has an address which can be jumped to using the jumpoperations.</p><h2><a name="//apple_ref/cpp/Guide/Operations" class="dashAnchor"></a>Operations</h2><h3>Jump</h3><pre><code>jump &lt;label&gt;</code></pre><p>The jump operation sets the address of the next instruction to execute tothat identified by <label>.</p><h3>Jump If False</h3><pre><code>jump_if_false &lt;register&gt;, &lt;label&gt;</code></pre><p>The jump_if_true operation checks the value in <register> and jumps to <label>if it is &#39;false&#39;.</p><p>If is a runtime error if <register> does not contain a boolean.</p><h3>Jump If True</h3><pre><code>jump_if_true &lt;register&gt;, &lt;label&gt;</code></pre><p>The jump_if_true operation checks the value in <register> and jumps to <label>if it is &#39;true&#39;.</p><p>If is a runtime error if <register> does not contain a boolean.</p><h3>Assign Constant</h3><pre><code>assign_constant &lt;register&gt;, &lt;constant&gt;</code></pre><p>The assign_constant operation copies <constant> into <register>. Here <constant>can be the nothing literal, the true or false literal, an integer literal, areal literal, a string literal, a list literal or array literal.</p><p>If <register> is typed then it is a runtime error if the type of <constant>does not conform to that type.</p><h3>Assign</h3><pre><code>assign &lt;dst-register&gt;, &lt;src-register&gt;</code></pre><p>The assign operation copies the value in <src-register> to <dst-register>.</p><p>If <dst-register> is typed then it is runtime error if the type of the valuein <src-register> does not conform to that type.</p><h3>Return</h3><pre><code>return [ &lt;result-reg&gt; ]</code></pre><p>The return operation exits the current handler, returning to the instruction afterthe invoke operation which created it. If present, the value in <result-reg> iscopied as the return value. If not present then the return value will be &#39;nothing&#39;.Additionally any values in out or inout parameters are copied back to the caller.</p><p>If <result-reg> is not present, then the return value will be &#39;nothing&#39;.</p><p>It is a runtime error if the type of the return value does not conform to thereturn type of the current handler&#39;s signature.</p><p>It is a runtime error if any out or inout parameters are unassigned at the pointof return.</p><h3>Invoke</h3><pre><code>invoke &lt;handler&gt;, &lt;result-reg&gt;, &lt;arg1-reg&gt;, ..., &lt;argn-reg&gt;</code></pre><p>The invoke operation creates a new frame copying values from the argument registersfor any in or inout parameters. It then starts executing the bytecode attachedto <handler>, a definition. The return value is placed into the register <result-reg>.</p><p>If is a runtime error if the number of arguments provided is different from thesignature of <handler></p><p>If it a runtime error if for in and inout parameters, the contents of <arg_i>does not conform to the type of the parameter required by the signature.</p><h3>Invoke Indirect</h3><pre><code>invoke &lt;handler-reg&gt;, &lt;result-reg&gt;, &lt;arg1-reg&gt;, ..., &lt;argn-reg&gt;</code></pre><p>The invoke indirect operation functions identically to the invoke operationexcept that it calls the handler in <handler-reg>.</p><p>It is a runtime error if <handler-reg> does not contain a handler value.</p><h3>Fetch</h3><pre><code>fetch &lt;dst-register&gt;, &lt;definition&gt;</code></pre><p>The fetch operation copies the value of <definition> into <dst-register>. The<definition> may be a variable, constant or handler. In the case of a handler,a handler value is created.</p><p>It is a runtime error if the type of the value of <definition> does not conformto the type of <dst-register>.</p><h3>Store</h3><pre><code>store &lt;src-register&gt;, &lt;definition&gt;</code></pre><p>The store operation copies the contents of <src-register> into <definition>. The<definition> must be a module level variable.</p><p>It is a runtime error if the type of the value in <src-register> does not conformto the type of <definition>.</p><h3>Assign List</h3><pre><code>assign_list &lt;dst-reg&gt;, &lt;element1-reg&gt;, ..., &lt;elementn-reg&gt;</code></pre><p>The assign_list operation builds a list value from <element1-reg> up to<elementn-reg>.</p><p>It is a runtime error if the type of <dst-reg> does not conform to list.</p><h3>Assign Array</h3><pre><code>assign_array &lt;dst-reg&gt;, &lt;key1-reg&gt;, &lt;value1-reg&gt;, ..., &lt;keyn-reg&gt;, &lt;valuen-reg&gt;</code></pre><p>The assign_array operation builds an array value from each key value pair<key1-reg>, <value1-reg> up to <keyn-reg>, <valuen-reg>.</p><p>It is a runtime error if the type of <dst-reg> does not conform to array.</p><h3>Reset</h3><pre><code>reset &lt;reg&gt;</code></pre><p>The reset operation performs default initialization of <reg>. If the type of<reg> has no default value, it reverts to unassigned.</p></body></html>