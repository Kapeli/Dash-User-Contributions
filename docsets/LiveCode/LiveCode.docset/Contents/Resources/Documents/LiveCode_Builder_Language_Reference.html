<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>LiveCode Builder Language Reference</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: reference</h2><h1>LiveCode Builder Language Reference</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>LiveCode Builder is a variant of the current LiveCode scripting language(LiveCode Script) which has been designed for &#39;systems&#39; building. It isstatically compiled with optional static typing and direct foreign codeinterconnect (allowing easy access to APIs written in other languages).</p><p>Unlike most languages, LiveCode Builder has been designed around theidea of extensible syntax. Indeed, the core language is very small -comprising declarations and control structures - with the majority ofthe language syntax and functionality being defined in modules.</p><blockquote><p><strong>Note:</strong> It is an eventual aim that control structures will also beextensible, however this is not the case in the current incarnation).</p></blockquote><p>The syntax will be familiar to anyone familiar with LiveCode Script,however LiveCode Builder is a great deal more strict - the reason beingit is intended that it will eventually be compilable to machine codewith the performance and efficiency you&#39;d expect from any &#39;traditional&#39;programming language. Indeed, over time we hope to move the majority ofimplementation of the whole LiveCode system over to being written inLiveCode Builder.</p><blockquote><p><strong>Note:</strong> One of the principal differences is that type conversion isstrict - there is no automatic conversion between different types suchas between number and string. Such conversion must be explicitlyspecified using syntax (currently this is using things like<em>... parsed as number</em> and <em>... formatted as string</em>.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Tokens" class="dashAnchor"></a>Tokens</h2><p>The structure of tokens is similar to LiveCode Script, but again alittle stricter. The regular expressions describing the tokens are asfollows:</p><ul><li><strong>Identifier</strong>: [A-Za-z_][A-Za-z0-9_.]*</li><li><strong>Integer</strong>: [0-9]+</li><li><strong>Binary Integer</strong>: 0b[01]+</li><li><strong>Hexadecimal Integer</strong>: 0x[0-9a-fA-F]+</li><li><strong>Real</strong>: [0-9]+&quot;.&quot;[0-9]+([eE][-+]?[0-9]+)?</li><li><strong>String</strong>: &quot;[<sup>\n\r&quot;]*&quot;</sup></li><li><strong>Separator</strong>: Any whitespace containing at least one newline</li></ul><p>Strings use backslash (&#39;\&#39;) as an escape - the following are understood:</p><ul><li><strong>\n</strong>: LF (ASCII 10)</li><li><strong>\r</strong>: CR (ASCII 13)</li><li><strong>\t</strong>: TAB (ASCII 9)</li><li><strong>\q</strong>: quote &#39;&quot;&#39;</li><li>**\u{X...X}: character with unicode codepoint U+X...X - any number of nibbles may be specified, but any values greater than 0x10FFFF will be replaced by U+FFFD.</li><li><strong>\</strong>: backslash &#39;\&#39;</li></ul><blockquote><p><strong>Note:</strong> The presence of &#39;.&#39; in identifiers are used as a namespacescope delimiter.</p><p><strong>Note:</strong> Source files are presumed to be in UTF-8 encoding.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Comments" class="dashAnchor"></a>Comments</h2><p>LiveCode Builder supports single line comments, which begin with <code>//</code>or <code>--</code> and extend to the end of the line.  There are also blockcomments, which begin with <code>/*</code> and end with <code>*/</code>, and can spanmultiple lines.</p><ul><li><strong>Single-line comment</strong>: (--|//)[<sup>\n\r]*</sup></li><li><strong>Block comment</strong>: /*(<a href="*%5B%5E/%5D"><sup>*</sup></a>?)**/</li></ul><blockquote><p><strong>Note:</strong> A block comment that spans multiple lines terminates theline of code that it begins on.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Line continuation" class="dashAnchor"></a>Line continuation</h2><p>A LiveCode builder statement or declaration can be continued ontomultiple lines of code by placing the line continuation character <code>\</code>at the end each line.</p><ul><li><strong>Line continuation</strong>: \[\t ]*(\n|\r\n|\r)</li></ul><blockquote><p><strong>Note:</strong> Tab and space characters are allowed after the <code>\</code> and before thenewline, but no other characters.</p><p><strong>Note:</strong> A line continuation cannot occur within a comment.</p></blockquote><h3>Case-Sensitivity</h3><p>At the moment, due to the nature of the parser being used, keywords areall case-sensitive and reserved. The result of this is that, using alllower-case identifiers for names of definitions should be avoided.However, identifiers <em>are</em> case-insensitive - so a variable with namepFoo can also be referenced as PFOO, PfOO, pfoO etc.</p><blockquote><p><strong>Aside:</strong> The current parser and syntax rules for LiveCode Builderare constructed at build-time of the LiveCode Builder compiler anduses <em>bison</em> (a standard parser generator tool) to build the parser.Unfortunately, this means that any keywords have to be reserved as theparser cannot distinguish the use of an identifier in context (whetherit is a keyword at a particular point, or a name of a definition).</p></blockquote><p>It is highly recommended that the following naming conventions be usedfor identifiers:</p><ul><li><strong>tVar</strong> - for local variables</li><li><strong>pVar</strong> - for in parameterns</li><li><strong>rVar</strong> - for out parameters</li><li><strong>xVar</strong> - for inout parameters</li><li><strong>mVar</strong> - for global variables in widgets</li><li><strong>sVar</strong> - for global variables in libraries</li><li><strong>kConstant</strong> - for constants</li><li>Use identifiers starting with an uppercase letter for handler and type names.</li></ul><p>By following this convention, there will not be any ambiguity betweenidentifiers and keywords. (All keywords are all lower-case).</p><blockquote><p><strong>Note:</strong> When we have a better parsing technology we will beevaluating whether to make keywords case-insensitive as well. At thevery least, at that point, we expect to be able to make all keywordsunreserved.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Typing" class="dashAnchor"></a>Typing</h2><p>LiveCode Builder is a typed language, although typing is completelyoptional in most places (the only exception being in foreign handlerdeclarations). If a type annotation is not specified it is simply takento be the most general type <em>optional any</em> (meaning any value, includingnothing).</p><p>The range of core types is relatively small, comprising the following:</p><ul><li><strong>nothing</strong>: the single value <em>nothing</em></li><li><strong>Boolean</strong>: one of <em>true</em> or <em>false</em></li><li><strong>Integer</strong>: any integral numeric value (size limitations apply)</li><li><strong>Real</strong>: any numeric value (size and accuracy limitations apply)</li><li><strong>Number</strong>: any integer or real value</li><li><strong>String</strong>: a sequence of UTF-16 code units</li><li><strong>Data</strong>: a sequence of bytes</li><li><strong>List</strong>: a sequence of any values</li><li><strong>Array</strong>: a mapping from strings to values</li><li><strong>any</strong>: a value of any type</li></ul><p>Additionally, all types can be annotated with <strong>optional</strong>. An optionalannotation means the value may be the original type or nothing.</p><blockquote><p><strong>Note:</strong> The current compiler does not do type-checking; alltype-checking happens at runtime. However, this is being worked on sothere will soon be a compiler which will give you type errors atcompile-time.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Modules" class="dashAnchor"></a>Modules</h2><pre><code>Module    : &#39;module&#39; &lt;Name: Identifier&gt; SEPARATOR        { ( Definition | Metadata | Import ) SEPARATOR }      &#39;end&#39; &#39;module&#39;</code></pre><p>The smallest compilable unit of LiveCode Builder is the module. Eachmodule is uniquely named using reverse DNS notation, and the names ofmodules are considered to live in a global namespace.</p><p>A module is a collection of public and private definitions, includingconstants, variables, types and handlers.</p><p>A module may depend on another module through import. An importedmodules public definitions become accessible to the importing module.</p><blockquote><p><strong>Note:</strong> For integration with the existing LiveCode system, there aretwo module variants which may be used. Widgets (use &#39;widget&#39; insteadof &#39;module&#39;) and Libraries (use &#39;library&#39; instead of &#39;module&#39;). Awidget appears in LiveCode as a control, whilst a library adds all itspublic handlers to the bottom of the message path.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Metadata" class="dashAnchor"></a>Metadata</h2><pre><code>Metadata    : &#39;metadata&#39; &lt;Name: Identifier&gt; &#39;is&#39; &lt;Value: String&gt;</code></pre><p>The metadata clauses allow a set of key-values to be encoded in thecompiled module. These are not used in compilation or execution, but maybe used by the system loading and using the module.</p><p>At the moment, the following keys are understood:</p><ul><li>title: a human-readable name for the module</li><li>description: a simple description of the module&#39;s purpose</li><li>version: a string in the form X.Y.Z (with X, Y and Z integers) describing the modules version</li><li>author: the name of the author of the module</li></ul><blockquote><p><strong>Note:</strong> The current metadata mechanism is unlikely to remain part ofthe language. It is intended that it will be replaced by a packagedescription file, which will allow modules to be grouped together withother resources.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Imports" class="dashAnchor"></a>Imports</h2><pre><code>Import    : &#39;use&#39; &lt;Name: Identifier&gt;</code></pre><p>The use clauses allow a module to refer to another module by importingall the target module&#39;s public definitions into its namespace.</p><p>The name of the module specified must be its full name, e.g.com.livecode.canvas.</p><p>A module may use any other module, as long as doing so does not cause acycle in the dependency graph.</p><blockquote><p><strong>Note:</strong> The current IDE and extension installation system does notyet implement arbitrary dependencies - the only dependencies itunderstands are those which are builtin to the system (e.g.com.livecode.canvas). However, you can still write and test outmodules with dependencies locally - they just cannot be uploaded tothe extensions portal.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Definitions" class="dashAnchor"></a>Definitions</h2><pre><code>Definition  : ( &#39;public&#39; | &#39;private&#39; ) ConstantDefinition  | ( &#39;public&#39; | &#39;private&#39; ) TypeDefinition  | ( &#39;public&#39; | &#39;private&#39; ) HandlerTypeDefinition  | ( &#39;public&#39; | &#39;private&#39; ) VariableDefinition  | ( &#39;public&#39; | &#39;private&#39; ) HandlerDefinition  | ( &#39;public&#39; | &#39;private&#39; ) ForeignHandlerDefinition  | PropertyDefinition  | EventDefinition</code></pre><p>Definitions are what are used to define usable entities in the language.All definitions are named using a unique identifier (so you cannot havetwo definitions with the same name).</p><p>Definitions can be either <em>public</em> or <em>private</em> (the default is private- so there is no need to explicitly specify that). Public definitionsare available when the module is used by another module whereas privatedefinitions can only be used within the module.</p><blockquote><p><strong>Note</strong>: Properties and events are, by their nature, always public asthey define things which only make sense to access from outside.</p><p><strong>Note</strong>: When writing a library module, all public handlers are addedto bottom of the message path in LiveCode Script.</p></blockquote><h3>Constants</h3><pre><code>ConstantDefinition  : &#39;constant&#39; &lt;Name: Identifier&gt; is &lt;Value: Expression&gt;</code></pre><p>A constant definition defines a named constant. The value can be anyexpression which depends on only on constant values to evaluate.</p><blockquote><p><strong>Note:</strong> Constants are not currently implemented, although the syntaxis recognised.</p></blockquote><h3>Types</h3><pre><code>TypeDefinition  : &#39;type&#39; &lt;Name: Identifier&gt; &#39;is&#39; &lt;TypeOf: Type&gt;</code></pre><p>A type definition defines an alias, it names the given type with thegiven Name, allowing the name to be used instead of the type.</p><pre><code>Type  : &lt;Name: Identifier&gt;  | &#39;optional&#39; &lt;Target: Type&gt;  | &#39;any&#39;  | &#39;nothing&#39;  | &#39;Boolean&#39;  | &#39;Integer&#39;  | &#39;Real&#39;  | &#39;Number&#39;  | &#39;String&#39;  | &#39;Data&#39;  | &#39;Array&#39;  | &#39;List&#39;  | &#39;Pointer&#39;</code></pre><p>A type clause describes the kind of value which can be used in avariable or parameter.</p><p>If a type is an identifier, then this is taken to be a named typedefined in a type definition clause.</p><p>An optional type means the value can be either the specified type ornothing. Variables which are of optional type are automatically initialzed to nothing.</p><p>The remaining types are as follows:</p><ul><li><strong>any</strong>: any value</li><li><strong>Boolean</strong>: a boolean value, either the value <em>true</em> or <em>false</em>.</li><li><strong>Integer</strong>: any integer number value</li><li><strong>Real</strong>: any real number value</li><li><strong>Number</strong>: any number value</li><li><strong>String</strong>: a sequence of UTF-16 code units</li><li><strong>Data</strong>: a sequence of bytes</li><li><strong>Array</strong>: a map from string to any value (i.e. an associative array, just like in LiveCode Script)</li><li><strong>List</strong>: a sequence of any value</li><li><strong>nothing</strong>: a single value <em>nothing</em> (this is used to describe handlers with no return value - i.e. void)</li><li><strong>Pointer</strong>: a low-level pointer (this is used with foreign code interconnect and shouldn&#39;t be generally used).</li></ul><blockquote><p><strong>Note:</strong> <em>Integer</em> and <em>Real</em> are currently the same as <em>Number</em>.</p><p><strong>Note:</strong> In a subsequent update you will be able to specify lists andarrays of fixed types. For example, <em>List of String</em>.</p><p><strong>Note:</strong> In a subsequent update you will be able to define recordtypes (named collections of values - like structs in C) and handlertypes (allowing dynamic handler calls through a variable - likefunction pointers in C).</p></blockquote><h3>Handler Types</h3><pre><code>HandlerTypeDefinition  : [ &#39;foreign&#39; ] &#39;handler&#39; &#39;type&#39; &lt;Name: Identifier&gt; &#39;(&#39; [ ParameterList ] &#39;)&#39; [ &#39;returns&#39; &lt;ReturnType: Type&gt; ]</code></pre><p>A handler type definition defines a type which can hold a handler.Variables of such types can hold handlers (just like function pointersin C) which allows them to be called dynamically.</p><p>If the handler type is defined as foreign then automatic bridging to a Cfunction pointer will occur when the type appears as the type of aparameter in a foreign handler definition.</p><blockquote><p><strong>Note:</strong> Passing an LCB handler to a foreign function requirescreation of a function pointer. The lifetime of the function pointeris the same as the widget or module which created it.</p></blockquote><h3>Record Types</h3><pre><code>RecordTypeDefinition  : &#39;record&#39; &#39;type&#39; &lt;Name: Identifier&gt; SEPARATOR    { RecordTypeFieldDefinition }    &#39;end&#39; &#39;record&#39;RecordTypeFieldDefinition  : &lt;Name: Identifier&gt; [ &#39;as&#39; &lt;TypeOf: Type&gt; ]</code></pre><p>A record type definition defines a type that consists of 0 or morenamed fields, each with its own optional type.</p><h3>Variables</h3><pre><code>VariableDefinition  : &#39;variable&#39; &lt;Name: Identifier&gt; [ &#39;as&#39; &lt;TypeOf: Type&gt; ]</code></pre><p>A variable definition defines a module-scope variable. In a widgetmodule, such variables are per-widget (i.e. instance variables). In alibrary module, there is only a single instance (i.e. a private globalvariable).</p><p>The type specification for the variable is optional, if it is notspecified the type of the variable is <em>optional any</em> meaning that it canhold any value, including being nothing.</p><p>Variables whose type has a default value are initialized to that value at thepoint of definition. The default values for the standard types are:</p><ul><li><strong>optional</strong>: nothing</li><li><strong>Boolean</strong>: false</li><li><strong>Integer</strong>: 0</li><li><strong>Real</strong>: 0.0</li><li><strong>Number</strong>: 0</li><li><strong>String</strong>: the empty string</li><li><strong>Data</strong>: the empty data</li><li><strong>Array</strong>: the empty array</li><li><strong>List</strong>: the empty list</li><li><strong>nothing</strong>: nothing</li></ul><p>Variables whose type do not have a default value will remain unassigned and itis a checked runtime error to fetch from such variables until they are assigneda value.</p><h3>Handlers</h3><pre><code>HandlerDefinition  : [ &#39;unsafe&#39; ] &#39;handler&#39; &lt;Name: Identifier&gt; &#39;(&#39; [ ParameterList ] &#39;)&#39; [ &#39;returns&#39; &lt;ReturnType: Type&gt; ] SEPARATOR      { Statement }    &#39;end&#39; &#39;handler&#39;</code></pre><p>Handler definitions are used to define functions which can be calledfrom LiveCode Builder code, invoked as a result of events triggering ina widget module, or called from LiveCode Script if public and inside alibrary module.</p><p>There is no distinction between handlers which return a value and oneswhich do not, apart from the return type. Handlers can be called eitherin expression context, or in statement context. If a handler whichreturns no value (it is specified as <em>returns nothing</em>) is called inexpression context then its value is <em>nothing</em>.</p><pre><code>ParameterList  : { Parameter , &#39;,&#39; }Parameter  : ( &#39;in&#39; | &#39;out&#39; | &#39;inout&#39; ) &lt;Name: Identifier&gt; [ &#39;as&#39; &lt;ParamType: Type&gt;</code></pre><p>The parameter list describes the parameters which can be passed to thehandler. Handlers must be called with the correct number of parameters,using expressions which are appropriate to the mode.</p><p>An in parameter means that the value from the caller is copied to theparameter variable in the callee handler.</p><p>An out parameter means that no value is copied from the caller, and thevalue on exit of the callee handler is copied back to the caller onreturn.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to return from a handlerwithout ensuring all non-optional &#39;out&#39; parameters have been assigneda value. However, this will only occur for typed variables whose type doesnot have a default value as those which do will be default initialized at thestart of the handler.</p></blockquote><p>An inout parameter means that the value from the caller is copied to theparameter variable in the callee handler on entry, and copied back outagain on exit.</p><p>The type of parameter is optional, if no type is specified it is takento be <em>optional any</em> meaning it can be of any type.</p><blockquote><p><strong>Note:</strong> Only assignable expressions can be passed as arguments toinout or out parameters. It is a checked compile-time error to pass anon-assignable expression to such a parameter.</p></blockquote><p>If &#39;unsafe&#39; is specified for the handler, then the handler itself is consideredto be unsafe, and may only be called from other unsafe handlers or unsafestatement blocks.</p><h3>Foreign Handlers</h3><pre><code>ForeignHandlerDefinition  : &#39;foreign&#39; &#39;handler&#39; &lt;Name: Identifier&gt; &#39;(&#39; [ ParameterList ] &#39;)&#39; [ &#39;returns&#39; &lt;ReturnType: Type&gt; ) ] &#39;binds&#39; &#39;to&#39; &lt;Binding: String&gt;</code></pre><p>A foreign handler definition binds an identifier to a handler defined inforeign code.</p><p>The last parameter in a foreign handler declaration may be &#39;...&#39; to indicatethat the handler is variadic. This allows binding to C functions such assprintf.</p><p>Note: No bridging of types will occur when passing a parameter in the non-fixedsection of a variadic argument list. You must ensure the arguments you pass thereare of the appropriate foreign type (e.g. CInt, CDouble).</p><p>There are a number of types defined in the foreign, java and objc modules whichmap to the appropriate foreign type when used in foreign handler signatures.</p><p>There are the standard machine types (defined in the foreign module):</p><ul><li>Bool maps to an 8-bit boolean</li><li>Int8/SInt8 and UInt8 map to 8-bit integers</li><li>Int16/SInt16 and UInt16 map to 16-bit integers</li><li>Int32/SInt32 and UInt32 map to 32-bit integers</li><li>Int64/SInt64 and UInt64 map to 64-bit integers</li><li>IntSize/SIntSize and UIntSize map to the integer size needed to hold a memory size</li><li>IntPtr/SIntPtr and UIntPtr map to the integer size needed to hold a pointer</li><li>NaturalSInt and NaturalUInt map to 32-bit integers on 32-bit processors and64-bit integers on 64-bit processors</li><li>NaturalFloat maps to the 32-bit float type on 32-bit processors and the 64-bitfloat (double) type on 64-bit processors</li></ul><p>There are the standard C primitive types (defined in the foreign module)</p><ul><li>CBool maps to &#39;bool&#39;</li><li>CChar, CSChar and CUChar map to &#39;char&#39;, &#39;signed char&#39; and &#39;unsigned char&#39;</li><li>CShort/CSShort and CUShort map to &#39;signed short&#39; and &#39;unsigned short&#39;</li><li>CInt/CSInt and CUInt map to &#39;signed int&#39; and &#39;unsigned int&#39;</li><li>CLong/CSLong and CULong map to &#39;signed long&#39; and &#39;unsigned long&#39;</li><li>CLongLong/CSLongLong and CULongLong map to &#39;signed long long&#39; and &#39;unsigned long long&#39;</li><li>CFloat maps to &#39;float&#39;</li><li>CDouble maps to &#39;double&#39;</li></ul><p>There are types specific to Obj-C types (defined in the objc module):</p><ul><li>ObjcObject wraps an obj-c &#39;id&#39;, i.e. a pointer to an objective-c object</li><li>ObjcId maps to &#39;id&#39;</li><li>ObjcRetainedId maps to &#39;id&#39;, and should be used where a foreign handlerargument expects a +1 reference count, or where a foreign handler returnsan id with a +1 reference count.</li></ul><p>Note: When an ObjcId is converted to ObjcObject, the id is retained;when an ObjcObject converted to an ObjcId, the id is not retained. Conversely,when an ObjcRetainedId is converted to an ObjcObject, the object takes the+1 reference count (so does not retain); when an ObjcObject is put into anObjcRetainedId, a +1 reference count is taken (so does retain).</p><p>There are aliases for the Java primitive types (defined in the java module)</p><ul><li>JBoolean maps to Bool</li><li>JByte maps to Int8</li><li>JShort maps to Int16</li><li>JInt maps to Int32</li><li>JLong maps to Int64</li><li>JFloat maps to Float32</li><li>JDouble maps to Float64</li></ul><p>All the primitive types above will implicitly bridge between correspondinghigh level types:</p><ul><li>CBool and Bool bridge to and from Boolean</li><li>All integer and real types bridge to and from Number</li></ul><p>Other LCB types pass as follows into foreign handlers:</p><ul><li>any type passes an MCValueRef</li><li>nothing type passes as the null pointer</li><li>Boolean type passes an MCBooleanRef</li><li>Integer type passes an MCNumberRef</li><li>Real type passes an MCNumberRef</li><li>Number type passes an MCNumberRef</li><li>String type passes an MCStringRef</li><li>Data type passes an MCDataRef</li><li>Array type passes an MCArrayRef</li><li>List type passes an MCProperListRef</li></ul><p>Finally, the Pointer type passes as void * to foreign handlers. If you wanta pointer which can be null, then use optional Pointer - LCB will throw anerror if there is an attempt to map from the null pointer value to a slotwith a non-optional Pointer type.</p><p>Modes map as follows:</p><ul><li>in mode is just pass by value</li><li>out mode passes a pointer to a variable of one of the above types, the variable is uninitialized on entry</li><li>inout mode passes a pointer to a variable of one of the above types, the variable is initialized to a value on entry</li></ul><p>If the return type is of a Ref type, then it must be a copy.</p><p>If an out parameter is of a Ref type, then it must be a copy (on exit)</p><p>If an inout parameter is of a Ref type, then its existing value must bereleased, and replaced by a copy (on exit).</p><p>The binding string for foreign handlers is language-specific and currentlysupported forms are explained in the following sections.</p><p>Foreign handlers&#39; bound symbols are resolved on first use and an erroris thrown if the symbol cannot be found.</p><p>Foreign handlers are always considered unsafe, and thus may only be calledfrom unsafe context - i.e. from within an unsafe handler, or unsafe statementblock.</p><h4>The C binding string</h4><p>The C binding string has the following form:</p><pre><code>&quot;c:[library&gt;][class.]function[!calling][?thread]&quot;</code></pre><p>Here <em>library</em> specifies the name of the library to bind to (if nolibrary is specified a symbol from the engine executable is assumed).</p><p>Here <em>class</em> is currently unused.</p><p>Here <em>function</em> specifies the name of the function symbol to bind to (onWindows, the symbol must be unadorned, and so exported from the libraryby listing it in a DEF module).</p><p>Here <em>calling</em> specifies the calling convention which can be one of:</p><ul><li><code>default</code></li><li><code>stdcall</code></li><li><code>thiscall</code></li><li><code>fastcall</code></li><li><code>cdecl</code></li><li><code>pascal</code></li><li><code>register</code></li></ul><p>All but <code>default</code> are Win32-only, and on Win32 <code>default</code> maps to<code>cdecl</code>. If a Win32-only calling convention is specified on anon-Windows platform then it is taken to be <code>default</code>.</p><p>Here <em>thread</em> is either empty or <code>ui</code>. The <code>ui</code> form is used to determinewhether the method should be run on the UI thread (currently only applicableon Android and iOS).</p><h4>The Obj-C binding string</h4><p>The Obj-C binding string has the following form:</p><pre><code>&quot;objc:class.(+|-)method[?thread]&quot;</code></pre><p>Here <em>class</em> specifies the name of the class containing the method to bind to.</p><p>Here <em>method</em> specifies the method name to bind to in standard Obj-C selectorform, e.g. addTarget:action:forControlEvents:. If the method is a class methodthen prefix it with &#39;+&#39;, if it is an instance method then prefix it with &#39;-&#39;.</p><p>Here <em>thread</em> is either empty or <code>ui</code>. The <code>ui</code> form is used to determinewhether the method should be run on the UI thread (currently only applicableon Android and iOS).</p><h4>The Java binding string</h4><p>The Java binding string has the following form:</p><pre><code>&quot;java:[className&gt;][functionType.]function[!calling][?thread]&quot;</code></pre><p>Here <em>className</em> is the qualified name of the Java class to bind to.</p><p>Here <em>functionType</em> is either empty, or <code>get</code> or <code>set</code>, which are currently used for getting and setting member fields of a Java class.</p><p>For example</p><pre><code>&quot;java:java.util.Calendar&gt;set.time(J)&quot;&quot;java:java.util.Calendar&gt;get.time()J&quot;</code></pre><p>are binding strings for setting and getting the <code>time</code> field of a Calendar object.</p><p>Here <em>function</em> specifies the name of the method or field to bind to. Thefunction <code>new</code> may be used to call a class constructor. <em>function</em> alsoincludes the specification of function signature, according to the <a href="http://journals.ecs.soton.ac.uk/java/tutorial/native1.1/implementing/method.html">standard rules for forming these</a> when calling the JNI.</p><p>The function <code>interface</code> may be used on Android to create an interface proxy - that is an instance of a generic Proxy class for a given interface. This effectively allows LCB handlers to be registered as the targets for java interface callbacks, such as event listeners.</p><p>The foreign handler binding to such a function takes a value that should either be a <code>Handler</code> or an <code>Array</code> - if it is a <code>Handler</code>, the specified listener should only have one available callback. If the listener has multiple callbacks, an array can be used to assign handlers to each. Each key in the array must match the name of a callback in the listener. The specified handlers must match the callback&#39;s parameters and return type, using JObject where primitive type parameters are used.</p><p>Overloaded methods in the interface are not currently supported.</p><p>For example:</p><pre><code>handler type ClickCallback(in pView as JObject) returns nothingforeign handler _JNI_OnClickListener(in pHandler as ClickCallback) returns JObject binds to &quot;java:android.view.View$OnClickListener&gt;interface()&quot;foreign handler _JNI_SetOnClickListener(in pButton as JObject, in pListener as JObject) returns nothing binds to &quot;java:android.view.View&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V&quot;  public handler ButtonClicked(in pView as JObject) returns nothing    post &quot;buttonClicked&quot;    MCEngineRunloopBreakWait()end handlerpublic handler SetOnClickListenerCallback(in pButton as JObject)    unsafe        variable tListener as JObject        put _JNI_OnClickListener(ButtonClicked) into tListener        _JNI_SetOnClickListener(pButton, tListener)    end unsafeend handler</code></pre><p>or</p><pre><code>handler type MouseEventCallback(in pMouseEvent as JObject) returns nothingforeign handler _JNI_MouseListener(in pCallbacks as Array) returns JObject binds to &quot;java:java.awt.event.MouseListener&gt;interface()&quot;foreign handler _JNI_SetMouseListener(in pJButton as JObject, in pListener as JObject) returns nothing binds to &quot;java:java.awt.Component&gt;addMouseListener(Ljava/awt/event/MouseListener;)V&quot; public handler MouseEntered(in pEvent as JObject) returns nothing    post &quot;mouseEnter&quot;    MCEngineRunloopBreakWait()end handlerpublic handler MouseExited(in pEvent as JObject)    -- do something on mouse entterend handlerpublic handler SetMouseListenerCallbacks(in pJButton as JObject)    variable tArray as Array    put MouseEntered into tArray[&quot;mouseEntered&quot;]    put MouseExited into tArray[&quot;mouseExited&quot;]    unsafe        variable tListener as JObject        put _JNI_MouseListener(tArray) into tListener        _JNI_SetMouseListener(pJButton, tListener)    end unsafeend handler</code></pre><blockquote><p><em>Important:</em> On Android, interface callbacks are <em>always</em> run on theengine thread. This means JNI local references from other threads(in particular the UI thread) are unavailable. Therefore it is not advised to do anything using the JNI in interface callbacks. </p></blockquote><p>Here <em>calling</em> specifies the calling convention which can be one of:</p><ul><li><code>instance</code></li><li><code>static</code></li><li><code>nonvirtual</code></li></ul><p>Instance and nonvirtual calling conventions require instances of the givenJava class, so the foreign handler declaration will always require a Javaobject parameter.</p><p>Here, <em>thread</em> is either empty or <code>ui</code>. The <code>ui</code> form is used to determinewhether the method should be run on the UI thread (currently only applicableon Android and iOS).</p><blockquote><p><strong>Warning:</strong> At the moment it is not advised to use callbacks that may beexecuted on arbitrary threads, as this is likely to cause your applicationto crash.</p></blockquote><h3>Properties</h3><pre><code>PropertyDefinition  : &#39;property&#39; &lt;Name: Identifier&gt; &#39;get&#39; &lt;Getter: Identifier&gt; [ &#39;set&#39; &lt;Setter: Identifier&gt; ]</code></pre><p>Property definitions can only appear in widget modules. They define aproperty which can be accessed from LiveCode Script in the usual way(e.g. <em>the myProperty of widget 1</em>).</p><p>Both getter and setter clauses can use either a variable or handleridentifier. If a variable identifier is used, then the property value isfetched (and stored) from that variable. If a handler identifier is usedthen a handler is called instead.</p><p>A getter handler must take no arguments and return a value. A setterhandler must take a single argument and return no value.</p><p>The set clause is optional. If it is not present then the property isread-only.</p><h3>Events</h3><pre><code>EventDefinition  : &#39;event&#39; &lt;Name: Identifier&gt; &#39;(&#39; [ ParameterList ] &#39;)&#39; [ &#39;as&#39; &lt;ReturnType: Type&gt; ]</code></pre><p>Event definitions define a callable handler which calls back to theenvironment.</p><blockquote><p><strong>Note</strong>: Whilst events can be defined they currently cannot be used.To send a message to the LiveCode Script environment use the<em>dispatch</em> command which allows sending messages to arbitrary LiveCodeScript objects.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Statements" class="dashAnchor"></a>Statements</h2><pre><code>Statement  : VariableStatement  | IfStatement  | RepeatStatement  | ThrowStatement  | ReturnStatement  | PutStatement  | SetStatement  | GetStatement  | CallStatement  | BytecodeStatement  | UnsafeStatement</code></pre><p>There are a number of built-in statements which define control flow,variables, and basic variable transfer. The remaining syntax forstatement is defined in auxiliary modules.</p><h3>Variable Statements</h3><pre><code>VariableStatement  : &#39;variable&#39; &lt;Name: Identifier&gt; [ &#39;as&#39; &lt;TypeOf: Type&gt; ]</code></pre><p>A variable statement defines a handler-scope variable. Such variablescan be used after the variable statement and up to the end of the current statementblock, but not before.</p><p>Variables whose type have a default value are initialized with that value atthe point of definition in the handler. See the main Variables section for thedefaults of the standard types.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to attempt to use a variable whosetype has no default before it is assigned a value.</p></blockquote><p>The type specification for the variable is optional, if it is notspecified the type of the variable is <em>optional any</em> meaning that it canhold any value, including being nothing.</p><h3>If Statements</h3><pre><code>IfStatement  : &#39;if&#39; &lt;Condition: Expression&gt; &#39;then&#39; SEPARATOR      { Statement }    [ { &#39;else&#39; &#39;if&#39; &lt;Condition: Expression&gt; &#39;then&#39; SEPARATOR        { Statement } ]    [ &#39;else&#39; SEPARATOR        { Statement } ]    &#39;end&#39; &#39;if&#39;</code></pre><p>The if statement enables conditional execution based on the result of anexpression which evaluates to a boolean.</p><p>Each block of code in an if/else if/else statement defines a unique scope forhandler-local variable definitions.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to use an expression whichdoes not evaluate to a boolean in any condition expression.</p></blockquote><h3>Repeat Statements</h3><pre><code>RepeatStatement  : RepeatHeader SEPARATOR      { Statement }    &#39;end&#39; &#39;repeat&#39;  | &#39;next&#39; &#39;repeat&#39;  | &#39;exit&#39; &#39;repeat&#39;RepeatHeader  : &#39;repeat&#39; &#39;forever&#39;  | &#39;repeat&#39; &lt;Count: Expression&gt; &#39;times&#39;  | &#39;repeat&#39; &#39;while&#39; &lt;Condition: Expression&gt;  | &#39;repeat&#39; &#39;until&#39; &lt;Condition: Expression&gt;  | &#39;repeat&#39; &#39;with&#39; &lt;Counter: Identifier&gt; &#39;from&#39; &lt;Start: Expression&gt; ( &#39;up&#39; | &#39;down&#39; ) &#39;to&#39; &lt;Finish: Expression&gt; [ &#39;by&#39; &lt;Step: Expression&gt; ]  | &#39;repeat&#39; &#39;for&#39; &#39;each&#39; &lt;Iterator&gt; &#39;in&#39; &lt;Container: Expression&gt;</code></pre><p>The repeat statements allow iterative execute of a sequence ofstatements.</p><p>The block of code present in a repeat statement defines a unique scope forhandler-local variable definitions.</p><p>The <strong>repeat forever</strong> form repeats the body continually. To exit theloop, either an error must be thrown, or <strong>exit repeat</strong> must beexecuted.</p><p>The <strong>repeat times</strong> form repeats the body Count number times. If Countevaluates to a negative integer, it is taken to be zero.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to use an expression notevaluating to a number as the Count.</p></blockquote><p>The <strong>repeat while</strong> form repeats the body until the Conditionexpression evaluates to false.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to use an expression notevaluating to a boolean as the Condition.</p></blockquote><p>The <strong>repeat until</strong> form repeats the body until the Conditionexpression evaluates to true.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to use an expression notevaluating to a boolean as the Condition.</p></blockquote><p>The <strong>repeat with</strong> form repeats the body until the Counter variablereaches or crosses (depending on iteration direction) the value of theFinish expression. The counter variable is adjusted by the value of theStep expression on each iteration. The start, finish and stepexpressions are evaluated before the loop starts and are notre-evaluated. The Counter variable must be declared before the repeatstatement.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error to use expressions notevaluating to a number as Start, Finish or Step.</p></blockquote><p>The <strong>repeat for each</strong> form evaluates the Container expression, andthen iterates through it in a custom manner depending on the Iteratorsyntax. For example:</p><pre><code>repeat for each char tChar in &quot;abcdef&quot;  -- do something with tCharend repeat</code></pre><p>The <strong>next repeat</strong> statement terminates the current iteration of theenclosing loop and starts the next iteration of the loop, or exits ifcurrently on the last iteration.</p><p>The <strong>exit repeat</strong> statement terminates the current iteration of theenclosing loop, continuing execution at the statement after theenclosing loop&#39;s <strong>end repeat</strong>.</p><h3>Throw Statements</h3><pre><code>ThrowStatement  : &#39;throw&#39; &lt;Error: Expression&gt;</code></pre><p>The <strong>throw</strong> statement causes an error to be raised. This causesexecution to terminate, and the error is passed back to environment.</p><p>The Error expression must be an expression that evaluates to a string.</p><blockquote><p><strong>Note:</strong> There is currently no try / catch mechanism in LiveCodeBuilder, so throwing an error will cause the error to be raised inLiveCode Script in the appropriate context.</p></blockquote><h3>Return Statements</h3><pre><code>ReturnStatement  : &#39;return&#39; [ &lt;Value: Expression&gt; ]</code></pre><p>The <strong>return</strong> statement causes execution of the current handler to end,and control return to the caller.</p><p>If a Value expression is specified, it is evaluated and returned as theresult of the handler call.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error for a value returned from ahandler to not match the return type of the handler it is in.</p></blockquote><h3>Transfer Statements</h3><pre><code>PutStatement  : &#39;put&#39; &lt;Value: Expression&gt; into &lt;Target: Expression&gt;SetStatement  : &#39;set&#39; &lt;Target: Expression&gt; &#39;to&#39; &lt;Value: Expression&gt;</code></pre><p>The <strong>put</strong> and <strong>set</strong> statements evaluate the Value expression andassign the resulting value to the Target expression.</p><p>The target expression must be assignable.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error for the source value&#39;s type tonot be compatible with the target expression&#39;s type.</p></blockquote><pre><code>GetStatement  : &#39;get&#39; &lt;Value: Expression&gt;</code></pre><p>The <strong>get</strong> statement evaluates the Value expression and returns it asthe result of the statement. The value is subsequently available byusing <strong>the result</strong> expression.</p><h3>Call Statements</h3><pre><code>CallStatement  : &lt;Handler: Identifier&gt; &#39;(&#39; [ &lt;Arguments: ExpressionList&gt; ] &#39;)&#39;</code></pre><p>The call statement executes a handler with the given arguments.</p><p>The Handler identifier must be bound to either a handler or foreignhandler definition.</p><p>The Arguments are evaluated from left to right and passed as parametersto the variable.</p><blockquote><p><strong>Note:</strong> It is a checked runtime error for the types of &#39;in&#39; and&#39;inout&#39; arguments to not match the declared types of the handler&#39;sparameters.</p></blockquote><p>Any parameters of &#39;out&#39; type are not evaluated on entry, but assigned toon exit.</p><p>Any parameters of &#39;inout&#39; type are evaluated on entry, and assigned onexit.</p><blockquote><p><strong>Note:</strong> It is a checked compile-time error to pass non-assignableexpressions to parameters which are of either &#39;out&#39; or &#39;inout&#39; type.</p></blockquote><p>The return value of a handler is subsequently available by using <strong>theresult</strong> expression.</p><blockquote><p><strong>Note:</strong> All handlers return a value, even if it is nothing. Thismeans that calling a handler will always change <strong>the result</strong>.</p></blockquote><h3>Bytecode Statements</h3><pre><code>BytecodeStatement  : &#39;bytecode&#39; SEPARATOR        { BytecodeOperation }    &#39;end&#39;BytecodeOperation  : &lt;Label: Identifier&gt; &#39;:&#39;  | &#39;register&#39; &lt;Name: Identifier&gt; [ &#39;as&#39; &lt;Type: Type&gt; ]  | &lt;Opcode: Identifier&gt; { BytecodeArgument , &#39;,&#39; }BytecodeArgument  : ConstantValueExpression  | Identifier</code></pre><p>The bytecode statement allows bytecode to be written directly for the LiveCodeBuilder Virtual Machine.</p><p>Bytecode operation arguments can either be a constant expression, the name of adefinition in current scope, the name of a register, or the name of a label inthe current bytecode block. The exact opcodes and allowed arguments are definedin the LiveCode Builder Bytecode Reference.</p><p>Labels are local to the current bytecode block, and can be used as the targetof one of the jump instructions.</p><p>Register definitions define a named register which is local to the currentbytecode block. Registers are the same as handler-local variables exceptthat they do not undergo default initialization.</p><p>Bytecode statements are considered to be unsafe and can only appear insideunsafe handlers or unsafe statement blocks.</p><blockquote><p><strong>Note:</strong> Bytecode blocks are not intended for general use and the actualavailable operations are subject to change.</p></blockquote><h3>Unsafe Statements</h3><pre><code>UnsafeStatement  : &#39;unsafe&#39; SEPARATOR        { Statement }    &#39;end&#39; &#39;unsafe&#39;</code></pre><p>The unsafe statement allows a block of unsafe code to be written in a safecontext.</p><p>In particular, calls to unsafe handlers (including all foreign handlers) andbytecode blocks are allowed in unsafe statement blocks but nowhere else.</p><h2><a name="//apple_ref/cpp/Guide/Expressions" class="dashAnchor"></a>Expressions</h2><pre><code>Expression  : ConstantValueExpression  | VariableExpression  | ResultExpression  | ListExpression  | ArrayExpression  | CallExpression</code></pre><p>There are a number of expressions which are built-in and allow constantvalues, access to call results, list construction and calls. Theremaining syntax for expressions is defined in auxiliary modules.</p><h3>Constant Value Expressions</h3><pre><code>  ConstantValueExpression    : &#39;nothing&#39;    | &#39;true&#39;    | &#39;false&#39;    | INTEGER    | REAL    | STRING</code></pre><p>Constant value expressions evaluate to the specified constant value.</p><p>The <strong>nothing</strong> expression evaluates to the nothing value and can beassigned to any optional typed variable.</p><p>The <strong>true</strong> and <strong>false</strong> expressions evaluate to boolean values.</p><p>The INTEGER and REAL expressions evaluate to numeric values.</p><p>The STRING expression evaluates to a string value.</p><p>Constant value expressions are not assignable.</p><h3>Variable Expressions</h3><pre><code>VariableExpression  : &lt;Name: Identifier&gt;</code></pre><p>Variable expressions evaluate to the value of the specified variable.</p><p>Variable expressions are assignable.</p><h3>Result Expressions</h3><pre><code>ResultExpression  : &#39;the&#39; &#39;result&#39;</code></pre><p>The result expression evaluates to the return value of the previous(executed) non-control structure statement.</p><p>Result expressions are not assignable.</p><h3>List Expressions</h3><pre><code>ListExpression  : &#39;[&#39; [ &lt;Elements: ExpressionList&gt; ] &#39;]&#39;</code></pre><p>A list expression evaluates all the elements in the expression list fromleft to right and constructs a list value with them as elements.</p><p>The elements list is optional, so the empty list can be specified as<em>[]</em>.</p><p>List expressions are not assignable.</p><h3>Array Expressions</h3><pre><code>ArrayExpression  : &#39;{&#39; [ &lt;Contents: ArrayDatumList&gt; ] &#39;}&#39;ArrayDatumList  : &lt;Head: ArrayDatum&gt; [ &#39;,&#39; &lt;Tail: ArrayDatumList&gt; ]ArrayDatum  : &lt;Key: Expression&gt; &#39;:&#39; &lt;Value: Expression&gt;</code></pre><p>An array expression evaluates all of the key and value expressionsfrom left to right, and constructs an <strong>Array</strong> value as appropriate.Each key expression must evaluate to a <strong>String</strong>.</p><p>The contents are optional, so the empty array can be written as <code>{}</code>.</p><p>Array expressions are not assignable.</p><h3>Call Expressions</h3><pre><code>CallExpression  : &lt;Handler: Identifier&gt; &#39;(&#39; [ &lt;Arguments: ExpressionList&gt; ] &#39;)&#39;</code></pre><p>A call expression executes a handler.</p><p>Its use is identical to a call statement, except that the return valueof the handler is the value of the expression, rather than beingavailable as <strong>the result</strong>.</p><blockquote><p><strong>Note:</strong> Handlers which return no value (i.e. have nothing as theirresult type) can still be used in call expressions. In this case thevalue of the call is <strong>nothing</strong>.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Namespaces" class="dashAnchor"></a>Namespaces</h2><p>Identifiers declared in a module are placed in a scope named using themodule name. This allows disambiguation between an identifier declaredin a module and an identical one declared in any of its imports, byusing a fully qualified name.</p><p>For example:</p><pre><code>module com.livecode.module.importeepublic constant MyName is &quot;Importee&quot;public handler GetMyName() returns String    return MyNameend handlerpublic type MyType is Numberend modulemodule com.livecode.module.usesimportuse com.livecode.module.importeepublic constant MyName is &quot;Uses Import&quot;public handler GetMyName() returns String    return MyNameend handlerpublic type MyType is Stringhandler TestImports()    variable tVar as String    put MyName into tVar    -- tVar contains &quot;Uses Import&quot;    put com.livecode.module.importee.MyName into tVar    -- tVar contains &quot;Importee&quot;    put com.livecode.module.usesimport.MyName into tVar    -- tVar contains &quot;Uses Import&quot;    put com.livecode.module.importee.GetMyName() into tVar    -- tVar contains &quot;Importee&quot;    variable tVarMyType as MyType    put tVar into tVar1 -- valid    variable tVarImportedType as com.livecode.module.importee.MyType    put tVar into tVarImportedType -- compile errorend handlerend module</code></pre><h2><a name="//apple_ref/cpp/Guide/Experimental Features" class="dashAnchor"></a>Experimental Features</h2><p><strong>Warning</strong>: This section describes current language features and syntaxthat are considered experimental and unstable.  They are likely to changeor go away without warning.</p><h3>Safe Foreign Handlers</h3><pre><code>SafeForeignHandler  : &#39;__safe&#39; &#39;foreign&#39; &#39;handler&#39; &lt;Name: Identifier&gt; &#39;(&#39; [ ParameterList ] &#39;)&#39; [ &#39;returns&#39; &lt;ReturnType: Type&gt; ) ] &#39;binds&#39; &#39;to&#39; &lt;Binding: String&gt;</code></pre><p>By default foreign handlers are considered unsafe and thus can only be used inunsafe blocks, or unsafe handlers. However, at the moment it is possible for aforeign handler to actually be safe if it has been explicitly written to wrapa foreign function so it can be easily used from LCB.</p><p>Specifically, it is reasonable to consider a foreign handler safe if itconforms to the following rules:</p><ul><li>Parameter types and return type are either ValueRefs, or bridgeable types</li><li>Return values of ValueRef type are retained</li><li>If the function fails then MCErrorThrow has been used</li><li>&#39;out&#39; mode parameters are only changed if the function succeeds</li><li>A return value is only provided if the function succeeds</li></ul><p>Examples of foreign handlers which can be considered safe are all the foreignhandlers which bind to syntax in the LCB standard library.</p><h3>Foreign Aggregate Types</h3><p>C-style aggregates (e.g. structs) can now be accessed from LCB via the newaggregate parameterized type. This allows calling foreign functions which hasarguments taking aggregates by value, or has an aggregate return value.</p><p>Aggregate types are foreign types and can be used in C and Obj-C foreignhandler definitions. They bridge to and from the List type, allowing anaggregate&#39;s contents to be viewed as a sequence of discrete values.</p><p>Aggregate types are defined using a <code>foreign type</code> clause and binding string.e.g.</p><pre><code>public foreign type NSRect binds to &quot;MCAggregateTypeInfo:qqqq&quot;</code></pre><p>The structure of the aggregate is defined by using a sequence of type codesafter the &#39;:&#39;, each type code represents a specific foreign (C) type:</p><table><thead><tr><th>Char</th><th>Type</th></tr></thead><tbody><tr><td>a</td><td>CBool</td></tr><tr><td>b</td><td>CChar</td></tr><tr><td>c</td><td>CUChar</td></tr><tr><td>C</td><td>CSChar</td></tr><tr><td>d</td><td>CUShort</td></tr><tr><td>D</td><td>CSShort</td></tr><tr><td>e</td><td>CUInt</td></tr><tr><td>E</td><td>CSInt</td></tr><tr><td>f</td><td>CULong</td></tr><tr><td>F</td><td>CSLong</td></tr><tr><td>g</td><td>CULongLong</td></tr><tr><td>G</td><td>CSLongLong</td></tr><tr><td>h</td><td>UInt8</td></tr><tr><td>H</td><td>SInt8</td></tr><tr><td>i</td><td>UInt16</td></tr><tr><td>I</td><td>SInt16</td></tr><tr><td>j</td><td>UInt32</td></tr><tr><td>J</td><td>SInt32</td></tr><tr><td>k</td><td>UInt64</td></tr><tr><td>K</td><td>SInt64</td></tr><tr><td>l</td><td>UIntPtr</td></tr><tr><td>L</td><td>SIntPtr</td></tr><tr><td>m</td><td>UIntSize</td></tr><tr><td>M</td><td>SIntSize</td></tr><tr><td>n</td><td>Float</td></tr><tr><td>N</td><td>Double</td></tr><tr><td>o</td><td>LCUInt</td></tr><tr><td>O</td><td>LCSInt</td></tr><tr><td>p</td><td>NaturalUInt</td></tr><tr><td>P</td><td>NaturalSInt</td></tr><tr><td>q</td><td>NaturalFloat</td></tr><tr><td>r</td><td>Pointer</td></tr></tbody></table><p>When importing an aggregate to a List, each field in the aggregate is alsobridged, except for Pointer types which are left as Pointer. When exportingan aggregate from a List, each element is bridged to the target field type.</p><p><em>Note</em>: Any foreign type binding to an aggregate must be public otherwise thetype will not work correctly.</p></body></html>