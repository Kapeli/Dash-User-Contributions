<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>LiveCode Documentation Format Reference</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: reference</h2><h1>LiveCode Documentation Format Reference</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>LiveCode uses a custom documentation format for the dictionary and for extension APIs. The format has very few special characters and is intended to maximise readability and modifiability. </p><h2><a name="//apple_ref/cpp/Guide/Format" class="dashAnchor"></a>Format</h2><p>Documentation for a LiveCode API or documentation entry consists of a series of elements and their values, in the following form:</p><p><em>elementName</em> : <em>content</em></p><p>There are several standard types of <em>content</em>; which one may be used depends on the <em>elementName</em>.</p><h3>Element names</h3><p>Elements are optional unless otherwise specified.</p><h4>Name (required)</h4><p>The name of the API entry. The name must be a single word.</p><blockquote><p><em>Note:</em> For inline docs, the name element is automatically generated</p></blockquote><h4>Synonyms</h4><p>A comma-delimited list of synonyms for this API entry.</p><h4>Type (required)</h4><p>The type of this API entry. One of the following:(API-level)    * command    * function    * property    * message    * constant    * keyword    * control structure    * operator    * statement    * expression</p><p>(Glossary-level)    * library    * widget    * glossary    * object</p><p>The glossary-level entries have part of their content generated from the API-level entries.</p><blockquote><p><em>Note:</em> For inline docs, the type element is automatically generated</p></blockquote><h4>Syntax (required for API-level entries)</h4><p>A description of how to use or call this facet of the API. May just be the name itself, for keywords etc.An entry may have a number of Syntax elements, if there are variations within the same entry.</p><p>The following can be used to specify livecode syntax:- [optional]- [repeated optional ...]- { variant 1 | variant 2 }- <parameterName></p><p>For example, the syntax for the first variant of the <code>split</code> command:</p><pre><code>split &lt;variable&gt; {by | using | with} &lt;primaryDelimiter&gt; [and &lt;secondaryDelimiter&gt;]</code></pre><p>describes the following possible usages:- <code>split tVar by comma</code>- <code>split tVar using return</code>- <code>split tVar with &quot;a&quot;</code>- <code>split tVar by comma and return</code>- <code>split tVar using the rowdel and the columndel</code>- <code>split tVar with tDelim1 and tDelim2</code></p><p>The syntax for <code>answer file with type</code>:</p><pre><code>answer file[s] &lt;prompt&gt; [with &lt;defaultPath&gt;] [with type &lt;types&gt; [or type &lt;types&gt; ...]] [titled &lt;windowTitle&gt;] [as sheet]</code></pre><p>gives an example of the repetition notation, namely it allows something like</p><pre><code>answer files with type tType1 or type tType2 or type tType3 or type tType4</code></pre><blockquote><p><em>Note:</em> For inline docs, the Syntax elements are automatically generated</p></blockquote><h4>Summary (required)</h4><p>A summary of the API entry being documented. The summary should be a single line. Anything more in-depth should be included in the description.</p><h4>Associated</h4><p>A comma-delimited list of names of other API or docs entries. Each one must be of type <strong>object</strong>, <strong>glossary</strong>, <strong>library</strong>, or <strong>widget</strong>. It is used to generate the docs for the entries to which it is associated.</p><p>In particular, every API entry in a library should have that library name in its Associated list.</p><h4>Introduced</h4><p>The LiveCode version in which the API entry was first available.</p><h4>OS</h4><p>A comma-delimited list specifying which operating systems the API entry is available for. One or more of the following:</p><ul><li>mac</li><li>windows</li><li>linux</li><li>iOS</li><li>android</li><li>RPi</li><li>html5</li></ul><h4>Platforms</h4><p>A comma-delimited list specifying which platforms the API entry is available for. One or more of the following:</p><ul><li>desktop</li><li>server</li><li>web</li><li>mobile</li></ul><h4>Example</h4><p>Example elements should show how API entries are used in context. Each example will be displayed in the documentation viewer as a multiline code block. Where possible, an example should be entirely self contained, so that it is runnable as a block of code without any additions.</p><p>An API entry can have any number of Example elements. </p><h4>Parameters</h4><p>The parameters element itself does not do anything, but can be helpful for readability as a precursor to the parameter elements themselves.Parameter elements are specified in the following way:<em>paramName</em> (*paramType*) : <em>paramDescription</em></p><p>The param type is optional, although may be helpful to include, and is required for further formatting of parameter descriptions to take place. The three types that will instigate further formatting are:</p><ul><li>enum</li><li>set</li><li>array</li></ul><p>A parameter of <strong>enum</strong> type is one that expects one of a specified list of values. Similarly, a parameter of <strong>set</strong> type is one that expects a comma-delimited list of one or more of a specified list of values. After the param description of the <strong>enum</strong> or <strong>set</strong> type, these values should be listed in the following way<code>    - value1 : description of value1    - value2 : description of value2    - ...</code>etc.</p><p>After the description parameter of <strong>array</strong> type, the format of the array may optionally be specified in the following way:</p><pre><code>{     key1 (keyType) : description of key1    value1 (valueType) : description of value1    key2 (keyType) : description of key2    value2 (valueType) : description of value2    ...}</code></pre><p>The key type and value type are optional. If one of the values is a sub-array, and the <strong>array</strong> type is specified, then the array specification may be nested as follows:</p><pre><code>{     key1 (keyType) : description of key1    value1 (array) : description of value1    {        key2 (keyType) : description of key2        value2 (valueType) : description of value2        ...    }    ...}</code></pre><p>The indentation is not necessary, but is helpful for readability.</p><h4>Value and return parameters</h4><p>For simple return parameters, i.e. the direct return value of a function, use the Returns element.When a value is both an input and output value, for example the value of a property, use the Value element.The Returns and Value elements are mutually exclusive.</p><p>Some functions and commands in LiveCode change the value of &#39;the result&#39; and the &#39;it&#39; variable. In these cases there are also special return parameter elements It and The result.</p><p>All of these elements can have a type specified in brackets before the colon, as for parameter elements. The same comments about formatting apply to return parameters.</p><h4>Description (required)</h4><p>A full description of the API entry. The description may have markdown elements which will be rendered in the documentation viewer.</p><h4>References</h4><p>A comma-delimited list of other API or docs entries that are referenced. The references element is essential for linking around the documentation viewer.</p><p>The references list should be in the form:</p><blockquote><p><em>entryName</em> (*entryType*), <em>entryName</em> (*entryType*), <em>entryName</em> (*entryType*), ...</p></blockquote><h4>Tags</h4><p>A comma-delimited list of tags for this entry. The documentation viewer can filter entries by tag.</p><h3>Other documentation syntax</h3><p>The Description element is the only one that allows standard markdown. There is only (essentially) one other syntactic form allowed in API documentation, which is enclosing text in angle brackets &lt;&gt;. There are three purposes of the angle brackets syntax:</p><ul><li>Specifying occurrences of the name of the current API entry.</li><li>Specifying occurrences of the names of parameters.</li><li>Specifying links to other API entries or documentation.</li></ul><p>In the first two cases, applying the syntax merely consists in enclosing the relevant occurrences in angle brackets, eg to reference a parameter <em>pParam</em> in the entry named <em>thisEntry</em>,</p><blockquote><p>This is a sentence in which &lt;pParam&gt; ought to be marked as being a parameter in the API entry for &lt;thisEntry&gt;</p></blockquote><p>To specify a link to another API or docs entry, the latter <strong>must</strong> be included in the References element. If there is only one item in the References element with a matching name, then it suffices to enclose the referencing text in angle brackets.</p><blockquote><p>This will link correctly to the &lt;other&gt; function&#39;s API entry provided the References element contains only one item with the name &quot;other&quot;.</p></blockquote><p>If the referencing text is different from the name of the entry, such as if it is pluralised or possessive, include the referenced entry name as a label inside the angle brackets.</p><blockquote><p>This will also link correctly to &lt;other|other&#39;s&gt; API entry, but display as &quot;other&#39;s&quot; in the documentation viewer.</p></blockquote><p>If the target name is shared by two references, then the link should be disambiguated by including the type in brackets:</p><blockquote><p>We might want to link to the &lt;other(function)&gt; function and the &lt;other(command)&gt; command in the same entry, if the references contain &quot;other (function)&quot; and &quot;other (command)&quot;.</p></blockquote><p>It is possible to do both of the above at the same time:</p><blockquote><p>This sentence contains links to &lt;other(function)|other&#39;s&gt; and &lt;other(command)|other&#39;s&gt; dictionary entries.</p></blockquote><h3>Separate docs files</h3><p>To specify the documentation for a library in one separate file, it must have the following structure:</p><p>Library: <em>libraryName</em></p><p>Summary: <em>librarySummary</em></p><p>Description:<em>libraryDescription</em></p><p>Name: <em>entryName</em></p><p>Type: <em>entryType</em></p><p>Syntax: <em>entrySyntax</em></p><p>Summary: <em>entrySummary</em></p><p>...other elements associated with <em>entryName</em>...</p><p>Name: <em>anotherEntryName</em>etc.</p><h3>Inline documentation</h3><p>Documentation for LiveCode script and LiveCode extensions can be done in-line. In this case, the Name, Type, Syntax and Associated elements are auto-generated. </p><p>The code-block enclosed in /** */ immediately preceding the handler or syntax definition is used for the other elements of the documentation for that entry. In LiveCode extensions, the types of parameters are also pulled from the associated handler.</p><h3>Separate docs files examples</h3><h4>Dictionary example</h4><p>Here is the dictionary document for the <em>textEncode</em> function:</p><pre><code>Name: textEncodeType: functionSyntax: textEncode(&lt;stringToEncode&gt;, &lt;encoding&gt;)Summary: Converts from text to binary data.Introduced: 7.0OS: mac,windows,linux,ios,androidPlatforms: desktop,server,web,mobileExample:textEncode(&quot;A&quot;,&quot;UTF16&quot;)Example:put textEncode(field &quot;output&quot;,&quot;UTF-8&quot;) into tOutputput tOutput into url (&quot;file:output.txt&quot;)Parameters:stringToEncode (string): Any string, or expression that evaluates to a string.encoding (enum): the encoding to be used- &quot;ASCII&quot;- &quot;ISO-8859-1&quot;: Linux only- &quot;MacRoman&quot;: OS X only- &quot;Native&quot;: ISO-8859-1 on Minux, MacRoman on OS X, CP1252 on Windows- &quot;UTF-16&quot;- &quot;UTF-16BE&quot;- &quot;UTF-16LE&quot;- &quot;UTF-32&quot;- &quot;UTF-32BE&quot;- &quot;UTF-32LE&quot;- &quot;UTF-8&quot;- &quot;CP1252&quot;Returns: Returns the &lt;stringToEncode&gt; as binary data.Description:Converts from text to binary data.The &lt;textEncode&gt; function takes text, and returns it as binary data, encoded with the specified encoding.It is highly recommended that any time you interface with things outside LiveCode (files, network sockets, processes, etc) that you explicitly textEncode any text you send outside LiveCode and &lt;textDecode&gt; all text received into LiveCode. If this doesn&#39;t happen, a platform-dependent encoding will be used (which normally does not support Unicode text).It is not, in general, possible to reliably auto-detect text encodings so please check the documentation for the programme you are communicating with to find out what it expects. If in doubt, try UTF-8.References: textDecode (function)</code></pre><h4>Library example</h4><pre><code>Module: com.livecode.sortType: libraryDescription: This library consists of the sorting operations provided by the standard library of LiveCode BuilderName: SortListDescendingTextType: statementSyntax: sort &lt;Target&gt; in descending [text] orderSummary: Sorts &lt;Target&gt; in descending text order.Parameters:Target (inout list): An expression that evaluates to a list of strings. Example:         variable tTestList as List    put the empty list into tTestList    push &quot;abcd&quot; onto tTestList    push 1 onto tTestList    push &quot;xyz&quot; onto tTestList    push 2 onto tTestList    sort tTestList in descending order -- tTestList is [&quot;xyz&quot;, &quot;abcd&quot;, 1, 2]Description: Text sort is performed by comparing string elements on a codepoint by codepoint basis. Non-string elements come after all string elements in the sort order. The sort is stable, so that non-string elements are not re-ordered relative to each other.Tags: SortingName: SortListAscendingTextType: statementSyntax: sort &lt;Target&gt; in ascending [text] order</code></pre><h3>Inline examples</h3><p>In general, writing inline docs has fewer requirements since several of the elements are auto-generated.</p><h4>LiveCode Builder syntax example</h4><pre><code>/**  This library consists of the operations on lists included in the standard library of LiveCode Builder.*/module com.livecode.list/**Summary:        Returns the first element of &lt;Target&gt;.Target:         An expression which evaluates to a list.output:         The first element of &lt;Target&gt;Example:    variable tVar as List    put the empty list into tVar    push &quot;first element&quot; onto tVar    variable tResult as Boolean    if the head of tVar is &quot;first element&quot; then        put &quot;success&quot; into tResult    end ifDescription:Returns the first element of the list &lt;Target&gt; without modifying &lt;Target&gt;.\`\`\`  the head of tVar\`\`\`is equivalent to using the &lt;IndexedElementOfList&gt; operator with index -1,\`\`\`  tVar[1]\`\`\`References: IndexedElementOfList(operator)Tags: Lists*/syntax HeadOfList is prefix operator with precedence 1    &quot;the&quot; &quot;head&quot; &quot;of&quot; &lt;Target: Expression&gt;begin    MCListEvalHeadOf(Target, output)end syntaxend module</code></pre><h4>LiveCode Builder handler example</h4><pre><code>/**Summary: Logs the result of a test to the &lt;xResults&gt; listParameters:pModule: The name of the module this test comes from.pTest: The name of the test.pResult: The result of the testxResults: The ongoing list of test resultsDescription:Pushes either the string &quot;SUCCESS : &lt;pModule&gt;_&lt;pTest&gt;&quot; or the string &quot;FAILURE : &lt;pModule&gt;_&lt;pTest&gt;&quot; onto the results list,depending on the value of &lt;pResult&gt;*/public handler testLog(in pModule as String, in pTest as String, in pResult as Boolean, inout xResults as List)    variable tStringResult as String    if pResult then        put &quot;SUCCESS&quot; into tStringResult    else        put &quot;FAILURE&quot; into tStringResult    end if    push tStringResult &amp;&amp; &quot;:&quot; &amp;&amp; pModule &amp; &quot;_&quot; &amp; pTest onto xResultsend handler</code></pre><h4>LiveCode script handler example</h4><pre><code>/**Summary: Extracts the inline docs from a .lcb filepFile: The path to the .lcb file to extract docs fromReturns (string): A string consisting of all the docs for the library, and the syntax and handlers present in the .lcb fileDescription:&lt;revDocsGenerateDocsFileFromModularFile&gt; is used when packaging a widget to create its API documentation.It generates the Library and Type elements from the declaration in the &lt;pFile&gt; (either widget or library), and extractsthe comment block that precedes any initial declaration for use as the library-level Description element.It then extracts the comment blocks that precede syntax and handler definitions in &lt;pFile&gt;, and generates the Name, Type, Syntax, and Associated elements for each entry, as well as the parameter types.Tags: Package building*/function revDocsGenerateDocsFileFromModularFile pFile...end revDocsGenerateDocsFileFromModularFile</code></pre></body></html>