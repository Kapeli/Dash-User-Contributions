<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>LiveCode Builder Style Guide</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: reference</h2><h1>LiveCode Builder Style Guide</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>This document describes best practices to be followed when working withLiveCode Builder source code.  Please follow it <em>especially</em> when writing codeto be included with the main LiveCode product package.</p><h2><a name="//apple_ref/cpp/Guide/Copyright headers" class="dashAnchor"></a>Copyright headers</h2><p>Please include a license header at the top of the <code>.lcb</code> file.</p><p>For the main LiveCode repository, or for any community extensions, the licenseis the <a href="http://www.gnu.org/licenses">GNU General Public License v3</a> <em>without</em>the &quot;any later version&quot; clause.</p><h2><a name="//apple_ref/cpp/Guide/Naming" class="dashAnchor"></a>Naming</h2><h3>Module name</h3><p>The module name uses reverse DNS notation.  For example, a module created bythe Example Organisation would use module names beginning with <code>org.example</code>.</p><p>Replace any hyphen (<code>-</code>) characters in a domain name with underscore (<code>_</code>)characters.  For example, a module derived from the <code>fizz-buzz.example.org</code>domain could be <code>org.example.fizz_buzz</code>.</p><p>Additionally, add an underscore (<code>_</code>) to the start of any element in the domainname starting with a digit.  For example, a module derived from the<code>999.example.org</code> domain could be <code>org.example._999</code>.</p><p>You must only use module names corresponding to domain names that you controlor are allowed to use.  This restriction is enforced by the the LiveCodeextension store.</p><p>If you don&#39;t have a domain name of your own, you may use module namesbeginning with <code>community.livecode.&lt;username&gt;</code>, replacing <code>&lt;username&gt;</code>with the username you use to log into the LiveCode extension store.For example, if your username is &quot;sophie&quot;, then you can create amodule named <code>community.livecode.sophie.mymodule</code>.</p><p>For the main LiveCode repository, please use module names beginning with<code>com.livecode</code>.</p><p>Always write module names in lower case.</p><h3>Naming variables and parameters</h3><p>Give variables and parameters <code>xCamelCaseNames</code> with a leading lowercasecharacter indicating their scope and availability.</p><p>The meanings of the leading lowercase characters are:</p><table><thead><tr><th>Prefix</th><th>Context</th><th>Meaning</th></tr></thead><tbody><tr><td>k</td><td>all</td><td>constant</td></tr><tr><td>s</td><td>module</td><td>static variable</td></tr><tr><td>m</td><td>widget</td><td>static variable</td></tr><tr><td>p</td><td>handler definitions</td><td><code>in</code> argument</td></tr><tr><td>r</td><td>handler definitions</td><td><code>out</code> argument</td></tr><tr><td>x</td><td>handler definitions</td><td><code>inout</code> argument</td></tr><tr><td>t</td><td>handler bodies</td><td>local variable</td></tr></tbody></table><p>In general, please use nouns to name your variables and parameters.  Make thenames descriptive; for example:</p><pre><code>variable tOutputPath as String  -- Goodvariable tString as String      -- Bad</code></pre><p>For <code>Boolean</code> variables, please try to use &quot;yes or no&quot; names.  For example:</p><pre><code>variable tIsVisible as Booleanvariable tHasContents as Boolean</code></pre><h3>Naming handlers</h3><p>Give handlers <code>camelCase</code> names.</p><p>Use verbs to name your handlers.  For example,</p><pre><code>handler rotateShape(inout xShape, in pAngleInDegrees)   -- ...end handler</code></pre><h3>Naming types</h3><p>Give types <code>TitleCase</code> names.</p><p>To distinguish from handlers, use nouns to name your types.  For example,</p><pre><code>type RotationAngle is Number</code></pre><h2><a name="//apple_ref/cpp/Guide/Documenting the source code" class="dashAnchor"></a>Documenting the source code</h2><p>In-line documentation for a definition is extracted from a<code>/** */</code> comment block immediately before the start of the definition.</p><p>Always add a top-level documentation block at the start of the LCBfile describing your widget, library or module.  In addition, addin-line documentation to all of the following:</p><ul><li><code>syntax</code> definitions</li><li><code>property</code> definitions</li><li><code>public handler</code> definitions in libraries and modules</li><li><code>public variable</code> definitions in modules</li></ul><p>It is particularly important to add documentation to all syntax and toany public handlers that aren&#39;t primarily accessed using syntax.</p><p>Additionally, add documentation for all messages that are posted by awidget.  The documentation for each message must be placed in thetop-level documentation block for the widget.  For example:</p><pre><code>/*The navigation bar widget is intended for use in mobile apps forswitching between cards, although there are many other possibleuses....Name: hiliteChangedType: messageSyntax: on hiliteChangedSummary: Sent when a navigation item is selected...*/widget com.livecode.widget.navbar-- ..end widget</code></pre><p>Please refer to the <a href="Extending%20LiveCode.md">Extending LiveCode</a> guide for fulldetails of the syntax of in-line documentation comments, including examples.</p><h2><a name="//apple_ref/cpp/Guide/Named constants" class="dashAnchor"></a>Named constants</h2><p>Often, it is useful to use constant values in your code.  Please declare namedconstants rather than placing the values in-line.  For example, you maywant to create three tabs labelled &quot;Things&quot;, &quot;Stuff&quot;, and &quot;Misc&quot;:</p><pre><code>constant kTabNames is [&quot;Things&quot;, &quot;Stuff&quot;, &quot;Misc&quot;]handler createTabs()   variable tName   repeat for each element tName in kTabNames      -- Create the tab   end repeatend handler</code></pre><p>In particular, please avoid any &quot;magic numbers&quot; in your code.</p><h2><a name="//apple_ref/cpp/Guide/Whitespace" class="dashAnchor"></a>Whitespace</h2><h3>Indentation</h3><p>Please indent with tab characters.  Use one tab character per level ofindentation.</p><p>Please do not use a level of indentation at <code>module</code> level.</p><p>Comments should be indented to the same level as the code they apply to.</p><p>For example:</p><pre><code>module org.example.indent-- Example handlerhandler fizzBuzz(in pIsFizz)   if pIsFizz then      return &quot;Fizz&quot;   else      -- Maybe this should have a capital letter      return &quot;buzz&quot;   end ifend handlerend module</code></pre><p>If it&#39;s necessary to mix spaces and tabs for indentation, please use 3 spacesper tab.</p><h3>Wrapping</h3><p>Avoid lines longer than 80 characters.  Break long lines using a <code>\</code>continuation character.  Indent continuation lines by two levels. Forexample:</p><pre><code>constant kWordList is [&quot;a&quot;, &quot;very&quot;, &quot;long&quot;, &quot;list&quot;, &quot;that&quot;, &quot;is&quot;, &quot;much&quot;,\      &quot;more&quot;, &quot;readable&quot;, &quot;when&quot;, &quot;wrapped&quot;, &quot;nicely&quot;]</code></pre><p>When breaking a handler definition or handler type definition, breaklong lines at commas:</p><pre><code>handler processStringAndArray(in pStringArg as String, \      in pArrayArg as Array) returns Boolean</code></pre><h3>Handler declarations, definitions and calls</h3><p>In handler definitions and handler type definitions, don&#39;t insertwhitespace between the handler name and the parameter list.  Forexample:</p><pre><code>handler type Fizzer()   -- Goodhandler type Buzzer ()  -- Bad</code></pre><p>In handler parameter lists, please add a space between each parameter.  Forexample:</p><pre><code>handler formatAsString(in pValue, out rFormat) -- Goodhandler isEqualTo(in pLeft,in pRight)          -- Bad</code></pre><p>Please observe the same formatting in handler calls.  For example:</p><pre><code>variable tFormattedvariable tIsEqualformatAsString(3.1415, tFormatted)             -- GoodisEqualTo (tFormatted,&quot;3.1415&quot;) into tIsEqual  -- Bad</code></pre><h3>List and array literals</h3><p>In list and array literals, please add a space between each element,after the comma.  For array literals, also insert space between keyand value, after the colon.  For example:</p><pre><code>constant kPowersOfTwo is [1, 2, 4, 8]constant kBorderWidths is {&quot;top&quot;: 0, &quot;bottom&quot;: 0, &quot;left&quot;: 1, &quot;right&quot;: 2}</code></pre><h2><a name="//apple_ref/cpp/Guide/Widget-specific guidelines" class="dashAnchor"></a>Widget-specific guidelines</h2><p>This section contains recommendations that are specific to writingwidgets.</p><p>As a general rule, try to minimize surprise for users who mix widgetswith classic LiveCode controls by using similarly named events andproperties with similar semantics.</p><h3>Writing load handlers</h3><p>When writing an <code>onLoad()</code> handler to initialise a widget fromserialised state:</p><ul><li>Always call property setters to update the widget state.  Do not setinstance variables directly.</li><li>Always check that the property array contains each key rather thanaccessing it unilaterally.</li><li>If keys are absent from the property array, do not set them todefault values.  Rely on the <code>onCreate()</code> handler to have alreadydone that.</li></ul><p>Example:</p><pre><code>public handler onLoad(in pProperties)   if &quot;showBorder&quot; is among the keys of pProperties then      setShowBorder(pProperties[&quot;showBorder&quot;])   end if   if &quot;opaque&quot; is among the keys of pProperties then      setShowBackground(pProperties[&quot;opaque&quot;])   end ifend handler</code></pre><h3>Classic control properties</h3><p>Where possible, try to make the names and effects of widgetproperties as similar as possible to properties of classic controls.For example:</p><ul><li><strong>label</strong>: the text for the primary text label</li><li><strong>showBorder</strong>: whether to display an outline</li><li><strong>opaque</strong>: whether to fill in the background</li></ul><h3>Host control properties</h3><p>When relying on properties that are implemented by the widget hostcontrol, such as the classic color and pattern properties, include<code>metadata</code> definitions to display them in the PI, but do not include a<code>property</code> definition.</p><p>Because there is no <code>property</code> definition, the documentation for thehost control property must be placed in the top-level documentationblock comment before the start of widget definition.</p><p>For example, to shadow the <code>borderColor</code> host control property:</p><pre><code>/**Test widget that demonstrates shadowing the&lt;borderColor(property)&gt; property....Name: borderColorType: propertySyntax: set the borderColor of &lt;widget&gt; to &lt;color&gt;Syntax: get the borderColor of &lt;widget&gt;Summary: Color for drawing circular outlineDescription:The &lt;borderColor&gt; property controls the color used to draw thewidget&#39;s outline.*/widget org.example.host_control_property-- ...metadata borderColor.editor  is &quot;com.livecode.pi.colormetadata borderColor.section is &quot;Colors&quot;metadata borderColor.label   is &quot;Border color&quot;metadata borderColor.default is &quot;109,109,109&quot;-- ...end widget</code></pre><h3>Events</h3><p>Always implement:</p><ul><li><code>onCreate()</code></li><li><code>onSave()</code></li><li><code>onLoad()</code></li><li><code>onPaint()</code></li></ul><p>You should <em>usually</em> implement:</p><ul><li><code>onGeometryChanged()</code>: if you have any non-trivial recomputationrequired to handle resizing</li><li><code>onMouseDown()</code>/<code>onMouseUp()</code>/<code>onMouseMove()</code>: always <code>post</code> these toscript in order to behave like a classic control</li></ul></body></html>