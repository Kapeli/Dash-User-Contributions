<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>LiveCode Script</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: introduction</h2><h1>LiveCode Script</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>Before getting started with LiveCode, there are a number of things youmay want to know. This guide introduces LiveCode, tells you where tobegin, how to install, register and how to use the documentation.</p><h2><a name="//apple_ref/cpp/Guide/Welcome" class="dashAnchor"></a>Welcome</h2><p>LiveCode makes it easy to turn your concepts, ideas or designs intopowerful applications. You can create desktop, Internet, database andnetwork applications. LiveCode includes a complete graphical userinterface builder, as well as the tools you need to produce faceless orbackground applications.</p><p>LiveCode is easy to learn. If you are a complete beginner to the worldof programming, you will find you can become productive quickly. If youare an experienced programmer, you will find the environment extremelypowerful and one of the most productive you have used.</p><p>LiveCode’s programming language is object-based. This makes it easy towrite modules of code that are attached directly to individual objects.Unlike other languages, LiveCode lets you both run and edit anapplication live. Traditionally the run, edit, compile and debug cyclein programming takes up a lot of time. In LiveCode all of theseactivities can take place together.</p><p>If you’re coming from another language, you’ll appreciate that theLiveCode language is typeless, with data automatically stored in themost efficient format and converted, so you don’t have to learn how todeal with different types of data. Memory management is fully automatic.LiveCode applications are not interpreted in the traditional sense, sothey provide excellent performance. A LiveCode graphical applicationwill often feel more responsive to use than a Java application, and takeless time to write.</p><p>A LiveCode application is completely cross-platform. That means you canrun any application you create on all major modern operating systems,including Windows, Linux, Unix and Mac OS. Unlike most othercross-platform frameworks, a LiveCode application will always look andfeel native on each platform that you deliver it on. You can takeadvantage of many platform specific features on each platform.</p><p>LiveCode removes the need to learn how to access most individualprogramming interfaces for each operating system. This saves you thetime and effort of learning thousands of platform-specific interfacecalls.</p><p>The goal of this manual is to provide the most accessible, comprehensiveand useful guide to LiveCode possible. We aim to provide a level ofdepth that covers the advanced feature set, while remaining accessibleto beginners. We hope you find this material useful and enjoy usingLiveCode.</p><h2><a name="//apple_ref/cpp/Guide/Where to Begin" class="dashAnchor"></a>Where to Begin</h2><p>We recommend you start by taking a look at <a href="https://livecode.com/resources/">our onlineresources</a>. There is a wide variety ofintroductory material there, including step-by-step examples and guidesfor performing common tasks.</p><h2><a name="//apple_ref/cpp/Guide/System Requirements" class="dashAnchor"></a>System Requirements</h2><p>Memory and disk requirements below are for the <em>LiveCode developmentenvironment</em>, not for applications created by LiveCode. Applicationscreated with LiveCode will require sufficient free system resources toload, display, process and interact with the content of the application.Because this will vary considerably depending on the applicationcreated, it is not possible to publish a list of requirements forapplications built with LiveCode. You will need to test your applicationto determine the minimum requirements. Many LiveCode applications willrun on a moderately powerful computer and require substantially fewerresources than those listed for the development environment, others willrequire more.</p><h3>All Operating Systems</h3><p>To use LiveCode you will need:</p><ul><li><p>1024x768 or larger monitor</p></li><li><p>True color display (16-bit or 32-bit depth)</p></li><li><p>At least 256Mb of memory</p></li><li><p>At least 150Mb of disk space</p></li></ul><h3>Requirements for Windows Systems</h3><p>LiveCode supports the following versions of Windows:</p><ul><li><p>Windows 2000 SP4</p></li><li><p>Windows XP SP2 and above</p></li><li><p>Windows Server 2003</p></li><li><p>Windows Vista SP1 and above (both 32-bit and 64-bit)</p></li><li><p>Windows 7 (both 32-bit and 64-bit)</p></li><li><p>Windows Server 2008</p></li></ul><h3>Requirements for Linux Systems</h3><p>The minimal requirements for LiveCode to run on Linux are:</p><ul><li>32-bit installation, or a 64-bit linux distribution that has a 32-bit compatibility layer</li><li>2.4.x or later kernel</li><li>glibc 2.3.2 or later X11R5 capable Xserver running locally on a24-bit display*</li><li>compositing window manager (optional - required for alpha-blendedwindow shapes)</li><li>gtk/gdk/glib (optional - required for native theme support)</li><li>pango/xft (optional - required for pdf printing, anti-aliased textand unicode font support)</li><li>lcms (optional - required for color profile support in JPEGs andPNGs)</li><li>gksu (optional - required for elevate process support)</li><li>mplayer (optional - required for video playback)</li><li>esd (optional - required for audio playback)</li></ul><p>Although impossible to test every existing Linux distribution, we areaiming to ensure that LiveCode runs on as wide a variety of systems aspossible. To achieve this, the engine has been implemented to haveminimal direct dependencies on system software, and will gracefullydegrade in feature set if it cannot find the libraries it needs.Generally any recent linux distribution including Gnome/GTK support willhave the required libraries for full feature support – for example,Ubuntu 7 supports all these features (although alpha blended windowshape support requires you to be running with &#39;Advance Desktop Effects&#39;turned on).</p><h3>Requirements for Mac OS X Systems</h3><p>LiveCode supports the following versions of Mac OS X:</p><ul><li>10.6.x (Snow Leopard)</li><li>10.7.x (Lion)</li><li>10.8.x (Mountain Lion)</li><li>10.9.x (Mavericks)</li><li>10.10.x (Yosemite)</li><li>10.11.x (El Capitan)</li></ul><h2><a name="//apple_ref/cpp/Guide/Using the Documentation" class="dashAnchor"></a>Using the Documentation</h2><h3>Documentation Conventions</h3><p>Language Terms</p><p>This documentation contains examples of LiveCode language syntax. Thesyntax for each language term is provided in <strong>boldface text</strong>.</p><p>The syntax description uses the standard conventions to indicate partsof the syntax: </p><ul><li><code>[]</code> Square brackets enclose optional portions.</li><li><code>{}</code> Curly braces enclose sets of alternatives from which to choose.</li><li><code>|</code> Vertical bars separate different alternatives.</li><li><code>\</code> Line continuation character – this line continues to the next line.</li><li><em>Italics</em> indicate placeholders that you don&#39;t enter literally.</li></ul><p>Code examples are provided in <code>typewriter text</code> or </p><pre><code>code blocks</code></pre><h4>Menu Reference</h4><p>When you are told to choose an item from a menu, the menu name iswritten, followed by an arrow, followed by the menu item. For example<strong>File -&gt; New</strong> means choose &quot;New&quot; from the &quot;File&quot; menu.</p><h4>Keyboard Shortcuts</h4><p>Many menu items have keyboard equivalents. These items can be accessedby holding down a modifier key and pressing another key. The modifierkeys used throughout this document are generally the modifier keys usedon Windows, Linux and Unix. If you are using Mac OS, you may need tosubstitute modifier keys using the table below. For example, if you areusing a Mac, where we say press <strong>control-x</strong> in this documentation, youmay need to press <strong>command-x</strong>.</p><table><thead><tr><th><strong>Windows and Linux keyboard shortcuts</strong></th><th><strong>Mac equivalent</strong></th></tr></thead><tbody><tr><td>Control</td><td>Command</td></tr><tr><td>Alt</td><td>Option</td></tr></tbody></table><p>Figure 2– Cross-platform Keyboard Shortcuts</p><h4>Screen Snapshots</h4><p>Screenshots are used extensively throughout the documentation. Pleaseremember that LiveCode is a cross-platform application. While many ofthe snapshots are taken on the Windows platform, most of the feature setwill work on Linux, Unix and Mac OS. Snapshots of these platforms areused from time to time and are also used to illustrate platform specificfeatures.</p><h5>Note Styles</h5><blockquote><p><strong>Tip:</strong> This style of note tells you about an alternative way todo something or describes a shortcut.</p><p><strong>Important:</strong> This style of note describes an aspect of LiveCodethat may confuse you if you don&#39;t know about it and tells you how toavoid unexpected behavior.</p><p><strong>Note:</strong> This style of note provides some additional informationthat may be useful, or emphasizes a key point.</p><p><strong>Caution:</strong> This style of note warns you about a potentialproblem that might cause an error or loss of data.</p></blockquote><h3>Navigating the Documentation</h3><p>The LiveCode documentation is spread across four areas; the StartCenter, the Dictionary (API), the Guides and other resources.</p><p>The Start Center is aimed at introducing you to LiveCode, and should beyour first port of call if you have not used LiveCode before. Thedictionary, or API, is a reference resource which you can refer to whileimplementing your projects. Guides are online resources at livecode.com. Other resources include Sample Stacks, a free, online repository of user-contributed stacks, User forums, and the resources page at livecode.com/resources/.</p><p>You can access the documentation from within LiveCode from the <strong>Help</strong>menu. Additional resources are available at<a href="http://www.livecode.com">www.livecode.com</a>.</p><h3>Start Center</h3><p>The purpose of the Start Center is to introduce you to LiveCode andprovide you with enough knowledge to start implementing your ownprojects. It can be accessed by choosing <strong>Help -&gt; Start Center</strong>. </p><p>The first time you open the Start Center you will see an invitation to take the Interactive Tour, a step-by-step tutorial that guides you through creation of a simple project in LiveCode. If you choose to skip the tour you may always enter it later by clicking the Interactive Welcome button in the Start Center.</p><p><img src="images/startCenter_firstrun.png" alt=""/></p><p>The Start Center itself is split across three sections&mdash;quick links to the LiveCode pages on various social media sites; a collection of quick link buttons, which take you to various helps and guides; and a list of your most recently opened stacks.</p><p><img src="images/startCenter_labels.png" alt=""/></p><h4>Social Media Links</h4><p>LiveCode maintains pages on popular social media sites, such as Facebook, YouTube, LinkedIn and Stack Overflow. These can help you keep up to date on LiveCode product announcements, professional networking, and help and training resources.</p><h4>Recent Stacks</h4><p>This shows a list of your most recently opened stacks. Double click on a stack to open it and close the Start Center window.</p><h4>Quick Links</h4><p>The quick link buttons let you quickly access tutorials, sample projects, guides, LiveCode blog posts, and online user forums. Here is an overview of these links:</p><h5>Interactive Welcome</h5><p>Enter the Interactive Tour, a step-by-step tutorial that guides you through creation of a simple project in LiveCode.</p><h5>New</h5><p>Click this button to create a new stack. You will see a menu of common stack types and sizes to choose from. Once you choose your stack size or type the new stack will be created and the Start Center menu will close.</p><h5>Sample Projects</h5><p>The Sample Projects button opens an online repository of sample stacks submitted by LiveCode developers. The repository contains dozens of stacks that you can download for free and use as you wish.</p><h5>Tutorials</h5><p>Opens the LiveCode online tutorial web page. From here you can choose one of dozens of lessons and how-to tutorials that give you step-by-step instructions on how to create things, from a simple &quot;hello world&quot; application to simple games to sophisticated graphical effects.</p><h5>In Depth Guides</h5><p>Opens the LiveCode Dictionary. Here you can choose to enter the API documentation, the definitive reference of all of the terms in the LiveCode scripting language. Or you can open one of several user guides, which describe in detail how to develop and deploy apps in LiveCode. </p><h5>Forums</h5><p>LiveCode has a very active and friendly user community. We encourage allnew users to sign up to our mailing list and user forums as they are agreat way to get technical help, meet new people and keep up-to-datewith what is going on in the world of LiveCode. The “User Forums”section provides a link to our forum registration page as well as a listof links to the most recent posts which have been made.</p><h5>Blog</h5><p>This button takes you to LiveCode&#39;s online blog, where LiveCode engineersand developers regularly post updates about what&#39;s new in LiveCode, how-to tutorials, and announcements of interest to the LiveCode developer community.</p><h5>Account</h5><p>Click this button to log in to your LiveCode online store account. There you can see your purchases, as well as look for useful add-ons to make LiveCode and even more powerful development tool.</p><h3>Dictionary</h3><p>The LiveCode Dictionary contains detailed reference materials for developing applications with LiveCode. It is divided into two main sections&mdash;the LiveCode API reference and the LiveCode Guides. It can be accessed by choosing <strong>Dictionary (API)</strong> from the <strong>Help</strong> menu, or by clicking the Dictionary icon on the LiveCode Toolbar.</p><p><img src="images/toolbar-dict.png" alt=""/></p><h4>LiveCode APIs</h4><p>The LiveCode Application Programming Interface, or API, reference contains the complete syntax for all LiveCode components, including LiveCode Script, LiveCode Builder, and all installed widgets and libraries. If you are new to LiveCode you will likely spend most of your time in LiveCode Script, the scripting language used in developing LiveCode applications. The examples that follow will be taken from the LiveCode Script API, but the API documentation for all components uses the same format and layout.</p><p><img src="images/image4.png" alt=""/></p><p>To search one of the API lists, click on the API tab at top left, then choose the API you want to search from the option list. For example, to search for a LiveCode Script term, choose LiveCode Script.</p><p><strong>Searching.</strong> If you know what term you want to look up, or if you have a good idea of what it might be, just start typing it into the search box, and a list of terms that match your search term will appear in the entries list. </p><p><img src="images/dict-search.png" alt=""/></p><p><strong>Filtering.</strong> If, on the other hand, you don’t know the name of the term, but have a general idea of what terms you want to look at you can filter the list of terms by clicking on a filter topic. For instance, to see a list of messages that buttons can respond to, click &quot;message&quot; under the <strong>type</strong> category and &quot;button&quot; under <strong>associations</strong>. You can clear a filter by clicking again on the selected filter.</p><p><img src="images/dict-filter.png" alt=""/></p><p>Note that the entries list displays only the entry name, token type, and syntax for the entry. You can view the complete entry by clicking on the desired line in the list. This will show the entry in the area underneath the entries list. Each LiveCode scripting term is thoroughly documented with the proper syntax, detailed examples, a detailed description, related terms, and more.</p><p><img src="images/dict-entry.png" alt=""/></p><h4>LiveCode User Guides</h4><p>The User Guides are a complete reference to LiveCode. They detail what the dialogs and windows within the development environment do, and explain the LiveCode language in depth. To open a guide, click on the Guide tab in the Dictionary and choose the desired guide from the list.</p><p><img src="images/guides.png" alt=""/></p><h3>RevOnline</h3><p>RevOnline gives you the opportunity to upload and share your projects aswell as download those created by other members of the LiveCode onlinecommunity. It can be accessed via the Sample Stacks button located in themenu bar. The main interface can be seen below:</p><p><img src="images/revonline-main.png" alt=""/></p><p>The interface is designed to organise the online content into variouscategories to aid you in finding the kind of content you wish todownload. You will find three main types of content in RevOnline, stacks(LiveCode programs), externals and code snippets. Externals arelibraries that can extend the functionality of the LiveCode languageusing a lower level language. A code snippet is a portion of LiveCodescript that you can paste into and incorporate into your own projects.</p><p>The results of searching or browsing through the RevOnline content aredisplayed in the <em>search list</em> area. This is an explanation of thecontrols you can use to adjust the parameters of your search:</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Search field</strong></td><td>Enter text and press return or click “Go” to search. Matches will be made against the titles of uploaded content, the author’s name and content descriptions.</td></tr><tr><td><strong>Type list</strong></td><td>Highlight one of the items in this list filter search to only show results of that type. Selecting “All” will display content of all three types.</td></tr><tr><td><strong>Tag list</strong></td><td>Tag your own and others people’s content with a word or phrase. All tags are listed here alphabetically. Selecting a tag will filter the search results for uploads that have been tagged accordingly. Selecting “All” will remove the filtering.</td></tr><tr><td><strong>Search order</strong></td><td>Change the order in which the search results are displayed. There are four options. “A to Z” lists content alphabetically by title, “Popularity” by the number of times it has been downloaded, “Rating” by the average user rating (out of five stars) and “Date” by the date on which the content was uploaded to RevOnline</td></tr><tr><td><strong>Order direction</strong></td><td>The direction (ascending/descending) of the search order can be changed by clicking on the arrow to the right of the sort control.</td></tr><tr><td><strong>View mode</strong></td><td>The search list area can be viewed in two modes, a vertical scrolling list or a grid. In “list” mode 10 results will be displayed per page, in “grid” mode the number of results displayed will be dependent upon the size of the RevOnline stack. Whilst in “grid” mode the <em>viewing pane</em> area will not be visible.</td></tr><tr><td><strong>User filter</strong></td><td>If you apply user filter to a search, the user’s name will appear above the type and tag lists (see below), subsequently only content by that user will be returned in the search results. Clicking on the button or text of the user filter will remove it.</td></tr></tbody></table><p><img src="images/revonline-user-filter.png" alt=""/></p><p>The <em>search list</em> area displays a preview of the results your search hasreturned. At the top of this list you will see the <em>page controls</em> whichallow you to navigate forwards and backwards through the pages of yoursearch should it return more results than can be displayed on one page.</p><p><img src="images/revonline-page-list.png" alt=""/></p><p>An example of the search list previews can be seen below:</p><p><img src="images/revonline-list-preview.png" alt=""/></p><p>At the top of the preview is the content’s name. You can also see itsaverage user rating out of five stars, the total number of times it hasbeen downloaded, the authors name and a list of tags applied to thisupload. The “download” button at the bottom will download and launchthis particular stack, it also tells you the size of the download. The<em>preview image</em> can either be a custom screenshot as above or one ofthree standard images. These are black for stacks, red for code snippetsand green for externals. The <em>type icon</em> in the lower left corner of thepreview image also indicates the type, these are shown below for astack, code snippet and external respectively:</p><p><img src="images/image17.png" alt=""/> <img src="images/image18.png" alt=""/> <img src="images/image19.png" alt=""/></p><p>Clicking on the <em>preview image</em> or content title will update the righthand <em>viewing pane</em> with more detailed information about this upload.Clicking on the authors name will display the author’s user profile inthe <em>viewing pane</em> and introduce a <em>user filter</em> to the search results.When the <em>search list</em> is in “grid” mode the <em>viewing pane</em> will behidden, doing either of the above operations will cause the <em>searchlist</em> to switch back to “list” mode and display the associated contentin the <em>viewing pane</em>.</p><p>The <em>viewing pane</em> displays detailed information on users and uploads.</p><p><img src="images/revonline-view-pane.png" alt=""/></p><p>If you are a viewing stack details as shown above, in addition to theinformation provided by the preview you will also see a headline,description and a revision number which is incremented whenever theauthor uploads a new version of their stack, code snippet or external.Clicking on the author’s name or <em>user profile image</em> will display theirprofile view. Clicking on the <em>content type</em> or any of the tags in the<em>list of applied tags</em> will apply these filters to the search controls.When viewing an external your will see an additional “Platform:” fieldthat indicates which platforms the external library is compatible with,make sure your operating system is supported before downloading andinstalling an external. If you are currently logged in to your RevOnline account you will be able to give the upload a rating by hoveringover the <em>rating control</em> and clicking when the rating you wish tosubmit is displayed, this can only be done once per upload. You can alsotag the upload by clicking on the <em>add tag control</em> which brings upfollowing dialog:</p><p><img src="images/image21.png" alt=""/></p><p>As you type into the text entry field, tag suggestions will appear in adrop down menu that can be selected using the arrow keys. Once you havefinished typing press the ok button to submit your tag, you must belogged in to complete this operation.</p><p>The <em>status bar</em> at the bottom of the RevOnline interface displays thenumber of results your search has returned as well as a progress barindicating the progression of searches and downloads. You will also seetext feedback in response to the operations you perform such as“Retrieving stack details ...” and “Content tagged” etc.</p><p>In the top right corner of RevOnline you will find the <em>login controls</em>which will display your current login status as shown below:</p><p><img src="images/revonline-login-status-not-logged-in.png" alt=""/><img src="images/revonline-login-status-logged-in.png" alt=""/></p><p>In order to upload, rate and tag content in RevOnline you must have anaccount, this account is also required for making comments in the wikidocs detailed elsewhere. To register for an account just click on the“Sign Up” control and enter your email in the dialog that appears. Youremail address will be used as your username for logging in, a passwordwill be emailed to you upon signing up. After receiving this email youmust hit the activation link in the email before your account can beaccessed. Once activated, you can login to your account using the “LogIn” control pictured above which will bring up the following dialog:</p><p><img src="images/revonline-login-dialog.png" alt=""/></p><p>The “Remember me” check box will cause RevOnline to maintain yourusername in the “Email :” field between login attempts. The “Sign inautomatically” check box will mean that you are automatically signed inupon opening RevOnline, however if you explicitly sign out you will haveto re-enter your password regardless of this preference. If you forgetyour password at any time you can use the “Forgot your password?” linkin the login dialog to have a new one emailed to you.</p><p>Upon logging in and viewing your profile for the first time you will bepresented with your profile view in edit mode where you have theopportunity to enter information about into the highlighted fields andchange your profile picture using the <em>change profile picture</em> controlas shown below:</p><p><img src="images/revonline-account-details.png" alt=""/></p><p>Clicking on the <em>change profile picture</em> control will bring up thefollowing dialog:</p><p><img src="images/image25.png" alt=""/></p><p>Use the <em>Position Controls</em> to move the centre of the image up, down,left or right. You can zoom in or out using the <em>Zoom controls</em>.Pressing the <em>Re-centre image</em> button will reset the image to itsoriginal position and zoom level. Once you are happy with orientation ofyour picture click ok, or cancel to discard your changes. This dialog isalso used to change stack preview pictures.</p><p>When you have finished editing your profile you can hit the “savechanges” button to submit your information, a minimum of a first andlast name must be entered before you can save. You can also choose todisplay your email or not and change your password to one of yourchoosing using the “Change password” control. You can reach this profileat any time by clicking on the “My Account” control in the <em>logincontrols</em> which will both display your profile and display all youruploads in the <em>search list</em>. To exit this view simply remove the userfilter or hit the “My Account” control again.</p><p>To upload content to RevOnline simply click on the “upload content” inthe <em>login controls,</em> you will then be presented with the contentbrowser view.</p><p><img src="images/revonline-content-browser-code.png" alt=""/></p><p>Clicking on the tabs at the top of this view will change the contenttype. Above you can see the code snippet view, it simply requires you topaste a section of code into the <em>code entry field</em> and press ok, if youhave your code snippet stored in your clipboard you can simply press the“paste” button. For stacks you can either select a stack from the listof recently opened stacks or browse to the files location using the“browse” button. For externals you need to check which platforms yourexternal will support and then browse to the appropriate file you wishto upload (shown below). The default file types for extensions on eachplatform are; “.dll” for Windows , “.bundle” for Mac OS X and “.so” forLinux.</p><p><img src="images/revonline-content-browser-external.png" alt=""/></p><p>When uploading a code snippet or external RevOnline will place the codeor file into an installer stack. The installer stacks give you theoption to “install” or “try” an external file or “copy to clipboard” acode snippet. When using the try option with an external the file willbe removed from your installation when you next exit LiveCode.</p><p>Once you have pressed ok you will be presented with the edit mode viewfor the file you are uploading. Here you can enter a name descriptionand change the preview picture for your upload (note – you cannot editthe title of an external upload it must be the name of one of the filesyou have included). If you attempt to upload a file that has alreadybeen uploaded to RevOnline, you will be taken to the existing version ofthat file to edit, this avoids duplicate uploads.</p><p>Whenever you are viewing content that you have uploaded or your ownprofile whilst logged in the edit controls will appear above the<em>viewing pane</em>, shown below:</p><p><img src="images/revonline-edit-stack.png" alt=""/></p><p>By clicking on the “edit profile” or “edit stack” (for stacks etc.)button you are entering edit mode which allows you to make changes tothe information shown. When editing your profile you can simply save ordiscard the changes you have made. When editing an upload you have theadditional options of deleting and updating the uploaded file. Thedelete control will permanently remove your upload from RevOnline. Theupdate control allows you to replace the stack file, code snippet orexternal library with a newer version. Clicking on this control willpresent you with the content browser view discussed earlier. After youhave chosen a replacement file you need to save your changes in orderfor the new file to be submitted.</p><p><img src="images/revonline-edit-content-controls.png" alt=""/></p><p>The list of tags applied to your own uploads can be altered by using the“Add/Delete tags” control </p><p><img src="images/revonline-add-delete-tags.png" alt=""/></p><p>which will bring up the following dialog:</p><p><img src="images/image30.png" alt=""/></p><p>This works in a similar way to the previously explained tag dialogexcept that you can view the entire list of tags and edit which ones youwish to be displayed. When hitting return after entering the name foryour tag a new <em>tag item</em> will appear in the list (also achieved bypressing the <em>add tag</em> button). Tags can be removed by clicking on theappropriate <em>remove tag button</em>. If your tag list is too large for onepage you can browse through the pages of tags using the <em>page controls</em>at the bottom of the dialog. Once you have finished editing the list youcan submit your changes by clicking the ok button.</p><p>Additional options for the RevOnline interface can be set in theRevOnline tab of the preferences stack. As pictured below:</p><p><img src="images/revonline-preferences.png" alt=""/></p><p>Here you can set the remember password and user name preferences andchange your password to one of your choosing. The search results inRevOnline are cached to speed up performance. You can tweak the size andtime for which this cache remains valid using the two slider controls. Alarger cache will give you faster performance but will take longer topickup changes made to the online content made by other users. If thetext only searches option is checked RevOnline will only retrieve thetext data for the search list previews which can also improveperformance.</p><h2><a name="//apple_ref/cpp/Guide/Additional Resources" class="dashAnchor"></a>Additional Resources</h2><p>If you have a question that isn&#39;t answered in this documentation, youcan find additional information to help you on our web site. You canalso connect with the LiveCode developer community, which includes manyexperienced developers who offer their expertise for the common good toanswer questions and help their fellow developers. You&#39;ll find examplecode, information on planned enhancements, and the latest updates.Visit:</p><p><a href="http://www.livecode.com">http://www.livecode.com</a></p><h3>Developer Community</h3><p>There are a number of ways to engage with the LiveCode community:</p><ul><li><p>The <a href="http://forums.livecode.com/">forums</a> (section 1.6.3 above), areavailable for getting help from other developers, for discussing featurerequests and future directions, and for receiving announcements fromLiveCode.</p></li><li><p>Ask a question on<a href="http://stackoverflow.com/questions/tagged/livecode">stackoverflow</a>.</p></li><li><p>Talk about LiveCode on <a href="https://www.reddit.com/r/livecode">the LiveCodesubreddit</a>.</p></li><li><p>Join the <a href="https://www.facebook.com/groups/livecodeusers">LiveCode usergroup</a> on Facebook.</p></li><li><p>Use the <a href="http://lists.runrev.com/mailman/listinfo/use-livecode">LiveCode mailinglist</a> is alsoavailable.</p></li></ul><blockquote><p><strong>Tip:</strong> Tip: You can use the Google search engine to search the listarchives, using <a href="http://www.google.com/advanced_search?q=site:lists.runrev.com">thislink</a></p></blockquote><h3>Technical Support</h3><p>LiveCode offers <em>up and running</em> technical support to all users toassist you in getting the development environment working on yoursystem.</p><p>Many editions include additional technical support for more <em>advanced</em>problems and questions. Where support is not included, a separatetechnical support contract for advanced support can be purchased.</p><p>Contact us <a href="https://livecode.com/about/contact/">here</a> or at<a href="mailto:support@livecode.com">support@livecode.com</a>.</p><h2><a name="//apple_ref/cpp/Guide/Getting Started" class="dashAnchor"></a>Getting Started</h2><p>Creating a simple <em>graphical application</em> in LiveCode can take justminutes. First you create a user interface, including any windows,palettes, dialogs you require. Then you populate the user interface withcontrols, like push buttons, check boxes, text fields or menus. Finally,you use LiveCode’s English-like programming language to tell yourapplication how to behave.</p><h3>Prerequisites</h3><p>Before you get started, you should be familiar with how to use yourcomputer. You should also be familiar with common applications such as aweb browser, word processor and email client. If you are using Linux orUnix, you should be familiar with basic use of the command line. If youare not familiar with using a computer, we recommend you spend some timegetting acquainted before trying to learn LiveCode.</p><h3>Event Driven Programming</h3><p>A LiveCode application is driven by user actions. LiveCode constantlywatches the computer for common actions, such as clicking on a button,typing into a field, sending data across a network, or quitting anapplication.</p><p>Whenever an event occurs, LiveCode sends a message. When writing yourprogram, you decide what messages you want your program to respond to.LiveCode automatically sends each message to the most relevant object.For example, if a user clicks on a button, LiveCode sends a message tothe button. You place code within the button that tells it how torespond to being clicked on.</p><p>There are a wide range of possible events. When a user clicks on abutton, a series of events are sent to the button. For example, when themouse first moves within the border of the button a <strong>mouseEnter</strong>message is sent. Then a series of mouseMove messages are sent as the mouse moves over the button. When the mouse button is depressed a <strong>mouseDown</strong> message is sent. When the mouse is released a <strong>mouseUp</strong>message is sent. You don’t have to respond to all of these events. You simply place code within an object to handle the events you want your application to respond to.</p><p>Events that are not handled by individual objects can be handled in anumber of ways at different levels of your application, in libraries, orthey can be ignored. The rules that govern what happen to events thatare not processed by an object are described in the section <em>The MessageHierarchy</em>.</p><p>We’ll return to Event Driven Programming in more detail in the section<em>Coding in LiveCode</em>.</p><h3>Object-Based Programming</h3><p>Any <em>graphical application</em> you build using LiveCode will be based onobjects. With LiveCode you typically create the objects of yourapplication before writing any code. You can start by drawing thebuttons, text fields, and other controls that make up your application.LiveCode operates like other layout, drawing or application developmentenvironment. You can select controls by clicking them, move them bydragging them around, resize them, and change their ‘layer’ to move themcloser or further from the ‘top’ of the interface.</p><p>Once you have the objects in place, you can proceed to attach code toeach object to respond to the events you want. LiveCode includes acomplete graphical development environment that makes it easy to createand edit any kind of user interface. It includes objects for all thebasic operating system elements, including buttons, checkboxes, textfields, menus, graphics, and many more. In addition you can create andcustomize your own objects that look and behave however you want.</p><p>If you are writing a non-graphical application, you can choose to createobjects to assist in organizing your code into sections and load theseobjects off screen, or you can simply write your code in a text file andrun the text file directly. This method is commonly used to communicatewith Apache and other web browsers when using LiveCode to buildserver-side or network applications.</p><p>Object-Based programming is covered in more detail in the section<em>Building a User Interface</em>. Non-graphical applications are covered inmore detail in the section <em>Building a Web Application</em>.</p><h3>The ‘Edit’ and ‘Run’ Mode</h3><blockquote><p><strong>Important:</strong> In order to enter <strong>run</strong> mode, choose the browse toolin the <em>top left</em> of the tools palette.</p></blockquote><p>In order to <strong>edit</strong>, choose the pointer tool from the <em>top right</em> ofthe tools palette.</p><p>Unlike most other development systems, a LiveCode application can becreated, edited, debugged and run live.</p><p>When in run mode, objects receive all the normal messages that drive aLiveCode application. For example, clicking on a button in run mode willcause a <strong>mouseUp</strong> message to be sent to it, causing the button&#39;s script to run if you&#39;ve designed it to respond to the <strong>mouseUp</strong> message.</p><p>When in edit mode, objects do not receive messages when you click onthem, and you can move, resize or edit the properties for objects.</p><blockquote><p><strong>Tip:</strong> To temporarily stop all messages being sent to yourapplication while editing it, choose <em>Suppress Messages</em> from the<em>Development</em> menu or <em>Toolbar</em>.</p></blockquote><p>There few other differences between the two tool modes. You can view andedit properties and code in either mode. Your application does not stoprunning while you make changes to it. Only mouse interaction withobjects is suspended in edit mode to allow you to edit them more easily.</p><p>Because LiveCode is constantly live, you can easily make simple changesand watch each change take effect as you make it. This allows you todesign and experiment using an iterative process, resulting in a moreproductive and satisfying development experience.</p><h2><a name="//apple_ref/cpp/Guide/Structuring your Application" class="dashAnchor"></a>Structuring your Application</h2><h3>Cards, Stacks &amp; Files</h3><p>The first step in creating a LiveCode application is creating a window,which in LiveCode is called a stack. Each window you see in LiveCode isa stack. Palettes, dialog boxes, and standard windows are all stacks.</p><p>Each stack contains one or more sets of information called cards. Eachcard can have a different appearance or all the cards in a stack canlook the same. By going from card to card in a stack, you change what&#39;sbeing displayed in that stack&#39;s window. You can think of a LiveCodestack as a stack of playing cards (hence the name), where you can flipthrough the cards, but only one card at a time is visible. A stack canhave a single card or many cards. See Figure 3 – Stack file Structure,below.</p><p>All user interface objects (controls) are created by dragging them on toa card area.</p><p>You can also group controls together if you want them to operate as aset. For example, if you have a set of navigation buttons that go fromcard to card in your stack, you can make them into a single group.Groups can appear on more than one card, so your navigation buttons orbackground image can appear on each card of your stack. For moredetails, see the section on <em>Group and Backgrounds</em>.</p><p>A collection of stacks can be saved together in a single file. This fileis known as a stack file. The first stack in the file is called the mainstack and will be loaded automatically when your application is run.</p><h3>The Structure of a Stack File</h3><p>Each LiveCode file contains one or more stacks: either a single mainstack, or a main stack and one or more substacks. Since each stack is awindow (including editable windows, modeless and modal dialog boxes, andpalettes), a single stack file can contain multiple windows.</p><p>You can use this capability to bundle several related stacks into asingle file for easy distribution, to organize your stacks intocategories, or to allow several stacks to inherit properties from thesame main stack.</p><p><img src="images/image32.png" alt=""/></p><p>Figure 3 – Stack File Structure</p><h3>Opening a Stack File</h3><p>When you open a stack file, either by using the &quot;Open Stack&quot; menu itemin the File menu or by using one of the navigation commands (see <strong>open,go</strong>, <strong>modal</strong>, <strong>modeless</strong>, <strong>palette</strong>, or <strong>topLevel</strong> in the<em>LiveCode Dictionary</em>), the stack file&#39;s main stack opens automaticallyto its first card.</p><blockquote><p><strong>Important:</strong> A stack file is saved as a whole. If you save a stack,all the other stacks in the same stack file are saved at the same time.</p></blockquote><p>Substacks in the stack file do not open automatically when the stackfile opens. You must open a substack in a handler or the Message Box, orby using the Application Browser.</p><h3>Main Stacks and Substacks</h3><p>The first stack created in a stack file is called the <em>mainstack</em>. Anyother stacks created in the same stack file are called <em>substacks</em> ofthe mainstack.</p><p>The mainstack is part of the object hierarchy of all other stacks in thesame stack file. In other words (for the purposes of inheritedproperties and shared behaviors), the mainstack <em>contains</em> itssubstacks. Events that are not handled by a substack are passed on tothe mainstack&#39;s script, color and font properties are inherited from themainstack by its substacks. For more details on the object hierarchy andinheritance in LiveCode in general, see the section on <em>The MessagePath</em>.</p><p>Dialog boxes and palettes are commonly stored as substacks of the mainapplication window, which is typically a mainstack. This allows you tostore code and common functions used by all the substacks in themainstack&#39;s script. Because mainstacks are part of the object hierarchyof their substacks, the substacks can call this functionality fromscripts within the substack.</p><h3>Stacks, Stack Files, and Memory</h3><p>A stack file can be loaded into memory without actually being open. Astack whose window is closed (not just hidden) is not listed in the<strong>openStacks</strong> function. However, it takes up memory, and its objectsare accessible to other stacks. (For example, if a closed stack loadedinto memory contains a certain image, you can use the image as a buttonicon in another stack.)</p><p>If one stack in a stack file is loaded into memory, so are any otherstacks in the same stack file. You cannot load one stack in a stack filewithout loading all the rest at the same time even if you open only oneof the stacks.</p><p>A stack can be loaded into memory without being open under the followingconditions:</p><p>A piece of code in another stack read or set a property within theclosed stack. This automatically loads the referenced stack into memory.</p><p>The stack is in the same stack file as another stack that is open.</p><p>The stack was opened and then closed, and its <strong>destroyStack</strong> propertyis set to false. If the <strong>destroyStack</strong> property is false, the stack isclosed but not unloaded when its window is closed.</p><blockquote><p><strong>Tip:</strong> To manipulate a stack window in an external, use the<strong>windowID</strong> property. For more information, see the <em>LiveCode Dictionary</em>.</p></blockquote><h3>Media &amp; Resources</h3><p>When planning a project, it is important to consider what types of mediayou will need to access and how to structure access to that media.</p><p>LiveCode supports a wide range of media formats. Media can be accessedusing the built-in media support, through QuickTime on older Mac OS X systems or via an external library. The advantage of using the built-in support is that you can consistently display or play back the media on all platforms without having to check that any 3<sup>rd</sup> party component has been installed. Other 3<sup>rd</sup> party libraries may allow a greater range of media access.</p><p>Since each loaded stack file takes up as much memory as the size of allits stacks, it is often advisable to place large, seldom-used objects(such as color pictures, sound, and video) in external files, which canbe bundled with your application and loaded into memory only when youneed them.</p><p>The built-in media support allows you to embed media directly withinyour stack file, or to reference it externally, storing it in a datafolder, online or on a CD.</p><table><thead><tr><th><strong>Embedding Media within your project</strong></th><th><strong>Referencing Media externally</strong></th></tr></thead><tbody><tr><td>Allows distribution of a single-file application for easy, reliable distribution</td><td>Requires you to distribute the media files separately</td></tr><tr><td>Requires importing media whenever it is updated</td><td>Allows you to edit media files directly, they update automatically</td></tr><tr><td>Requires enough memory to load all the media</td><td>Makes it easy to load and unload media if you need to reduce memory requirements</td></tr><tr><td>Allows you to use the built-in editing capabilities directly</td><td>Requires you to import and export the media to use the built-in editing capabilities</td></tr><tr><td>Is less practical for creating large themed or localized applications where one set of media is replaced with another set</td><td>Makes it easy to create themed or localized applications by simply linking to a different directory</td></tr></tbody></table><blockquote><p><strong>Tip:</strong> When importing images, use the Image Library, or create a‘library’ card that contains all the originals, then reference thoseobjects throughout your project. For more details on referencingimages, see the section on the <em>button</em> object.</p></blockquote><p>For details of the image formats supported natively, see the section onthe <em>Image</em> object. For details of the audio formats supported natively,see the section on the <em>audioClip</em> object. For details on how to controla movie, see the section on the <em>Player</em> object.</p><h3>How to Use External Files</h3><p>There are three main ways to use external files:</p><p>Keep media such as images, sounds, and video in external files, in theappropriate format, and use referenced controls to display the contentsof the files. When you use a referenced control, the image, sound, orvideo file is loaded into memory only when a card that contains thereferenced control is being displayed. The memory needed for the image,sound, or video is therefore only used when actually needed. By using<em>relative file paths</em>, you can move the application and its data filesto any other system. For more details on using file paths, see thesection on <em>File Name Specifications and File Paths</em>.</p><blockquote><p><strong>Note:</strong> To create a referenced control, use the &quot;New ReferencedControl&quot; submenu in the File menu, or create an empty image or playerobject, then set the object&#39;s <strong>fileName</strong> property to a file path forthe file you want to reference. For more details, see the section on<em>Building a User Interface</em>.</p></blockquote><p>Keep portions of your application in a separate stack file, and refer tothe stacks in that stack file as necessary. The <strong>stackFiles</strong> propertysimplifies referring to external stack files. When you set a stack&#39;s<strong>stackFiles</strong> property to include one or more file paths, the stacks atthose locations become available to your stack by simply referring tothe stacks by name.</p><p>Keep portions of your application on a server, and download them usingthe built in URL commands. For more details on the URL commands, see thesection on <em>Working with Files, URLs &amp; Sockets</em>.</p><h3>When to use a Database</h3><p>You don&#39;t need to use an external database to store information for yourapplication. You can store information in stacks, in text files, and ina variety of other files, read it into your application as needed, andmodify it. However, as a rule of thumb, we recommend that when you haveover two thousand records of information, or you want to allow multipleusers to access information at the same time, you consider using adatabase.</p><p>In these circumstances an external database offers many advantages. Adatabase located on your local machine will be fast and efficient ataccessing and searching records. A database located on a server can beaccessed by more than one user. Depending on the particularimplementation, a database may be suitable for constant access byhundreds of users, each receiving and updating data continually. SQLdatabases have built-in record-locking capabilities, preventing oneuser&#39;s changes from wiping out another&#39;s— a necessity for reliablemulti-user databases. Other built-in features work behind the scenes toensure the data in the database is not corrupted by interference betweendifferent users.</p><p>SQL databases are also built for speed. When searching tens or hundredsof megabytes or more, the performance of an optimized database willgenerally be much better than that of a stack doing the same search.Moreover, stacks must be loaded into memory to be searched, andtherefore the whole collection of data must fit into local memory.</p><p>Finally, if you use an external database, you can put the heavy-dutyprocessing on a server designed for the purpose, while using LiveCode&#39;sflexibility to give the user options for selecting data, then presentingit in a usable form.</p><p>With LiveCode’s built in <em>Database Library</em>, your application cancommunicate with external SQL databases. You can get data fromsingle-user and multi-user databases, update data in them, getinformation about the database structure, and display data from thedatabase in your stack. </p><p>For more details on working with databases, see the <em>Working with Databases</em> guide.</p><h3>LiveCode Memory Limits</h3><p>The following table details the memory limits for different types ofLiveCode components. Please note that these limits refer to the maximumsthat may be in use at any one time. You can store additional informationon disk or in a database and load it when it is required.</p><h4>A note about entries designated as &quot;Unlimited&quot;:</h4><p>Since each open stack file resides completely in memory, LiveCode stacks(and all structures within a stack) are effectively limited by availablememory and by LiveCode&#39;s total address space of 4G (4,294,967,296 bytes)on 32-bit systems</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>Total addressable space</td><td>4 GB (on 32-bit systems)</td></tr><tr><td>Maximum length of a line in a field</td><td>65,536 characters storage <br> No more than 32,786 pixels wide for display</td></tr><tr><td>Maximum size of an object</td><td>Unlimited</td></tr><tr><td>Maximum number of objects in a group</td><td>Unlimited</td></tr><tr><td>Maximum number of objects on a card</td><td>Unlimited</td></tr><tr><td>Maximum number of cards in a stack</td><td>Unlimited</td></tr><tr><td>Maximum number of objects in a stack</td><td>Unlimited</td></tr><tr><td>Maximum length of object names</td><td>65,536 characters</td></tr><tr><td>Maximum length of custom property names</td><td>255 characters</td></tr><tr><td>Maximum length of command or function names</td><td>65,536 characters</td></tr><tr><td>Maximum size of custom properties</td><td>Unlimited</td></tr><tr><td>Maximum number of custom properties</td><td>Unlimited</td></tr><tr><td>Maximum size of a script</td><td>Unlimited</td></tr><tr><td>Maximum size of other properties</td><td>64K</td></tr><tr><td>Maximum nesting level in control structures</td><td>Unlimited</td></tr><tr><td>Maximum level of recursion</td><td>Unlimited</td></tr></tbody></table><h2><a name="//apple_ref/cpp/Guide/Building a User Interface" class="dashAnchor"></a>Building a User Interface</h2><p>The user interface for your application is often one of its mostimportant features. Building a clear, logical and aesthetically pleasinguser interface will make all the difference to the success of yourapplication. This chapter discusses how to build a user interface usingLiveCode. It tells you how to create and lay out controls, which objectsto use and even how to build your own custom objects. We then touchbriefly on some tips for good user interface design.</p><h3>Creating and Organizing Objects</h3><h4>Creating Controls with the Tools Palette</h4><p>The main tools palette allows you to change between Edit and Run mode, create objects, and edit bitmap images with the paint tools.</p><p><img src="images/script-build-ui-tools-palette.png" alt=""/></p><p>Figure 13 - The Main Tools Palette</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Run mode</strong></td><td>Click to enter run mode. When in run mode, objects receive all the normal messages that drive a LiveCode application. For example, clicking on a button in run mode will cause a <strong>mouseUp</strong> message to be sent to it and the script will run.</td></tr><tr><td><strong>Edit mode</strong></td><td>Click to enter edit mode. When in edit mode, objects do not receive messages when you click on them, and you can move, resize or edit the properties for objects. For more details about the run and Edit mode, see the section <em>The ‘Edit’ and ‘Run’ Mode</em>.</td></tr><tr><td><strong>Widget objects</strong><br><strong>Button objects</strong><br><strong>Field objects</strong><br><strong>Scrollbar objects</strong><br><strong>Image &amp; Player</strong><br></td><td>Drag any object within these areas onto an editable stack to create a new object. Double-click an object to create a object of that type in the center of the front most editable stack. For more details on all of these objects, see the section about each object type later in this chapter.</td></tr><tr><td><strong>Vector Graphics</strong></td><td>Press the grey triangle at the bottom right of the Image &amp; Player area to hide and show this section. Click to choose the type of new graphic you want to create. Use the fill bucket to choose the fill color, the fill pencil to choose the line color, the line thickness menu to choose the line thickness, and the optional shape menu to choose preferences specific to the type of graphic selected. Click and drag in an editable stack to create the new graphic.</td></tr><tr><td><strong>Bitmap graphics</strong></td><td>The paint tools allow you to edit bitmap graphics that have been imported into LiveCode or create your own. To use them, create an image object and paint within that area, or modify an existing image. You cannot use the paint tools to edit an image that has its filename property set, as that image data is stored outside LiveCode. For more details on working with images, see the section on <em>Images</em> later in this chapter and the chapter on <em>Working with Media</em>.</td></tr></tbody></table><blockquote><p><strong>Tip:</strong> You can also create objects using the <strong>New Control</strong>sub-menu in the Object menu, or by typing <strong>create [object type]</strong> inthe Message box. For more information on creating objects using theMessage Box, see the section on <em>Building Interfaces Using Scripts</em>,later in this chapter.</p></blockquote><p>To open a system-standard color chooser, double-click on color chooserpopup menus at the bottom of the Vector Graphics or Bitmap Graphicssections of the tools palette.</p><h4>Alignment &amp; Layering</h4><p><img src="images/script-build-ui-size-position.png" alt=""/></p><p>Figure 14 – Size &amp; Position Inspector</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Lock size and position</strong></td><td>Locks the object so that its size and position cannot be adjusted interactively with the mouse when in edit mode. This also prevents images, groups and players from automatically resizing to display their entire content whenever the card that they are on is reopened. For more details see the entry for <em>lockLocation</em> in the LiveCode Dictionary.</td></tr><tr><td><strong>Width &amp; Height</strong></td><td>Allows you to set the width and height of the object(s) currently being operated on by the Property Inspector. Objects are resized from their center. For more details, see the <em>width</em> and <em>height</em> properties in the LiveCode Dictionary.</td></tr><tr><td><strong>Fit Content</strong></td><td>Automatically sizes the object large enough to display its content. In the case of buttons, the content is the text and any icon. For images, this is the native width and height of the original image before any scaling. For more details, see the entry for <em>formattedWidth</em> and <em>formattedHeight</em> in the LiveCode Dictionary.</td></tr><tr><td><strong>Location</strong></td><td>Sets the objects position (the center of the object) relative to the top left of the card.</td></tr><tr><td><strong>Left, Top, Right &amp; Bottom</strong></td><td>Sets the position of one of the object’s edges.</td></tr><tr><td><strong>Layer</strong></td><td>Sets the layer of the object. The buttons with arrows allow you to send an object to the back, move an object back one layer, bring an object forward one layer and bring an object to the front. Layer determines which objects are displayed in front or behind others, as well as the object’s number and tabbing order. Note that you cannot relayer objects that are grouped unless you are in edit background mode, or have the <em>relayerGroupedControls</em> set to true. For more details, see the section on <em>Group &amp; Backgrounds</em>. For more details on tabbing order see the section on <em>The Keyboard Focus</em> below.</td></tr></tbody></table><p>Use the Align Objects Inspector to resize objects relative to otherobjects, to reposition objects and/or to relayer objects.</p><p><img src="images/script-build-ui-align-objects.png" alt=""/></p><p>Figure 15 – Align Objects Inspector</p><p>To open the Align Objects Inspector, select multiple objects, then openthe Inspector and choose Align Objects from the menu at the top of theInspector. The Align Objects pane will automatically be displayed if youselect multiple objects of different types.</p><blockquote><p><strong>Important:</strong> The Align Objects Inspector resizes objects relative toeach other. Always select the object you want to use as a referencefirst, then select other objects that you want to make the same asthat object next. If you want to distribute objects, select them inthe order that you would like them to be distributed.</p></blockquote><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Equalize</strong></td><td>Make objects the same width, height, or have exactly the same rectangle.</td></tr><tr><td><strong>Align</strong></td><td>Aligns the objects by their left, right, top or bottom edges, or by their horizontal center or vertical center, using the first object selected as a reference.</td></tr><tr><td><strong>Distribute</strong></td><td>Distributes the objects with an equal difference between them, using the order they were selected. ‘First to last’ selected will distribute objects evenly between the edges of the first and last objects selected. ‘Edge to edge’ will distribute the objects so that their edges touch each other exactly. ‘Across card’ will distribute the objects evenly over the entire card area.</td></tr><tr><td><strong>Nudge</strong></td><td>Nudge the selected object the number of pixels specified in the center of the arrows. To change the number of pixels, click on the number.</td></tr><tr><td><strong>Relayer</strong></td><td>‘First to last selected’ will relayer the objects in the selection in the order they were selected. &#39;Last to first&quot; will relayer the objects in reverse order. Use these buttons to set the tab order of a set of objects. For more information on the tabbing order, see the section on <em>The Keyboard Focus</em> below.</td></tr></tbody></table><h4>The Keyboard Focus</h4><p>The focus is an indication to the user of which control will receive akeystroke. Exactly which objects are capable of receiving the keyboardfocus depend on the current operating system, and the properties appliedto the control. Edit fields can receive the focus, as can all otherobjects on Windows and Linux, and many objects on Mac OS.</p><p>The order in which the user moves through controls that can receive thekeyboard focus is determined by the object’s layer. When a card isopened, LiveCode automatically focuses the first object on the card thatis capable of receiving the keyboard focus.</p><p>You can turn on the ability of an object to get the keyboard focus bychecking the <em>Focus with Keyboard</em> option in the object’s Inspector, orby setting its <em>traversalOn</em> property by script.</p><p>On some platforms objects give an indication that they have the focus bydisplaying a border. You can specify whether a border should bedisplayed by setting an object’s Show Focus Border option in theInspector, or setting its <em>showFocusBorder</em> property by script.</p><h3>Object &amp; Control Types</h3><h4>Stacks – for displaying windows, palettes and dialog boxes</h4><p>In LiveCode, each window is a stack. This includes editable windows,modeless and modal dialog boxes, and palettes, as well as sub-windowsavailable on some operating systems, such as sheets and drawers.</p><blockquote><p><strong>Tip:</strong> If you want to make controls within a stack scale andposition automatically when you resize the stack, see the section onthe <em>Geometry Manager</em>.</p></blockquote><p>This topic discusses the way windows are implemented in LiveCodeapplications; how to change window appearance; and how to control thebehavior of the various window types. This topic does not cover theorganization of stacks within a stack file, which is covered in detailin the section <em>Structuring Your Application</em>.</p><blockquote><p><strong>Caution:</strong> Do not start your stack name with &quot;rev&quot;. Stacks withnames starting with &quot;rev&quot; are reserved by the LiveCode developmentenvironment.</p></blockquote><p>You create a new stack – which can then be displayed in any number ofmodes (as described below) – by choosing <strong>File -&gt; New Mainstack</strong>. Youcan edit stack properties by choosing <strong>Object -&gt; Stack Inspector</strong>.</p><h4>Window Types and the Mode of a Stack</h4><p>The nature of a stack&#39;s window depends on the stack&#39;s <strong>style</strong> propertyand on what command was used to open the stack. You can either specifythe window type when opening the stack, or allow the stack&#39;s <strong>style</strong>property to determine the type of window it is displayed in.</p><blockquote><p><strong>Note:</strong> We recommend you specify the mode you want a stack to beopened in as part of the command you use to open the stack, ratherthan using the style property. This makes it easy to switch a stackbetween editable mode in the development environment, and for example,a dialog in the runtime environment.</p></blockquote><h4>The Standard Window Types</h4><p>LiveCode windows are usually one of four types: editable or <strong>topLevel</strong>windows, <strong>modal</strong> or <strong>modeless</strong> dialog boxes, or <strong>palette</strong> windows.</p><blockquote><p><strong>Important:</strong> You will normally create a new stack and edit it whileit is in editable mode. If you want to create a dialog, create thestack like any other stack. Then when opening it, specify in thescript that it should be displayed as a dialog, or a palette, etc. Theappropriate commands for doing this are detailed with each type ofwindow below.</p></blockquote><p>You can test out these commands as you work on your window layout andscripts, using the <em>Message Box</em> (see section of the same name), orusing the <em>window context menu</em> (see <em>Modal Dialog Boxes</em>, below). Formore details on wr<code>it</code>ing scripts in general, see the section on <em>Codingin LiveCode</em>.</p><p>Most windows are editable or <strong>topLevel</strong> windows, and this is thedefault mode for LiveCode stacks. If you open a stack using the <strong>go</strong>command (without specifying a mode), or using the Open Stack menu item,then the stack is displayed as an editable window unless its <strong>style</strong>property specifies another window type.</p><h4>Editable Windows – for documents</h4><p>An editable window has the appearance and behavior of a standarddocument window. It can be interleaved with other windows, and you canuse any of LiveCode&#39;s tools to create, select, move, or delete objectsin the stack.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-editable-stack-mac.png" alt=""/></td><td><img src="images/script-build-ui-editable-stack-win.png" alt=""/></td><td><img src="images/script-build-ui-editable-stack-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 16 – Editable Document Windows on Multiple Platforms</p><p>To display a stack in an editable window, you use the <strong>topLevel</strong> or<strong>go</strong> commands:</p><pre><code>topLevel stack &quot;My Stack&quot;go stack &quot;My Stack&quot; – &quot;topLevel&quot; is the default modego stack &quot;My Stack&quot; as topLevel</code></pre><p>Stacks whose <strong>style</strong> property is set to &quot;topLevel&quot; always open aseditable windows, regardless of what command you use to open them.</p><blockquote><p><strong>Note:</strong> If the stack&#39;s <strong>cantModify</strong> property is set to true, thewindow retains its standard appearance, but tools other than theBrowse tool can no longer be used in it. In other words, every toolbehaves like the Browse tool when clicking in an unmodifiable stack&#39;swindow.</p></blockquote><h4>Modeless Dialog Boxes – for alerts and settings</h4><p>Modeless dialog boxes are similar to editable windows. Like editablewindows, they can be interleaved with other windows in the application.Their appearance may differ slightly from the appearance of editablewindows, depending on the platform.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-modeless-stack-mac.png" alt=""/></td><td><img src="images/script-build-ui-modeless-stack-win.png" alt=""/></td><td><img src="images/script-build-ui-modeless-stack-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 17 – Modeless Dialog Boxes on Multiple Platforms</p><p>Like unmodifiable stacks, modeless dialog boxes do not allow use oftools other than the Browse tool. Use modeless dialog boxes in yourapplication for windows such as a Preferences or Find dialog box, thatdo not require the user to dismiss them before doing another task.</p><p>To display a stack in a modeless dialog box, you use the <strong>modeless</strong> or<strong>go</strong> commands:</p><pre><code>modeless stack &quot;My Stack&quot;go stack &quot;My Stack&quot; as modeless</code></pre><p>Stacks whose <strong>style</strong> property is set to &quot;modeless&quot; always open asmodeless dialog boxes, regardless of what command you use to open them.</p><h4>Modal Dialog Boxes – for alerts and settings</h4><p>A modal dialog box is a window that blocks other actions while thewindow is displayed. You cannot bring another window in the applicationto the front until the dialog box is closed, nor can you edit the stackusing the tools in the Tools palette. While a modal dialog box is beingdisplayed, the handler that displayed it pauses until the dialog box isclosed.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-modal-stack-mac.png" alt=""/></td><td><img src="images/script-build-ui-modal-stack-win.png" alt=""/></td><td><img src="images/script-build-ui-modal-stack-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 18 – Modal Dialog Boxes on Multiple Platforms</p><p>Modal dialog boxes do not have a close box. Usually, they contain one ormore buttons that close the window when clicked.</p><blockquote><p><strong>Important:</strong> If you mistakenly open a modal dialog box withouthaving included a button to close the window, use the contextual-menushortcut (Control-Shift-Right-click for Unix or Windows,Command-Control-Shift-click for Mac OS) to display a context menu.Choose <em>toplevel</em> to make the stack editable.</p></blockquote><p>To display a stack in a modal dialog box, you use the <strong>modal</strong> command or <strong>go</strong> commands:</p><pre><code>modal stack &quot;My Stack&quot;go stack &quot;My Stack&quot; as modal</code></pre><p>Stacks whose <strong>style</strong> property is set to &quot;modal&quot; always open as modal dialog boxes, regardless of what command you use to open them.</p><h4>Palettes – for accessory and tool windows</h4><p>A palette has a slightly different appearance, with a narrower title barthan an editable window. Like dialog box windows, a palette does notallow use of tools other than the Browse tool.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-palette-stack-mac.png" alt=""/></td><td><img src="images/script-build-ui-palette-stack-win.png" alt=""/></td><td><img src="images/script-build-ui-palette-stack-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 19 – Palette Windows on Multiple Platforms</p><p>A palette floats in front of any editable windows or modeless dialogboxes that are in the same application. Even when you bring anotherwindow to the front, it does not cover any palettes.</p><blockquote><p><strong>Note:</strong> On some Linux systems, palettes have the same appearance andbehavior as ordinary windows and do not float. On Mac OS X systems,palette windows disappear when their application is in the backgroundand another application is in front.</p></blockquote><p>To display a stack in a palette, you use the <strong>palette</strong> command or <strong>go</strong> commands:</p><pre><code>palette stack &quot;My Stack&quot;go stack &quot;My Stack&quot; as palette</code></pre><p>Stacks whose <strong>style</strong> property is set to &quot;palette&quot; always open as palettes, regardless of what command you use to open them.</p><h4>Ask Question Dialog – for asking a question</h4><p>The ask question dialog is a special type of window that is designed tomake it easy to ask the user a question. It includes special syntax foropening the dialog with question text and returning any answer to thescript that called it. You can also specify the window title, as well asan icon to be displayed in the window. The font, object positions,button order and icon will <em>automatically change</em> to reflect theoperating system. However, if you do require more flexibility than isprovided in this dialog, you should create your own modal dialog boxinstead (see above).</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-ask-dialog-mac.png" alt=""/></td><td><img src="images/script-build-ui-ask-dialog-win.png" alt=""/></td><td><img src="images/script-build-ui-ask-dialog-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 20 – Ask Question Dialog Boxes on Multiple Platforms</p><p>To display the ask dialog, use the following commands:</p><pre><code>ask &quot;What is your name?&quot;ask question &quot;What is the answer?&quot; titled &quot;Question&quot;</code></pre><blockquote><p><strong>Tip:</strong> You can try this example out right now by coping and pasting it into <strong>Tools -&gt; Message Box</strong>, then pressing return.</p></blockquote><p>The word question specifies the icon, and may be any of question |information | error warning.</p><p>To change the miniature application icon shown in the Mac OS X platformpicture above, see the entry for gREVAppIcon in the <em>LiveCode Dictionary</em>.</p><p>The result is returned in the <em>special variable</em> it.</p><pre><code>if it is &quot;Joe&quot; then doSomeThing</code></pre><p>For complete details on the syntax, see the ask command in the <em>LiveCode Dictionary</em>.</p><p><img src="images/image62.png" alt=""/></p><p>Figure 21 – Icons for Ask and Answer Dialogs on Multiple Platforms</p><h4>Answer Alert Dialog – for displaying a dialog</h4><p>Like the ask dialog box above, the answer dialog is a special dialogthat has been designed to make it easy to display information in adialog on screen and optionally allow the user to make a choice from alist of up to seven choices. The answer command opens the dialog, letsyou specify the text and the button choices, and returns the buttonclick to the script that called it. You can also specify the windowtitle, as well as an icon to be displayed in the window. As with the askdialog, the font, object positions, button order and icon will<em>automatically change</em> to reflect the operating system. However, if youdo require more flexibility than is provided in this dialog, you shouldcreate your own modal dialog box instead (see above).</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-answer-dialog-mac.png" alt=""/></td><td><img src="images/script-build-ui-answer-dialog-win.png" alt=""/></td><td><img src="images/script-build-ui-answer-dialog-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 22 – Answer Dialogs on Multiple Platforms</p><pre><code>answer &quot;Hello World!&quot;answer question &quot;What city is the capital of Italy?&quot; with \     &quot;Paris&quot; or &quot;London&quot; or &quot;Rome&quot; titled &quot;Multiple Choice&quot;</code></pre><p>The result is returned in the <em>special variable</em> it.</p><pre><code>if it is &quot;Rome&quot; then     answer information &quot;That was the correct answer.&quot;end if</code></pre><p>For complete details on the syntax, see the answer command in the <em>LiveCode Dictionary.</em></p><p>The answer dialog is implemented internally as a stack attached to theLiveCode IDE. For details on customizing the IDE, see the section on<em>Editing the LiveCode User Interface</em>.</p><blockquote><p><strong>Tip:</strong> If you&#39;re not sure what a stack&#39;s name is, you can use the<strong>mouseStack</strong> function to find out. Enter the following in theMessage Box (Tools -&gt; Message Box), then move the mouse pointer overthe stack window and press Return: <code>put the mouseStack</code></p></blockquote><h4>File Selector Dialogs</h4><p>The file selector dialogs allow you to display the system standarddialogs. These dialogs allow the user to select a file or a set offiles, select a directory, or specify a name and location to save afile.</p><p>The syntax for bringing up the file selector dialogs mirrors the syntaxfor the alert and question dialogs detailed above. However, unlike thesedialogs, the file selector dialogs are displayed using the systemstandard dialogs where available. The notable exception at the time ofthis writing is Linux platform, where a built-in dialog is used insteaddue to more limited OS support. (You can force the other platforms touse this built-in stack based file selector by setting the<em>systemFileSelector</em> global property.)</p><p><img src="images/image64.png" alt=""/></p><p>Figure 23 – Answer File dialog for selecting a file</p><pre><code>answer file &quot;Select a file:&quot;answer file &quot;Select an image file:&quot; \     with type &quot;Movies|avi&quot; or type &quot;All Files|&quot;</code></pre><p>The file path to the file selected by the user is returned in the<em>special variable</em> it. If the user cancelled the dialog, the specialvariable <strong>it</strong> will be empty and &quot;cancel&quot; will be returned by <em>the result</em> function.</p><p>For complete details on the syntax, see the <strong>answer file with type</strong> command in the <em>LiveCode Dictionary.</em></p><p><img src="images/image65.png" alt=""/></p><p>Figure 24 – Ask File dialog for saving a file</p><pre><code>ask file &quot;Save this document as:&quot; with &quot;Untitled.txt&quot; answer file &quot;Select an image file:&quot; \     with type &quot;Text Files|txt&quot; or type &quot;All Files|&quot;</code></pre><p>The file path to the file to be saved is returned in the specialvariable <strong>it</strong>. If the user cancelled the dialog, the it variable will be empty and cancel will be returned by <em>the result</em> function.</p><p>For complete details on the syntax, see the ask file with type in the<em>LiveCode Dictionary.</em></p><p><img src="images/image66.png" alt=""/></p><p>Figure 25 – Answer folder dialog for choosing a directory</p><pre><code>answer folder &quot;Please choose a folder:&quot;answer folder &quot;Please choose a folder:&quot; with &quot;/root/default folder&quot;</code></pre><p>The file path to the folder selected by the user is returned in thespecial variable <strong>it</strong>. If the user cancelled the dialog, the <strong>it</strong>variable will be empty and &quot;cancel&quot; information will be returned by <em>the result</em> function.</p><p>For complete details on the syntax, see answer folder in the <em>LiveCode Dictionary</em>.</p><h4>Color Chooser Dialog</h4><p>The <strong>answer color</strong> dialog allows you to display the operating system’sstandard color picker dialog.</p><p><img src="images/script-build-ui-answer-color.png" alt=""/></p><p>Figure 26 – Answer color dialog for choosing a color </p><pre><code>answer color</code></pre><p>The color chosen is returned in the special variable <strong>it</strong>. If theuser cancelled the dialog, it will be empty and &quot;cancel&quot; will bereturned by <em>the result</em> function.</p><p>For complete details on the syntax, see answer color in the <em>LiveCode Dictionary.</em></p><h4>Printer Dialogs</h4><p>The printer dialogs allow you to display the standard printer and page setup dialogs.</p><p><img src="images/image68.png" alt=""/></p><p>Figure 27 – Answer printer for standard printer dialog</p><p>Use the <strong>answer printer</strong> command to display a standard printer dialog prior to printing. If the user cancels the dialog, &quot;cancel&quot; will be returned by <em>the result</em> function.</p><h4>Alpha Blend Windows – for Enhanced Tooltips and Multimedia</h4><p>Use the <em>Shape</em> option in the <em>Stack Inspector</em> to set a stack’s<strong>windowShape</strong> property to the transparent, or <em>alpha channel</em> of animage that has been imported together with its alpha channel (i.e. ineither PNG or GIF format). This allows you to create a window with&quot;holes&quot; or a window with variable translucency. You can apply a shape toany type of stack, regardless of the mode it is opened, allowing such awindow to block as a dialog, float as a palette, etc.</p><blockquote><p><strong>Important:</strong> The border and title bar of a stack are not shown ifthe stack&#39;s <strong>windowShape</strong> is set. This means you will need to providemethods of dragging and closing the window if you want the user to beable to do these tasks.</p></blockquote><p><img src="images/script-build-ui-window-shape.png" alt=""/></p><p>Figure 29 – Window with alpha mask applied</p><p>You can change the <strong>windowShape</strong> property dynamically by script to aseries of images to create an animated translucent window.</p><h4>System Palettes – for utilities floating above applications</h4><p>A system palette is like a palette, except that it floats in front ofall windows on the screen, not just the windows in its application. Usesystem palettes for utilities that you want the user to be able to seeand access in every application.</p><p><img src="images/script-build-ui-system-window.png" alt=""/></p><p>Figure 30 – System Window floating above other applications</p><p>To display a stack in a system palette, you turn on the check box in theStack Inspector &quot;Float Above Everything&quot;. For more details on thisfeature, see the entry for systemWindow in the <em>LiveCode Dictionary</em>.</p><p>Using this feature overrides the stack&#39;s <strong>style</strong> or <strong>mode</strong>.</p><p>The system palette style is currently not supported on Linux &amp; Unix.</p><h4>Stack menus – for displaying non-standard menus</h4><blockquote><p><strong>Note:</strong> Usually a menu in a LiveCode application is implemented as abutton. We recommend that menus are implemented using buttons, asthese will automatically be drawn with the native theme on eachplatform. For more details, see the section on Menus below</p></blockquote><p>It is also possible to display a stack as a <em>pulldown</em>, <em>popup</em>, or<em>option</em> menu. Stack menus are used when a menu needs to containsomething other than just text. For example, a popup menu containing aslider, or an option menu consisting of icons instead of text, can beimplemented as a stack menu.</p><p>To display the stack menu, you create a button and set its <strong>menuName</strong>property to the stack&#39;s name. When the user clicks the button, the stackis displayed with the behavior of a menu. Internally, the menu isimplemented as a window, and you can use the <strong>popup</strong>, <strong>pulldown</strong>, or<strong>option</strong> command to display any stack as one of these menu types.</p><h4>Stack Decorations – for Window Appearance</h4><p>Stack decorations allow you to specify how the title bar and border of awindow will be drawn. You can access the stack decorations options in<strong>Object -&gt; Stack Inspector</strong>.</p><p>Apart from the differences in appearance between different window modes,the appearance and functionality of a window can vary depending on thestack&#39;s properties and the platform it is being displayed on.A window&#39;stitle bar displays the window&#39;s title, as well as a close box, minimizebox or collapse box, and maximize box or zoom box.</p><p><img src="images/image72.png" alt=""/></p><p>Figure 31 – Window Decorations on Windows and Mac OS X</p><blockquote><p><strong>Note:</strong> On Mac OS X, a stack&#39;s <strong>shadow</strong> property controls whetherthe stack window has a drop shadow. On OS X systems, you can set thisproperty to false to create a window with no shadow.</p></blockquote><p>The properties above can also be set by script, for more details see the<strong>decorations</strong> property in the <em>LiveCode Dictionary</em>.</p><p>While the stack&#39;s mode is separate from its <strong>decorations</strong>, the modemay affect whether these properties have an effect. If the<strong>decorations</strong> property is set to &quot;default&quot;, it displays theappropriate decorations <em>for the current window type</em> on the currentplatform.</p><h4>Button Controls – for performing actions</h4><p>A button is a clickable object that is typically for allowing a user toperform an action by clicking.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-standard-button-mac.png" alt=""/></td><td><img src="images/script-build-ui-standard-button-win.png" alt=""/></td><td><img src="images/script-build-ui-standard-button-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-default-button-mac.png" alt=""/></td><td><img src="images/script-build-ui-default-button-win.png" alt=""/></td><td><img src="images/script-build-ui-default-button-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-rectangle-button-mac.png" alt=""/></td><td><img src="images/script-build-ui-rectangle-button-win.png" alt=""/></td><td><img src="images/script-build-ui-rectangle-button-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 32 – Button Objects on Multiple Platforms</p><p>Check boxes and radio buttons are used to allow the user to makechoices. Radio buttons are used when only one option for a set ofoptions may be selected at any time. Check boxes are used where someoptions may be turned on and others may be off.</p><blockquote><p><strong>Note:</strong> LiveCode will automatically enforce the rule of highlightingone radio button at a time if you place the radio buttons together ina group. For more details on groups, see the section on <em>Groups and Backgrounds</em>.</p></blockquote><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-check-box-mac.png" alt=""/></td><td><img src="images/script-build-ui-check-box-win.png" alt=""/></td><td><img src="images/script-build-ui-check-box-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-radio-button-mac.png" alt=""/></td><td><img src="images/script-build-ui-radio-button-win.png" alt=""/></td><td><img src="images/script-build-ui-radio-button-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 33 – Check Boxes and Radio Buttons on Multiple Platforms</p><p>All button objects in LiveCode are highly flexible and customizable.Common settings include the ability to show and hide the border or fill,and to display an icon.</p><p>Icons allow you to provide a wide range of functionality. For exampleyou can create a roll over effect by setting a hover icon. Or you cancreate a custom check box by setting an icon and a highlight icon –doing so will replace the system standard check box and display youricon in each state depending on whether the button has been pressed ordepressed.</p><p><img src="images/image75.png" alt=""/></p><p>Figure 34 – Custom Buttons for Multimedia</p><blockquote><p><strong>Important:</strong> Button icons are not limited in width or height. Theycan be animated by using an animated GIF. In fact, an icon canreference <strong>any</strong> image contained within your LiveCode stack file.Referencing an image in this way saves disk space and allows you toupdate all icons in your stack by updating a single image. See thechapter <em>Working with Media</em> for more information.</p></blockquote><h4>Text Field Controls – for displaying or entering text</h4><p>Fields allow you to display text. Fields can optionally allow the userto edit the text. Fields support multiple fonts, styles and colors,images and a subset of basic HTML tags. Fields can be linked to adatabase using the Database Query Builder or by directly accessing adatabase with the database library. They can display and render XMLusing the XML library. List fields allow the user to select one or a setof choices. Table fields allow display of data similar to a spreadsheet.Other types of field can easily be created, including tree views, or anyhybrid between these types, with a little scripting. At the time of thiswriting there is also a 3<sup>rd</sup> party library available thatallows you to host a web browser within an object and control it byscript.</p><p><img src="images/image76.png" alt=""/></p><p>Figure 35 – Field Controls</p><h4>List and Table Field Controls</h4><p>List fields allow you to display a set of choices. Users cannot editlist fields. You can specify whether the user is allowed to make asingle selection or multiple selections.</p><p><img src="images/image77.png" alt=""/></p><p>Figure 36 – List Fields</p><h4>Table Field Control – for displaying a table</h4><p>Table fields allow you to display data in cells, and optionally allowthe user to edit the cells. Table fields are ideal for displaying basictabular data. For more complex data display requirements we recommendyou use the Data Grid control.</p><p><img src="images/image78.png" alt=""/></p><p>Figure 37 – Table Field</p><h4>Data Grid Control – for presenting data</h4><p>Data Grids allow you to display data in both grid and form modes. Youcan customize a data grid to include custom layouts that include anyother LiveCode object. Data grids can provide a view into a data source,allowing you to display large data sets. For full documentation on usingdata grids, see the <a href="http://lessons.runrev.com/spaces/lessons/manuals/datagrid">onlinedocumentation</a></p><p><img src="images/image79.png" alt=""/></p><p>Figure 38 – Data Grid</p><h4>Cards</h4><p>Each stack contains one or more separate screens of controls. Eachscreen is known as a card. Each card can have an entirely differentappearance, or all the cards in a stack can share some or all elements,by using <em>shared groups</em>, known as <em>backgrounds</em> (see below).</p><p>Choosing <strong>Object -&gt; New Card</strong> will create a new card within thecurrent stack. The new card will either be completely blank, or willcontain any shared groups from the previous card.</p><h4>Groups &amp; Backgrounds – for organizing, and sharing controls</h4><p>Groups, LiveCode&#39;s most versatile object type, are used for severalpurposes: radio button clusters; menu bars; for creating scrollableobject areas within cards; and as backgrounds for displaying sets ofobjects that are shared between cards. Groups can also be used forcreating a simple card and stack database, by holding fields thatcontain a different record on each card.</p><h5>What Is a Group?</h5><p>A group is a single object that holds a set of objects. Objects aregrouped by selecting the controls you want to include in the group, thenusing the <strong>group</strong> command or choosing <strong>Object –&gt; Group Selected</strong>.</p><p>Once you&#39;ve created the group, it becomes an object in its own right.You can select, copy, move, and resize the group, and all the objects inthe group come with it. The objects in the group maintain their ownidentities, and you can add objects to the group or delete them, but theobjects are owned by the group instead of the card.</p><p>A group has its own properties and its own script. Groups can be anysize, can be shown or hidden, and can be moved to any location in thestack window, just like any other control. Like other controls, groupscan be layered in any order with the other controls on the card. Groupscan also display a border around a set of objects.</p><p><img src="images/image80.png" alt=""/></p><p>Figure 39 – Group of radio buttons with group title and border</p><p>Unlike other controls, however, groups can appear on more than one card.You place a group on a card using the <strong>place</strong> command or the <strong>Place Group</strong> submenu in the <strong>Object menu</strong>.</p><blockquote><p><strong>Important:</strong> A group that is shared between cards appears at thesame location on each card. A change made to the position of a sharedgroup on one card is reflected on all the other cards that share thegroup.</p></blockquote><h5>Groups and Backgrounds</h5><p>Both the term <strong>group</strong> and the term <strong>background</strong> can be used to referto groups. The terms are interchangeable in some circumstances and meandifferent things in others. The differences are explained in more detailbelow.</p><p>In general, the term <strong>group</strong> refers to groups that are placed on acard, while the term <strong>background</strong> refers to all the groups in a stackthat are available for use as <em>backgrounds</em> (see below). The expression</p><pre><code>the number of groups </code></pre><p>evaluates to the number of groups on the current card. The expressionthe number of backgrounds evaluates to the number of background groupsin the current stack, including groups that are not placed on thecurrent card.</p><blockquote><p><strong>Tip:</strong> When you refer to a group by number, if you use the word<strong>group</strong>, the number is interpreted as referring to the groups on thereferenced card, in order by layer. If you use the word<strong>background</strong>, the number is interpreted as referring to the groupsin the stack, in the order of their creation.</p></blockquote><p>For example, the expression the name of group 1 evaluates to the<strong>name</strong> of the lowest-layered group on the current card, while theexpression the name of background 1 evaluates to the <strong>name</strong> of thefirst group that was created in the stack--whether or not thatparticular group is placed on the current card, or appears on any cardat all.</p><p>The term <strong>background</strong> can be also used to refer to the set of cardsthat share a particular group. The following statement goes to the thirdcard on which the group named &quot;Navigation&quot; is placed:</p><pre><code>go card 3 of background &quot;Navigation&quot;</code></pre><h5>Nested Groups</h5><p>LiveCode supports nested groups (one group containing another). Since agroup is itself a control, it can be contained in another group.</p><p>Creating a nested group is just like creating a group: select thecontrols you want to group (including the existing group), then choose<strong>Object -&gt; Group Selected</strong>. The existing group is now a member of thenew group.</p><h5>Selecting and Editing Groups</h5><p>To select a group, simply click on one of the objects that is containedwithin it. This will select the group.</p><p>If you want to select an object within the group, instead of the groupitself, there are two ways to do so. You can turn on the <strong>Select Grouped</strong> option on the toolbar or in <strong>Edit -&gt; Select Grouped Controls</strong>. This causes groups to be ignoredwhen selecting objects, allowing you to select objects inside a group asif the group didn’t exist. You can enter this mode by script by togglingthe <strong>selectGroupedControls</strong> global property.</p><p>Alternatively you can go into edit group mode, a special mode that onlydisplays the objects within that group. Select the group, then press<strong>Edit Group</strong> on the toolbar or choose <strong>Object -&gt; Edit Group</strong>. Whenyou have finished, choose <strong>Object -&gt; Stop Editing Group</strong>. You cantoggle this mode programmatically by using the commands <strong>start editing</strong> and <strong>stop editing</strong>.</p><blockquote><p><strong>Tip:</strong> If a group&#39;s border has been set, an outline appears at thegroup&#39;s edges. However, clicking within or on the border does notselect the group. To select the group, you must click one of itscontrols.</p></blockquote><h5>Placing and Removing Backgrounds</h5><p>Once you create a group, you can display it on any or all cards in thestack. First, ensure that the group’s Behave as Background option hasbeen set in the Inspector. Then navigate to the card you want to placethe group on and choose <strong>Object -&gt; Place Group</strong> to place an instanceof a particular group on the current card. You can control thesefeatures from script by using the <strong>backgroundBehavior</strong> property and<strong>place</strong> command.</p><blockquote><p><strong>Note:</strong> When you create a new card, if there are any groups on thecurrent card whose Behave as Background has been set, they areautomatically placed on the new card. To make it easy for allthe cards in a stack to share a single group, create the group on thefirst card and set this property to true, before you create any othercards.</p></blockquote><p>To remove a group from the current card without deleting it from thestack select the group and choose <strong>Object -&gt; Remove Group</strong>. The groupdisappears from the current card, but it&#39;s still placed on any othercards that share the group. You can remove a group by script using the<strong>remove</strong> command.</p><blockquote><p><strong>Tip:</strong> You can use the <strong>start editing</strong> command from the MessageBox to edit a group that has not been placed on any card. Since thegroup is not on any card, you must refer to it using the term&quot;background&quot; instead of the term &quot;group&quot;.</p></blockquote><p>You can completely delete a group in the same way as you delete anyother object, by selecting the group and choose <strong>Edit -&gt; Clear</strong> orpressing backspace.</p><blockquote><p><strong>Important:</strong> Deleting a background group removes it from all thecards it appears on, and from the stack itself.</p></blockquote><p>To dissolve a group back into its component controls, select the groupand choose <strong>Object -&gt; Ungroup</strong>. You can ungroup a group by scriptusing the <strong>ungroup</strong> command. Ungrouping deletes the group object andits properties (including its script) from the stack, but does notdelete the controls in it. Instead, they become card controls of thecurrent card. The controls disappear from all other cards the group ison.</p><blockquote><p><strong>Note:</strong> If you ungroup a group, then select the controls and regroupthem before leaving the current card, the group is restored as it was.However, leaving the current card makes the ungrouping permanent anddeletes the group from all other cards it was on.</p></blockquote><h5>Groups and the Message Path</h5><p>For details on how groups and backgrounds fit into the Message Path, seethe section on <em>Groups, Backgrounds &amp; The Message Path</em>, below.</p><h4>Graphics, Images, Players, Audio &amp; Video Clip Objects – for multimedia</h4><p>LiveCode supports a wide range of media formats, allowing you to producerich media applications. The image object allows you to import orreference images, manipulate images by script or interactively with thepaint tools, and save them out in different formats with variablecompression options. Support extends to alpha channeled PNG images andanimated GIF images. Images can be imported and reused within a stack tocreate custom or interactive interface elements. To learn how to workwith these objects in a script, see the section on <em>Working with Media</em>.</p><p>Image formats supported include GIF, JPEG, PNG, BMP, XWD, XBM, XPM, orPBM, PGM, or PPM files. On Mac OS systems, PICT files can also beimported (but they cannot be displayed on Unix or Windows systems). Forfull details on each of these formats, see the section on <em>Working with Media</em>.</p><p>You can import images using <strong>File -&gt; Import as Control -&gt; ImageFile</strong>. You can reference an image using <strong>File -&gt; New Referenced Control -&gt; Image file</strong>.</p><p>Paint tools can only be used on images that have been imported as acontrol. See the section on <em>Using the Paint Tools</em> for details on howto use the paint tools.</p><p><img src="images/image81.png" alt=""/></p><p>Figure 40 – Image, Graphic and Player objects</p><p>Vector graphics can also be created and manipulated with the graphictools and by script. LiveCode supports paths with variable fills,gradients, blended and antialiased graphics. At time of this writingthere is also a 3<sup>rd</sup> party library that allows the import andexport of SVG format graphics. Use graphic objects to create interactiveinterfaces, graphs, charts or games.</p><p>Use the player object to display and interact with any media formatssupported by AVFoundation on Mac OS X and DirectShow on Windows. LiveCode allows you to turn on and off tracks within a movie and set callback messages that trigger scripts at specific points in the movie,and stream movies from a server. At time of this writing there is also a3<sup>rd</sup> party library that allows you to edit and save movies byscript.</p><p>The Audio Clip &amp; Video Clip objects allow you to embed audio or videoclip data within a stack. They do not have any visualrepresentation and can be accessed by script or in the ApplicationBrowser. Players, Audio &amp; Video clips are covered in their respectivesections within the chapter on <em>Working with Media</em>.</p><h4>Menu Controls – for displaying choices</h4><p>Menus are used to display a list of choices. The <em>pulldown</em> menudisplays a standard <em>pulldown</em> menu, and can be automatically insertedinto the main menu bar on Mac OS systems. The <em>option</em> menu allows achoice from a list. The combobox allows the user to type an <em>option</em> orchoose from a list. Popup menus can be displayed underneath the cursorand used to provide context sensitive options anywhere in yourapplication. For more information on working with <em>pulldown</em> menuswithin the main menu bar, see the section on the <em>Menu Builder</em> below.</p><p>Menu contents can be defined using a list of item names and specialcharacters to indicate where shortcuts and checkmarks should be placed.This is the most common type of menu and is known as a <em>contents menu</em>.LiveCode will automatically draw menus defined as <em>contents</em> menus usingthe native system look on each platform. When you choose an item from acontents menu, LiveCode will send a <strong>menuPick</strong> message along with thename of the item chosen.</p><p>Alternatively, menus may be constructed from a <em>stack panel</em>, giving youcomplete control over the menu contents and allowing the display of anyobject type of functionality. When you choose an item from a <em>stack panel</em> menu, the individual object within the menu will receive a<strong>mouseUp</strong> message. Note that panel menus cannot be displayed within the main menu bar on Mac OS systems.</p><p>For more details on working with and scripting menus in general, see thesection <em>Working with Menus</em> in the <em>Programming a User Interface</em> guide.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-pulldown-menu-mac.png" alt=""/></td><td><img src="images/script-build-ui-pulldown-menu-win.png" alt=""/></td><td><img src="images/script-build-ui-pulldown-menu-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-option-menu-mac.png" alt=""/></td><td><img src="images/script-build-ui-option-menu-win.png" alt=""/></td><td><img src="images/script-build-ui-option-menu-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-combo-box-mac.png" alt=""/></td><td><img src="images/script-build-ui-combo-box-win.png" alt=""/></td><td><img src="images/script-build-ui-combo-box-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-popup-menu-mac.png" alt=""/></td><td><img src="images/script-build-ui-popup-menu-win.png" alt=""/></td><td><img src="images/script-build-ui-popup-menu-linux.png" alt=""/></td></tr><tr><td>Mac</td><td>Windows</td><td>Linux</td></tr></tbody></table><p>Figure 41 – Menu Controls</p><p>The cascade menu is a special type of control that is only used whenbuilding a stack panel menu. Sub-menu items can be created in list-basedcontent menus without using this object.</p><p><img src="images/image83.png" alt=""/></p><p>Figure 42 – Tab Menu on Windows</p><p>The tabbed panel is a type of menu in LiveCode. You can specify a listof tabs to be displayed and receive a <code>menuPick</code>message when the userclicks on a tab in the same way as other menus. There are two commontechniques for implementing a tabbed interface: group the objects foreach tab together and show or hide the appropriate group when you changetab; or place the tab object into a group which is then placed as abackground on multiple cards.</p><h4>Other Controls</h4><p>Scroll bars can be used as a <em>progress</em> bar to display a value, a<em>slider</em> to allow the user to choose a value, or to scroll objects.(Note that you don’t need to use a scrollbar object with fields orgroups as these can display a built-in scroll bar.) Sliders andscrollbars can be displayed both horizontally and vertically – todisplay vertically, resize so that the height is greater than the width.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><img src="images/script-build-ui-progress-bar-mac.png" alt=""/></td><td><img src="images/script-build-ui-progress-bar-win.png" alt=""/></td><td><img src="images/script-build-ui-progress-bar-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-scrollbar-mac.png" alt=""/></td><td><img src="images/script-build-ui-scrollbar-win.png" alt=""/></td><td><img src="images/script-build-ui-scrollbar-linux.png" alt=""/></td></tr><tr><td><img src="images/script-build-ui-slider-mac.png" alt=""/></td><td><img src="images/script-build-ui-slider-win.png" alt=""/></td><td><img src="images/script-build-ui-slider-linux.png" alt=""/></td></tr></tbody></table><p>Figure 43 – Scrollbars</p><h3>Using the Menu Builder</h3><p>The menu builder allows you to create and edit a standard menu bar thatwill work correctly regardless of the platform you intend to deploy on.On Windows and Unix, menus built with the Menu Builder will appear inthe top of the window. On Mac OS they will be displayed in the main menubar. It is also possible to generate a menu bar by script. For moredetails, see the section on <em>Programming a User Interface</em>.</p><p>Choose <strong>Tools -&gt; Menu Builder</strong> to open the Menu Builder.</p><p><img src="images/script-build-ui-menu-builder.png" alt=""/></p><p>Figure 44 – Menu Builder</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Preview</strong></td><td>This option allows you to preview your menu bar in the main menu bar. It only applies on Mac OS systems where the option Set as Menu Bar on Mac OS has been turned on.<br><br> &gt; <strong>Important:</strong> To bring back the LiveCode development menu bar when working with a stack that has this option turned on, click on a LiveCode IDE window such as the Tool bar.</td></tr><tr><td><strong>Menu bar settings</strong></td><td>This area specifies the main settings for your menu bar. Use the <em>New</em> button to create a new menu bar in the current top most editable stack. Enter the name for your menu bar in the text area. <em>Delete</em> will permanently delete your menu bar. Use the <em>Edit</em> button to load an existing menu bar from the top most editable stack to edit in the area below.</td></tr><tr><td><strong>Menu edit area</strong></td><td>Select a menu to work on from the scrolling list. At a minimum your application should have a File, Edit and Help menu. These menus are created for you automatically when you create a new menu bar. To create a new menu, move the orange <em>divider bar</em> to the position in the menu bar you want to create the new menu, and press <em>New Menu</em>. Disable the currently selected menu by checking <em>Disabled</em>. Choose the keyboard shortcut (the portion of the name that is underlined), using the <em>Mnemonic</em> popup menu (Windows, Linux &amp; Unix only). To move a menu in the list, select it then press the <em>up or down arrows</em> (to the right of the name area).</td></tr><tr><td><strong>Menu content area</strong></td><td>Select a menu item to work on from the scrolling list. To create a new menu item, move the orange <em>divider bar</em> to the position in the menu bar you want to create the new menu, and press <em>New Item</em>. Disable the currently selected item checking <em>Disabled</em>. Choose the keyboard shortcut (the portion of the name that is underlined, for use when the menu is open), using the <em>Mnemonic</em> popup menu (Windows, Linux &amp; Unix only). To move a menu item up or down the list, select it then click the <em>up or down arrows</em> (to the right of the name area). To move items into a <em>submenu</em>, click the <em>Right</em> arrow, or click the <em>Left</em> arrow to move a submenu item back into the main menu bar. To insert a <em>divider</em>, position the orange divider bar where you want the divider, the click the blue divider button (top right). To make the menu item a <em>Checkbox</em> or <em>Diamond</em> option, choose the appropriate option from the <em>Mark</em> popup menu. To create a control key <em>shortcut</em> for the item, click the Shortcut check box and enter the letter you want to use for the shortcut. To understand the <em>symbols</em> that are created next to the menu items, see the section on <em>Menu Bars</em> within the chapter on <em>Programming a User Interface</em>.</td></tr><tr><td><strong>Scripting</strong></td><td><em>Edit Script</em> opens the Code Editor for the currently selected menu. <em>Auto Script</em> places a blank script within the currently selected button with spaces to insert actions for each of the menu items within that item. We recommend you press Auto Script before pressing Edit Script when you create a menu.</td></tr></tbody></table><h3>Using the Geometry Manager</h3><p>Use the Geometry Manager to specify how objects should be scaled and positioned when the user resizes the window.</p><p><img src="images/script-build-ui-geometry-manager.png" alt=""/></p><p>Figure 45 – The Geometry Manager</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Scale or Position Selector</strong></td><td>Choose whether you want the control to be <em>scaled</em> or <em>positioned</em> when the stack is resized. Scaling will change the dimensions of the control as the stack resizes. Positioning will move the control, it does not change its dimensions. Note that it is possible to scale an object in the horizontal plane and have it position in the vertical. Select Scale then set the options for one axis in the Linking area. Then select Position and set the options for the other axis. If you set options in both the Scale and Position modes for both axis, the Scaling options will be ignored.</td></tr><tr><td><strong>Linking area</strong></td><td>Use the linking area to specify the <em>relationship</em> between the control and the window, or other controls as the stack is resized. In Scaling mode you can link each edge of the object to the window or another object. In positioning mode, you can only link the X and Y axis of an object. Click the gray bars to create a link. A single click results in an absolute link, a second click will create a relative link. An absolute link will keep the object the current number of pixels away from what it is being linked to. For example, if you link the right edge to the edge of the window and the edge is currently 10 pixels away from the edge of the window, whenever the stack is resized the edge will remain exactly 10 pixels away. However if you use a relative link the distance will be calculated as a percentage of the total width of the card. The object will remain the same percentage away from the edge of the card, the exact number of pixels will vary.<br><br>When linking to another control, be sure to link to a control that is moved relative to the window, or by a script (e.g. in a <code>resizeStack</code>handler).<br><br>When using the Geometry Manager with an existing <code>resizeStack</code>handler, be sure to pass the <code>resizeStack</code>message, otherwise the Geometry Manager will not be able to take effect.<br><br>To force the Geometry to manually update, call <strong>revUpdateGeometry</strong>.<br><br> &gt; <strong>Tip:</strong> You can use the Geometry Manager to scale objects with a &quot;divider&quot; bar. Create and script the bar to move, then link the edges of the controls to it, then call revUpdateGeometry each time it moves to have the objects scale automatically.</td></tr><tr><td><strong>Clipping settings</strong></td><td>Turn on Prevent Object Clipping Text to prevent the control getting too small to display its label when the window is resized. If the control is a field, you can also turn on the option to display scroll bars if the text within the field does not fit.</td></tr><tr><td><strong>Limit settings</strong></td><td>Allows you to set the minimum and maximum possible widths and heights for the object.</td></tr><tr><td><strong>Remove All</strong></td><td>Removes all Geometry settings from the control. Use this option if the settings you have applied do not give the desired effect and you want to start over.</td></tr></tbody></table><h3>10 Tips for Good User Interface Design</h3><p>If you are creating a simple utility for yourself, a handful of otherpeople, or as a research project, the design of the interface is lessimportant. However, if you are creating software for a wide group of endusers, you should take time to carefully design the user interface. Ascomputer software has become more mature over the past couple ofdecades, user expectations of what their software experience should behave increased. Increasingly, users expect clear, uncluttered interfaceswhich are visually appealing. Getting this right is part art and partscience. It is beyond the scope of this manual to give detailedinstruction on this topic. There are many good books and resourcesdevoted to this evolving area. However we thought it would be useful togive you our top 10 tips for good user interface design.</p><ul><li>Less is more</li></ul><p>Don&#39;t use three buttons where one would do. The fewer choices a user hasto make the easier your software will be to learn.</p><ul><li>Design to communicate</li></ul><p>Good design supports whatever you are trying to communicate.</p><ul><li>Get the defaults right</li></ul><p>Providing preferences is great for power users. Just remember that themajority of your users will never adjust the defaults. So focus ongetting the default behaviors right before you start to add preferences.</p><ul><li>Layout</li></ul><p>A clean consistent layout helps to convey a feeling of professionalismand make your software useable. If you have used a button that is 20pixels wide in one part of your interface then use the same size ofbutton elsewhere. Line your objects up carefully.</p><ul><li>Screen resolution</li></ul><p>Consider what screen resolution you are designing for and whether or notyou want your interface to be resizable early on. This decision willhave a big impact on your design.</p><ul><li>Consider the program flow</li></ul><p>If you program performs a complex task with many options, considercreating a wizard style interface which guides the user step by stepthrough the task. That way they are never faced with a screen coveredwith dozens of options and no idea what to do next.</p><ul><li>Test it on real users</li></ul><p>Bring in a group of people and watch them use the program. Don&#39;tinterfere or help them out, just get them going and take notes. If youdon&#39;t have a budget for expensive user testing labs, this process can beas simple as gathering a group of students and offering them free pizza.You&#39;ll get a ton of useful feedback that will really help make yourprogram easy to use.</p><ul><li>Don&#39;t use square wheels</li></ul><p>The various types of widget and control type available have built up ameaning for users over years of use. Don&#39;t use something that has a wellunderstood function to perform a different sort of task. If you need awidget that does something new, build something new.</p><ul><li>Skinning</li></ul><p>If you&#39;re producing a custom skin for your application, a good rule ofthumb is either make it entirely custom or use standard OS widgets. AnOS native button can look very out of place in the middle of a carefullydesigned custom skin.</p><ul><li>HCI guidelines for the three main platforms</li></ul><p>Each of the platforms that LiveCode supports has its own set of UserInterface Guidelines. We recommend you take time to familiarize yourselfwith them.</p><p>Apple Human Interface Guidelines:</p><p><http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGIntro/chapter_1_section_1.html></p><p>Windows Vista User Experience Guidelines:</p><p><a href="http://msdn2.microsoft.com/en-us/library/aa511258.aspx">http://msdn2.microsoft.com/en-us/library/aa511258.aspx</a></p><p>GNOME Human Interface Guidelines 2.0:</p><p><a href="http://library.gnome.org/devel/hig-book/stable/">http://library.gnome.org/devel/hig-book/stable/</a></p><p>KDE Human Interface Guidelines:</p><p><a href="http://wiki.openusability.org/guidelines/index.php/Main_Page">http://wiki.openusability.org/guidelines/index.php/Main_Page</a></p><h2><a name="//apple_ref/cpp/Guide/Coding in LiveCode" class="dashAnchor"></a>Coding in LiveCode</h2><p>Writing code is how you give your application functionality. Writing theright code means your application will do what you want it to do.Fortunately, LiveCode’s built in high level language, makes this taskeasy. The English-like syntax is easy to read and write. This chapterwalks you through writing LiveCode.</p><h3>The Structure of a Script</h3><h3>What is a Script</h3><p>Every object in LiveCode can contain a script, which tells it what todo. You edit the script of an object using the Code Editor (see <em>TheCode Editor</em>). A script is organized into a set of individual <em>messagehandlers</em>, each one of which can respond to a different event (see<em>Messages</em>) or contain a specific piece of functionality. Scripts cansend messages to each other. In a well organized application, a scriptwill regularly pass data between different types of message handlerswhich have been grouped and organized to deliver functionality, with aminimum amount of duplication. A script can contain sections of codethat is commented – remarks that are intended for a human to read andare not executed. Technically a script is simply another objectproperty, so one script can set another – within certain limits.</p><h3>The Types of Handler</h3><p>A <em>handler</em> is a complete section of code. Each handler can be executedindependently. There are four types of handler: commands (messagehandlers), functions, getProp handlers and setProp handlers.</p><h3>Message Handlers</h3><p>Each <em>message</em> handler begins with the <strong>on</strong> control structure followedby the name of the message that this handler responds to. The handlerends with the <strong>end</strong> control structure and the name of the message.Message handlers look like this:</p><pre><code>on mouseUp    beepend mouseUp</code></pre><p>A message handler is executed when the object whose script contains thehandler receives the message. This example handler responds to the<strong>mouseUp</strong> message (see <em>Messages</em>).</p><h3>Function Handlers</h3><p>Each function handler begins with the <strong>function</strong> control structurefollowed by the name of the function that this handler computes. Thehandler ends with the <strong>end</strong> control structure and the name of thefunction. Function handlers are typically called by another handler andreturn a value using the <strong>return</strong> control structure. Function handlerslook like this:</p><pre><code>function currentDay    return item 1 of the long dateend currentDay</code></pre><p>A function handler is executed when a handler in the same script (or onein an object lower in the <em>message hierarchy</em>) calls the function. Thisexample handler returns today&#39;s name.</p><h3>GetProp Handlers</h3><p>Each <strong>getProp</strong> handler begins with the <strong>getProp</strong> control structurefollowed by the name of the custom property that this handlercorresponds to. The handler ends with the <strong>end</strong> control structure andthe name of the property. <strong>getProp</strong> handlers look like this:</p><pre><code>getProp myCustomProperty    return the scroll of me + 20end myCustomProperty</code></pre><p>A <strong>getProp</strong> handler is executed whenever the value of thecorresponding custom property is requested by a LiveCode statement. Youcan write a <code>getProp</code>handler for any custom property of the object oranother object lower in the message hierarchy. For more information, seethe section on <em>Custom Properties</em>.</p><h3>SetProp Handlers</h3><p>Each setProp handler begins with the <strong>setProp</strong> control structurefollowed by the name of the custom property that this handlercorresponds to. The handler ends with the <strong>end</strong> control structure andthe name of the property. setProp handlers look like this:</p><pre><code>setProp myCustomProperty newSetting    set the hilite of me to true    pass myCustomPropertyend myCustomProperty</code></pre><p>A setProp handler is executed whenever the value of the correspondingcustom property is changed by the <strong>set</strong> command. You can write asetProp handler for any custom property of the object or another objectlower in the object hierarchy. For more information, see the section on<em>Custom Properties</em>.</p><h3>Comments</h3><p>Comments are remarks that are intended for a human to read and are notexecuted. For some recommendations on what sort of comments to includeand when, see the section on <em>Good Design Recommendations</em>.Comments canbe placed either in a handler, or outside any handler.</p><p>Any line (or portion of a line) that starts with two dashes (**--**) ora hash mark (**#**) is a comment. Placing these characters at thebeginning of a line is called &quot;commenting out&quot; the line.</p><pre><code>on mouseUp -- this part is a comment    beep    -- and this is a comment tooend mouseUp</code></pre><p>You can temporarily remove a statement, or even an entire handler, bycommenting it out. To comment out several lines at once, select them andchoose <strong>Script -&gt; Comment</strong>.</p><p>Since comments are not executed, you can place them anywhere in ascript--inside a handler or outside all handlers.</p><p>Comments that start with <strong>--</strong> or ## only extend to the end of theline. To create a multiple-line comment, or <em>block comment</em>, surround itwith <strong>/\</strong>* and <strong>*/</strong> instead:</p><pre><code>on openCard    /* This is a multiple-line comment that might    contain extensive information about this handler,    such as the author&#39;s name, a description, or the    date the handler was last changed. */    show image &quot;My Image&quot;    pass openCard /* You can also make one-line comments */end openCard</code></pre><p>Block comments are handy when you want to temporarily remove a sectionof code while debugging a handler. You can place the characters &quot;/*&quot; atthe start of the section, and &quot;*/&quot; at the end, to prevent the sectionfrom being executed.</p><h3>Compiling a Script</h3><p>A script is compiled when you change the script either by clicking Applyin the Code Editor (or, if altering a script from another script, usingthe <strong>set</strong> command). During compilation, the entire script is analyzed.</p><p>If a compile error is found when a script is being compiled, the entirescript is unavailable for execution until the error is corrected and thescript is re-compiled. This applies only to compile errors. If anexecution error occurs during the execution of a handler, it does notaffect the ability to use other handlers in the same script. For moreinformation on dealing with errors, see the section on <em>Debugging</em>.</p><p>You cannot change a script while a handler in it is executing, becausewhat is executed is the compiled version, not the text in the <strong>script</strong>property.</p><h3>Summary</h3><p>Each object has a script, which can be empty or can contain one or moreLiveCode handlers. You change a script using the Code Editor, or bysetting the object&#39;s <strong>script</strong> property.</p><p>A script can contain four kinds of handlers: commands, functionhandlers, setProp handlers, and getProp handlers.</p><p>A comment is a part of the script that is not executed. Comments startwith <strong>--</strong> or <strong>#</strong>.</p><p>If a script contains a compile error, none of its handlers can be useduntil the error is fixed.</p><h2><a name="//apple_ref/cpp/Guide/Events" class="dashAnchor"></a>Events</h2><p>LiveCode is based upon events. Every action a script takes is triggeredby an event, which is sent in the form of a message.</p><h3>What Causes Messages to be Sent</h3><p>Messages are sent by <em>events</em>. Events include user actions (such astyping a key or clicking the mouse button) and program actions (such ascompleting a file download or quitting the application). LiveCodewatches for events and sends a message to the appropriate object when anevent occurs.</p><blockquote><p><strong>Note:</strong> When a tool other than the Browse tool is active, thedevelopment environment traps the built-in messages that are normallysent when clicking (such as <strong>mouseDown</strong> and <strong>mouseUp</strong>). This is sothat, for example, you can use the Pointer tool to select and move abutton without triggering its <strong>mouseUp</strong> handler.</p></blockquote><p>These messages are referred to as built-in messages, and include<strong>mouseDown</strong>, <strong>mouseUp</strong>, <strong>keyDown</strong>, <strong>openCard</strong>, and all the othermessages described in the LiveCode Dictionary.</p><p>LiveCode also sends a message whenever a handler executes a <em>custom</em>command (see <em>Sending Messages</em>). However, <em>built-in</em> commands areexecuted directly by the engine and don&#39;t result in sending a message.Similarly, LiveCode sends a function call whenever a handler calls a<em>custom</em> function, a <strong>setProp</strong> trigger whenever a handler sets a<em>custom</em> property, and a <strong>getProp</strong> call whenever a handler gets thevalue of a custom property.</p><h3>Responding to Events</h3><p>To respond to a message, you write a message handler with the same nameas the message. For example, to respond to a <strong>keyDown</strong> message sent toa field (which is sent when the user presses a key while the insertionpoint is in the field), place a <strong>keyDown</strong> handler in the field&#39;sscript:</p><pre><code>on keyDown theKey -- responds to keyDown message    if theKey is a number then beepend keyDown</code></pre><h2><a name="//apple_ref/cpp/Guide/The Message Path" class="dashAnchor"></a>The Message Path</h2><p>The <em>message path</em> is the set of rules that determine which objects, inwhich order, have the opportunity to respond to a message. The messagepath is based on the <em>object hierarchy</em>.</p><h3>The Object Hierarchy</h3><p>Each LiveCode object is part of another object, of a different objecttype. For example, each card is part of a stack, each grouped control ispart of a group, and so on. This <em>object hierarchy</em> defines theownership and inheritance relationship between objects.</p><p>Font, color and pattern properties are <em>inherited</em> from the object’sowner if they are not set. This means that if you set the <strong>textFont</strong>of a stack, all the objects within that stack that do not have their<strong>textFont</strong> property set will use that text font.</p><h3>The Message Path</h3><p>When a message is sent to an object, it is often handled directly by amessage handler in that object. However if no handler is present, themessage will continue along a path until it finds a message handler thatcan respond to it. This makes it possible to group similar functionalitytogether at different levels within your application. This behaviorapplies both to event messages sent as a result of a user action, andcustom messages sent by script. It is therefore possible to writelibraries of common functions.</p><p>The object hierarchy is closely related to the <em>path</em> that a messagetravels on. In most cases, when an object passes a message on, themessage goes to the object&#39;s owner in the object hierarchy.</p><p>The Message Path is detailed in the figure below.</p><p><img src="images/image89.png" alt=""/></p><p>Figure 48 – The Message Path</p><p>For example, suppose the user clicks a button in a main stack, causingLiveCode to send a <strong>mouseUp</strong> message to the button. If the button&#39;sscript does not contain a handler for the <strong>mouseUp</strong> message, themessage is passed along to the card the button is on. If the card&#39;sscript contains a <strong>mouseUp</strong> handler, the handler is executed. But ifthe card does not handle the <strong>mouseUp</strong> message, it is passed on to thecard&#39;s stack. If the stack script contains a <strong>mouseUp</strong> handler, thehandler is executed. But if the stack does not handle the <strong>mouseUp</strong>message, it is passed on to the engine.</p><p>The engine is the end of the message path, and if a message reaches it,the engine takes any default action (e.g. inserting a character into afield or highlighting a button), then throws the message away.</p><p>If a message corresponding to a <em>custom</em> command or a <em>custom</em> functioncall reaches the end of the message path without finding a handler,instead of being thrown away, it causes an execution error.</p><blockquote><p><strong>Note:</strong> In order to be considered a background (as per the MessagePath diagram above), a group must have its <strong>backgroundBehavior</strong>property is set to true.</p></blockquote><p>If a stack&#39;s <strong>dynamicPaths</strong> property is set to true, message handlersin that stack use HyperCard&#39;s dynamic path behavior: if a handler usesthe <strong>go</strong> or <strong>find</strong> command to go to a card other than the originalcard, that destination card&#39;s message path is inserted into the messagepath as long as the handler is on that card. The <strong>dynamicPaths</strong>property is provided for compatibility with imported HyperCard stacks,and is normally set to false, but you may encounter this behavior whenworking with a stack that was originally created in HyperCard.</p><h3>The Message Target</h3><p>The object that a message <em>was originally sent</em> to is called themessage&#39;s target. You can get the target from within any handler in themessage path by using the <strong>target</strong> function.</p><blockquote><p><strong>Tip:</strong> To get the name of the object whose script is currentlyexecuting, use the <strong>me</strong> keyword.</p></blockquote><p>For example, if you click a button (causing a <strong>mouseUp</strong> message to besent), and the button&#39;s script contains a <strong>mouseUp</strong> handler, then the<strong>target</strong> function returns the button&#39;s name. However, if the buttondoesn&#39;t handle the <strong>mouseUp</strong> message, it&#39;s passed to the card, and ifthe card has a <strong>mouseUp</strong> handler, it is executed in response to themessage. In this case, the card&#39;s script is executing, but the<strong>target</strong> is not the card--it&#39;s the button that was originally clicked,because LiveCode sent the <strong>mouseUp</strong>message to the button.</p><h3>Handlers with the Same Name</h3><p>If two different objects in the message path each have a handler withthe same name, the message is handled by the first object that receivesit and has a handler for it.</p><p>For example, suppose that a button&#39;s script includes a <strong>mouseUp</strong>handler, and so does the stack script. If you click the button, a<strong>mouseUp</strong> message is sent to the button. Because the button&#39;s scripthas a <strong>mouseUp</strong> handler, the button handles the message, and it isn&#39;tpassed any further. The message is never sent to the stack script, sofor this click event, the stack script&#39;s <strong>mouseUp</strong> handler is notexecuted.</p><blockquote><p><strong>Note:</strong> If an object&#39;s script has more than one handler with thesame name, the first one is executed when the object receives thecorresponding message. Other handlers in the same object&#39;s script withthe same name are never executed.</p></blockquote><h3>Trapping Messages</h3><p>When an object receives a message and a handler for that message isfound, the handler is executed. Normally, a message that&#39;s been handleddoes not go any further along the message path. Its purpose having beenserved, it disappears. Such a message is said to have been <em>trapped</em> bythe handler.</p><p>If you want to prevent a message from being passed further along themessage path, but don&#39;t want to do anything with it, an empty handlerfor the message will block it from being passed on. This exampleprevents the <strong>mouseDown</strong> message from being acted on by the object theempty handler is in, as well as any objects below it in the objecthierarchy:</p><pre><code>on mouseDownend mouseDown</code></pre><p>You can use the same technique to block custom function calls,<strong>setProp</strong> triggers, and <strong>getProp</strong> calls.</p><h3>Blocking System Messages</h3><p>You can block system messages – for example those sent when you navigateto another card – from being sent while a handler is executing bysetting the <strong>lockMessages</strong> property to true.</p><p>For example, if the handler opens another stack, LiveCode normally sends<strong>openCard</strong> and <strong>openStack</strong> messages to the stack. If the stackcontains handlers for these messages that would cause unwanted behaviorduring this operation, you can use the <strong>lockmessages</strong> command beforegoing to the stack in order to temporarily block these messages. Whenthe handler finishes executing, the <strong>lockMessages</strong> property isautomatically reset to its default value of false, and normal sending ofmessages resumes.</p><blockquote><p><strong>Tip:</strong> To block navigation messages while testing or debugging astack, press Suppress Messages on the toolbar or choose <strong>Development -&gt; Suppress Messages</strong>.</p></blockquote><h3>Passing a Message to the Next Object</h3><p>To let a message pass further along the message path, use the <strong>pass</strong>control structure. The <strong>pass</strong> control structure stops the currenthandler and sends the message on to the next object in the message path,just as though the object hadn&#39;t contained a handler for the message:</p><pre><code>on openCard    doSpecialSetupForThisCard    pass openCard -- let stack get the message tooend openCard</code></pre><h3>Selectively Trapping or Passing Messages</h3><p>Some built-in messages, such as <strong>keyDown</strong>, trigger an action, sotrapping the message prevents the action from being performed at all.The following example passes the <strong>keyDown</strong> message only if thecharacter typed is a number:</p><pre><code>on keyDown theKey    if theKey is a number then pass keyDownend keyDown</code></pre><p>If you place this handler in a field&#39;s script, it allows the user toenter numbers, but any other keystrokes are trapped by the <strong>keyDown</strong>handler and not allowed to pass.</p><p>A similar principle applies to <strong>setProp</strong> triggers. If a <strong>setProp</strong>handler does not pass the <strong>setProp</strong> trigger, the custom property isnot set.</p><h3>Groups, Backgrounds &amp; The Message Path</h3><p>As you can see from the diagram above a group&#39;s position in the messagepath depends on whether the &quot;Behave as Background&quot; check box has beenset (by script or using the <strong>backgroundBehavior</strong> property).</p><p>If background behavior is false, the group is in the message path forall controls it owns, but is not in the message path of any otherobject.</p><p>If the background behavior is true, the group is <em>also</em> in the messagepath for any cards it is placed on. If you send a message to a cardcontrol, the message passes through the control, then the card, then anybackground groups on the card in order of <strong>number</strong>, then the stack.</p><p>Since a group owns any controls that are part of the group, if you senda message to a control within a group, the group is in the message pathfor its own controls, regardless of whether it’s background behavior istrue or false. If a group has already received a message because it wasoriginally sent to one of the controls in the group, the message is notsent through the group again after the card has handled it.</p><blockquote><p><strong>Tip:</strong> If you want a handler in a group&#39;s script to affect only theobjects in the group, place the following statement at the beginningof the handler:</p><p>if the owner of the target is not me then pass <em>message</em>.</p><p>This filters out any objects that are not part of the group.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Commands and Functions" class="dashAnchor"></a>Commands and Functions</h2><p>You use commands and functions to perform the actions of yourapplication. Commands instruct the application to do something – such asplay a movie, display a window, or change a property. Functions computea value – different functions might add a column of numbers, or get thefifteenth line of a certain file, or find out whether a key is beingpressed.</p><h3>Using Built-in Commands and functions</h3><p>LiveCode has over one hundred and fifty built-in commands, and over twohundred built-in functions, all of which are documented in the LiveCodeDictionary.</p><h4>Commands</h4><p>A command is an instruction to LiveCode to do something. A command isplaced at the start of a statement (either the start of a line or aftera control structure such as &quot;then&quot;). The command is followed by anyparameters that specify the details of what the command is to do.</p><p>Here are some examples of how built-in commands are used in statements:</p><pre><code>go next card -- go commandbeep --beep commandset the hilite of me to true-- set command</code></pre><h4>Functions</h4><p>A function call is a request to LiveCode for information. A function isstated using the name of the function, followed by opening and closingbrackets that may contain any parameters that specify the details ofwhat the function is to act on.</p><p>When you use a function in a statement, LiveCode calls the function tocompute the specified information, then substitutes that information inthe script as if the script had originally written that information inplace of the function call. The information returned can therefore be<em>put</em> into a <em>variable</em> or other <em>container</em> by using the put command infront of a function.</p><p>Here&#39;s an example of how a function is used:</p><pre><code>put round(22.3) into field &quot;Number&quot;</code></pre><p>When this statement is executed, LiveCode calls the <strong>round</strong> function.When you round off 22.3, the resulting number is 22, so the statementputs the number 22 into the field.</p><p>The number you&#39;re rounding off is placed in parentheses after the<strong>round</strong> function&#39;s name. This number is called the function&#39;sparameter. A function can have one parameter, or none, or several. Theparameters are enclosed in parentheses and, if there&#39;s more than one,they&#39;re separated with commas. Here are some examples:</p><pre><code>put date() into myVariable -- date function, no parametersput length(&quot;hello&quot;) into me -- length function, 1 parameterget average(10,2,4) -- average function, 3 parameters</code></pre><blockquote><p><strong>Important:</strong> A function call, by itself, is not a completestatement. You need to use a function call in conjunction with acommand or control structure. (In the first example above, the<strong>round</strong> function is used with the <strong>put</strong> command.)</p></blockquote><h4>Writing function calls with the &quot;the&quot; form</h4><p>If a built-in function has no parameters or one parameter, it can bewritten in a different form, with no parentheses:</p><pre><code>put the date into myVariable -- date functionput the length of &quot;hello&quot; into me -- length function</code></pre><p>If the function has no parameters, this form is written as the<em>functionName</em>. If it has one parameter, this form is written as the<em>functionName</em> of parameter.</p><p>The &quot;the&quot; form works the same way as the &quot;()&quot; form shown above, and youcan use the two forms interchangeably for <em>built-in functions</em> withfewer than two parameters. The LiveCode Dictionary entry for eachbuilt-in function shows how to write both forms.</p><p>You can use the &quot;the&quot; form for built-in functions, but not for customfunctions that you write. Writing custom functions is discussed later.</p><h3>Custom Commands and Functions</h3><p>You use custom commands and custom functions the same way as any othercommand or function.</p><h4>Using custom commands</h4><p>You can execute a custom command simply by typing the name of thecommand you want to send.</p><pre><code>myCommand</code></pre><p>You respond to a custom command&#39;s message in the same way, by writing amessage handler with the name of the command:</p><pre><code>on myCommand -- a custom command    beep 3    go next card    add 1 to field &quot;Card Number&quot;end myCommand</code></pre><p>If you don&#39;t specify an object, the message is sent to the object whosescript is being executed, and then passes up the message hierarchy asnormal.</p><p>Like a built-in command, a custom command is an instruction to LiveCodeto do something. You can include parameters with a custom command bypassing them after the name:</p><pre><code>checkForConnection &quot;ftp://ftp.example.org&quot;makePrefsFile fileLoc,field &quot;Preferences&quot;</code></pre><p>Built-in commands can have very flexible syntax:</p><pre><code>go to card 3 of stack &quot;Dialogs&quot; as modalgroup image &quot;Help Icon&quot; and field &quot;Help Text&quot;hide button ID 22 with visual effect dissolve very fast</code></pre><p>However, the syntax of custom commands is more limited. A custom commandcan have several parameters, and if there is more than one, they areseparated by commas:</p><pre><code>libURLDownloadToFile myFile,newPath,&quot;downloadComplete&quot;revExecuteSQL myDatabaseID,field &quot;Query&quot;,&quot;\*b&quot; &amp; &quot;myvar&quot;</code></pre><p>But custom commands cannot use words like &quot;and&quot; and &quot;to&quot; to join partsof the command together, the way built-in commands can. Because of this,custom commands cannot be as English-like as built-in commands can be.</p><h4>Using custom functions</h4><p>When you use the custom function &quot;fileHeader&quot; in a statement, thefunction handler is executed, and the function call is replaced by thevalue in the <strong>return</strong> statement. This example shows how the functioncan be used:</p><pre><code>put fileHeader(it) into myFileHeaderVar</code></pre><p>And the corresponding custom function:</p><pre><code>function fileHeader theFile    put char 1 to 8 of URL (&quot;file:&quot; &amp; theFile) into tempVar    put binaryDecode(&quot;h\*&quot;,tempVar) into tempVar    return tempVarend fileHeader</code></pre><p>Like a built-in function or library function, a custom function call isa request for information. Here are a few examples showing the use ofmade-up custom functions:</p><pre><code>get formattedPath(&quot;/Disk/Folder/File.txt&quot;)put summaryText(field &quot;Input&quot;) into field &quot;Summary&quot;if handlerNames(myScript, &quot;getProp&quot;) is empty then beep</code></pre><p>Custom functions don&#39;t have a &quot;the&quot; form, and are always written withparentheses following the function name. If the function has parameters,they are placed inside the parentheses, separated by commas. If thefunction doesn&#39;t have parameters, the parentheses are empty.</p><h3>Passing Parameters</h3><p>A value that you pass from one handler to another is called a parameter.</p><p>In the example below, the following statement sends the &quot;alertUser&quot;message with a parameter:</p><pre><code>alertUser &quot;You clicked a button!&quot;</code></pre><p>The parameter &quot;You clicked a button!&quot; is passed to the &quot;alertUser&quot;handler, which accepts the parameter and places it in a parametervariable called &quot;theMessage&quot;. The &quot;alertUser&quot; handler can then use theparameter in its statements:</p><pre><code>on alertUser theMessage    beep    answer theMessage -- uses the parameter &quot;theMessage&quot;end alertUser</code></pre><h3>Passing Multiple Parameters</h3><p>If a statement passes more than one parameter, the parameters areseparated by commas. The following example has two parameters,&quot;theMessage&quot; and &quot;numberOfBeeps&quot;:</p><pre><code>on seriouslyBugUser theMessage,numberOfBeeps    beep numberOfBeeps    answer theMessageend seriouslyBugUser</code></pre><p>To use this custom command, you call it like this:</p><pre><code>seriouslyBugUser &quot;Hello&quot;,5</code></pre><p>When the &quot;seriouslyBugUser&quot; handler is executed with the statementabove, the <em>theMessage</em> parameter is &quot;Hello&quot;, and the <em>numberOfBeeps</em>parameter is 5.</p><h3>Parameter Variables</h3><p>In the example above, &quot;theMessage&quot; and &quot;numberOfBeeps&quot; are the parametervariables. You declare parameter variables in the first line of ahandler. When the handler begins executing, the values you passed areplaced in the parameter variables. You can use parameter variables thesame way as ordinary variables: you can put data into them, use them inexpressions, and so on.</p><p>Parameter variables are local variables, so they go out of existence assoon as the handler stops executing.</p><h4>Parameter variable names</h4><p>You can give a parameter any name that&#39;s a legal variable name. Thenames of variables must consist of a single word and may contain anycombination of letters, digits, and underscores (_). The firstcharacter must be either a letter or an underscore.</p><p>It is not the name, but the order of parameters that is significant.</p><h4>Empty parameters</h4><p>A handler can have any number of parameter variables regardless of thenumber of parameters passed to it. If there are more parameter variablesthan there are values to put in them, the remaining parameter variablesare left empty. Consider the following handler, which has threeparameter variables:</p><pre><code>on processOrder itemName,itemSize,numberOfItems    put itemName into field &quot;Name&quot;    put itemSize into field &quot;Size&quot;    if numberOfItems is empty then put 1 into field &quot;Number&quot;    else put numberOfItems into field &quot;Number&quot;end processOrder</code></pre><p>The following statement places an order for one sweater:</p><pre><code>processOrder &quot;sweater&quot;,&quot;large&quot;</code></pre><p>The statement only passes two parameters, while the &quot;processOrder&quot;handler has three parameter variables, so the third parameter variable,&quot;numberOfItems&quot;, is empty. Because the handler provides for thepossibility that &quot;numberOfItems&quot; is empty, you can pass either two orthree parameters to this handler.</p><h4>Setting a default value for a parameter</h4><p>To use a default value for a parameter, you check whether the parameteris empty. If it is, then no value has been passed, and you can simplyput the desired default into the parameter, as in the following example:</p><pre><code>logData theData,theFilePath    if theFilePath is empty then        put &quot;logfile&quot; into theFilePath    end if    put theData into URL (&quot;file:&quot; &amp; theFilePath)end logData</code></pre><p>The &quot;logData&quot; handler puts data into a file, whose name and location youspecify in the second parameter. If you only provide one parameter, thehandler uses the filename &quot;logfile&quot; as the default value, and logs thedata to that file:</p><pre><code>logData field 1,&quot;/Disk/Folder/data.txt&quot; *-- specifies a file*logData myVariable-- doesn&#39;t specify a file, uses &quot;logfile&quot;</code></pre><p>The first statement above specifies the second parameter, so it doesn&#39;tuse the default value. The second statement only specifies oneparameter, so the data will be placed in &quot;logfile&quot; by default.</p><h3>Implicit Parameters</h3><p>If a statement passes more parameters than the receiving handler hasparameter variables to hold them, the receiving handler can access theextra parameters with the <strong>param</strong> function:</p><pre><code>function product firstFactor,secondFactor    put firstFactor \* secondFactor into theProduct    if the paramCount \&gt; 2 then    repeat with x = 3 to the paramCount        multiply theProduct by param(x)    end repeat    end if    return theProductend product</code></pre><p>The function above assumes that two parameters will be passed to bemultiplied, but can multiply more numbers by using the <strong>param</strong>function to access parameters beyond the first two. The followingstatement uses the &quot;product&quot; custom function above to multiply fournumbers together:</p><pre><code>answer product(22,10,3,7)</code></pre><p>When the &quot;product&quot; handler executes, the first two parameters – 22 and10 – are placed in the parameter variables &quot;firstFactor&quot; and&quot;secondFactor&quot;. The third parameter, 3, is accessed with the expression<code>param(3)</code>, and the fourth parameter, 7, is accessed with the expression<code>param(4)</code>.</p><h3>Passing Parameters by Reference</h3><p>Normally, if you pass a variable name as a parameter, that variable isnot changed by anything the called handler does. This is because thevariable itself is not passed, only its contents. Passing parameters inthis way is called &quot;passing by value&quot; because the variable&#39;s value--notthe variable itself--is what is passed.</p><p>If the name of a parameter variable is preceded with the <strong>@</strong>character, that parameter&#39;s value is a variable name, rather than thevalue in the variable. Changing the parameter variable in the calledhandler changes the value of the variable in the calling handler. Thisway of passing parameters is called &quot;passing by reference&quot;, because youpass a reference to the variable itself instead of just its value.</p><p>For example, the following handler takes a parameter and adds 1 to it:</p><pre><code>on setVariable @incomingVar    add 1 to incomingVarend setVariable</code></pre><p>The following handler calls the &quot;setVariable&quot; handler above:</p><pre><code>on mouseUp    put 8 into someVariable    setVariable someVariable*-- call by reference*    answer &quot;someVariable is now:&quot; &amp;&amp; someVariableend mouseUp</code></pre><p>Executing this <strong>mouseUp</strong> handler displays a dialog box that says&quot;someVariable is now: 9&quot;. This is because, since &quot;someVariable&quot; waspassed by reference to the &quot;setVariable&quot; handler, its value was changedwhen &quot;setVariable&quot; added 1 to the corresponding parameter variable.</p><p>You can pass parameters by reference to any custom function or customcommand, simply by preceding the parameter name with the <strong>@</strong> characterin the first line of the handler, as in the &quot;setVariable&quot; examplehandler above. Do not use the <strong>@</strong> character when referring to theparameter elsewhere in the handler.</p><blockquote><p><strong>Note:</strong> If a parameter is passed by reference, you can pass onlyvariable names for that parameter. You cannot pass string literals orexpressions using other containers such as fields. Trying to use the&quot;setVariable&quot; command described above using the following parameterswill cause an execution error:</p></blockquote><h4>Empty parameters</h4><p>If a handler defines a parameter as being passed by reference, you mustinclude that parameter when calling the handler. Omitting it will causean execution error.</p><h3>Returning Values</h3><p>Once a function handler has calculated a value, it needs a way to sendthe result back to the handler that called the function. And if an erroroccurs during a message handler, it needs a way to send an error messageback to the calling handler.</p><p>The <strong>return</strong> control structure is used within a function handler topass the resulting value back to the calling handler. The returned valueis substituted for the function call in the calling statement, just likethe value of a built-in function. Take another look at the example fromabove:</p><pre><code>function expanded theString    repeat for each character nextChar in theString        put nextChar &amp; space after expandedString    end repeat    return char 1 to -2 of expandedStringend expanded</code></pre><p>In the custom function example above, the**return** control structuresends the spaced-out string back to the <strong>mouseUp</strong> handler that calledthe &quot;expanded&quot; function.</p><blockquote><p><strong>Note:</strong> The <strong>return</strong> control structure stops the handler, so it&#39;susually the last line in the handler.</p></blockquote><h3>Returning an Error from a Message Handler</h3><p>When used in a message handler, the <strong>return</strong> control structure servesa slightly different purpose: it returns an error message to the callinghandler.</p><p>When used in a message handler, the <strong>return</strong> control structure setsthe <strong>result</strong> function for the calling handler. If you want to returnan error message to the calling handler, use the <strong>return</strong> controlstructure within the message handler.</p><p>Here&#39;s an example of a message handler that displays a dialog box:</p><pre><code>on echoAMessage    ask &quot;What do you want to show?&quot;    if it is empty then return &quot;No message!&quot;        else answer itend echoAMessage</code></pre><p>This handler asks the user to enter a message, then displays thatmessage in a dialog box. If the user doesn&#39;t enter anything (or clicksCancel), the handler sends an error message back to the calling handler.A handler that uses the &quot;echoAMessage&quot; custom command can check the<strong>result</strong> function to see whether the command successfully displayed amessage:</p><pre><code>on mouseUp    echoAMessage    if the result is empty then beepend mouseUp</code></pre><p>The <strong>result</strong> function is also set by many built-in commands in case ofan error. If you check the <strong>result</strong> in a handler, the value belongs towhatever command – built-in or custom – that set it last, so if you&#39;regoing to check the <strong>result</strong>, be sure to do so right after the commandwhose success you want to check.</p><h3>Summary</h3><p>In this topic, you have learned that:</p><p>A command instructs the application to do something, while a functionrequests the application to compute a value.</p><p>You create a custom command or custom function by writing a handler forit.</p><p>Values that you pass to a handler are called parameters.</p><p>To pass a parameter by reference, you precede its name with an <strong>@</strong>sign in the first line of the handler.</p><p>When used in a function handler, the <strong>return</strong> control structurereturns a value.</p><p>When used in a message handler, the <strong>return</strong> control structure returnsan error message that can be accessed with the <strong>result</strong> function.</p><h2><a name="//apple_ref/cpp/Guide/Variables" class="dashAnchor"></a>Variables</h2><p>A variable is a place to store data that you create, which has noon-screen representation. Variables can hold any data you want to putinto them. One way to think of a variable is as a box with a name on it.You can put anything you want into the box, and take it out later, bysimply providing the variable&#39;s name:</p><pre><code>put 1 into thisThing -- a variable named &quot;thisThing&quot;put thisThing into field ID 234put &quot;Hello Again!&quot; into line 2 of thisThing</code></pre><p>But unlike some other types of <em>containers</em>, variables are non-permanentand aren&#39;t saved with the stack. Instead, variables are automaticallydeleted either when their handler is finished running or when you quitthe application (depending on the variable&#39;s <em>scope</em>). You can also usethe <strong>delete variable</strong> command to delete a variable. When a variable isdeleted, not only the content of the variable disappears, but also thevariable itself--the &quot;box&quot;.</p><blockquote><p><strong>Tip:</strong> To save a variable&#39;s value, set a custom property of thestack to the value of the variable in your applications<strong>closeStackRequest</strong> or <strong>shutDown</strong> handler. To restore thevariable, put the custom property into a variable in the application&#39;s<strong>startUp</strong> or <strong>openStack</strong> handler.</p></blockquote><h3>Variable Scope</h3><p>The <em>scope</em> of a variable is the part of the application where thevariable can be used. If you refer to a variable in a handler that&#39;soutside the variable&#39;s scope, you&#39;ll get either an execution error or anunexpected result.</p><p>There are three levels of variable scope: <strong>local</strong>, <strong>scriptlocal</strong>,and <strong>global</strong>. Every variable is one of these three types. Thedifference between these scopes is in where they can be used and howlong their value lasts.</p><h3>Local Variables</h3><p>A local variable can be used only in the handler that creates it. Oncethe handler finishes executing, the variable is deleted. The next timeyou execute the handler, the variable starts from scratch: it does notretain what you put into it the last time the handler was executed.</p><p>To create a local variable, you simply put something into it. If you usethe <strong>put</strong> command with a variable name that does not yet exist, thevariable is automatically created as a local variable:</p><pre><code>put true into myNewVar -- creates variable named &quot;myNewVar&quot;</code></pre><blockquote><p><strong>Tip:</strong> While you can use almost any word that isn’t a LiveCodelanguage word – also known as a <em>reserved word</em> – for a variable name,it will help you greatly if you get into the habit of naming variableslogically and consistently. For details of what names are allowed forvariables, see the section on <em>Variable Names</em> below. For somerecommendations on naming variables, see the section on <em>Tips for Writing Good Code</em>, below.</p></blockquote><p>Alternatively, you can create a local variable explicitly by declaringit using the <strong>local</strong> command inside a handler:</p><blockquote><p><strong>Important:</strong> If you use a local variable in one handler, and thathandler calls another handler, you can&#39;t use the local variable in thesecond handler. If you use a variable with the same name, LiveCodecreates a second variable that is local to the second handler. But thetwo local variables don&#39;t affect each other, because they&#39;re indifferent handlers.</p></blockquote><pre><code>local myNewVar -- creates variable named &quot;myNewVar&quot;put true into myNewVar -- puts a value into &quot;myNewVar&quot;.</code></pre><p>One common source of bugs involves misspelling a local variable name.Normally, doing so doesn&#39;t produce an execution error, because if youuse a variable that doesn&#39;t exist, LiveCode creates it automatically.This means that if you misspell a variable name, LiveCode creates a newvariable with the mispelled name. Such a bug may be difficult to trackdown because it can result in a variable having the wrong value withoutcausing an error message.</p><p>To prevent this problem, you can require all local variables to bedeclared with the <strong>local</strong> command. You do this by turning on <strong>Script -&gt; Variable Checking</strong> in the Code Editor menu bar. If this option is on, trying to use a local variable that doesn&#39;t existwill cause an execution error, instead of automatically creating it. Anymisspelled variable names will therefore cause an obvious executionerror when their handler is executed, making them easy to find.</p><p>Local variables are deleted when the handler that they&#39;re used infinishes executing. You can also use the <strong>delete variable</strong> command todelete a local variable.</p><h3>Script Local Variables</h3><p>A script local variable can be used in <em>any handler</em> in an object&#39;sscript. You cannot use a script local variable in handlers in otherobjects&#39; scripts. Unlike a local variable, a script local variableretains its value even after a handler finishes executing.</p><p>To create a script local variable, you must use the <strong>local</strong> command inthe script, but outside any handler. We recommend you always declarescript local variables at the top of a script so they in one place andeasy to find:</p><pre><code>local mySharedVariableon mouseDown    put 2 into mySharedVariableend mouseDownon mouseUp    answer mySharedVariable *-- displays &quot;2&quot;*end mouseUp</code></pre><blockquote><p><strong>Note:</strong> If you put the <strong>local</strong> command in a handler, instead ofoutside any handler, it creates a local variable instead. The commandcreates a script local variable only if you put it in the script butnot within a handler.</p></blockquote><p>You can also use the <strong>delete variable</strong> command to delete a scriptlocal variable.</p><h3>Global Variables</h3><p>A global variable can be used in any handler, <em>anywhere</em> in theapplication. Unlike a <em>local</em> variable, a global variable retains itsvalue even after the handler that created it finishes executing. Unlikea <em>script local</em> variable, a global variable can be used by any handlerin any object&#39;s script.</p><p>The same global variable can be used by any stack during a session. Youcan declare a global variable in one stack, and use it in others.</p><p>To create a global variable, you must declare it using the <strong>global</strong>command:</p><pre><code>global someGlobalSetting</code></pre><p>You must also use the <strong>global</strong> command at the start of a handler tomake an existing global variable <em>available</em> to a handler. While aglobal variable can be used by any handler, you must do this in anyhandler you are going to use it in. If you don&#39;t declare a globalvariable before using it, the handler will not take the globalvariable&#39;s existence into account, and will simply create a localvariable with the same name.</p><p>You can use the <strong>global</strong> command either inside a handler, or outsideany handler at the top of a script (like a script local). If you use thecommand in a handler, the global variable can be used by any statementin that handler. If you use the command in a script but outside anyhandler, the global variable is available to every handler in thatscript.</p><p>The following example shows the use of a global variable in a buttonscript. In this example, the variable is declared outside any handler,so the individual handlers don&#39;t need to declare it again:</p><pre><code>global myGlobal -- declares global for the whole scripton mouseDown -- can use &quot;myGlobal&quot;    put 1 into myGlobalend mouseDownon mouseUp -- can use &quot;myGlobal&quot;    add 2 to myGlobal    answer myGlobal-- displays &quot;3&quot;end mouseUp</code></pre><p>To use the same global variable in a handler where the variable isn&#39;tdeclared in the script, you must place the <strong>global</strong> declaration in thehandler:</p><pre><code>on mouseUp -- in another button&#39;s script    global myGlobal    add 5 to myGlobal    answer myGlobalend mouseUp</code></pre><p>If you click the first button, then the secoond, the second buttondisplays the number 8.</p><p>As with script local variables, we recommend you place all <strong>global</strong>declarations in scripts at the top of the script, making thedeclarations easy for you to find later.</p><blockquote><p><strong>Tip:</strong> You can get a list of existing global variables with the<strong>globalNames</strong> function. You can also choose <strong>Development &gt; Variable Watcher</strong> to see a list of global variablesand change their values. Or you can get the value using the Message Box.</p></blockquote><p>Global variables are automatically deleted when you quit theapplication. You can also use the <strong>delete variable</strong> command to deletea global variable.</p><h3>Variable Names</h3><p>The names of variables must consist of a single word and may contain anycombination of letters, digits, and underscores (_). The firstcharacter must be either a letter or an underscore. You cannot use anyLiveCode language word as a name of a variable.</p><p>Here are some examples of <strong>legal</strong> variable names:</p><pre><code>someVariablepicture3my\_new\_file_output</code></pre><p>Here are some names that <strong>cannot</strong> be used as variable names:</p><pre><code>3rdRock -- illegal as starts with a digitthis&amp;That -- illegal as &quot;&amp;&quot; cannot be usedMy Variable –- illegal as it is more than one word</code></pre><p>Avoid giving a variable the same name as a custom property. If you referto a custom property, and there is a variable by the same name, LiveCodeuses the contents of the variable as the name of the custom property.Generally this will produce unexpected results.</p><p>Global variables whose names begin with &quot;gRev&quot; are reserved by theLiveCode development environment.</p><p>See the section on <em>Tips for Writing Good Code</em> below for advice on choosing variable names.</p><h3>Special Variable Types</h3><p>Most of the time, you use variables that you create yourself, using the<strong>local</strong> or <strong>global</strong> commands, or simply by putting a value into anew variable in order to create it.</p><p>LiveCode also creates certain types of variables automatically:<em>parameter</em> variables, <em>command-line</em> variables, <em>environment</em>variables, and the special variable <strong>it</strong>.</p><h4>Parameter variables</h4><p>In a handler for a custom command or custom function, you can defineparameters on the first line of the handler. For example, the followinghandler defines two parameters named &quot;thisThing&quot; and &quot;thatThing&quot;:</p><pre><code>on myHandler thisThing,thatThing    add thisThing to thatThing    subtract thatThing from field 2end myHandler</code></pre><p>When you use the custom command or custom function, you can pass values to it using the parameters:</p><pre><code>myHandler 15,4+1-- puts &quot;15&quot; into the parameter &quot;thisThing&quot;,-- and puts &quot;5&quot; into the parameter &quot;thatThing&quot;</code></pre><p>When named parameters are used in a handler, they are called parametervariables. Within the handler, the parameters can be used in the sameway as local variables: you can get their value, use them inexpressions, and put data into them.</p><p>Like local variables, parameter variables persist only as long as thehandler is executing.</p><h4>Environment variables</h4><p>Most operating systems that LiveCode supports provide information aboutthe operating environment in <em>environment</em> variables.</p><p>You can access environment variables by prepending the <strong>$</strong> characterto the variable&#39;s name. For example, the following statement gets thecontents of the LOGNAME environment variable, which holds the currentuser&#39;s login name:</p><pre><code>get $LOGNAME</code></pre><p>See your operating system&#39;s technical documentation to find out whatenvironment variables are available.</p><p>You can also create your own environment variables by prepending the<strong>$</strong> character to the new environment variable&#39;s name:</p><pre><code>put field 3 into $MYENVVAR</code></pre><blockquote><p><strong>Note:</strong> Environment variables behave like global variables and canbe used in any handler. However, you do not need to use the <strong>global</strong>command to declare them before using them.</p></blockquote><p>The environment variables that you create this way are available to theapplication, and are also exported to processes started up by the<strong>shell</strong> function or the <strong>open process</strong> command.</p><h4>Command-line argument variables</h4><p>If you start up the application from a command line, the command name isstored in the variable <code>$0</code>and any arguments passed on the command lineare stored in numbered variables starting with the <strong>$</strong> character.</p><p>For example, if you start the application by typing the following shellcommand:</p><pre><code>myrevapp -h name</code></pre><p>then the variable <code>$0</code>contains &quot;myrevapp&quot; (the name of the application),$1 contains &quot;-h&quot;, and <code>$2</code>contains &quot;name&quot;.</p><blockquote><p><strong>Note:</strong> Command-line argument variables behave like global variablesand can be used in any handler. However, you do not need to use the<strong>global</strong> command to declare them before using them.</p></blockquote><h4>The special variable &quot;it&quot;</h4><p>The <strong>it</strong> variable is a special local variable used by LiveCode tostore certain results.</p><p>Certain commands--such as <strong>get</strong>, <strong>convert</strong>, <strong>read from file</strong>,<strong>ask</strong>, and <strong>answer</strong>--put their results in this special variable. Fora complete list of commands that use the <strong>it</strong> variable, see the entryfor <strong>it</strong> in the LiveCode Dictionary. The following example shows howthe <strong>answer</strong> command uses the <strong>it</strong> variable:</p><pre><code>on mouseUp     answer &quot;Go where?&quot; with &quot;Backward&quot; or &quot;Forward&quot;     -- the answer command puts the button the user clicked     -- into the it variable:    if it is &quot;Backward&quot; then         go back     else         go next     end ifend mouseUp</code></pre><p>You can use the <strong>it</strong> variable in the same way as any other localvariable, using the <strong>put</strong> command to put things into it and using thevariable in expressions to work with the contents.</p><h3>Array Variables</h3><p>A variable can hold more than a single value. A variable that holds morethan one value is called an array, and each of the values it holds iscalled an element. Each element has its own name (called the element&#39;skey).</p><p>If you think of a variable as a box with a name, you can think of anarray as a box with compartments inside it. Each compartment is an<em>element</em>, and each compartment has a name, or <em>key</em>, of its own.</p><p>You specify an element of an array variable by using the variable namealong with the element&#39;s key. You enclose the key in square brackets.The key may be a name, number or variable. Here&#39;s an example that showshow to put data into one element of an array:</p><pre><code>put &quot;ABC&quot; into myVariable[&quot;myKeyName&quot;]</code></pre><blockquote><p><strong>Note:</strong> If you use a key that&#39;s not a number or variable, you shouldenclose the key&#39;s name in double quotes whenever you refer to it. Thisprevents problems in case there is a variable or reserved word withthe same name.</p></blockquote><p>You can use any element of an array variable in the same way you use thewhole variable: put data into the element (or before or after it) andfind out what data it contains. In this way, any element of a variableis like a variable in and of itself.</p><p>Array elements may contain nested or sub-elements, making themmulti-dimensional. This type of array is ideal for processinghierarchical data structures such as trees or XML. To access asub-element, simply declare it using an additional set of squarebrackets.</p><pre><code>put &quot;ABC&quot; into myVariable[&quot;myKeyName&quot;][“aChildElement”]</code></pre><p>You may nest elements within themselves to any number of levels.</p><h4>Deleting Elements of an Array</h4><p>You use the <strong>delete variable</strong> command to remove one element from anarray variable, in the same way you delete a variable. To delete anelement, you specify both the variable and the element&#39;s key:</p><pre><code>delete variable myVar[&quot;myElement&quot;] delete variablemyVar[“myElement”][“child1”]</code></pre><p>This statement removes the element named &quot;myElement&quot; from the variable&quot;myVar&quot;, but does not delete the other elements in the array.</p><h4>Listing the Elements in an Array</h4><blockquote><p><strong>Tip:</strong> To delete the contents of an element without deleting theelement itself, put <strong>empty</strong> into the element:</p></blockquote><pre><code>put empty into myVar[&quot;myElement&quot;]</code></pre><p>You use the <strong>keys</strong> function to list the elements in an array variable.The <strong>keys</strong> function returns a list of elements, one per line:</p><pre><code>put the keys of myArray into listOfElements</code></pre><h4>Listing Nested Elements within an Element</h4><p>You use the <strong>keys</strong> function to list the child elements of an elementwithn an array variable. The <strong>keys</strong> function returns a list ofelements, one per line:</p><pre><code>put the keys of myArray[“node25”] into listOfElements</code></pre><h4>Transforming a List of Data into an Array</h4><p>The <strong>split</strong> command separates the parts of a variable into elements ofan array. You can specify what character in the list you want the datato be split by. The data will be converted into a set of elements namedaccording to where it is split. For example:</p><pre><code>put &quot;A apple,B bottle,C cradle&quot; into myVariablesplit myVariable by comma and space</code></pre><p>Will result in the following:</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>A</td><td>apple</td></tr><tr><td>B</td><td>bottle</td></tr><tr><td>C</td><td>cradle</td></tr></tbody></table><p>For more details, see the <strong>split</strong> command in the LiveCode Dictionary.</p><h4>Combining the Elements of an Array into a List</h4><p>The <strong>combine</strong> command combines the elements of the <em>array</em> into a single variable. After the command is finished executing, the variable specified by <em>array</em> is no longer an array.</p><p>For example:</p><pre><code>combine myArray using return</code></pre><p>Will combine the contents of the each element of the original <em>array</em> so that they appear on a separate line.</p><p>For more information, see the <strong>combine</strong> command in the LiveCode Dictionary.</p><h4>Nesting an Array</h4><p>You may place an entire array as a child of an element by putting an array variable into an element of another array. For example:</p><pre><code>put tMyArray into tBigArray[“node50”]</code></pre><p>Will result in the entire array being placed as a child of <code>node50</code> within tBigArray.</p><h4>More Information</h4><p>For more information about using array variables, see the guide on <em>Processing Text and Data</em>.</p><h3>Constants</h3><p>A constant is a value that has a name. Like a variable, a constant isset in your script. Unlike variables, constants cannot be changed.</p><p>When you use a constant, LiveCode substitutes the value of the constantfor its name. The following example uses a constant named &quot;slash&quot;:</p><pre><code>put slash after field &quot;Expressions&quot; *-- displays &quot;/&quot;*</code></pre><p>You create a new constant using the <strong>constant</strong> command.</p><p>You cannot put anything into a constant once it&#39;s been created.</p><h4>Built-in constants</h4><p>The LiveCode language defines several constants, such as <strong>return</strong>,<strong>space</strong>, and <strong>comma</strong>, for characters that have special meaning inscripts and therefore can&#39;t be entered literally into an expression.</p><blockquote><p><strong>Tip:</strong> To see a list of all built-in constants, open theDocumentation window, click LiveCode Dictionary, and choose&quot;Constants&quot; from the menu at the top of the window.</p></blockquote><h4>User-defined constants</h4><p>You can also define your own constants using the <strong>constant</strong> command:</p><pre><code>constant myName=&quot;Joe Smith&quot;</code></pre><p>Like variables, constants can have different scope depending on how theyare created. A constant can be defined as either a local constant or ascript local constant:</p><p>If you place the <strong>constant</strong> command in a handler, the constant can beused only in that handler.</p><p>If you place the <strong>constant</strong> command in a script, but outside anyhandler, the constant can be used in any handler in the script.</p><h2><a name="//apple_ref/cpp/Guide/Containers, Operators &amp; Sources of Value" class="dashAnchor"></a>Containers, Operators &amp; Sources of Value</h2><h3>What is a Container?</h3><p>Containers are sources of information that can be edited using chunkexpressions. In addition to variables, LiveCode has six other containertypes: fields, buttons, images, URLs, the selection, and the message box.</p><p>Fields, buttons, and imported images are all LiveCode objects. Alldisplay their content on the screen, in different ways, and the contentsof all three are saved when you save the stack they are in. URLs referto external resources (either files on the system, or items on anInternet server). The Message Box is a special container that&#39;s part ofthe development environment. All of these containers are covered in moredetail in their respective sections.</p><h3>Setting and Retrieving Data from Containers</h3><p>You use the <strong>put</strong> command to place data into a container, or to placedata from a container into another container or variable. Containerssupport the use of chunk expressions, the ability to specify a portionof a container by referring to it in English. For more details, see thesection on <em>Chunk Expressions</em>.</p><h3>What are Sources of Value?</h3><p>Sources of value are like containers. They can be retrieved using the<strong>get</strong> command. However unlike containers, they cannot be set using the<strong>put</strong> command. Sources of value include properties, function calls,literal strings, and constants.</p><h3>Getting and Setting Properties</h3><p>You can use the <strong>get</strong> command to retrieve data from properties.Properties may be set using the <strong>set</strong> command. When retrieving datayou may use chunk expressions. However you must set a property in itsentirety, using the set command. Properties are covered in more detailin the section on <em>Properties</em>. Examples of retrieving and settingproperties are to be found throughout this <em>User’s Guide</em>.</p><h3>What are Literal Strings?</h3><p>A literal string is a string of characters whose value is itself. If the string is a number, the value is that number.</p><h3>Using Literal Strings</h3><p>When you use a literal string in an expression, LiveCode simply substitutes the string for itself:</p><pre><code>put &quot;Hello World!&quot; into field 1get 1 + 2 + itput 1 - 4.234 into field &quot;Result&quot;</code></pre><h4>Quoting strings</h4><p>Literal strings that consist of more than one word or are reserved wordsin the LiveCode language must be enclosed in double quotes:</p><pre><code>put &quot;This is a test&quot; into myVar -- worksput This is a test into myVar -- **DOESN&#39;T WORK - not quoted**put That into myVar -- worksput This into myVar -- **DOESN&#39;T WORK - reserved word**</code></pre><p>In some contexts, you can use an unquoted one-word literal stringwithout causing a script error. However, you should make a practice ofalways quoting literal strings (other than numbers), because it ensuresthat the statement will continue to work properly even if the stringbecomes a reserved LiveCode word in the future.</p><p>If the <strong>Script -&gt; Variable Checking</strong> option is set to true, compilinga script that contains an unquoted literal string causes a script error.</p><h3>What are Operators?</h3><p>Use operators to put together, compare or perform an operation on data.Use a <em>String Operator</em> to combine data. Use a <em>Numeric Operator</em> toperform a calculation. Finally, use a <em>Logical Operator</em> to return trueor false.</p><h3>Numeric Operators</h3><p>Numeric operators produce a number as their result. Numeric operatorsinclude the arithmetic operators (**+**, <strong>-</strong>, <strong>\</strong>*, <strong>/</strong>, <strong>mod</strong>,<strong>div</strong>, and <strong>^</strong>) and the bitwise operators (**bitAnd**, <strong>bitOr</strong>,<strong>bitXOr</strong>, and <strong>bitNot</strong>). For individual usage instructions, look upthe operator you wish to use in the LiveCode Dictionary.</p><p>For example:</p><pre><code>put &quot;1+2 =&quot; &amp;&amp; 1+2 into field &quot;Eq&quot; -- displays &quot;1+2 = 3&quot;</code></pre><h4>String operators</h4><p>String operators produce a string of characters as their result. String operators are the concatenation operators (**&amp;**, <strong>&amp;&amp;</strong>, and <strong>,</strong>).</p><pre><code>put &quot;1+2 =&quot; &amp;&amp; 1+2 into field &quot;Eq&quot; -- displays &quot;1+2 = 3&quot;</code></pre><h3>Logical Operators</h3><p>Logical operators produce either &quot;true&quot; or &quot;false&quot; as their result.</p><p>Logical operators include the comparison operators (**=**, <strong>&lt;&gt;</strong>,<strong>&lt;</strong>, <strong>&gt;</strong>, <strong>&lt;=</strong>, <strong>&gt;=</strong>), existence operators (**there is a**,<strong>there is no</strong>, <strong>is in</strong>, <strong>is not in</strong>, <strong>is among</strong>, <strong>is not among</strong>, <strong>contains</strong>), data type operators (**is a**, <strong>is not a</strong>), geometry operators (**is within**, <strong>is not within</strong>), and basic logical operators (**and**, <strong>or</strong>, <strong>not</strong>).</p><pre><code>if the platform is &quot;MacOS&quot; and field &quot;Time&quot; &lt; zero then ...</code></pre><h3>Binary versus Unary Operators</h3><p>Operators can use either one argument (a unary operator) or twoarguments (a binary operator):</p><pre><code>&quot;a&quot; &amp; &quot;b&quot; -- &amp; is binary there is a field &quot;c&quot; -- **there is a** is unary</code></pre><p>The <strong>bitNot</strong>, <strong>there is a</strong>, <strong>there is no</strong>, <strong>is a</strong>, <strong>is not a</strong>,and <strong>not</strong> operators are unary operators. All other operators arebinary operators.</p><h3>Conversion of Values</h3><p>LiveCode converts values in expressions to whatever type of data isneeded for the operation. This conversion happens automatically, so youdon&#39;t need to know what type of data you are dealing with in advance(something that in other languages is called &quot;type casting&quot;).</p><p>For example, suppose you have the following statement:</p><pre><code>put char 2 of &quot;123&quot; + char 3 of &quot;456&quot; into field 3</code></pre><p>Character 2 of the literal string &quot;123&quot; is the single-character string&quot;2&quot;, and character 3 of the literal string &quot;456&quot; is the single-characterstring &quot;6&quot;. When LiveCode uses the <strong>+</strong> operator, it automaticallyconverts these strings to numbers so that they can be added together.Then it converts the resulting number back to a string so that it can beplaced in a field as text.</p><h3>Operator Precedence</h3><p>When you combine sources of value using operators, LiveCode evaluateseach source of value in the expression. Next, it applies any operatorsto arrive at a final value for the expression. LiveCode does notnecessarily apply all the operators in right-to-left order.</p><p>Instead, it uses the operator precedence order to determine how tocompute expressions that include more than one operator. Precedencedetermines the order in which LiveCode carries out calculations inexpressions. If an expression contains more than one operator, theoperators with higher precedence are calculated before operators withlower precedence.</p><p>Figure 49 – Operator Precedence</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>Grouping</td><td>**() **</td><td>Any part of the expression in parentheses is evaluated first. If parentheses are nested, the innermost values are evaluated first.</td></tr><tr><td>Unary</td><td><strong>-</strong><br><strong>not</strong><br><strong>bitNot</strong><br><strong>there is a</strong><br><strong>there is no</strong></td><td>Next, unary operations (that act on only one operand) are done. This includes unary minus (which makes a number negative).</td></tr><tr><td>Exponentiation</td><td><strong>^</strong></td><td>Next, exponentiation operations are done.</td></tr><tr><td>Multiplication</td><td><strong>\</strong>*<br><strong>/</strong><br><strong>div</strong><br><strong>mod</strong></td><td>Multiplication and division are done next. These are numeric operators and result in a number.</td></tr><tr><td>Addition</td><td><strong>+</strong><br><strong>-</strong></td><td>Addition and subtraction are done next. These are numeric operators and result in a number.</td></tr><tr><td>Concatenation</td><td><strong>&amp;</strong><br><strong>&amp;&amp;</strong><br><strong>,</strong></td><td>Operations that join two strings are done next. These are string operators and result in a string.</td></tr><tr><td>Comparison</td><td><strong>&lt;</strong><br><strong>&lt;=</strong><br><strong>&gt;</strong><br><strong>&gt;=</strong><br><strong>contains</strong><br><strong>is among</strong><br><strong>is not among</strong><br><strong>is in</strong><br><strong>is not in</strong><br><strong>is within</strong><br><strong>is not within</strong><br><strong>is a</strong><br>**is not a **</td><td>Operations that compare two values are done next. These are logical operators and result in either true or false.</td></tr><tr><td>Equality</td><td><strong>=, is</strong><br><strong>&lt;&gt;, !=, ?, is not</strong></td><td>Operations that compare two values for equality are done next. These are logical operators and result in either true or false.</td></tr><tr><td>bitAnd</td><td><strong>bitAnd</strong></td><td>bitAnd operations are done next.</td></tr><tr><td>bitXOr</td><td><strong>bitXOr</strong></td><td>bitXOr operations are done next.</td></tr><tr><td>bitOr</td><td><strong>bitOr</strong></td><td>bitOr operations are done next.</td></tr><tr><td>and</td><td><strong>and</strong></td><td>and operations are done next.</td></tr><tr><td>or</td><td><strong>or</strong></td><td>or operations are done last.</td></tr><tr><td>function calls</td><td></td><td>Functions are evaluated after all possible operators in the function’s parameters are evaluated.</td></tr></tbody></table><h3>Using the Grouping Operator <em>()</em></h3><p>Suppose you want to change the precedence used in an expression. Thegrouping operator () has higher precedence than all other operators, soyou can use it to change the order in which operators are evaluated. Inother words, if you enclose part of an expression in parentheses, anyoperations inside the parentheses are evaluated before anything elsehappens.</p><p>For example, function calls have higher precedence than division, so theexpression the sin of 1/4 means &quot;get the sine of 1, then divide it by4&quot;:</p><pre><code>get the sin of 1/4 -- does the sin function first</code></pre><p>If you want the sine of 1/4, you need to change the order of evaluationso that the division is done first. You do this by surrounding the partyou want evaluated first with parentheses:</p><pre><code>get the sin of (1/4) -- does the division first</code></pre><p>If parentheses are nested, the expression within the innermost set ofparentheses is evaluated first.</p><h3>Factors and Expressions</h3><p>An expression is any source of value, or combination of sources ofvalue. Any of the sources of value discussed above – containers,properties, function calls, literal strings, and constants – are simpleexpressions. You use operators to combine sources of value to producemore complex expressions.</p><h3>Defining Factors</h3><p>A factor is the first fully resolvable portion of an expression. (Allfactors are expressions, but not all expressions are factors.) A factorcan be either a source of value, or an expression that combines sourcesof value but doesn&#39;t include any binary operators outside parentheses.Enclosing an expression in parentheses turns it into a factor.</p><p>These examples show some expressions, along with the first factor ineach expression, to help you see the distinction:</p><table><thead><tr><th>Expression</th><th>First factor</th></tr></thead><tbody><tr><td>3 + 4</td><td>3</td></tr><tr><td>(3 + 4)</td><td>(3 + 4)</td></tr><tr><td>(3 + 4)/field 4</td><td>(3 + 4)</td></tr><tr><td>field 6 * pi</td><td>field 6</td></tr><tr><td>sin of pi/4</td><td>sin of pi</td></tr><tr><td>sin(pi/4)</td><td>sin(pi/4)</td></tr><tr><td>sin(pi/4) * exp2(12)</td><td>sin(pi/4)</td></tr><tr><td>whole world</td><td>whole</td></tr><tr><td>&quot;whole world&quot;</td><td>&quot;whole world&quot;</td></tr></tbody></table><h4>When it matters</h4><p>The distinction between factors and expressions matters when you&#39;re using the <strong>the</strong> form of built-in functions, when you use <strong>URL</strong>, and when you refer to objects.</p><p>If you use the <strong>the</strong> form of a built-in function that has a parameter, the parameter must be a factor, not an expression:</p><pre><code>get the sqrt of 4 + 5 -- yields 7get sqrt(4+5) -- yields 3get the sqrt of (4 + 5) -- yields 3</code></pre><p>In the first example above, although we intended to get the square rootof 9, we actually ended up with the square root of 4. This is becausethe expression <code>4 + 5</code> is not a factor (because it contains a binaryoperator that&#39;s not inside parentheses). The first factor in theexpression <code>4 + 5</code> is 4, so the first example gets the square root of 4(which is 2), then adds 5 to that result.</p><p>The second example avoids this problem because it doesn&#39;t use the &quot;the&quot;form of the function. Since the parameter is enclosed in parentheses,you can use either a factor or an expression, and obtain the intendedresult, the square root of 9.</p><p>In the third example, we turn the expression <code>4 + 5</code> into a factor bysurrounding it with parentheses. Since the parameter is now a factor, wecan get the correct result, even using the <strong>the</strong> form of the function.</p><p>When referring to URLs, the URL is a factor:</p><pre><code>get URL &quot;file:myfile.txt&quot; -- worksget URL &quot;file:&quot; &amp; &quot;myfile.txt&quot; -- **DOESN&#39;T WORK**get URL (&quot;file:&quot; &amp; &quot;myfile.txt&quot;) -- works</code></pre><p>In the first example, the URL specified is a factor because it is a simple string with no operators.</p><p>The <strong>URL</strong> in the second example is not a factor, because it includes the binary operator <strong>&amp;</strong>, so the <strong>get</strong> command tries to get the URL &quot;file:&quot; – which is nonexistent--and concatenate the content of that <strong>URL</strong> with the string &quot;myfile.txt&quot;.</p><p>In the third example, we turn the <strong>URL</strong> into a factor by surrounding it with parentheses, providing the expected result.</p><p>When referring to <strong>cards</strong> or <strong>backgrounds</strong>, the <strong>name</strong>, <strong>number</strong> or <strong>ID</strong> of the object is an expression:</p><pre><code>go card 1 + 1 -- goes to card 2go card 3 of background &quot;Data&quot; &amp;&amp; &quot;Cards&quot;-- goes to first card with the group &quot;Data Cards&quot;</code></pre><p>However, when referring to controls (including groups) or stacks, the <strong>name</strong>, <strong>number</strong>, or <strong>ID</strong> of the object is a factor:</p><pre><code>answer field 1 + 10 -- displays field 1 content + 10answer field (1 + 10) -- displays field 11 contentselect button &quot;My&quot; &amp;&amp; &quot;Button&quot; -- **DOESN&#39;T WORK**select button (&quot;My&quot; &amp;&amp; &quot;Button&quot;) – works</code></pre><h2><a name="//apple_ref/cpp/Guide/Making Decisions" class="dashAnchor"></a>Making Decisions</h2><p>You make decisions using the <strong>if … then … else</strong> control structure or, if you want to choose from a list of options, use the <strong>switch</strong> control structure.</p><h3>If … then … else</h3><p>Use the <strong>if</strong> control structure to execute a statement or list ofstatements under certain circumstances. For example, you may want yourapplication to respond differently depending on a user action.</p><p>The <strong>if</strong> control structure always begins with the word <strong>if</strong>. There are four forms of the <strong>if</strong> control structure:</p><pre><code>if condition then statement [else elseStatement]</code></pre><p>This form may have a line break before the words <code>then</code> or <code>else</code> or both.</p><pre><code>if condition then     statementList [else     elseStatementList] end ifif condition then statement [else     elseStatementList end if]if condition then     statementList else elseStatement</code></pre><p>The <em>condition</em> is any expression that evaluates to true or false. The<em>statementList</em> or <em>elseStatementList</em> consists of one or more LiveCodestatements, and can also include if, switch, try, or repeat controlstructures. The <em>statement</em> or <em>elseStatement</em> consists of a singleLiveCode statement.</p><p>If the <em>condition</em> evaluates to true, the <em>statement</em> or <em>statementList</em>is executed; if the <em>condition</em> evaluates to false, the <em>statement</em> or<em>statementList</em> is skipped. If the if control structure contains an elseclause, the <em>elseStatement</em> or <em>elseStatementList</em> is executed if the<em>condition</em> is false.</p><p>If one if control structure is nested inside another, use of the secondform described above is recommended, since the other forms may causeambiguities in interpreting which else clause belongs with which ifstatement.</p><p>The if control structure is most suitable when you want to check asingle <em>condition</em>. If you need to check for multiple possibilities,doing something different for each one, use a switch control structureinstead.</p><h3>Switch</h3><p>Use the <strong>switch</strong> control structure when you want to choose among several possible values for an expression and then execute a set of statements that depends on the value.</p><pre><code>switch [switchExpression] case {caseValue | caseCondition}    [statementList] [default defaultStatementList] end switch</code></pre><p>The <strong>switch</strong> control structure begins with the word switch on a singleline, with an optional <em>switchExpression</em>. The <strong>switch</strong> line isfollowed by one or more case sections. Each case section begins with thecase keyword, followed by either a <em>caseValue</em> (if a <em>switchExpression</em>was included on the <strong>switch</strong> line) or a <em>caseCondition</em> (if no<em>switchExpression</em> was included). If the <em>caseValue</em> is equal to the<em>switchExpression</em>, or the <em>caseCondition</em> evaluates to true, LiveCodebegins executing the following statements.</p><p>The <strong>case</strong> sections may be followed by an optional default section. Ifno <strong>break</strong> statement has been encountered yet in the switch controlstructure, the statements in the default section are executed. The<strong>switch</strong> structure ends with an end switch statement.</p><p>The <em>switchExpression</em> is any expression. The <em>caseValue</em> is anyexpression. If the <em>caseValue</em> evaluates to the same value as the<em>switchExpression</em>, the condition is matched for that case section. The<em>caseCondition</em> is any expression that evaluates to true or false. (Ifthe <em>caseCondition</em> evaluates to true, the condition is matched for thatcase section. Each <em>statementList</em> consists of one or more LiveCodestatements, and can also include if, switch, try, or repeat controlstructures. The <em>defaultStatementList</em> consists of one or more LiveCodestatements.</p><p>Flow of control in a <strong>switch</strong> structure is less complicated than itlooks. In general, when LiveCode enters a <strong>switch</strong> control structure,it looks for the first case section whose <em>caseValue</em> is equal to the<em>switchExpression</em>, or whose <em>caseCondition</em> is true. When a matchingcondition is found, all statements following it are executed--evenstatements in another case section--until either a break statement isencountered or the <strong>switch</strong> control structure ends.</p><p>This means that if you do not end a <strong>case</strong> section&#39;s <em>statementList</em>with a break statement, the statements in all the following casesections (and the default section) are executed even if those casesections don&#39;t have a matching <em>caseValue</em> or a true <em>caseCondition</em>.Occasionally, this behavior is useful. However, in most cases, youshould place a break statement at the end of each <em>statementList</em>. Thisensures that only one <em>statementList</em> is executed, and the rest areskipped.</p><p>This also means that you can attach more than one <em>caseValue</em> or<em>caseCondition</em> to the same <em>statementList</em>, simply by placing one caseline above the next. The following example beeps if the current card iseither the last or first card, and goes to the next card otherwise:</p><pre><code>switch (the number of this card) case 1 case (the number of cards)    -- either of the above conditions execute the following     -- statement:    beep     break default     go next card end switch</code></pre><p>There is no limit to the number of <strong>case</strong> sections you can include ina <strong>switch</strong> control structure, although the more case sections thereare, the more expressions LiveCode must evaluate and the more slowly the<strong>switch</strong> structure executes.</p><h2><a name="//apple_ref/cpp/Guide/Extending the Message Path" class="dashAnchor"></a>Extending the Message Path</h2><p>This section deals with how to extend the message path, either by addingcode libraries to the message path, or by sending messages directly toobjects that are not currently in the message path.</p><h3>Creating a Code Library</h3><p>A library is a set of custom commands and custom functions for aspecific application or a specific area of functionality. You can createa library for any purpose you want, and put any custom commands andfunctions into it that you need. Libraries are typically used to storeroutines that are common across your application. You can also exchangeuseful libraries with other developers.</p><p>To create a code library, place the handlers you want to use in anyobject that&#39;s available in your stack. This object is now a codelibrary. Then use the <strong>insert script</strong> command to add that object tothe message path. To insert the script of a stack into the message path,use the <strong>start using</strong> command. Typically you would run one of thesecommands as your application is starting up, so that all the scripts canaccess the libraries you require. Libraries do not need to be in thesame stack or even stack file, you can load any stack on disk and thenload the libraries within it to make them available to all runningstacks. This makes it easy to design your application in modules, sharecode with other developers or update your application libraries withoutmodifying your application. You can design your standalone applicationto work in the same way, making it easy to update it using a small patchutility, i.e. without having to reinstall the entire application.</p><h3>Using backScripts</h3><p>To make the script of an object available to any other handler inLiveCode:</p><pre><code>insert script of card &quot;Library&quot; into back</code></pre><p>The script of an object that&#39;s been inserted into the back, as in theabove example, is called a <strong>backScript</strong>. Such an object is placed lastin the message path of all objects. It receives messages after any otherobject, and just before the engine receives the message. The<strong>backScript</strong> object remains in the message path until the end of thesession (or until you remove it with the <strong>remove script</strong> command.)</p><p>Because a <strong>backScript</strong> receives messages after all other objects inthe message path, if you place a handler in the <strong>backScript</strong>, iteventually gets all the corresponding messages, no matter what objectsent them, unless another object handles them first.</p><h3>Using frontScripts</h3><p>You can also extend the message path by placing objects into the frontof the message path, before any other object. The script of such anobject is called a frontscript, and you use the <strong>insert script</strong>command to place the object in the front:</p><pre><code>insert script of button &quot;Interceptor&quot; into front</code></pre><p>Because the object is in the front of the message path, it receivesmessages even before the target of the message. For example, if youclick a button, any objects in the front of the message path receive the<strong>mouseUp</strong> message first, before the button. If you place a handler ina frontscript, it receives all the corresponding messages before anyother object can handle them.</p><p>Use a frontscript when you want to be able to handle a message even ifthe target object has a handler for it. For example, the LiveCodedevelopment environment displays a contextual menu when you<strong>Control-Shift-right-click</strong> an object. It does this with a<strong>mouseDown</strong> handler in a frontscript. Whenever you click an object,the frontscript receives the <strong>mouseDown</strong> message first, and checkswhether the needed keys are being pressed. If they are, the handlerdisplays the contextual menu; the <strong>mouseDown</strong> message is trapped andgoes no further. Otherwise, the handler passes the message to the nextobject in the message path, which is the object you clicked.</p><h3>Using a Stack&#39;s Script with <em>start using</em></h3><p>The <strong>start using</strong> command is similar to the <strong>insert script</strong> command,but can be used only to place stacks, not other object types, in themessage path.</p><p>The <strong>start using</strong> command inserts the stack at the end of the messagepath, <em>after</em> the object&#39;s stack and main stack, but <em>before</em> objectsthat have been inserted into the back with <strong>insert script</strong>.</p><h3>Sending Messages Directly to Objects</h3><p>If the handler you want to use is not in the message path, instead ofinserting it into the path to make it a code library, you can use the<strong>send</strong> command to directly <strong>send</strong> a message to the object whosescript contains the handler.</p><blockquote><p><strong>Tip:</strong> You can use this technique to skip a portion of the messagepath, by sending the message directly to an object further up thehierarchy.</p></blockquote><pre><code>on mouseUp     -- in button script     send &quot;mouseUp&quot; to this stack end mouseUp</code></pre><p>For example, suppose you have a handler for a custom command called<em>myCommand</em> in the script of a button, and you want to execute thathandler from a card script. Since the button is not in the card&#39;smessage path, you can&#39;t simply use the command in the script, because ifthe <em>myCommand</em> message goes through the card&#39;s message path, it won&#39;tfind the handler. The following statement sends the message directly tothe button whose script includes the handler:</p><pre><code>send &quot;myCommand&quot; to button &quot;Stuff&quot; of card &quot;Stuff Card&quot;</code></pre><blockquote><p><strong>Important:</strong> When you send a message to an object, the message pathfor that message starts with the target object. For example, if astack script contains a <strong>send</strong> command that sends a message to abutton, the message moves through the button&#39;s message path, not thestack&#39;s.</p></blockquote><p>If you want to use a custom function whose function handler is not inthe message path, you can use the <strong>value</strong> function to specify theobject. The <strong>value</strong> function can be thought of as an equivalent of the<strong>send</strong> command for function calls.</p><p>For example, if card 1 of a stack contains a function handler called&quot;myFunction&quot; you can use the function from within the script of card 3with the following statement:</p><pre><code>get value(&quot;myFunction(1,2,3)&quot;,card 1)</code></pre><h3>The <em>send</em> Command versus the <em>call</em> Command</h3><p>The <strong>call</strong> command is similar to the <strong>send</strong> command. Like the<strong>send</strong> command, the <strong>call</strong> command sends a message to the specifiedobject, allowing you to use handlers that aren&#39;t in the message path.</p><p>The difference between <strong>send</strong> and <strong>call</strong> is how they handle objectreferences in the handler that is triggered by the sent message. If themessage is sent by the <strong>send</strong> command, object references in thehandler are treated relative to the object you sent the message to.</p><p>For example, suppose card 1 of a stack contains the following handler:</p><pre><code>on showCard     answer the number of this card end showCard</code></pre><p>If a handler in the script of card 3 uses the <strong>send</strong> command to send a&quot;showCard&quot; message to card 1, the dialog box displays &quot;1&quot;, the number ofthe card the handler is on. However, if the same handler uses the<strong>call</strong> command instead, the dialog box displays &quot;3&quot;, the number of thecard that used the <strong>call</strong> command. In other words, handlers that aretriggered by the <strong>send</strong> command use the context of the object thehandler is in, while handlers that are triggered by the <strong>call</strong> commanduse the context of the object that triggered the handler.</p><h3>Writing reusable code using behaviors</h3><p>Behaviors are a method to create common functionality between objectswithout duplicating the scripts.</p><p>An object with a <strong>behavior</strong> set will act as though its script was setto the script of the <strong>behavior</strong> button. If multiple objects share thesame behavior, each will have its own set of script local variables. Anyreferences to <strong>me</strong>, the <strong>owner of me</strong>, etc will resolve to the childobject currently executing.</p><p>Behavior scripts must be stored in button objects. To set an object’sbehavior, refer to the long id of the button containing the behaviorscript.</p><h2><a name="//apple_ref/cpp/Guide/Timer Based Messaging" class="dashAnchor"></a>Timer Based Messaging</h2><p>Timers allow you to schedule events to happen in the future. Use timersfor updating the display at regular intervals, processing data inchunks, playing animations, displaying status bars, or anywhere whereyou need to schedule events. Messages can be scheduled with millisecondprecision and fire many times a second to create an animation, or can bescheduled to arrive hours later. When you schedule an event to bedelivered in the future, LiveCode continues to respond to user events asnormal. This makes timer based messaging ideal where you want your userinterface to remain responsive while doing data processing or updatingthe display.</p><h3>Delivering a Message in the Future</h3><p>To deliver a message after a specified time period, use the <em>in time</em> form of the send command.</p><pre><code>send &quot;updateStatus&quot; to me in 20 secondssend &quot;updateAnimation&quot; to me in 33 milliseconds</code></pre><h3>Repeating a Timer Message</h3><p>If you want to send a message repeatedly, for example to continuouslydraw frames in an animation, simply send the same message again at theend of the message handler. The following example starts an animationwhen the button is clicked on, then updates the frame at 30 frames persecond (every 33 milliseconds).</p><pre><code>on mouseUp     updateAnimation end mouseUpon updateAnimation     -- insert code to update animation here     send updateAnimation to me in 33 milliseconds end updateAnimation</code></pre><p>The result will be that the <em>updateAnimation</em> message is sent, it willupdate the screen then send itself to itself in a 33 milliseconds. Themessage will continue to be delivered indefinitely. Therefore it isimportant that you ensure there is an condition in the message handlerthat will exit when the task is done, without sending the message again.Alternatively you can directly cancel any message to stop the loop (seethe section <em>Canceling a Timer Message</em> below for more details).</p><p>To create a <em>smooth script driven animation</em>, you should allow for thetime it takes to redraw the display and for any interruptions (e.g.another intensive process causing your message to be delivered late).Thus it is best to send the message a little more frequently than youneed to redraw the screen, and to check each time the message isactivated what frame you should currently be on.</p><pre><code>-– variables will be available to all script handlerslocal sTotalFrames, sStarton mouseUp    -- store the current start time    put the milliseconds into sStart    -- put the number of frames in your animation here    put 100 into sTotalFrames updateAnimationend mouseUpon updateAnimation    -- calculate milliseconds since start    put the milliseconds – sStart into tElapsedTime    put round(tElapsedTime / 33) into tFrameNumber    -- calculate current frame number    if tFrameNumber &gt; sTotalFrames then        -- if we have reached the end        set the currentFrame of image 1 to sTotalFrames        -- draw the last frame        exit updateAnimation        -- exit without sending updateAnimation again    end if    -- insert code for drawing the screen here    -- in this example we assume the animation is a simple    -- animated GIF    -- but you could have any type of operation here, e.g.    -- setting the transform of a vector    set the currentFrame of image 1 to tFrameNumber    -- send another updateAnimation message     send updateAnimation to me in 22 millisecondsend updateAnimation</code></pre><p>For more example scripts involving timers and animation, see the <em>Sample Scripts</em> section of the online documentation.</p><h3>Canceling a Timer Message</h3><p>When a timer message is sent, <strong>the result</strong> function contains the ID ofthe message generated. Use the <strong>cancel</strong> command to cancel thatmessage, preventing it from being delivered. In the following example, adialog will be displayed 20 seconds after the user moves the mouse overa button. If the mouse moves out of the button before the 20 seconds haselapsed, the dialog will not be displayed.</p><pre><code>local LTimerIDon mouseEnter    send &quot;displayDialog&quot; to me in 20 seconds    put the result into lTimerIDend mouseEnteron mouseLeave    cancel lTimerIDend mouseLeaveon displayDialog    answer &quot;The mouse was over this button for 20 seconds.&quot;end displayDialog</code></pre><blockquote><p><strong>Important:</strong> Ensure you have a way to cancel any pending timermessages. Typically you may want to ensure that a timer is cancelledwhen the card is closed. For example a timer message that draws ananimation on the current card will generate a script error if the cardis changed and the message is still sent, as the script will no longerbe able to find the objects.</p></blockquote><h3>Displaying a List of Pending Timer Messages</h3><p>You can get a list of all the currently pending timer based messagesusing the <strong>pendingMessages</strong> function.</p><pre><code>put the pendingMessages into tMessagesList</code></pre><p><em>tMessagesList</em> will now contain a list of messages, one per line. Eachline consists of four items, separated by commas:*the message ID, *thetime the message is scheduled for, *the message name, *the long IDproperty of the object that the message will be sent to</p><blockquote><p><strong>Tip:</strong> You can see a list of all pending messages using the <em>Message Box</em> pending messages tab – the fifth icon along. For more details, see the section on the <em>Message Box</em>.</p></blockquote><p>For more details, see the pendingMessages entry in the <em>LiveCode Dictionary</em>.</p><blockquote><p><strong>Tip:</strong> To cancel all currently pending messages indiscriminately,use the following repeat loop:</p></blockquote><pre><code>repeat for each line l in the pendingMessages    cancel (item 1 of l)`end repeat</code></pre><h2><a name="//apple_ref/cpp/Guide/Tips for Writing Good Code" class="dashAnchor"></a>Tips for Writing Good Code</h2><p>Its worth taking time to establish some conventions in how you writecode. There are many benefits to making your coding practicesconsistent. Consistently named variables are easier to debug duringdevelopment because you will always know the scope of a particularvariable (whether it&#39;s a global, or applies only to the current handler,etc.). It makes it easier to understand the code you have written whenyou come to read it 6 months later. By making appropriate use offunctions and libraries, you make your program more modular andtherefore easier to modify and add features to in the future. Acomprehensive guide to writing good code is beyond the scope of thismanual. But we thought it would be helpful to give you some hints andtips</p><h4>Variable naming</h4><p>Use consistent variable names to make your code easier to understand. Itmay not seem important now, but when you have forgotten how it works 6months later it will help to make it readable. It also makes it easierto exchange you code with other members of the LiveCode community, whenyou need to get help with something.</p><table><thead><tr><th>Character</th><th>Example</th><th>Usage</th></tr></thead><tbody><tr><td>g</td><td>gVar</td><td>Global variables</td></tr><tr><td>t</td><td>tVar</td><td>Handler-local variables</td></tr><tr><td>s</td><td>sVar</td><td>Script-local variables</td></tr><tr><td>p</td><td>pVar</td><td>Parameters</td></tr><tr><td>k</td><td>kVar</td><td>Constants</td></tr><tr><td>c</td><td>cVar</td><td>Custom properties</td></tr></tbody></table><h4>Variable scope</h4><p>As a general rule of thumb, use a variable with just enough scope and nomore for the task at hand. In other words, if a handler local variableis all you need for a calculation, don&#39;t use a script local. If a scriptlocal would do, don&#39;t use a global. This makes it less likely that youwill introduce unexpected errors into your code by using the samevariable name for different purposes. A handler local variable only hasmeaning within that handler so you can safely use the same variable namein other handlers.</p><h4>Use of comments</h4><p>Comment your code as you go. Don&#39;t write comments where the meaning isobvious. But even a sentence next to a complex routine will help you orothers to quickly understand it later.</p><h4>Use of functions</h4><p>If you&#39;re writing a lot of code, consider whether it can be written as aseries of functions instead of as a single monolithic handler. Thismakes it much easier to understand the function of each discrete sectionof code. The more you can make these functions &quot;black boxes&quot;, that takeinput and produce output without dependences, the easier it will be ifyou later want to change how that aspect of the code works.</p><h4>Explicit Variables</h4><p>If you&#39;re working on a larger code base you may want to turn on theVariable Checking option in the Script menu of the Code Editor. Thismakes LiveCode require that you declare all variables (even scriptlocals) before you can compile your script. It also requires you toplace all literal strings in quotes. This method of coding can help youto quickly track down errors as you go by making you think a littleabout what variables you are going to use at an early stage, andpointing out spelling mistakes.</p><p>What&#39;s most important is that you develop your own consistent style andthen stick to it. Once you have been applying some of these techniquesfor a short time, they will become second nature.</p><p>For a more in-depth look at this subject, we recommend <a href="http://www.fourthworld.com/embassy/articles/scriptstyle.html">Fourth World&#39;sScripting Style Guide</a></p></body></html>