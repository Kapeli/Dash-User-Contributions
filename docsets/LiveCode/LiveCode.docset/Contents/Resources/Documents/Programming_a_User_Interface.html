<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Programming a User Interface</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: basic</h2><h1>Programming a User Interface</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>The user interface for your application is often one of its most important features. The <em>LiveCode Script</em> guide shows how to build a user interface using LiveCode’s tools and development environment. In this guide we look at how you can edit, or even build a user interface programmatically. Everything you can do using the built-in tools you can also do programmatically. You can even create and modify a user interface at run time in a standalone application, or provide interactive methods for your users to modify specific aspects of your application. This set of capabilities allow you to produce applications that construct their interface using XML files or a custom data structure, programmatically construct aspects of complex interfaces, modify their look using user specified parameters, create themed or skinned interface options, build your own interface editing tools that plug-in to LiveCode’s IDE and much more. You can also create custom objects and attach your own virtual behaviors and custom properties to them. We recommend you spend a little time becoming familiar with building an interface using the tools in the development environment before creating or editing an interface programmatically.</p><h2><a name="//apple_ref/cpp/Guide/Referring to Objects" class="dashAnchor"></a>Referring to Objects</h2><p>In general, you can refer to any object by its <strong>name</strong>, <strong>number</strong>, or <strong>ID</strong> property.</p><h3>Referring to objects by name</h3><p>You can refer to an object using its object type followed by its name. For example, to refer to a button named &quot;OK&quot;, use the phrase <code>button &quot;OK&quot;</code>:</p><pre><code>set the loc of button &quot;OK&quot; to 32,104</code></pre><p>To change an object&#39;s name, enter a name in the object&#39;s property inspector, or use the <strong>set</strong> command to change the object&#39;s <strong>name</strong> property:</p><pre><code>set the name of field &quot;Old Name&quot; to &quot;New Name&quot;select after text of field &quot;New Name&quot;</code></pre><h3>Referring to objects by number</h3><p>A control&#39;s number is its layer on the card, from back to front. A card&#39;s number is its position in the stack. A stack&#39;s number is the order of its creation in the stack file. A main stack&#39;s number is always zero.</p><p>You can refer to an object using its object type followed by its number. For example, to refer to the third-from-the-back field on a card, use the phrase &quot;field 3&quot;:</p><pre><code>set the backgroundColor of field 3 to blue</code></pre><p>To change the number of a card or control, change the Layer box in the Size &amp; Position pane of the object&#39;s property inspector, or use the <strong>set</strong> command to change the object&#39;s <strong>layer</strong> property:</p><pre><code>set the layer of field &quot;Backmost&quot; to 1</code></pre><blockquote><p><strong>Tip:</strong> New objects are always created at the top layer. To refer to an object you&#39;ve just created, use the ordinal <strong>last</strong>:</p></blockquote><pre><code>create buttonset the name of last button to &quot;My New Button&quot;</code></pre><h3>Referring to objects by ID</h3><p>Each object in LiveCode has an ID number. The <strong>ID</strong> property never changes (except for stack IDs), and is guaranteed unique within the stack: no two objects in the same stack can have the same <strong>ID</strong> property.</p><p>You can refer to an object using its object type, then keyword <code>ID</code>, followed by its <code>ID</code> number. For example, to refer to a card whose **<code>ID</code>** property is 1154, use the phrase card <code>ID</code> 1154:</p><pre><code>go to card ID 1154</code></pre><p>You cannot change an object&#39;s <strong>ID</strong> property (except for a stack).</p><blockquote><p><strong>Important:</strong> Wherever possible, you should name your objects and refer to them by name instead of using number or ID. Both the number and ID properties will change if objects are copied and pasted. Additionally, your scripts will rapidly become difficult to read if there are many ID or numerical references to objects.</p></blockquote><h3>Referring to objects by ordinal</h3><p>You can refer to an object using its object type followed by the ordinal numbers <strong>first</strong> through <strong>tenth</strong>, or the special ordinals <strong>middle</strong> and <strong>last</strong>. To refer to a random object, use the special ordinal <strong>any</strong>. For example, to refer to the last card in the current stack, use the special ordinal <strong>last</strong>:</p><pre><code>go to last card</code></pre><h3>The special descriptor ‘this’</h3><p>Use the <strong>this</strong> keyword to indicate the current stack, or the current card of a stack:</p><pre><code>set the backgroundColor of this stack to whitesend &quot;mouseUp&quot; to this cardset the textFont of this card of stack &quot;Menubar&quot; to &quot;Sans&quot;</code></pre><h3>Control references</h3><p>A control is any object that can appear on a card. Fields, buttons, scrollbars, images, graphics, players, widgets, and groups are all controls. Stacks, cards, audio clips, and video clips are <em>not</em> controls.</p><p>You can refer to an object of any of these object types using the word &quot;control&quot;, followed by an ID, name, or number:</p><pre><code>hide control ID 2566send mouseDown to control &quot;My Button&quot;set the hilite of control 20 to false</code></pre><p>If you use a name, as in the expression <code>control &quot;Thing&quot;</code>, the reference is to the first control (with the lowest <strong>layer</strong>) that has that name.</p><p>When you refer to a control by number using its object type, the reference is to the Nth control of that type. For example, the phrase field 1 refers to the lowest field on the card. This may not be the lowest control, because there may be controls of other types underneath field 1. However, when you refer to a control by number using the word control, the reference is to the Nth control of any type. The phrase control 1 refers to the lowest control on the card, which may be of any type.</p><blockquote><p><strong>Tip:</strong> To refer to the object underneath the mouse pointer, use the <strong>mouseControl</strong> function.</p></blockquote><h3>Nested Object References</h3><p>To refer to an object that belongs to another object, nest the references in the same order as the object hierarchy. For example, if there is a button called &quot;My Button&quot; on a card called &quot;My Card&quot;, you can refer to the button like this:</p><pre><code>show button &quot;My Button&quot; of card &quot;My Card&quot;</code></pre><p>You can mix names, numbers, ordinal references, and IDs in a nested object reference, and you can nest references to whatever depth is required to specify the object. The only requirement is that the order of references be the same as the order of the object hierarchy, going from an object to the object that owns it. Here are some examples:</p><pre><code>field ID 34 of card &quot;Holder&quot;player 2 of group &quot;Main&quot; of card ID 20 of stack &quot;Demo&quot;first card of this stack</code></pre><p>stack &quot;Dialog&quot; of stack &quot;Main&quot; <em>-- &quot;Dialog&quot; is a substack</em></p><p>If you don&#39;t specify a card in referring to an object that is contained by a card, LiveCode assumes the object is on the current card. If you don&#39;t specify a stack, LiveCodeassumes the object is in the current stack. You can reference a control in another stack by either of the following methods:</p><p>Use a nested reference that includes the name of the stack:</p><pre><code>field 1 of stack &quot;My Stack&quot;graphic &quot;Outline&quot; `of` card &quot;Tools&quot; `of` stack &quot;Some Stack&quot;</code></pre><p>Set the <strong>defaultStack</strong> property to the stack you want to refer to first. The <strong>defaultStack</strong> specifies the current stack, so you can refer to any object in the <strong>defaultStack</strong> without including a stack name. This example sets a checkbox in the current stack to have the same setting as a checkbox in another stack called &quot;Other Stack&quot;:</p><pre><code>put the defaultStack into savedDefault -- so you can set it back laterset the defaultStack to &quot;Other Stack&quot;put the hilite of button &quot;Me&quot; into meSettin -- this button is in &quot;Other Stack&quot;set the defaultStack to savedDefaultset the hilite of button &quot;Me Too&quot; to meSetting -- this button is in the original stack</code></pre><p>If an object is in a group, you can include or omit a reference to the group in a nested reference to the object. For example, suppose the current card contains a button called &quot;Guido&quot;, which is part of a group called &quot;Stereotypes&quot;. You can refer to the button with any of the following expressions:</p><pre><code>button &quot;Guido&quot;button &quot;Guido&quot; of card 5button &quot;Guido&quot; of group &quot;Stereotypes&quot;button &quot;Guido&quot; of group &quot;Stereotypes&quot; of card 5</code></pre><p>If there is no other button named &quot;Guido&quot; on the card, these examples are equivalent. If there is another button with the same name in another group (or on the card, but not in any group), you must either specify the group (as in the second and third examples) or refer to the button by its <strong>ID</strong> property, to be sure you&#39;re referring to the correct button.</p><h3>Avoid using numbers as object names</h3><p>It is dangerous to set the <strong>name</strong> property of an object to a number.</p><p>For example, create three fields on a new card, naming the first one&quot;3&quot;, the second one &quot;2&quot;, and the third one &quot;1&quot;.  In other words, thecreation order of those three fields is the reverse of the numericalnames you&#39;ve given them.  Now use the message box to:</p><pre><code>put &quot;This is field 3&quot; into field 3</code></pre><p>The third field created, the one named &quot;1&quot;, has its text set.  Thenumber of the field, <em>not</em> the <strong>name</strong> set by you, was used byLiveCode as the object reference.</p><p>This shows the perils of using a number as the <strong>name</strong> of an object.There are built-in properties of controls (the <strong>layer</strong> and the<strong>number</strong>) that are based on integers, and to use integers in yetanother way, in the <strong>name</strong> property, will likely cause unexpectedbehaviour at best.</p><p>This applies to cards as well.  The card order supersedes anynumerical card <strong>name</strong>.</p><p>You can, however, use a name which includes a number safely.  Forexample, you could call you fields &quot;field1&quot;, &quot;field2&quot; and &quot;field3&quot;.</p><p>Now there is no conflict when you use the message box to:</p><pre><code>put &quot;This is field 3&quot; into field &quot;field3&quot;</code></pre><p>You could also construct numerical field names:</p><pre><code>on mouseUp   repeat with y = 1 to 3      put y into field (&quot;field&quot; &amp; y)   end repeatend mouseUp</code></pre><p>This will put the values &quot;1&quot;, &quot;2&quot; and &quot;3&quot; into the fields named&quot;field1&quot;, &quot;field2&quot; and &quot;field3&quot;.  The &quot;field&quot;, concatenated with thenumber, removes the conflict with the control number.</p><h2><a name="//apple_ref/cpp/Guide/Properties" class="dashAnchor"></a>Properties</h2><p>A property is an attribute of a LiveCode object. Each type of object has many built-in properties, which affect the object&#39;s appearance or behavior. You can also define custom properties for any object, and use them to store any kind of data.</p><p>This topic discusses how to use properties, how properties are inherited between objects, and how to create and switch between collections of property settings.</p><p>To fully understand this topic, you should know how to create objects, how to use an object&#39;s property inspector, and how to write short scripts.</p><h3>Using Object Properties</h3><p>A property is an attribute of an object, and each object type has its own set of built-in properties appropriate for that type. An object can be <em>completely described</em> by its built-in properties; if you could make all the properties of two objects identical, they&#39;d be the same object. It is thus possible to describe an object entirely as an array of properties, or to export and import properties using text or XML files. More details on some of the methods you can use to do this are covered later in this chapter.</p><blockquote><p><strong>Note:</strong> Since no two objects can have the same <strong>ID</strong> property, it&#39;s not possible in practice for two different objects to become the same object, because the <strong>ID</strong> will always be different.</p></blockquote><p>Built-in properties determine the appearance and behavior of stacks and their contents - fonts, colors, window types, size and placement, and much more – as well as much of the behavior of the LiveCode application. By changing properties, you can change almost any aspect of your application. When you combine the ability to change properties with the ability to create and delete objects programmatically, you can modify every aspect of your application (subject to any limitations of the license agreement applicable to your edition of LiveCode).</p><h3>Referring to properties</h3><p>Property references consist of <code>the</code> word <code>the</code>, <code>the</code> property name, <code>the</code> word of, and areference to <code>the</code> object:</p><pre><code>the armedIcon of button &quot;My Button&quot;the borderWidth of field ID 2394the name of card 1 of stack &quot;My Stack&quot;</code></pre><p>Properties are sources of value, so you can get the value of a property by using it in an expression:</p><pre><code>put the height of field &quot;Text&quot; into myVarput the width of image &quot;My Image&quot; + 17 after field &quot;Values&quot;if item 1 of the location of me \&gt; zero then beep</code></pre><p>For example, to use the <strong>width</strong> property of a button as part of an arithmetic expression, use a statement like the following:</p><pre><code>add the width of button &quot;Cancel&quot; to totalWidths</code></pre><p>The value of the property – in this case, the width of the button in pixels – is substituted for the property reference when the statement is executed.</p><p>To see a list of all the language words (including properties) applicable to a particular object type, open the <em>Dictionary</em> and navigate to the entry for the object type. You canfilter the entries to only show object types by clicking on the <em>object</em> in the typefilter section.</p><h3>Changing properties</h3><p>To change the value of a property, you use the <strong>set</strong> command:</p><pre><code>set the borderColor of group &quot;My Group&quot; to &quot;red&quot;set the top of image ID 3461 to zero</code></pre><p>You can also see and change many of an object&#39;s properties by selecting the object and choosing <em>Object Inspector</em>. See the chapter <em>Building a User Interface</em> for more details.</p><p>Most built-in properties affect the appearance or behavior of the object. For example, a button&#39;s <strong>height</strong>, <strong>width</strong>, and <strong>location</strong> are properties of the button. Changing these properties in a handler causes the button&#39;s appearance to change. Conversely, dragging or resizing the button changes the related properties.</p><p><strong>Read-only properties</strong></p><p>Some properties can be read, but not set. These are called read-only properties. Trying to set a read-only property causes an execution error.</p><p>To find out whether a property is read-only, check its entry in the LiveCode Dictionary.</p><p><strong>Changing a part of a property</strong></p><p>Properties are not containers, so you cannot use a chunk expression to change a <em>part</em> of the property. However, you can use a chunk expression to <em>examine</em> part of a property. For example, you cannot set line 1 of a property to a new value: you must set the whole property. For more details see the section <em>Chunk Expressions</em> in the chapter on <em>Processing Text and Data</em>.</p><p>To change one part of a property, first put the property value into a variable, change the required part of the variable, then set the property back to the new variable contents:</p><pre><code>put the rect of me into tempRectput &quot;10&quot; into item 2 of tempRectset the rect of me to tempRect</code></pre><p><strong>Custom properties and virtual properties</strong></p><p>A custom property is a property that you define. You can create as many custom properties for an object as you want, and put any kind of data into them, including binary data or array data. You can even store a file in a custom property.</p><p>Virtual properties are custom properties that trigger a custom script action when you change them, allowing you to implement &quot;virtual&quot; object behaviors.</p><p><em>Custom properties</em> and <em>virtual properties</em> are covered in their respective sections later in this chapter.</p><h3>Property Inheritance</h3><p>Most properties are specific to the object they are part of, and affect only that object.</p><p>However, some properties of an object, such as its color and text font, take on the settings of the object above it in the object hierarchy. For example, if a field&#39;s background color property is not specified (that is, if its <strong>backgroundColor</strong> property is empty), the field takes on the background color of the card that owns it. If no background color is specified for the card either, the stack&#39;s background color is used, and so on. This means you can set a background color for a stack, and every object in it will automatically use that background color, without your having to set it for each object.</p><p>This process of first checking the object, then the object&#39;s owner, then the object that owns that object, and so on, is called <em>inheritance</em> of properties. Each object inherits the background color of the object above it in the hierarchy. Similar inheritance rules apply to the <strong>foregroundColor</strong>, <strong>topColor</strong>, <strong>bottomColor</strong>, <strong>borderColor</strong>, <strong>shadowColor</strong>, and <strong>focusColor</strong> properties, to their corresponding pattern properties, and to the <strong>textFont</strong>, <strong>textSize</strong>, and <strong>textStyle</strong> properties.</p><h3>Overriding inheritance</h3><p>Inheritance is used to determine an object&#39;s appearance only if the object itself has no setting for the property. If an inheritable property of an object is not empty, that setting overrides any setting the object might inherit from an object above it in the object hierarchy.</p><p>For example, if a button&#39;s <strong>backgroundColor</strong> property is set to a color reference instead of being empty, the button uses that background color, regardless of the button&#39;s owners. If the object has a color of its own, that color is always used.</p><p><strong>The effective keyword</strong></p><p>If an inheritable property of an object is empty, you can&#39;t simply check the property to find out what color or font settings the object displays. In this case, use the <strong>effective</strong> keyword to obtain the inherited setting of the property. The <strong>effective</strong> keyword searches the object&#39;s owners, if necessary, to find out what setting is <em>actually</em> used.</p><p>For example, suppose you have a field whose <strong>textFont</strong> property is empty. The <strong>textFont</strong> of the card that the field is on is set to &quot;Helvetica&quot;, so the field inherits this setting and displays its text in the Helvetica font. To find out what font the field is using, use the expression <code>the effective textFont</code>:</p><pre><code>get the textFont of field &quot;My Field&quot; *-- empty*get the effective textFont of field &quot;My Field&quot; *-- Helvetica*</code></pre><p>You can use the <strong>effective</strong> keyword with any inherited property.</p><h2><a name="//apple_ref/cpp/Guide/Global Properties" class="dashAnchor"></a>Global Properties</h2><p>LiveCode also has global properties, which affect the <em>overall behavior</em> of the application. Global properties are accessed and changed the same way as object properties. They do not belong to any particular object, but otherwise they behave like object properties.</p><blockquote><p><strong>Tip:</strong> To see a list of all global properties, open the <em>Message Box</em>, and choose the <em>Global Properties</em> icon – the third icon from the left at the top of the window. To see a list of all properties in the language, including both global and object properties, use the propertyNames global property.</p></blockquote><p>A few properties are <em>both</em> global <em>and</em> object properties. For example, the <strong>paintCompression</strong> is a global property, and also a property of images. For these properties, the global setting is separate from the setting for an individual object.</p><p>Some other global properties are affected by <em>system settings</em>. For example, the default value of the <strong>playLoudness</strong> property is set by the operating system&#39;s sound volume setting.</p><h3>Referring to global properties</h3><p>You refer to global properties using <strong>the</strong> and the property name:</p><pre><code>the defaultFolderthe emacsKeyBindingsthe fileType</code></pre><p>Since global properties apply to the whole application, you don&#39;t include an object reference when referring to them.</p><p>Global properties are sources of value, so you can get the value of a global property by using it in an expression:</p><pre><code>get the stacksInUseput the recentNames into field &quot;Recent Cards&quot;if the ftpProxy is empty then exit setMyProxy</code></pre><h3>Changing global properties</h3><p>To change a global property, you use the <strong>set</strong> command, in the same way as for object properties:</p><pre><code>set the itemDelimiter to &quot;/&quot;set the grid to falseset the idleTicks to 10</code></pre><p>Some global properties can be changed by other commands. For example, the <strong>lockScreen</strong> property can either be set directly, or changed using the <strong>lock screen</strong> and <strong><code>unlock screen</code></strong> commands. The following two statements are equivalent:</p><pre><code>set the lockScreen to false *-- does the same thing as...*unlock screen</code></pre><h3>Saving and restoring global properties</h3><p>Object properties are part of an object, so they are saved when the stack containing their object is saved. Global properties, however, are not associated with any object, so they are not saved with a stack. If you change the value of a global property, the change is lost when you quit the application.</p><p>If you want to use the same setting of a global property during a different session of your application, you must save the setting – in a Preferences file, in a custom property, or elsewhere in a saved file – and restore it when your application starts up.</p><h2><a name="//apple_ref/cpp/Guide/Text Related Properties" class="dashAnchor"></a>Text Related Properties</h2><p>Normally, properties are applied only to objects or, in the case of global properties, to the entire application. However, a few properties also apply to chunks in a field or to single characters in a field.</p><h3>Text style properties</h3><p>Certain text-related properties can be applied either to an entire field or to a chunk of a field:</p><pre><code>set the textFont of word 3 of field &quot;My Field&quot; to &quot;Courier&quot;set the foregroundColor of line 1 of field 2 to &quot;green&quot;if the textStyle of the clickChunk is &quot;bold&quot; then beep</code></pre><p>The following field properties can be applied to either an entire field or to a chunk of the field:</p><p>textFont, textStyle, and textSize</p><p>textShift</p><p>backgroundColor and foregroundColor</p><p>backgroundPattern and foregroundPattern (Unix systems)</p><p>Each chunk of a field inherits these properties from the field, in the same way that fields inherit from their owners. For example, if a word&#39;s <strong>textFont</strong> property is empty, the word is displayed in the field&#39;s font. But if you set the word&#39;s <strong>textFont</strong> to another font name, that word – and only that word – is displayed in its own font.</p><p>To find the text style of a chunk in a field, whether that chunk uses its own styles or inherits them from the field, use the <strong>effective</strong> keyword:</p><pre><code>get the effective textFont of word 3 of field ID 2355answer the effective backgroundColor of char 2 to 7 of field &quot;My Field&quot;</code></pre><blockquote><p><strong>Tip:</strong> If a chunk expression includes more than one style, the corresponding property for that chunk reports &quot;mixed&quot;. For example, if the first line of a field has a <strong>textSize</strong> of &quot;12&quot;, and the second line has a <strong>textSize</strong> of &quot;24&quot;, an expression like the textSize of line 1 to 2 of field &quot;My Field&quot; reports &quot;mixed&quot;.</p></blockquote><h3>Formatted text properties</h3><p>The <strong>htmlText</strong>, <strong>RTFText</strong>, and <strong>unicodeText</strong> properties of a chunk are equal to the text of that chunk, along with the formatting information that&#39;s appropriate for the property.</p><p>For example, if a field contains the text &quot;This is a test.&quot;, and the word &quot;is&quot; is boldfaced, the htmlText of word 2 reports &quot;&lt;b&gt;is&lt;/b&gt;&quot;.</p><p>For more information on these properties see the chapter on <em>Processing Text and Data</em>, as well as the individual entries for these properties in the <em>LiveCode Dictionary</em>.</p><p><strong>The formattedRect and related properties</strong></p><p>The <strong>formattedRect</strong> property (along with the <strong>formattedWidth</strong>, <strong>formattedHeight</strong>, <strong>formattedLeft</strong>, and <strong>formattedTop</strong>) reports the position of a chunk of text in a field. These properties are read-only.</p><p>The <strong>formattedRect</strong>, <strong>formattedLeft</strong>, and <strong>formattedTop</strong> properties can be used for a chunk of a field, but not the entire field. The <strong>formattedWidth</strong> and <strong>formattedHeight</strong> apply to both fields and chunks of text in a field.</p><p><strong>The imageSource, linkText, and visited properties</strong></p><p>The <strong>imageSource</strong> of a character specifies an image to be substituted for that character when the field is displayed. You use the <strong>imageSource</strong> to display images inside fields:</p><pre><code>set the imageSource of char 17 of field 1 to 49232set the imageSource of char thisChar of field &quot;My Field&quot; to &quot;http://www.example.com/banner.jpg&quot;</code></pre><p>The <strong>linkText</strong> property of a chunk lets you associate hidden text with part of a field&#39;s text. You can use the <strong>linkText</strong> in a <strong>linkClicked</strong> handler to specify the destination of a hyperlink, or for any other purpose.</p><p>The <strong>visited</strong> property specifies whether you have clicked on a text group during the current session. You can get the visited property for any chunk in a field, but it is meaningless unless the chunk&#39;s <strong>textStyle</strong> includes &quot;link&quot;.</p><p>The <strong>imageSource</strong>, <strong>linkText</strong>, and <strong>visited</strong> properties are the only properties that can be set to a chunk of a field, but not to the entire field or any other object. Because they are applied to text in fields, they are listed as field properties in the LiveCode Dictionary.</p><h2><a name="//apple_ref/cpp/Guide/Creating and Deleting Objects" class="dashAnchor"></a>Creating and Deleting Objects</h2><p>LiveCode allows you to create and delete objects programmatically. You may optionally specify all the properties for a new object before creating it.</p><h3>The Create Object Command</h3><p>You use the <strong>create</strong> command to create a new object.</p><pre><code>create [invisible] *type* [*name*] [in *group*]</code></pre><p>The <em>type</em> is any control that can be on a card: field, button, image, scrollbar, graphic, or player.</p><p>The <em>name</em> is the name of the newly created object. If you don&#39;t specify a <em>name</em>, the object is created with a default name.</p><p>The <em>group</em> is any group that&#39;s on the current card. If you specify a <em>group</em>, the new object is a member of the group, and exists on each card that has the group. If you don&#39;t specify a group, the object is created on the current card and appears only on that card.</p><pre><code>create button &quot;Click Me&quot;create invisible field in first group</code></pre><p>You can also create widgets of a given kind on a card, using the <strong>create widget</strong> command.</p><pre><code>create [invisible] widget [*name*] as *kind* [in *group*]</code></pre><p>The <em>kind</em> is the kind of any currently installed widget. </p><p>For more details, see the <em>create command</em> in the <em>LiveCode Dictionary</em>. For details on how to specify the properties of an object before creating it, see the section on <em>Creating Objects Off-screen Using Template Objects</em>, below.</p><h3>The Delete Object Command</h3><p>You can use the <strong>delete</strong> command to remove objects from the stack.</p><p>delete {*object}*</p><p>The <em>object</em> is any available object.</p><pre><code>delete this carddelete button &quot;New Button&quot;</code></pre><p>For more details, see the <em>delete command</em> in the <em>LiveCode Dictionary</em>.</p><h3>Creating Objects Off-screen Using Template Objects</h3><p>LiveCode uses <em>template objects</em> to allow you to specify the properties for an object before it is created. The template objects are off-screen models – there is one for each possible type of object, e.g. button, field, graphic, etc.</p><p>If you need to create a new object and then set some properties on the object, it is more efficient to make the changes to the template object, then create the object. Because the object can be created with all of its properties set correctly, there is no need to lock the screen and update or reposition the object after creating it. For example, the LiveCode development environment uses the template objects internally to create new objects from the main tool palette.</p><p>You set properties on template objects in the same way you set properties on normal objects.</p><p>set the {property} of the template{Objecttype} to {value}</p><p>For example, to create a button with the name &quot;Hello World&quot;, positioned at 100,100:</p><pre><code>set the name of the templateButton to &quot;Hello World&quot;set the location of the templateButton to 100,100create button</code></pre><p>When you have used the templateObject to create a new object, you should reset it before using it again. Resetting the templateObject sets all off its properties back to defaults.</p><p>reset the template[Objecttype]</p><p>For example, to reset the <code>templateButton</code>:</p><pre><code>reset the templateButton</code></pre><p>For more details on the template objects, search the <em>LiveCode Dictionary</em> for &quot;*template*&quot;.</p><h2><a name="//apple_ref/cpp/Guide/Property Arrays using the Properties Property" class="dashAnchor"></a>Property Arrays using the Properties Property</h2><p>In addition to retrieving individual object properties, you can retrieve or set an entire set as an array using the <strong>properties</strong> property. You can use this to edit, copy, export or import properties.</p><pre><code>set the properties of *object* to *propertiesArray*put the properties of *object* into propertiesArray</code></pre><p>The <strong>properties</strong> of an object is an array containing that object&#39;s significant built-in properties.</p><pre><code>put the properties of button 1 into myArrayset the properties of last player to the properties of player &quot;Example&quot;</code></pre><blockquote><p><strong>Tip:</strong> This example handler shows you how to write the properties of an object to a text file.</p></blockquote><pre><code>on mouseUp    put the properties of button 1 into tPropertiesArray    combine tPropertiesArray using return and &quot;|&quot;    ask file &quot;Save properties as:&quot;    if it is not empty then put tPropertiesArray into URL (&quot;file:&quot; &amp; it)end mouseUp</code></pre><p>In this example, each property name will be written followed by the &quot;|&quot; character and the property value and then a return character.</p><p>For more details, see the <em>properties property</em> in the <em>LiveCode Dictionary</em>.</p><h2><a name="//apple_ref/cpp/Guide/Custom Properties" class="dashAnchor"></a>Custom Properties</h2><p>A custom property is a property that you create for an object, in addition to its built-in properties. You can define custom properties for any object, and use them to store any kind of data.</p><p>This topic discusses how to <em>create</em> and <em>use</em> custom properties, and how to <em>organize</em> custom properties into <em>sets</em> (or <em>arrays</em>). The following section covers how to create virtual properties and use <strong>getProp</strong> and <strong>setProp</strong> handlers to handle custom property requests.</p><h3>Using Custom Properties</h3><p>A custom property is a property that you define. You can create as many custom properties for an object as you want, and put any kind of data into them (even binary data). You can even store a file in a custom property.</p><p>Use a custom property when you want to:- associate data with a specific object- save the data with the object in the stack file- access the data quickly</p><h3>Creating a Custom Property</h3><p>You create a custom property by setting the new property to a value. If you set a custom property that doesn&#39;t exist, LiveCode automatically creates the custom property and sets it to the requested value.</p><p>This means that you can create a custom property in a handler or the message box, simply by using the <strong>set</strong> command. The following statement creates a custom property called &quot;endingTime&quot; for a button:</p><pre><code>set the endingTime of button &quot;Session&quot; to the long time</code></pre><p>You can create custom properties for any object. However, you cannot create global custom properties, or custom properties for a chunk of text in a field. Unlike some built-in properties, a custom property applies only to an object.</p><blockquote><p><strong>Important:</strong> Each object can have its own custom properties, and custom properties are not shared between objects. Creating a custom property for one object does not create it for other objects.</p></blockquote><h3>The Content of a Custom Property</h3><p>You set the value of a custom property by using its property name together with the <strong>set</strong> command, in the same way you set built-in properties:</p><pre><code>set the myCustomProperty of button 1 to false</code></pre><p>You can see and change all of an object&#39;s custom properties in the Custom Properties pane of the object&#39;s property inspector: click the custom property you want to change, then enter the new value.</p><p><strong>Changing a part of a property</strong></p><p>Like <em>built-in properties</em>, custom properties are <em>not</em> containers, so you cannot use a chunk expression to change a part of the custom property. Instead, you put the property&#39;s value into a variable and change the variable, then set the custom property back to the new variable contents:</p><pre><code>put the lastCall of this card into myVarput &quot;March&quot; into word 3 of myVarset the lastCall of thisCard to myVar</code></pre><h3>Custom Property Names</h3><p>The name of a custom property must consist of a single word and may contain any combination of letters, digits, and underscores (_). The first character must be either a letter or an underscore.</p><p>Avoid giving a custom property the same name as a variable. If you refer to a custom property in a handler, and there is a variable by the same name, LiveCode uses the contents of the variable as the name of the custom property. This usually causes unexpected results.</p><blockquote><p><strong>Important:</strong> It is important to avoid giving custom properties the same name as existing engine properties <em>unless</em> those properties are only ever accessed in the context of a custom property set. Unintended effects may result if you attempt to use the name of an engine property as a custom property.</p></blockquote><p>Custom property names beginning with &quot;**rev**&quot; are reserved for LiveCode&#39;s own custom properties. Naming a custom property with a reserved name may produce unexpected results when working in the development environment.</p><h3>Referring to Custom Properties</h3><p>Custom property references look just like built-in property references: the word the, the property name, the word of, and a reference to the object.</p><p>For example, to use a custom property called &quot;lastCall&quot; that belongs to a card, use a statement like the following:</p><pre><code>put the lastCall of this card into field &quot;Date&quot;</code></pre><p>Like built-in properties, custom properties are sources of value, so you can get the value of a custom property by using it in an expression. The property&#39;s value is substituted for the property reference when the statement is executed. For example, if the card&#39;s &quot;lastCall&quot; custom property is &quot;Today&quot;, the example statement above puts the string &quot;Today&quot; into the &quot;Date&quot; field.</p><h3>Nonexistent Custom Properties</h3><p>Custom properties that don&#39;t exist evaluate to empty. For example, if the current card doesn&#39;t have a custom property called &quot;astCall&quot;, the following statement empties the field:</p><p>put the lastCall of this card into field &quot;Date&quot; <em>– empty</em></p><blockquote><p><strong>Note:</strong> Referring to a nonexistent custom property does not cause a script error. This means that if you misspell a custom property name in a handler, you won&#39;t get an error message, so you might not notice the problem right away.</p></blockquote><h3>Finding out Whether a Custom Property Exists</h3><p>The <strong>customKeys</strong> property of an object lists the object&#39;s custom properties, one per line:</p><pre><code>put the customKeys of button 1 into field &quot;Custom Props&quot;</code></pre><p>To find out whether a custom property for an object exists, you check whether it&#39;s listed in the object&#39;s <strong>customKeys</strong>. The following statement checks whether a player has a custom property called &quot;doTellAll&quot;:</p><pre><code>if &quot;doTellAll&quot; is among the lines of the customKeys of player &quot;My Player&quot; then*...*</code></pre><p>You can also look in the <em>Custom Properties</em> pane of the object&#39;s property inspector, which lists the custom properties. See the chapter on <em>Building a User Interface</em> for more details.</p><h3>Custom Properties &amp; Converting Text Between Platforms</h3><p>When you move a stack developed on a Mac OS or OS X system to a Windows or Unix system (or vice versa), LiveCode automatically translates text in fields and scripts into the appropriate character set. However, text in custom properties is not converted between the ISO and Macintosh character sets. This is because custom properties can contain binary data as well as text, and converting them would garble the data.</p><p>Characters whose ASCII value is between 128 and 255, such as curved quotes and accented characters, do not have the same ASCII value in the Mac OS character set and the ISO 8859-1 character set used on Unix and Windows systems. If such a character is in a field, it is automatically translated, but it&#39;s not translated if it&#39;s in a custom property.</p><p>Because of this, if your stack displays custom properties to the user--for example, if the stack puts a custom property into a field--and if the text contains special characters, it may be displayed incorrectly if you move the stack between platforms. To avoid this problem, use one of these methods:</p><p>Before displaying the custom property, convert it to the appropriate character set using the <strong>macToISO</strong> or <strong>ISOToMac</strong> function. The following example shows how to convert a custom property that was created on a Mac OS system, when the property is displayed on a Unix or Windows system:</p><pre><code>if the platform is &quot;MacOS&quot; then    answer the myPrompt of button 1else    answer macToISO(the myPrompt of button 1)end if</code></pre><p>Instead of storing the custom property as text, store it as HTML, using the <strong>HTMLText</strong> property of fields:</p><pre><code>set the myProp of this card to the HTMLText of field 1</code></pre><p>Because the <strong>HTMLText</strong> property encodes special characters as entities, it ensures that the custom property does not contain any special characters--only the platform-independent encodings for them. You can then set a field&#39;s <strong>HTMLText</strong> to the contents of the custom property to display it:</p><pre><code>set the HTMLText of field &quot;Display&quot; to the myProp of this card</code></pre><h3>Storing a file in a custom property</h3><p>You can use a URL to store a file&#39;s content in a custom property:</p><pre><code>set the myStoredFile of stack &quot;My Stack&quot; to URL &quot;binfile:mypicture.jpg&quot;</code></pre><p>You restore the file by putting the custom property&#39;s value into a URL:</p><pre><code>put the myStoredFile of stack &quot;My Stack&quot; into URL &quot;binfile:mypicture.jpg&quot;</code></pre><p>Because a custom property can hold any kind of data, you can store either text files or binary files in a custom property. You can use this capability to bundle media files or other files in your stack.</p><p>Many Mac OS Classic files have a resource fork. To store and restore such a file, you can use the <strong>resfile</strong> URL scheme to store the content of the resource fork separately.</p><blockquote><p><strong>Tip:</strong> To save space, compress the file before storing it:</p></blockquote><pre><code>set the myStoredFile of stack &quot;My Stack&quot; to compress(URL &quot;binfile:mypicture.jpg&quot;)</code></pre><p>When restoring the file, decompress it first:</p><pre><code>put decompress(the myStoredFile of stack &quot;My Stack&quot;) into URL &quot;binfile:mypicture.jpg&quot;</code></pre><p>For more information about using URL containers, see the section on <em>Working with Files, URLs and Sockets</em> in the <em>Transferring Information</em> guide.</p><h3>Deleting a custom property</h3><p>As described above, the <strong>customKeys</strong> property of an object is a list of the object&#39;s custom properties. You can set the <strong>customKeys</strong> of an object to control which custom properties it has.</p><p>In LiveCode, there is no command to delete a custom property. Instead, you place all the custom property names in a variable, delete the one you don&#39;t want from that variable, and set the object&#39;s <strong>customKeys</strong> back to the modified contents of the variable. This removes the custom property whose name you deleted.</p><p>For example, the following statements delete a custom property called &quot;propertyToRemove&quot; from the button &quot;My Button&quot;:</p><pre><code>get the customKeys of button &quot;My Button&quot;set the wholeMatches to truedelete line lineOffset(&quot;propertyToRemove&quot;,it) of itset the customKeys of button &quot;My Button&quot; to it</code></pre><p>You can also delete a custom property in the <em>Custom Properties</em> pane of the object&#39;s <em>Property Inspector</em>. Select the property&#39;s name and click the <em>Delete</em> button to remove it.</p><h2><a name="//apple_ref/cpp/Guide/Custom Property Sets" class="dashAnchor"></a>Custom Property Sets</h2><p>Custom properties can be organized into <em>custom property sets</em> – or arrays of custom properties. A custom property set is a group of custom properties that has a name you specify.</p><p>When you refer to a custom property, LiveCode looks for that property in the object&#39;s currently-active custom property set. When you create or set a custom property, LiveCode creates it in the currently-active custom property set, or sets the value of that property in the currently-active set. One custom property set is active at any one time, but you can use array notation to get or set custom properties in sets other than the current set.</p><p>The examples in the previous section assume that you haven&#39;t created any custom property sets. If you create a custom property without creating a custom property set for it, as shown in the previous examples, the new custom property becomes part of the object&#39;s default custom property set.</p><h3>Creating custom property sets</h3><p>To make a custom property set active, you set the object&#39;s <strong>customPropertySet</strong> property to the set you want to use. As with custom properties and local variables, if the custom property set you specify doesn&#39;t exist, LiveCode automatically creates it, so you can create a custom property set for an object by simply switching to that set.</p><p>The following statement creates a custom property set called &quot;Alternate&quot; for an object, and makes it the active set:</p><pre><code>set the customPropertySet of the target to &quot;Alternate&quot;</code></pre><p>The statement above creates the custom property set.</p><p>You can also view, create, and delete custom property sets in the Custom pane of the object&#39;s property inspector.</p><p>You can list all the custom property sets of an object using its <strong>customPropertySets</strong> property.</p><p>As with custom properties, you can create custom property sets for any object. But you can&#39;t create global custom property sets, or custom property sets for a chunk of a field.</p><h3>Custom property set names</h3><p>The names of custom property sets should consist of a single word, with any combination of letters, digits, and underscores (_). The first character should be either a letter or an underscore.</p><p>It is possible to create a custom property set with a name that has more than one word, or that otherwise doesn&#39;t conform to these guidelines. However, this is not recommended, because such a custom property set can&#39;t be used with the array notation described below.</p><blockquote><p><strong>Note:</strong> When you use the Custom Properties pane in the property inspector to create a custom property set, the pane restricts you to these guidelines.</p></blockquote><h3>Referring to custom property sets</h3><p>To switch the active custom property set, set the object&#39;s <strong>customPropertySet</strong> property to the name of the set you want to use:</p><pre><code>set the customPropertySet of button 3 to &quot;Spanish&quot;</code></pre><p>Any references to custom property refer to the current custom property set. For example, suppose you have two custom property sets named &quot;Spanish&quot; and &quot;French&quot;, and the French set includes a custom property called &quot;Paris&quot; while the Spanish set does not. If you switch to the Spanish set, the <strong>customKeys</strong> of the object does not include &quot;Paris&quot;, because the current custom property set doesn&#39;t include that property.</p><p>If you refer to a custom property that isn&#39;t in the current set, the reference evaluates to empty. If you set a custom property that isn&#39;t in the current set, the custom property is created in the set. You can have two custom properties with the same name in different custom property sets, and they don&#39;t affect each other: changing one does not change the other.</p><p>The <strong>customProperties</strong> property of an object includes only the custom properties that are in the current custom property set. To specify the <strong>customProperties</strong> of a particular custom property set, you include the set&#39;s name in square brackets:</p><pre><code>put the customProperties[mySet] of this card into myArray</code></pre><h3>Finding out whether a custom property set exists</h3><p>The <strong>customPropertySets</strong> property of an object lists the object&#39;s custom property sets, one per line:</p><pre><code>answer the customPropertySets of field &quot;My Field&quot;</code></pre><p>To find out whether a custom property set for an object exists, you check whether it&#39;s listed in the object&#39;s <strong>customPropertySets</strong>. The following statement checks whether an image has a custom property set called &quot;Spanish&quot;:</p><pre><code>if &quot;Spanish&quot; is among the lines of the customPropertySets of image ID 23945 then*...*</code></pre><p>You can also look in the Custom Properties pane of the object&#39;s property inspector, which lists the custom property sets in the &quot;Set&quot; menu halfway down the pane.</p><h3>The default custom property set</h3><p>An object&#39;s default custom property set is the set that&#39;s active if you haven&#39;t used the <strong>customPropertySet</strong> property to switch to another set. Every object has a default custom property set; you don&#39;t need to create it.</p><p>If you create a custom property without first switching to a custom property set – as in the earlier examples in this topic – the custom property is created in the default set. If you don&#39;t set the <strong>customPropertySet</strong> property, all your custom properties are created in the default set.</p><p>The default custom property set has no name of its own, and is not listed in the object&#39;s <strong>customPropertySets</strong> property. To switch from another set to the default set, you set the object&#39;s <strong>customPropertySet</strong> to empty:</p><pre><code>set the customPropertySet of the target to empty</code></pre><h3>Using multiple custom property sets</h3><p>Since only one custom property set can be active at a time, you can create separate custom properties with the same name but different values in different sets. Which value you get depends on which custom property set is currently active.</p><p><strong>A translation example</strong></p><p>Suppose your stack uses several custom properties that hold strings in English, to be displayed to the user by various commands. Your stack might contain a statement such as this:</p><p>answer the standardErrorPrompt of this stack</p><p>The statement above displays the contents of the custom property called &quot;standardErrorPrompt&quot; in a dialog box.</p><p>Suppose you decide you want to translate your application into French. To do this, you make your original set of English custom properties into a custom property set (which you might call &quot;myEnglishStrings&quot;), and create a new set called &quot;myFrenchStrings&quot; to hold the translated properties.</p><p>Each set has the same-named properties, but the values in one set are in French and the other in English. You switch between the sets depending on what language the user chooses. The statement:</p><p>answer the standardErrorPrompt of this stack</p><p>provides either the English or French, depending on which custom property set is active: &quot;myEnglishStrings&quot; or &quot;myFrenchStrings&quot;.</p><h3>Copying custom properties between property sets</h3><p>When it&#39;s created, a custom property set is empty, that is, there aren&#39;t any custom properties in it. You put custom properties into a new custom property set by creating the custom properties while the set is active:</p><pre><code>-- create new set and make it active:set the customPropertySet of button 1 to &quot;MyNewSet&quot;-- now create a new custom property in the current set:set the myCustomProp of button 1 to true</code></pre><p>You can also use the <strong>customProperties</strong> property (which was discussed earlier in this topic) to copy custom properties between sets. For example, suppose you have created a full set of custom properties in a custom property set called &quot;myEnglishStrings&quot;, and you want to copy them to a new custom property set, &quot;frenchStrings&quot;, so you can translate them easily. The following statements create the new custom property set, then copy all the properties from the old set to the new one:</p><pre><code>-- create the new set:set the customPropertySet of this stack to &quot;frenchStrings&quot;-- copy the properties in the English set to the new set:set the customProperties[&quot;frenchStrings &quot;] of this stack to the customProperties[&quot;frenchStrings &quot;] of this stack</code></pre><blockquote><p><strong>Caution:</strong> Custom property sets in the development environment</p></blockquote><h3>Arrays, custom properties, and custom property sets</h3><p>All the custom properties in a custom property set form an array. The array&#39;s name is the custom property set name, and the elements of the array are the individual custom properties in that custom property set.</p><p><strong>Referring to custom properties using array notation</strong></p><p>You can use array notation to refer to custom properties in any custom property set. This lets you get and set any custom property, even if it&#39;s not in the current set, without changing the current set.</p><p>For example, suppose a button has a custom property named &quot;myProp&quot; which is in a custom property set called &quot;mySet&quot;. If &quot;mySet&quot; is the current set, you can refer to the &quot;myProp&quot; property like this:</p><pre><code>get the myProp of button 1set the myProp of the target to 20</code></pre><p>But you can also use array notation to refer to the &quot;myProp&quot; property, even if &quot;mySet&quot; is not the current set. To refer to this custom property regardless of which custom property set is active, use statements like the following:</p><pre><code>get the mySet[&quot;myProp&quot;] of button 1set the mySet[&quot;myProp&quot;] of the target to 20</code></pre><blockquote><p><strong>Note:</strong> Because the default custom property set has no name, you cannot use array notation to refer to a custom property in the default set.</p></blockquote><p><strong>Storing an array in a custom property set</strong></p><p>If you store a set of custom properties in a custom property set, the set can be used just like an array. You can think of the custom property set as though it were a single custom property, and the properties in the set as the individual elements of the array.</p><p>To store an array variable as a custom property set, use a statement like the following:</p><pre><code>set the customProperties[&quot;myProperty&quot;] of me to theArray</code></pre><p>The statement above creates a custom property set called &quot;myProperty&quot;, and stores each element in &quot;theArray&quot; as a custom property in the new set. To retrieve a single element of the array, use a statement like this:</p><pre><code>get the myProperty[&quot;myElement&quot;] of field &quot;Example&quot;</code></pre><h3>Deleting a custom property set</h3><p>As described above, the <strong>customPropertySets</strong> property of an object is a list of the object&#39;s custom property sets. You can set the <strong>customPropertySets</strong> of an object to control which custom property sets it has.</p><p>In LiveCode, there is no command to delete a custom property set. Instead, you place all the custom property set names in a variable, delete the one you don&#39;t want from that variable, and set the <strong>customPropertySets</strong> back to the modified contents of the variable. This removes the custom property set whose name you deleted.</p><p>For example, the following statements delete a custom property set called &quot;mySet&quot; from the button &quot;My Button&quot;:</p><pre><code>get the customPropertySets of button &quot;My Button&quot;set the wholeMatches to truedelete line lineOffset(&quot;mySet&quot;,it) of itset the customPropertySets of button &quot;My Button&quot; to it</code></pre><p>You can also delete a custom property set in the Custom Properties pane of the object&#39;s property inspector. Select the set&#39;s name from the Set menu, then click the Delete button to remove it.</p><h2><a name="//apple_ref/cpp/Guide/Attaching Handlers to Custom Properties" class="dashAnchor"></a>Attaching Handlers to Custom Properties</h2><p>When you change a custom property, LiveCode sends a <strong>setProp</strong> trigger to the object whose property is being changed. You can write a <strong>setProp</strong> handler to trap this trigger and respond to the attempt to change the property. Like a message, this trigger uses the message path, so you can place the <strong>setProp</strong> handler anywhere in the object&#39;s message path.</p><p>Similarly, when you get the value of a custom property, LiveCode sends a <strong>getProp</strong> call to the object whose property is being queried. You can write a <strong>getProp</strong> handler to reply to the request for information. Like a function call, the <strong>getProp</strong> call also traverses the message path.</p><p>Using <strong>getProp</strong> and <strong>setProp</strong> handlers, you can:- validate a custom property&#39;s value before setting it- report a custom property&#39;s value in a format other than what it&#39;s stored as- ensure the integrity of a collection of properties by setting them all at once- change an object&#39;s behavior when a custom property is changed</p><p><strong>setProp</strong> triggers and <strong>getProp</strong> calls are not sent when a built-in property is changed or accessed. They apply only to custom properties.</p><h3>Responding to changing a custom property</h3><p>When you use the <strong>set</strong> command to change a custom property, LiveCode sends a <strong>setProp</strong> trigger to the object whose property is being changed.</p><p>A <strong>setProp</strong> trigger acts very much like a message does. It is sent to a particular object. If that object&#39;s script contains a <strong>setProp</strong> handler for the property, the handler is executed; otherwise, the trigger travels along the message path until it finds a handler for the property. If it reaches the end of the message path without being trapped, the <strong>setProp</strong> trigger sets the custom property to its new value. For more information about the message path, see the section on the <em>Message Path</em>.</p><p>You can include as many <strong>setProp</strong> handlers in a script for as many different custom properties as you need.</p><h3>The structure of a <em>setProp</em> handler</h3><p>Unlike a message handler, a <code>setProp</code> handler begins with the word <code>setProp</code> instead of the word <code>on</code>. This is followed by the handler&#39;s name (which is the same as the name of the custom property) and a parameter that holds the property&#39;s new value. A <code>setProp</code>handler, like all handlers, ends with the word &quot;end&quot; followed by the handler&#39;s name.</p><p>The following example shows a setProp handler for a custom property named &quot;percentUsed&quot;, and can be placed in the script of the object whose custom property it is:</p><pre><code>setProp percentUsed newAmount    -- responds to setting the percentUsed property    if newAmount is not a number or newAmount \&lt; zero or newAmount \&gt; 100 then        beep 2        exit percentUsed    end if    pass percentUsedend percentUsed</code></pre><p>When you set the &quot;percentUsed&quot; custom property, the &quot;percentUsed&quot; handler is executed:</p><pre><code>set the percentUsed of scrollbar &quot;Progress&quot; to 90</code></pre><p>When this statement is executed, LiveCode sends a <strong>setProp</strong> trigger to the scrollbar. The new value of 90 is placed in the <em>newAmount</em> parameter. The handler makes sure that the new value is in the range 0–100; if not, it beeps and exits the handler, preventing the property from being set.</p><p>For more details about the <strong>setProp</strong> control structure, see <strong>setProp</strong> in the LiveCode Dictionary.</p><p><strong>Passing the setProp trigger</strong></p><p>When the <strong>setProp</strong> trigger reaches the engine - the last stop in the message path - the custom property is set. If the trigger is trapped and doesn&#39;t reach the engine, the custom property is not set.</p><p>To let a trigger pass further along the message path, use the <strong>pass</strong> control structure. The <strong>pass</strong> control structure stops the current handler and sends the trigger on to the next object in the message path, just as though the object didn&#39;t have a handler for the custom property.</p><p>In the &quot;percentUsed&quot; handler above, if the <em>newAmount</em> is out of range, the handler uses the <strong>exit</strong> control structure to halt; otherwise, it executes the <strong>pass</strong> control structure. If the <em>newAmount</em> is in the right range, the pass control structure lets the property be set. Otherwise, since the trigger is not passed, it never reaches the engine, so the property is not changed.</p><p>You can use this capability to check the value of any custom property before allowing it to be set. For example, if a custom property is supposed to be boolean (true or false), a setProp handler can trap the trigger if the value is anything but true or false:</p><pre><code>setProp myBoolean newValue    if newValue is true or newValue is false    then pass myBooleanexit myBoolean</code></pre><p><strong>Using the message path with a setProp trigger</strong></p><p>Because <strong>setProp</strong> triggers use the message path, a single object can receive the <strong>setProp</strong> triggers for all the objects it owns. For example, <strong>setProp</strong> triggers for all controls on a card are sent to the card, if the control&#39;s script has no handler for that property. You can take advantage of the message path to implement the same <strong>setProp</strong> behavior for objects that all have the same custom property.</p><p>If a <strong>setProp</strong> handler sets its custom property, for an object that has that <strong>setProp</strong> handler in its message path, a runaway recursion will result. To avoid this problem, set the <strong>lockMessages</strong> property to true before setting the custom property.</p><blockquote><p><strong>Note:</strong> To refer to the object whose property is being set, use the <strong>target</strong> function. The <strong>target</strong> refers to the object that first received the <strong>setProp</strong> trigger- the object whose custom property is being set - even if the handler being executed is in the script of another object.</p></blockquote><p><strong>Setting properties within a setProp handler</strong></p><p>In the &quot;lastChanged&quot; example in the box above, the handler sets the custom property directly, instead of simply passing the <strong>setProp</strong> trigger. You must use this method if the handler makes a change to the property&#39;s value, because the <strong>pass</strong> control structure simply passes on the original value of the property.</p><p>If you use the <strong>set</strong> command within a <strong>setProp</strong> handler to set the same custom property for the current object, no <strong>setProp</strong> trigger is sent to the target object (this is to avoid runaway recursion, where the <strong>setProp</strong> handler triggers itself). Setting a different custom property sends a <strong>setProp</strong> trigger. So does setting the handler&#39;s custom property for an object other than the one whose script contains the <strong>setProp</strong> handler.</p><p>Using this method, you can not only check the value of a property, and allow it to be set only if it&#39;s in range, you can also change the value so that it is in the correct range, has the correct format, and so on.</p><p>The following example is similar to the &quot;percentUsed&quot; handler above, but instead of beeping if the <em>newAmount</em> is out of range, it forces the new value into the range 0–100:</p><pre><code>setProp percentUsed newAmount    set the percentUsed of the target to max(zero,min(100,newAmount))end percentUsed</code></pre><p><strong>Nonexistent properties</strong></p><p>If the custom property specified by a setProp handler doesn&#39;t exist, the setProp handler is still executed when a handler sets the property. If the handler passes the <strong>setProp</strong> trigger, the custom property is created.</p><p><strong>Custom property sets and setProp handlers</strong></p><p>A setProp handler for a custom property set behaves differently from a setProp handler for a custom property that&#39;s in the default set.</p><p>When you set a custom property in a custom property set, the <strong>setProp</strong> trigger is named for the set, not the property. The property name is passed in a parameter using a special notation. This means that, for custom properties in a set, you write a single setProp handler for the set, rather than one for each individual property.</p><p>The following example handles <strong>setProp</strong> triggers for all custom properties in a custom property set called <em>myFrenchStrings</em>, which contains custom properties named <em>standardErrorPrompt</em>, <em>filePrompt</em>, and perhaps other custom properties:</p><pre><code>setProp myFrenchStrings[myPropertyName] newValue-- The myPropertyName parameter contains the name of-- the property that&#39;s being set    switch myPropertyName    case &quot;standardErrorPrompt&quot;        set the myFrenchStrings[&quot;standardErrorPrompt&quot;] of the target to return &amp; newValue &amp; return        exit myFrenchStrings    break    case &quot;filePrompt&quot;        set the myFrenchStrings[&quot;filePrompt&quot;] of the target to return&amp; newValue &amp; return    exit myFrenchStrings    break    default        pass myFrenchStrings    end switchend myFrenchStrings</code></pre><p>As you can see from the <strong>exit</strong>, <strong>pass</strong>, and <strong>end</strong> control structures, the name of this setProp handler is the same as the name of the custom property set that it controls - &quot;myFrenchStrings&quot;. Because there is only one handler for all the custom properties in this set, the handler uses the <strong>switch</strong> control structure to perform a different action for each property that it deals with.</p><p>Suppose you change the &quot;standardErrorPrompt&quot; custom property:</p><pre><code>set the customPropertySet of this stack to &quot;myFrenchStrings&quot;set the standardErrorPrompt of this stack to field 1</code></pre><p>LiveCode sends a <strong>setProp</strong> trigger to the stack, which causes the above handler to execute. The property you set – &quot;standardErrorPrompt&quot; – is placed in the &quot;myPropertyName&quot; parameter, and the new value--the contents of field 1 – is placed in the &quot;newValue&quot; parameter. The handler executes the case for &quot;standardErrorPrompt&quot;, putting a <strong>return</strong> character before and after the property before setting it.</p><p>If you set a custom property other than &quot;standardErrorPrompt&quot; or &quot;filePrompt&quot; in the &quot;myFrenchStrings&quot; set, the default case is executed. In this case, the <strong>pass</strong> control structure lets the <strong>setProp</strong> trigger proceed along the message path, and when it reaches the engine, LiveCode sets the custom property.</p><blockquote><p><strong>Note:</strong> As mentioned above, you can address a custom property in a set either by first switching to that set, or using array notation to specify both set and property. The following example:</p></blockquote><pre><code>set the customPropertySet of me to &quot;mySet&quot; set the myProperty of me to true</code></pre><p>is equivalent to:</p><pre><code>set the mySet[&quot;myProperty&quot;] of me to true</code></pre><p>Regardless of how you set the custom property, if it is a member of a custom property set, the <strong>setProp</strong> trigger has the name of the set - not the custom property itself - and you must use a setProp handler in the form described above to trap the <strong>setProp</strong> trigger.</p><h3>Responding to a request for the value of a custom property</h3><p>When you use a custom property in an expression, LiveCode sends a getProp call to the object whose property&#39;s value is being requested.</p><p>A getProp call acts very much like a custom function call. It is sent to a particular object. If that object&#39;s script contains a <strong>getProp</strong> handler for the property, the handler is executed, and LiveCode substitutes the value it returns for the custom property reference. Otherwise, the call travels along the message path until it finds a handler for the property. If the getProp call reaches the end of the message path without being trapped, LiveCode substitutes the custom property&#39;s value in the expression.</p><p>You can include as many <strong>getProp</strong> handlers in a script as you need.</p><p><strong>The structure of a getProp handler</strong></p><p>Unlike a message handler, a <code>getProp</code> handler begins with the word <code>getProp</code>instead of the word <code>on</code>. This is followed by the handler&#39;s name (which is the same as the name of the custom property). A <code>getProp</code> handler, like all handlers, ends with the word &quot;end&quot; followed by the handler&#39;s name.</p><p>The following example is a getProp handler for a custom property named &quot;percentUsed&quot;:</p><pre><code>getProp percentUsed    global lastAccessTime    put the seconds into lastAccessTime    pass percentUsedend lastChanged</code></pre><p>When you use the &quot;percentUsed&quot; custom property in an expression, the handler is executed:</p><pre><code>put the percentUsed of card 1 into myVariable</code></pre><p>When this statement is executed, LiveCode sends a getProp call to the card to retrieve the value of the &quot;percentUsed&quot; property. This executes the getProp handler for the property. The example handler stores the current date and time in a global variable before the property is evaluated. For more details, see <em>getProp</em> in the <em>LiveCode Dictionary</em>.</p><p><strong>Returning a value from a getProp handler</strong></p><p>When the getProp trigger reaches the engine – the last stop in the message path – LiveCode gets the custom property from the object and substitutes its value in the expression where the property was used.</p><p>To let a trigger pass further along the message path, use the <strong>pass</strong> control structure. The <strong>pass</strong> control structure stops the current handler and sends the trigger on to the next object in the message path, just as though the object didn&#39;t have a handler for the custom property.</p><p>To report a value other than the value that&#39;s stored in the custom property - for example, if you want to reformat the value first – you use the <strong>return</strong> control structure instead of passing the getProp call. The following example is a getProp handler for a custom property named &quot;lastChanged&quot;, which holds a date in <strong>seconds</strong>:</p><pre><code>getProp lastChangedget the lastChanged of the targetconvert it to long datereturn itend lastChanged</code></pre><p>The <strong>return</strong> control structure, when used in a getProp handler, reports a property value to the handler that requested it. In the above example, the converted date – not the raw property – is what is reported. As you can see from the example, you&#39;re not limited to returning the actual, stored value of the custom property. In fact, you can return any value at all from a getProp handler.</p><blockquote><p><strong>Important:</strong> If you use a custom property&#39;s value within the property&#39;s getProp handler, no getProp call is sent to the target object. This is to avoid runaway recursion, where the <strong>getProp</strong> handler calls itself.</p></blockquote><p>A handler can either use the <strong>return</strong> control structure to return a value, or use the <strong>pass</strong> control structure to let LiveCode get the custom property from the object.</p><p>If the getProp call is trapped before it reaches the engine and no value is returned in the getProp handler, the custom property reports a value of <strong>empty</strong>. In other words, a getProp handler must include either a <strong>return</strong> control structure or a <strong>pass</strong> control structure, or its custom property will always be reported as empty.</p><p><strong>Using the message path with a getProp call</strong></p><p>Because getProp calls use the message path, a single object can receive the getProp calls for all the objects it owns. For example, getProp calls for all controls on a card are sent to the card, if the control&#39;s script has no handler for that property. You can take advantage of the message path to implement the same <strong>getProp</strong> behavior for objects that all have the same custom property.</p><p>If a <strong>getProp</strong> handler is not attached to the object that has the custom property and it uses the value of the custom property, a runaway recursion will result. To avoid this problem, set the <strong>lockMessages</strong> property to true before getting the custom property&#39;s value.</p><p><strong>Nonexistent properties</strong></p><p>If the custom property specified by a getProp handler doesn&#39;t exist, the getProp handler is still executed if the property is used in an expression. Nonexistent properties report <strong>empty</strong>; getting the value of a custom property that doesn&#39;t exist does not cause a script error.</p><p><strong>Custom property sets and getProp handlers</strong></p><p>A getProp handler for a custom property set behaves differently from a getProp handler for a custom property that&#39;s in the default set.</p><p>When you use the value of a custom property in a custom property set, the getProp call is named for the set, not the property. The property name is passed in a parameter using array notation. This means that, for custom properties in a set, you write a single getProp handler for the set, rather than one for each individual property.</p><p>The following example handles getProp calls for all custom properties in a custom property set called <em>expertSettings</em>, which contains custom properties named <em>fileMenuContents</em>, <em>editMenuContents</em>, and perhaps other custom properties:</p><pre><code>getProp expertSettings[thePropertyName]    -- The thePropertyName parameter contains the name of    -- the property that&#39;s being set    switch thePropertyName    case &quot;fileMenuContents&quot;        if the expertSettings[fileMenuContents] of the target is empty then return &quot;(No items&quot;        else pass expertSettings    break    case &quot;editMenuContents&quot;        if the expertSettings[editMenuContents] of the target is empty then return the noviceSettings[editMenuContents] of the target        else pass expertSettings    break    default        pass expertSettings    end switchend expertSettings</code></pre><p>As you can see from the <strong>pass</strong> and <strong>end</strong> control structures, the name of this getProp handler is the same as the name of the custom property set that it controls – &quot;expertSettings&quot;. Because there is only one handler for all the custom properties in this set, the handler uses the <strong>switch</strong> control structure to perform a different action for each property that it deals with.</p><p>Suppose you get the &quot;fileMenuContents&quot; custom property:</p><pre><code>set the customPropertySet of button 1 to &quot;expertSettings&quot;put the fileMenuContents of button 1 into me</code></pre><p>LiveCode sends a getProp call to the button, which causes the above handler to execute. The property you queried – &quot;fileMenuContents&quot; – is placed in the &quot;thePropertyName&quot; parameter. The handler executes the case for &quot;fileMenuContents&quot;: if the property is empty, it returns &quot;(No items&quot;. Otherwise, the <strong>pass</strong> control structure lets the getProp call proceed along the message path, and when it reaches the engine, LiveCode gets the custom property.</p><h2><a name="//apple_ref/cpp/Guide/Virtual Properties" class="dashAnchor"></a>Virtual Properties</h2><p>A virtual property is a custom property that exists only in a <strong>setProp</strong> and/or <strong>getProp</strong> handler, and is never actually set. Virtual properties are never attached to the object. Instead, they act to trigger <strong>setProp</strong> or <strong>getProp</strong> handlers that do the actual work.</p><p>When you use the <strong>set</strong> command with a virtual property, its setProp handler is executed, but the <strong>setProp</strong> trigger is not passed to the engine, so the property is not attached to the object. When you use a virtual property in an expression, its getProp handler returns a value without referring to the object. In both cases, using the property simply executes a handler.</p><p>You can use virtual properties to:- Give an object a set of behaviors- Compute a value for an object- Implement a new property that acts like a built-in property</p><h3>When to use virtual properties</h3><p>Because they&#39;re not stored with the object, virtual properties are transient: that is, they are re-computed every time you request them. When a custom property depends on other properties that may be set independently, it&#39;s appropriate to use a virtual property.</p><p>For example, the following handler computes the current position of a scrollbar as a percentage (instead of an absolute number):</p><pre><code>getProp asPercentage *-- of a scrollbar*    put the endValue of the target - the startValue of the target into valueExtent    return the thumbPosition of me \* 100 div valueExtentend asPercentage</code></pre><p>The &quot;asPercentage&quot; custom property depends on the scrollbar&#39;s <strong>thumbPosition</strong>, which can be changed at any time (either by the user or by a handler). Because of this, if we set a custom property for the object, it would have to be re-computed every time the scrollbar is updated in order to stay current. By using a virtual property, you can ensure that the value of the property is never out of date, because the getProp handler re-computes it every time you call for the &quot;asPercentage&quot; of the scrollbar.</p><p>Virtual properties are also useful solutions when a property&#39;s value is large. Because the virtual property isn&#39;t stored with the object, it doesn&#39;t take up disk space, and only takes up memory when it&#39;s computed.</p><p>Another reason to use a virtual property is to avoid redundancy. The following handler sets the width of an object, not in pixels, but as a percentage of the object&#39;s owner&#39;s <strong>width</strong>:</p><pre><code>setProp percentWidth newPercentage    set the width of the target to the width of the owner of the target * newPercentage div 100end percentWidth</code></pre><p>Suppose this handler is placed in the script of a card button in a 320-pixel-wide stack. If you set the button&#39;s &quot;percentWidth&quot; to 25, the button&#39;s <strong>width</strong> is set to 80, which is 25% of the card&#39;s 320-pixel width. It doesn&#39;t make much sense to store an object&#39;s percentWidth, however, because it&#39;s based on the object&#39;s <strong>width</strong> and its owner&#39;s <strong>width</strong>.</p><p>Consider using virtual properties whenever you want to define an attribute of an object, but it doesn&#39;t make sense to store the attribute with the object – because it would be redundant, because possible changes to the object mean it would have to be re-computed anyway, or because the property is too large to be easily stored.</p><h3>Handlers for a virtual property</h3><p>As you can see by looking at the example above, a handler for a virtual property is structured like a handler for any other custom property. The only structural difference is that, since the handler has already done everything necessary, there&#39;s no need to actually attach the custom property to the object or get its value from the object. When you set a virtual property or use its value, the <strong>setProp</strong> trigger or <strong>getProp</strong> call does not reach the engine, but is trapped by a handler first.</p><p><strong>Virtual property setProp handlers</strong></p><p>A setProp handler for an ordinary custom property includes the <strong>pass</strong> control structure, allowing the <strong>setProp</strong> trigger to reach the engine and set the custom property (or else it includes a <strong>set</strong> command that sets the property directly). A handler for a virtual property, on the other hand, does not include the <strong>pass</strong> control structure, because a virtual property should not be set. Since the property is set automatically when the trigger reaches the end of the message path, a virtual property&#39;s handler does not pass the trigger.</p><p>If you examine an object&#39;s custom properties after setting a virtual property, you&#39;ll find that the custom property hasn&#39;t actually been created. This happens because the <strong>setProp</strong> handler traps the call to set the property; unless you pass the setProp trigger, the property isn&#39;t passed to LiveCode, and the property isn&#39;t set.</p><p><strong>Virtual property getProp handlers</strong></p><p>Similarly, a getProp handler for an ordinary custom property either gets the property&#39;s value directly, or passes the getProp call so that the engine can return the property&#39;s value. But in the case of a virtual property, the object doesn&#39;t include the property, so the getProp handler must return a value.</p><h3>Creating new object properties</h3><p>You can use virtual properties to create a new property that applies to all objects, or to all objects of a particular type. Such a property acts like a built-in property, because you can use it for any object. And because a virtual property doesn&#39;t rely on a custom property being stored in the object, you don&#39;t need to prepare by creating the property for each new object you create: the virtual property is computed only when you use it in an expression.</p><p>The following example describes how to implement a virtual property called &quot;percentWidth&quot; that behaves like a built-in property.</p><p><strong>Setting the &quot;percentWidth&quot; property</strong></p><p>Suppose you place the &quot;percentWidth&quot; handler described above in a stack script instead of in a button&#39;s script:</p><pre><code>setProp percentWidth newPercentage    set the width of the target to the width of the owner of the target * newPercentage div 100end percentWidth</code></pre><p>Because <strong>setProp</strong> triggers use the message path, if you set the &quot;percentWidth&quot; of any object in the stack, the stack receives the <strong>setProp</strong> trigger (unless it&#39;s trapped by another object first). This means that if the handler is in the stack&#39;s script, you can set the &quot;percentWidth&quot; property of any object in the stack.</p><p>If you place the handler in a backscript, you can set the &quot;percentWidth&quot; of any object, anywhere in the application.</p><p>To refer to the object whose property is being set, use the <strong>target</strong> function. The <strong>target</strong> refers to the object that first received the <strong>setProp</strong> trigger--the object whose custom property is being set--even if the handler being executed is in the script of another object.</p><p><strong>Getting the &quot;percentWidth&quot; property</strong></p><p>The matching getProp handler, which lets you retrieve the &quot;percentWidth&quot; of an object, looks like this:</p><pre><code>getProp percentWidth    return 100 \* (the width of the target div the width of the owner of the target)end percentWidth</code></pre><p>If you place the handler above in a card button&#39;s script, the following statement reports the button&#39;s width as a percentage:</p><pre><code>put the percentWidth of button &quot;My Button&quot; into field 12</code></pre><p>For example, if the stack is 320 pixels wide and the button is 50 pixels wide, the button&#39;s <strong>width</strong> is 15% of the card <strong>width</strong>, and the statement puts &quot;15&quot; into the field.</p><p>Like the <strong>setProp</strong> handler for this property, the <strong>getProp</strong> handler should be placed far along the message path. Putting it in a stack script makes the property available to all objects in the stack; putting it in a backscript makes the property available to all objects in the application.</p><p><strong>Limiting the &quot;percentWidth&quot; property</strong></p><p>Most built-in properties don&#39;t apply to all object types, and you might also want to create a virtual property that only applies to certain types of objects. For example, it&#39;s not very useful to get the width of a substack as a percentage of its main stack, or the width of a card as a percentage of the stack&#39;s width.</p><p>You can limit the property to certain object types by checking the <strong>target</strong> object&#39;s name:</p><pre><code>setProp percentWidth newPercentage    if word 1 of the name of the target is &quot;stack&quot; or word 1 of the name of the target is &quot;card&quot; then exit setProp    set the width of the target to the width of the owner of the target * newPercentage div 100end percentWidth</code></pre><p>The first word of an object&#39;s <strong>name</strong> is the object type, so the above revised handler ignores setting the &quot;percentWidth&quot; if the object is a card or stack.</p><h2><a name="//apple_ref/cpp/Guide/Property Profiles" class="dashAnchor"></a>Property Profiles</h2><p>A property profile is a collection of object property settings, which is stored as a set. A profile for an object can contain settings for almost any properties of the object.</p><p>You can include values for most built-in properties in a profile, and create as many different property profiles as you need for any object. Once you&#39;ve created a profile, you can switch the object to the profile to change all the property values that are defined in the profile.</p><p>For example, suppose you create a property profile for a field that includes settings for the field&#39;s color properties. When you switch to that profile, the field&#39;s colors change, while all other properties (not included in the profile) remain the same.</p><p>Use property profiles when you want to:</p><ul><li>Create &quot;skins&quot; for your application</li><li>Display your application in different languages</li><li>Present different levels--&quot;novice&quot;,&quot;expert&quot;, and so on</li><li>Use different user-interface standards for different platforms</li></ul><p>For details on how to create property profiles using the IDE, see the section on <em>Property Profiles</em> in the chapter <em>Building a User Interface</em>.</p><h3>Profile names</h3><p>Profile names follow the same rules as variable names. A profile name must be a single word, consisting of letters, digits, and underscores, and must start with either a letter or an underscore.</p><blockquote><p><strong>Tip:</strong> If you want to use a single command to switch several objects to a particular profile, give the profile the same name for each of the objects it applies to.</p></blockquote><h3>The master profile</h3><p>Every object has a master profile that holds the default settings for all its properties. If you don&#39;t set an object&#39;s profile, the master profile is used. When you create a new profile, you can change settings for various properties to make them different from the master profile&#39;s settings.</p><p>If you don&#39;t specify a property setting in a profile, the master profile&#39;s setting is used, so you don&#39;t have to specify all properties of an object when you create a profile, only the ones you want to change.</p><p>By default, the master profile is named &quot;Master&quot;. You can change the master profile&#39;s name in the <em>Property Profiles</em> pane of the <em>Preferences</em> window.</p><h3>Switching between profiles</h3><p><strong>Switching a single object</strong></p><p>To switch an object&#39;s profile, you can use either the object&#39;s property inspector or the <strong>revProfile</strong> property.</p><pre><code>set the revProfile of player &quot;My Player&quot; to &quot;MyProfile&quot;</code></pre><p><strong>Switching all the objects on a card</strong></p><p>To switch the profiles of all the objects on a card, use the <strong>revSetCardProfile</strong> command:</p><pre><code>revSetCardProfile &quot;MyProfile&quot;,&quot;My Stack&quot;</code></pre><p>The statement above sets the profile of all objects on the current card of the stack named &quot;My Stack&quot;. (Although the <strong>revSetCardProfile</strong> command changes a card, you specify a stack name, not a card name.)</p><p>If an object on the card does not have a profile with the specified name, the object is left untouched.</p><p><strong>Switching all the objects in a stack</strong></p><p>To switch the profiles of all the objects in a stack, use the <strong>revSetStackProfile</strong> command:</p><pre><code>revSetStackProfile &quot;MyProfile&quot;,&quot;My Stack&quot;</code></pre><p>The statement above sets the profile of all objects in the stack named &quot;My Stack&quot;.</p><p>If an object in the stack does not have a profile with the specified name, the object is left untouched.</p><p><strong>Switching all the objects in a stack file</strong></p><p>To switch the profiles of all the objects in every stack in a stack file, use the <strong>revSetStackFileProfile</strong> command:</p><pre><code>revSetStackFileProfile &quot;MyProfile&quot;,&quot;My Stack&quot;</code></pre><p>The statement above sets the profile of all objects in the stack named &quot;My Stack&quot;, along with any other stacks in the same stack file.</p><p>If an object in any of the stacks does not have a profile with the specified name, the object is left untouched.</p><h3>Creating a profile in a handler</h3><p>In addition to creating property profiles in the property inspector, you can create a profile in a handler.</p><p>To enable creating profiles, check the &quot;Create profiles automatically&quot; box in the &quot;Property Profiles&quot; pane of the Preferences window. If this box is checked, setting the <strong>revProfile</strong> property of an object automatically creates the profile.</p><p>This ability is particularly useful if you want to create a number of profiles, as shown in the following example:</p><pre><code>on mouseUp    -- creates a profile for each card in the stack    repeat with thisCard = 1 to the number of cards        set the revProfile of card x to &quot;myNewProfile&quot;    end repeatend mouseUp</code></pre><p>The handler above creates a profile called &quot;myNewProfile&quot; for all the cards in the current stack.</p><p>In order for this handler to work, the &quot;Create profiles automatically&quot; option in the &quot;Property Profiles&quot; pane of the Preferences window must be turned on.</p><p>You can control this behavior either in Preferences window or using the <strong>gRevProfileReadOnly</strong> keyword. If you don&#39;t want to save property changes when switching profiles, do one of the following:</p><p>Set the <strong>gRevProfileReadOnly</strong> variable to true:</p><pre><code>global gRevProfileReadOnlyput true into gRevProfileReadOnly</code></pre><p>In the &quot;Property Profiles&quot; pane of the Preferences window, uncheck the box labeled &quot;Don&#39;t save changes in profile&quot;.</p><p>The two methods of changing this setting are equivalent: changing the <strong>gRevProfileReadOnly</strong> variable also changes the preference setting, and vice versa.</p><p>For more details, see <em>gRevProfileReadOnly</em> in the <em>LiveCode Dictionary</em>.</p><h3>Adding profile settings in a handler</h3><p>You can add a property setting to a profile by switching to the profile, then setting the property:</p><pre><code>set the revProfile of button 1 to &quot;MyProfile&quot;set the foregroundColor of button 1 to &quot;red&quot;set the revProfile of button 1 to &quot;Master&quot;</code></pre><p>By default, if you change a property and then switch profiles, the property you changed and its current setting is saved with the profile.</p><h2><a name="//apple_ref/cpp/Guide/Managing Windows, Palettes and Dialogs" class="dashAnchor"></a>Managing Windows, Palettes and Dialogs</h2><p>LiveCode provides complete control over all aspects of window management, including moving, re-layering, and changing window mode.</p><h3>Moving a window</h3><p>Usually, you use either the <strong>location</strong> or <strong>rectangle</strong> property of a stack to move the stack window.</p><p>The**location** property specifies the center of the stack&#39;s window, relative to the top left corner of the main screen. Unlike the <strong>location</strong> of controls, the <strong>location</strong> of a stack is specified in absolute coordinates. The following statement moves a stack to the center of the main screen:</p><pre><code>set the location of stack &quot;Wave&quot; to the screenLoc</code></pre><p>The <strong>rectangle</strong> property of a stack specifies the position of all four edges, and can be used to resize the window as well as move it:</p><pre><code>set the rectangle of this stack to &quot;100,100,600,200&quot;</code></pre><blockquote><p><strong>Tip:</strong> To open a window at a particular place without flickering, set the stack&#39;s <strong>location</strong> or <strong>rectangle</strong> property to the desired value either before going to it, or in the stack’s preOpenStack handler.</p></blockquote><p>You can also use associated properties to move a window. Changing a stack&#39;s <strong>bottom</strong> or <strong>top</strong> property moves the window up or down on the screen. Changing the <strong>left</strong> or <strong>right</strong> property moves the window from side to side.</p><h3>Changing a window&#39;s layer</h3><p>You bring a window to the front by using the <strong>go</strong> command:</p><pre><code>go stack &quot;Alpha&quot;</code></pre><p>If the stack is already open, the <strong>go</strong> command brings it to the front, without changing its mode.</p><p>To find out the layer order of open stack windows, use the <strong>openStacks</strong> function. This function lists all open stack windows in order from front to back.</p><p><strong>The palette layer</strong></p><p>Normally, palette windows float above editable windows and modeless dialog boxes. A palette will always above a standard window, even if you bring the standard window to the front. This helps ensure that palettes, which usually contain tools that can be used in any window, cannot disappear behind document windows. It&#39;s also a good reason to make sure you design palette windows to be small, because other windows cannot be moved in front of them if the palette blocks part of the window.</p><p><strong>The system palette layer</strong></p><p>System windows--stacks whose <strong>systemWindow</strong> property is true--float above all other windows, in every running application. This means that even if the user brings another application to the front, your application&#39;s system windows remain in front of all windows.</p><p>System windows are always in front of other windows, and you cannot change this behavior.</p><h3>The active window</h3><p>In most applications, commands are applied to the active window. Since LiveCode gives you the flexibility to use several different window types, not all of which are editable, the current stack is not always the same as the active window. The current stack is the target of menu choices such as <strong>View -&gt; Go Next</strong> and is the stack specified by the expression<em>this stack</em>.</p><p>For example, executing the <strong>find</strong> command may have unexpected results if stacks of different modes are open, because under these conditions, the search may target a stack that is not the frontmost window.</p><p><strong>Finding the current stack</strong></p><p>The current stack--the stack that responds to commands--is designated by the <strong>defaultStack</strong> property. To determine which stack is the current stack, use the following rules:</p><p><strong>1.</strong> If any stacks are opened in an editable window, the current stack is the frontmost unlocked stack. (A stack is unlocked if its <strong>cantModify</strong> property is set to false.)</p><p><strong>2.</strong> If there are no unlocked stacks open, the current stack is the frontmost locked stack in an editable window.</p><p><strong>3.</strong> If there are no stacks open in an editable window, the current stack is the frontmost stack in a modeless dialog box.</p><p><strong>4.</strong> If there are no editable or modeless windows open, the current stack is the frontmost palette.</p><p>Another way of expressing this set of rules is to say that the current stack is the frontmost stack with the lowest <strong>mode</strong> property. You can find out which stack has the lowest <strong>mode</strong> using the <strong>topStack</strong> function.</p><p><strong>The topStack function and the defaultStack property:</strong></p><p>The <strong>defaultStack</strong> property specifies which stack is the current stack. By default, the <strong>defaultStack</strong> is set to the <strong>topStack</strong>, although you can change the <strong>defaultStack</strong> to any open stack.</p><p>The <strong>topStack</strong> function goes through the open stacks first by <strong>mode</strong>, then by layer. For example, if any editable windows are open, the topmost editable window is the <strong>topStack</strong>. If there are no editable windows, the <strong>topStack</strong> is the topmost modeless dialog box, and so on.</p><p><strong>Changing the current stack</strong></p><p>To operate on a stack other than the current stack, set the <strong>defaultStack</strong> property to the stack you want to target before executing the commands. Usually, the <strong>defaultStack</strong> is the <strong>topStack</strong>, but you can change it if you want to override the usual rules about which window is active.</p><p><strong>A note about Unix systems</strong></p><p>If your system is set up to use pointer focus rather than click-to-type or explicit focus, you may experience unexpected results when using LiveCode, since the current stack will change as you move the mouse pointer. It is recommended that you configure your system to use explicit focus when using LiveCode or any other applications created in LiveCode.</p><h3>Creating a backdrop</h3><p>For some applications, you may want to create a solid or patterned backdrop behind your application&#39;s windows. This backdrop prevents other applications&#39; windows from being seen – although it does not close those windows – so it&#39;s appropriate for applications like a game or kiosk, where the user doesn&#39;t need to see other applications and where you want to keep distractions to a minimum.</p><blockquote><p><strong>Note:</strong> In LiveCode Media edition, you cannot turn off the backdrop property.</p></blockquote><p>To create a backdrop, you set the <strong>backdrop</strong> property to either a valid color reference, or the <strong>ID</strong> of an image you want to use as a tiled pattern:</p><pre><code>set the backdrop to &quot;\#99FF66&quot; *-- a color*set the backdrop to 1943 *-- an image ID*</code></pre><p>In the LiveCode development environment, you can create a backdrop by choosing <strong>View -&gt; Backdrop</strong>. Use the Preferences dialog box to specify a backdrop color to use.</p><h3>Open, Closed, and Hidden Windows</h3><p>Each open stack is displayed in a stack window. A stack can be open without being visible, and can be loaded into memory without being open.</p><p><strong>Hidden stacks</strong></p><p>A stack window can be either shown or hidden, depending on the stack&#39;s <strong>visible</strong> property. This means a window can be open without being visible on the screen.</p><blockquote><p><strong>Tip:</strong> To list all open stacks, whether they&#39;re visible or hidden, use the <strong>openStacks</strong> function.</p></blockquote><p><strong>Loaded stacks</strong></p><p>A stack can also be loaded into memory without actually being open. A stack whose window is closed (not just hidden) is not listed by the <strong>openStacks</strong> function. However, it takes up memory, and its objects are accessible to other stacks. For example, if a closed stack that&#39;s loaded into memory contains a certain image, you can use the image as a button icon in another stack.</p><p>A stack can be loaded into memory without being open under any of the following conditions:</p><p>A handler in another stack referred to a property of the closed stack. This automatically loads the referenced stack into memory.</p><p>The stack is in the same stack file as another stack that is open.</p><p>The stack was opened and then closed, and its <strong>destroyStack</strong> property is set to false. If the <strong>destroyStack</strong> property is false, the stack is closed, but not unloaded, when its window is closed.</p><blockquote><p><strong>Tip:</strong> To list all stacks in memory, whether they&#39;re open or closed, use the <strong>revLoadedStacks</strong> function.</p></blockquote><h3>The states of a stack</h3><p>A stack, then, can be in any of four states:</p><p><strong>Open and visible:</strong>The stack is loaded into memory, its window is open, and the window is visible.</p><p><strong>Open and hidden:</strong>The stack is loaded into memory, its window is open, but the window is hidden. The stack is listed in the Window menu and in the Project Browser.</p><p><strong>Closed but loaded into memory:</strong>The stack is loaded into memory, but its window is not open and it is not listed by the <strong>openStacks</strong> function or in the Window menu. However, its objects are still available to other stacks, and it is listed in the Project Browser. A stack that is closed but loaded into memory has a <strong>mode</strong> property of zero.</p><p>To remove such a stack from memory, choose <strong>Tools -&gt; Project Browser</strong>, find the stack&#39;s name, and Right-click it in the Project Browser window and choose &quot;Close and Remove from Memory&quot; from the contextual menu.</p><p><strong>Closed:</strong>The stack is not loaded into memory and has no effect on other stacks.</p><h3><strong>Window Types and the Mode Property</strong></h3><p>In a script, you can find out a stack window&#39;s type by checking the stack&#39;s <strong>mode</strong> property. This read-only property reports a number that depends on the window type. For example, the <strong>mode</strong> of an editable window is 1, and the <strong>mode</strong> of a <strong>palette</strong> is 4.</p><p>You can use the <strong>mode</strong> property in a script to check what sort of window a stack is being displayed in:</p><pre><code>if the mode of this stack is 5 then *-- modal dialog box*    close this stackelse -- some other type of window    beepend if</code></pre><p>For complete information about the possible values of the <strong>mode</strong> property, see its entry in the LiveCode Dictionary.</p><h3>Window Appearance</h3><p>Details of a window&#39;s appearance, such as the height of its title bar and the background color or pattern in the window itself, are mainly determined by the stack&#39;s mode. There are a few additional elements of window appearance that you can control with specific properties.</p><p><strong>The metal property</strong></p><p>On OS X systems, you use a stack&#39;s <strong>metal</strong> property to give the stack window a textured metal appearance. This metal appearance applies to the stack&#39;s title bar and its background.</p><blockquote><p><strong>Tip:</strong> The metal appearance, in general, should be used only for the main window of an application, and only for windows that represent a physical media device such as a CD player. See Apple&#39;s Aqua user-interface guidelines for more information.</p></blockquote><p><strong>Window background color</strong></p><p>The background color or pattern of a window&#39;s content area--the part that isn&#39;t part of the title bar--is determined by the window type and operating system, by default. For example, on Mac OS X systems, a striped background appears in palettes and modeless dialog boxes.</p><p>If you want a window to have a specific color or pattern, you can set the stack&#39;s <strong>backgroundColor</strong> or <strong>backgroundPattern</strong> property:</p><pre><code>set the backgroundColor of stack &quot;Alpha&quot; to &quot;aliceblue&quot;set the backgroundPattern of stack &quot;Beta&quot; to 2452 *-- img ID*</code></pre><p>This color or pattern overrides the usual color or background pattern.</p><h3>The Decorations Property</h3><p>Most of the properties that pertain to a window&#39;s appearance can also be set in the stack&#39;s <strong>decorations</strong> property. The <strong>decorations</strong> of a stack consists of a comma-separated list of decorations:</p><pre><code>set the decorations of stack &quot;Gamma&quot; to &quot;title,minimize&quot;</code></pre><p>The statement above sets the stack&#39;s**minimizeBox** property to true, as well as showing its title bar, and sets other stack properties (**maximizeBox**, <strong>closeBox</strong>, <strong>metal</strong>) to false. Conversely, if you set a stack&#39;s <strong>minimizeBox</strong> property to true, its <strong>decorations</strong> property is changed to include &quot;minimize&quot; as one of its items. In this way, the <strong>decorations</strong> property of a stack interacts with its <strong>closeBox</strong>, <strong>minimizeBox</strong>, <strong>zoomBox</strong>, <strong>metal</strong>, <strong>shadow</strong>, and <strong>systemWindow</strong> properties.</p><p><strong>The decorations property and menu bars in a window</strong></p><p>On Linux and Windows systems, the menu bar appears at the top of the window. On these systems, whether a window displays its menu bar is determined by whether the stack&#39;s <strong>decorations</strong> property includes &quot;menu&quot;:</p><pre><code>set the decorations of this stack to &quot;title,menu&quot;</code></pre><p>On Mac OS X systems, the menu bar appears at the top of the screen, outside any window. On these systems, the &quot;menu&quot; decoration has no effect.</p><p><strong>Title bar</strong></p><p>The user drags the title bar of a window to move the window around the screen. In general, if the title bar is not displayed, the user cannot move the window. You use the <strong>decorations</strong> property (discussed below) to hide and show a window&#39;s title bar.</p><p>When the user drags the window, LiveCode sends a <strong>moveStack</strong> message to the current card.</p><p>The <strong>decorations</strong> property affects only whether the window can be moved by dragging it. Even if a stack&#39;s <strong>decorations</strong> property does not include the title bar decoration, you can still set a stack&#39;s <strong>location</strong>, <strong>rectangle</strong>, and related properties to move or resize the window.</p><p><strong>Window title</strong></p><p>The title that appears in the title bar of a window is determined by the stack&#39;s <strong>label</strong> property. If you change a stack&#39;s <strong>label</strong> in a script, the window&#39;s title is immediately updated.</p><p>If the <strong>label</strong> is empty, the title bar displays the stack&#39;s <strong>name</strong> property. (If the stack is in an editable window whose <strong>cantModify</strong> is false, an asterisk appears after the window title to indicate this, and if the stack has more than one card, the card number also appears in the window title. These indicators do not appear if the stack has a <strong>label</strong>.)</p><p>Because the window title is determined by the stack&#39;s <strong>label</strong> property instead of its <strong>name</strong> property, you have a great deal of flexibility in changing window title. Your scripts refer to the stack by its <strong>name</strong>--which doesn&#39;t need to change--not its <strong>label</strong>, so you can change the window title without changing any scripts that refer to the stack.</p><p><strong>The close box</strong></p><p>The close box allows the user to close the window by clicking it. To hide or show the close box, you set the stack&#39;s <strong>closeBox</strong> property:</p><pre><code>set the closeBox of stack &quot;Bravo&quot; to false</code></pre><p>When the user clicks the close box, LiveCode sends a <strong>closeStackRequest</strong> message, followed by a <strong>closeStack</strong> message, to the current card.</p><p>The <strong>closeBox</strong> property affects only whether the window can be closed by clicking. Even if a stack&#39;s <strong>closeBox</strong> property is false, you can still use the <strong>close</strong> command in a handler or the message box to close the window.</p><p><strong>The minimize box or collapse box</strong></p><p>The terminology and behavior of this part of the title bar varies depending on platform. The minimize box shrinks the window to a desktop icon.</p><p>To hide or show the minimize box or collapse box, you set the stack&#39;s <strong>minimizeBox</strong> property:</p><pre><code>set the minimizeBox of this stack to true</code></pre><blockquote><p><strong>Tip:</strong> On OS X and Linux systems, you can set a stack&#39;s <strong>icon</strong> property to specify the icon that appears when the stack is minimized.</p></blockquote><p>When the user clicks the minimize box or collapse box, LiveCode sends an <strong>iconifyStack</strong> message to the current card.</p><p><strong>The maximize box or zoom box</strong></p><p>The terminology and behavior of this part of the title bar varies depending on platform. On Mac OS X systems, the zoom box switches the window between its current size and maximum size. The maximize box (Linux and Windows systems) expands the window to its maximum size.</p><p>To hide or show the zoom box or maximize box, you set the stack&#39;s <strong>zoomBox</strong> property:</p><pre><code>set the zoomBox of stack &quot;Hello&quot; to false</code></pre><p>When the user clicks the zoom box or maximize box, LiveCode sends a <strong>resizeStack</strong> message to the current card.</p><h3>Making a stack resizable</h3><p>A stack&#39;s <strong>resizable</strong> property determines whether the user can change its size by dragging a corner or edge (depending on operating system) of the stack window.</p><blockquote><p><strong>Tip:</strong> To move and resize controls automatically to fit when a stack is resized, use the &quot;Geometry&quot; pane in the control&#39;s property inspector.</p></blockquote><p>Some stack modes cannot be resized, regardless of the setting of the stack&#39;s <strong>resizable</strong> property. Modal dialog boxes, sheets, and drawers cannot be resized by the user, and do not display a resize box.</p><p>The <strong>resizable</strong> property affects only whether the window can be resized by dragging a corner or edge. Even if a stack&#39;s <strong>resizable</strong> property is set to false, you can still set a stack&#39;s <strong>location</strong>, <strong>rectangle</strong>, and related properties to move or resize the window.</p><p>When the user resizes a stack, LiveCode sends a <strong>resizeStack</strong> message to the current card.</p><h3>Irregularly-Shaped and Translucent Windows</h3><p>You can set a stack’s <strong>windowShape</strong> property to the transparent, or <em>alpha channel</em> of an image that has been imported together with its alpha channel. This allows you to create a window with &quot;holes&quot; or a window with variable translucency. You can apply a shape to any type of stack, regardless of the mode it is opened, allowing such a window to exhibit modal behavior as a dialog, float as a palette, etc.</p><p>You may use either a GIF or PNG image for irregularly shaped windows. If you want translucency you must use PNG images.</p><h2><a name="//apple_ref/cpp/Guide/Programming Menus &amp; Menu Bars" class="dashAnchor"></a>Programming Menus &amp; Menu Bars</h2><p>Menus in LiveCode are not a separate object type. Instead, you create a menu from either a button or a stack, then use special commands to display the menu or to include it in a menu bar.</p><p>This topic discusses menu bars, menus that are not in the menu bar (such as contextual menus, popup menus, and option menus), how to make menus with special features such as checkmarks and submenus, and how to use a stack window as a menu for total control over menu appearance.</p><p>To easily create menu bars that work cross-platform, choose <strong>Tools -&gt; Menu Builder</strong>. See the section on the <em>Menu Builder</em> in the chapter on <em>Building a User interface</em> for more details. The details about menu bars in this topic are needed only if you want edit menu bars by script, for example if you want to include specific features not supported by the Menu Builder.</p><h3>Menu Types</h3><p>LiveCode supports several menu types: <em>pulldown</em> menus, <em>option</em> menus (usually called popup menus on Mac OS X), <em>popup</em> menus (usually called contextual menus on Mac OS X), and <em>combo boxes</em>.</p><p>Each of these menu types is implemented by creating a button. If the button&#39;s <strong>style</strong> property is set to &quot;menu&quot;, clicking it causes a menu to appear. The button&#39;s <strong>menuMode</strong> property determines what kind of menu is displayed.</p><p>Even menu bars are created by making a pulldown-menu button for each menu, then grouping the buttons to create a single menu bar. The menu bar can be moved to the top of the stack window (on Unix and Windows systems). To display the menu bar in the standard location at the top of the screen on Mac OS X systems, you set the stack&#39;s <strong>menubar</strong> property to the group&#39;s name. The name of each button is displayed in the menu bar as a menu, and pulling down a menu displays the contents of the button as a list of menu items.</p><h3>Button Menus</h3><p>You can create a button menu by dragging out one of the menu controls from the tools palette. However, if you want to create one by script, the easiest is to create a button and set the <strong>style</strong> of the button to &quot;menu&quot;. Next, you can set the <strong>menuMode</strong> of the button to the appropriate menu type. You can either set the <strong>menuMode</strong> in a handler, or use the Type menu in the button&#39;s property inspector to set the menu type.</p><p>To create the individual menu items that will appear in the menu, set the button&#39;s <strong>text</strong> property to the menu&#39;s contents, one menu item per line. You can either set this property in a handler, or fill in the box labeled &quot;Menu items&quot; on the Basic Properties pane of the property inspector.</p><p>When you click the button, the specified menu type appears, with the text you entered displayed as the individual menu items in the menu.</p><blockquote><p><strong>Tip:</strong> To dynamically change the menu&#39;s contents at the time it&#39;s displayed, put a <strong>mouseDown</strong> handler in the button&#39;s script that puts the desired menu items into the button. When the menu appears, it displays the new menu items.</p></blockquote><p>For menus that retain a state (such as option menus and combo boxes), the button&#39;s <strong>label</strong> property holds the text of the currently chosen menu item.</p><p><strong>Handling the menuPick message</strong></p><p>When the user chooses an item from the menu, LiveCode sends the <strong>menuPick</strong> message to the button. The message parameter is the name of the menu item chosen. If you want to perform an action when the user chooses a menu item, place a <strong>menuPick</strong> handler like this one into the button&#39;s script:</p><pre><code>on menuPick theMenuItem    switch theMenuItem    case &quot;Name of First Item&quot;        -- do stuff here for first item    break    case &quot;Name of Second Item&quot;        -- do stuff here for second item    break    case &quot;Name of Third Item&quot;        -- do stuff here for third item    break    end switchend menuPick</code></pre><p><strong>Changing the currently-chosen menu item</strong></p><p>For menus that retain a state (such as option menus and combo boxes), you can change the currently-chosen menu item by changing the button&#39;s <strong>label</strong> property to the text of the newly chosen item</p><p>If you change the currently-chosen menu item in option menus, also set the button&#39;s <strong>menuHistory</strong> property to the line number of the newly chosen item. This ensures that the new choice will be the one under the mouse pointer the next time the user clicks the menu.</p><h3>Creating Cascading Menus</h3><p>To create a cascading menu (also called a submenu, pull-right menu, or hierarchical menu), add a tab character to the start of menu items that you want to place in the submenu.</p><p>For example, the following text, when placed in a menu button, creates two menu items, then a submenu containing two more items, and finally a last menu item:</p><p><strong>First Item</strong></p><p><strong>Second Item</strong></p><p><strong>Third Item Is A Submenu</strong></p><p><strong>First Item In Submenu</strong></p><p><strong>Second Item In Submenu</strong></p><p><strong>Last Menu Item Not In Submenu</strong></p><p>The depth of a submenu item is determined by the number of tab characters before the menu item&#39;s name. The submenu item becomes part of the closest line above the submenu item that has one fewer leading tab character.</p><p>This means that the first line of a menu cannot start with a tab character, and any line in the button&#39;s text can have at most one more tab character than the preceding line.</p><blockquote><p><strong>Important:</strong> You cannot create a cascading combo box at all, and cascading option menus do not work properly on all platforms. In general, you should create cascading menus only as a part of a pulldown menu.</p></blockquote><p><strong>Cascading menus and the menuPick message</strong></p><p>When the user chooses a menu item in a cascading menu, the parameter of the <strong>menuPick</strong> message contains the menu item name and the name of the submenu it&#39;s part of, separated by a vertical bar (<code>|</code>). For example, if the user chooses the &quot;Second Item In Submenu&quot; from the menu described above, the parameter sent with the <strong>menuPick</strong> message is:</p><pre><code>Third Item Is A Submenu|Second Item In Submenu</code></pre><h3>Ticks, Dashes &amp; Checks in Menus</h3><p>There are several special characters that you can put at the start of a line in the button&#39;s contents to change the behavior of the menu item:</p><ul><li>A dash on a line by itself creates a divider line!c checks the menu item!n unchecks the menu item!r places a diamond at the start of the menu item!u removes the diamond</li></ul><p>If you include any of the above special characters in a submenu item, the special character must be placed at the start of the line – before the tab characters that make it a submenu item.</p><blockquote><p><strong>Note:</strong> You cannot create divider lines in combo boxes or in option menus on Windows systems.</p></blockquote><p>There are three other special characters that can appear anywhere in a line:</p><p>Putting the <code>&amp;</code>character anywhere in a line underlines the next character and makes it the keyboard mnemonic for that menu item on Windows systems. The <code>&amp;</code>character does not appear in the menu, and is not sent with the parameter to the <strong>menuPick</strong> message when you choose the item from a menu.</p><p>Putting the <code>/</code>character anywhere in a line makes the next character the keyboard equivalent for the menu item. Neither the <code>/</code>nor the character following it appear in the menu, nor do they appear in the parameter to the <strong>menuPick</strong> message.</p><p>To put an <code>&amp;</code>or / character in the text of a menu, double the characters: &amp;<code>&amp;</code>or //.</p><p>Putting the <code>(</code>character anywhere in a line disables the menu item. To put a <code>(</code>character in a menu item without disabling it, precede it with a backslash: \(.</p><blockquote><p><strong>Note:</strong> You cannot disable lines in combo boxes or in option menus on Windows systems.</p></blockquote><p>All of the above special characters are filtered out of the parameter sent with the <strong>menuPick</strong> message when the user chooses a menu item. The parameter is the same as the characters that are actually displayed in the menu.</p><blockquote><p><strong>Note:</strong> The font and color of a button menu is determined by the button&#39;s font and color properties. However, on Mac OS systems, the font and color of the option menus and popup menus is controlled by the operating system&#39;s settings if the <strong>lookAndFeel</strong> is set to &quot;Appearance Manager&quot;, rather than by the button&#39;s font and color properties.</p></blockquote><p><strong>Enabling and disabling menu items</strong></p><p>To enable or disable a menu item in a handler, you can add or remove the &quot;(&quot; special character, but it is generally easier to use the <strong>enable menu</strong> and <strong>disable menu</strong> commands:</p><pre><code>enable menuItem 3 of button &quot;My Menu&quot;disable menuItem 4 of me</code></pre><p>These commands simply add or remove the <code>(</code>special character at the start of the designated line of the button&#39;s contents.</p><h3>Menu Bars on Linux and Windows Systems</h3><p>A menu bar is made up of a group of menu buttons, with the <strong>menuMode</strong> property of each button set to &quot;pulldown&quot;.</p><blockquote><p><strong>Tip:</strong> The Menu Builder can automatically create a menu bar for you. To use the Menu Builder, choose <strong>Tools -&gt; Menu Builder</strong>.</p></blockquote><p>To create a menu bar by hand without using the Menu Builder:</p><p><strong>1.</strong> Create a button for each menu, set the <strong>style</strong> of each button to &quot;menu&quot;, and set the <strong>menuMode</strong> of the button to &quot;pulldown&quot;. You can either set these properties in a handler, or simply choose <strong>Object -&gt; New Control Pulldown Menu</strong> to create each button.</p><p><strong>2.</strong> Put the menu items into each button&#39;s contents. In each button&#39;s script, create a <strong>menuPick</strong> handler to perform whatever actions you want to do when a menu item is chosen.</p><p><strong>3.</strong> Select the buttons and form them into a group, then move the group to the appropriate position at the top of the window. For Windows systems, set the <strong>textFont</strong> of the group to the standard font for Windows menus, &quot;MS Sans Serif&quot;.</p><blockquote><p><strong>Important:</strong> The buttons in your menu bar should not overlap. Overlapping buttons may cause unexpected behavior when the user tries to use a menu.</p></blockquote><h3>Menu Bars on Mac OS X Systems</h3><p>To create a Mac OS X menu bar, you follow the same steps as for a Linux and Windows menu bar above. This places a group of buttons, each of whose <strong>menuMode</strong> property is set to &quot;pulldown&quot;, at the top of your stack window.</p><p>Next, you set the <strong>menubar</strong> property of your stack to the name of the group. This does two things: it displays the menus in the menu bar at the top of the screen, and it shortens the stack window and scrolls it up so that the group of menu buttons is not visible in the window. Since the menus are in the menu bar, you don&#39;t need to see them in the stack window as well.</p><blockquote><p><strong>Important:</strong> If your stack has more than one card, make sure that the group is placed on all the cards. (To place a group on a card, choose <strong>Object menu Place Group</strong>, or use the <strong>place</strong> command.) This ensures that the menu bar will be accessible on all cards of the stack, and prevents the stack from changing size as you move from card to card (to accommodate shortening the stack window for the menu bar group).</p></blockquote><p><strong>The default menu bar</strong></p><p>If other stacks in your application don&#39;t have their own menu bars, set the <strong>defaultMenubar</strong> global property to the name of your menu group, as well as setting the stack&#39;s <strong>menubar</strong> property. The <strong>defaultMenubar</strong> is used for any stack that doesn&#39;t have a menu bar of its own.</p><blockquote><p><strong>Tip:</strong> For a custom menu bar to work correctly inside the LiveCode development environment, you must set the <strong>defaultMenubar</strong> to the name of your menu group. This overrides the LiveCode IDE menu bar. You can get the menu bar back by choosing the pointer tool.</p></blockquote><p><strong>Button menu references</strong></p><p>If the button is a button menu that&#39;s being displayed in the menu bar, you can use the word &quot;menu&quot; to refer to it:</p><pre><code>get menuItem 2 of menu &quot;Edit&quot;-- same as &#39;get line 2 of button &quot;Edit&quot;&#39;</code></pre><p>Because menus are also buttons, you can use a button reference to get the same information. But you may need to specify the group and stack the button is in, to avoid ambiguity. (For example, if there is a standard button named &quot;Edit&quot; on the current card, the expression <code>button &quot;Edit&quot;</code>refers to that button, not to the one in the menu bar.) An unambiguous button reference to a menu might look like this:</p><pre><code>get line 2 of button &quot;Edit&quot; of group &quot;Menu&quot; of stack &quot;Main&quot;</code></pre><p>The above statement produces the same information as the form using &quot;<code>menu</code>&quot;, but you need to know the group name and possibly which stack it&#39;s in, so the <em>menuName</em> form is a little more convenient.</p><p><strong>The layer of menu buttons</strong></p><p>For a menu bar to work properly on Mac OS X systems, the menus must be in layer order within the group. That is, the button for the File menu must be numbered 1, the button for the Edit menu must be 2, and so on. The Menu Builder takes care of this automatically; you only need to worry about layering if you&#39;re creating the menu bar by hand.</p><p><strong>Changing menus dynamically</strong></p><p>If you want to dynamically change a menu&#39;s contents with a <strong>mouseDown</strong> handler at the time the menu is displayed, you must place the <strong>mouseDown</strong> handler in the group&#39;s script. When a menu button is being displayed in the Mac OS menu bar, it does not receive <strong>mouseDown</strong> messages, but its group does.</p><p><strong>The editMenus property</strong></p><p>When you set the <strong>menubar</strong> property of a stack to the name of a group, the stack is resized and scrolled up so the part of the window that holds the menus is not visible. To reverse this action so you can see, select and edit the buttons that make up your menu bar, set the <strong>editMenus</strong> property to true. This resizes the stack window so the button menus are again visible, and you can use the tools in the LiveCode development environment to make changes to them.</p><p>To scroll the stack window again so that the menus are hidden, set the <strong>editMenus</strong> property back to false.</p><p><strong>Special menu items</strong></p><p>A few menu items on Mac OS X are handled directly by the operating system. To accommodate these special menu items while allowing you to create a fully cross-platform menu bar,LiveCode treats the last two menu items of the Help menu, the File menu, and the Edit menu differently.</p><p>By following these guidelines, you can make sure your menus will appear properly on all operating systems without having to write special code or create platform-specific menu bars.</p><p><strong>The Help menu and the &quot;About This Application&quot; menu item</strong></p><p>When LiveCode sets up the Mac OS X menu bar, it automatically makes the last button the Help menu (regardless of the button&#39;s name). The standard Help menu items, such as the &quot;Search&quot; bar are included for you automatically; you don&#39;t need to include them in your Help menu button, and you can&#39;t eliminate them from the Help menu.</p><p>LiveCode moves the last menu item in the Help menu to the &quot;About This Application&quot; position. On Mac OS X systems, it&#39;s the first menu item in the Application menu. Therefore, the last menu item in your Help menu button should be an appropriate &quot;About&quot; item. The menu item above it must be a divider line (a dash), and above that must be at least one menu item to be placed in the Help menu.</p><p><strong>The File menu and the &quot;Quit&quot; menu item</strong></p><p>On Mac OS X systems, the &quot;Quit&quot; menu item is normally placed in the Application menu (which is maintained by the operating system) rather than in the File menu, as is standard on other platforms. To accommodate this user-interface standard, LiveCode removes the last two menu items of the File menu when a standalone application is running on an OS X system. Therefore, the last menu item in your File menu button should be &quot;Quit&quot;. The menu item above it should be a divider line (a dash).</p><p><strong>The Edit menu and the &quot;Preferences&quot; menu item</strong></p><p>On OS X systems, the &quot;Preferences&quot; menu item is also normally placed in the Application menu. To accommodate this user-interface standard, LiveCode removes the last two menu items of the Edit menu when a standalone application is running on an OS X system. Therefore, the last menu item in your Edit menu button should be &quot;Preferences&quot;. The menu item above it should be a divider line (a dash).</p><blockquote><p><strong>Note:</strong> The Preferences menu item is treated in this special way only if its name starts with the string &quot;Preferences&quot;.</p><p><strong>Tip:</strong> If your application&#39;s user interface is presented in a language other than English, set the <strong>name</strong> of the Edit menu button to &quot;Edit&quot;, and set its <strong>label</strong> to the correct translation. This ensures that the engine can find the Edit menu, while making sure that the menu is shown in the correct language.</p></blockquote><p><strong>Choosing the special menu items</strong></p><p>When the user chooses any of these special menu items, a <strong>menuPick</strong> message is sent to the button that the menu item is contained in. This ensures that your button scripts will work on all platforms, even if LiveCode displays a menu item in a different menu to comply with user-interface guidelines.</p><h3>Stack Menus</h3><p>Button menus can be used for most kinds of standard menus. However, if you want to create a menu with a feature that is not supported by button menus--for example, if you want a popup menu that provides pictures, rather than text, as the choices--you can create a menu from a stack.</p><p><strong>Creating a stack menu</strong></p><p>To create a stack menu, you create a stack with a control for each menu item. Since the stack menu is a stack and each menu item is an object, the menu items receive mouse messages such as <strong>mouseEnter</strong>,**mouseLeave**, and <strong>mouseUp</strong>.</p><p>When the user chooses an item from the stack menu, a <strong>mouseUp</strong> message is sent to that control. To respond to a menu item choice, instead of handling the <strong>menuPick</strong> message, you can place a <strong>mouseUp</strong> handler in the script of the object.</p><p>To create a stack menu that looks like a standard menu, create a button in the stack for each menu item. The button&#39;s <strong>autoArm</strong> and <strong>armBorder</strong> properties should be set to true. Or you can choose &quot;Menu Item&quot; item in the &quot;New Control&quot; submenu of the Object menu to create a button with its properties set to the appropriate values.</p><p>Be sure to set the <strong>rectangle</strong> of the stack to the appropriate size for the menu. Remember, when you open the menu, the stack will be displayed exactly as it looks in an editable window.</p><p>Finally, either set the <strong>menuName</strong> property of a button to a reference to the stack, or place a <strong>mouseDown</strong> handler containing a <strong>pulldown</strong>, <strong>popup</strong>, or <strong>option</strong> command in the script of an object. When you click the button or object, the stack menu appears.</p><p><strong>Displaying a stack menu</strong></p><p>Stack menus can be associated with a button, just like button menus. But when you click the button, instead of displaying a menu with the button&#39;s contents, LiveCode displays a stack with the behavior of a menu.</p><p>You can also display a stack menu without associating it with a button, by using the <strong>pulldown</strong>, <strong>popup</strong>, or <strong>option</strong> command. Normally, you use these commands in a <strong>mouseDown</strong> handler, so that the menu appears under the mouse pointer:</p><pre><code>on mouseDown -- in card script    popup stack &quot;My Menu Panel&quot;end mouseDown</code></pre><h3>Displaying Context Sensitive Menus</h3><p>There are also several commands to display a context menu. Usually, you use these commands in a <strong>mouseDown</strong> handler – normally either in your card or stack script:</p><p><strong>popup</strong> command: opens a stack as a popup menu</p><p><strong>pulldown</strong> command: opens a stack as a pulldown menu</p><p><strong>option</strong> command: opens a stack as an option menu</p><blockquote><p><strong>Note:</strong> If you set a button&#39;s <strong>menuName</strong> property to the name of a stack, the stack menu is displayed automatically when the user clicks the button. You need the <strong>popup</strong>, <strong>pulldown</strong>, and <strong>option</strong> commands only if you want to display a stack menu in some way other than when a button is clicked.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Searching and Navigating Cards using the Find Command" class="dashAnchor"></a>Searching and Navigating Cards using the Find Command</h2><p>The find command in LiveCode allows you to search the fields of the current stack, then navigate to and highlight the results of the search automatically. While it is possible to build such a command using the comparison features detailed in the <em>Processing Text and Data</em> guide, for most purposes the find command provides a complete, pre-built solution.</p><p>find [*form*] textToFind [*in field*]</p><p>The <em>form</em> can be one of the following:</p><p><em>normal</em></p><p><em>characters</em> or character (or chars or char)</p><p><em>words</em> or <em>word</em></p><p><em>string</em></p><p><em>whole</em></p><p>If no <em>form</em> is specified, the find normal form is used.</p><p>The <em>textToFind</em> is any expression that evaluates to a string.</p><p>The <em>field</em> is any expression that evaluates to a field reference. If the <em>field</em> is not specified, the <strong>find</strong> command searches all the fields in the current stack (except fields whose dontSearch property is set to true).</p><pre><code>find &quot;heart&quot;find string &quot;beat must go on&quot; in field &quot;Quotes&quot;</code></pre><p>When the find command finds a match, it highlights the match on the screen – if necessary navigating to the card that contains the match and scrolling the field so the text is in view.</p><p>The find command can also be used to return the location of the text that was found.</p><p>To reset the find command so that it starts searching at the beginning again:</p><pre><code>find empty</code></pre><p>For more details on the find command and associated options, see the <em>find command</em> in the <em>LiveCode Dictionary</em>.</p><h2><a name="//apple_ref/cpp/Guide/Using Drag and Drop" class="dashAnchor"></a>Using Drag and Drop</h2><p>LiveCode allows you complete control over drag and drop – both within LiveCode windows and between LiveCode and other applications.</p><h3>Initiating a Drag Drop</h3><p>To begin a drag and drop operation, the user clicks and holds the mouse pointer. This sends a <code>mouseDown</code>message to the object.</p><p>If you drag from within a field, a <strong>dragStart</strong> message is sent. To allow drags from a locked field or from another object type, in the object&#39;s <strong>mouseDown</strong> handler, set the <strong>dragData</strong> property to the data you want to drag. When there is a value in the <strong>dragData</strong>, a drag and drop is initiated when the mouse is clicked and then moved.</p><pre><code>set the dragData[&quot;text&quot;] to &quot;text being dragged&quot;</code></pre><p>You can set the <strong>dragData</strong> to contain any of the following types of data:</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>text</td><td>The plain text being dragged.</td></tr><tr><td>HTML</td><td>The styled text being dragged, in the same format as the <strong>htmlText</strong></td></tr><tr><td>RTF</td><td>The styled text being dragged, in the same format as the <strong>RTFText</strong></td></tr><tr><td>Unicode</td><td>The text being dragged, in the same format as the <strong>unicodeText</strong></td></tr><tr><td>image</td><td>The data of an image (in PNG format)</td></tr><tr><td>files</td><td>The name and location of the file or files being dragged, one per line</td></tr></tbody></table><blockquote><p><strong>Note:</strong> LiveCode automatically handles the mechanics of dragging and dropping text between and within unlocked fields. To support this type of drag and drop operation, you don&#39;t need to do any scripting.</p></blockquote><p>For more details, see the entries for <em>dragStart</em> and <em>dragData</em> in the <em>LiveCode Dictionary</em>.</p><h3>Tracking During a Drag Drop Operation</h3><p>You can use the <strong>dragEnter</strong> message to show an outline around an object or change the cursor when the mouse moves into it during a drag operation.</p><pre><code>on dragEnter -- show a green outline around the drop target    set the borderColor of the target to &quot;green&quot;end dragEnter</code></pre><p>You can use the <strong>dragMove</strong> message to update the screen whenever the cursor moves during a drag and drop operation.</p><pre><code>on dragMove -- in a field script    -- set the cursor so it shows you can only drop onto a link    if the textStyle of the mouseChunk contains &quot;link&quot;    then set the cursor to the ID of image &quot;Drop Here&quot;    else set the cursor to the ID of image &quot;Dont Drop&quot;end dragMove</code></pre><p>You can use the <strong>dragLeave</strong> message to remove any outline around an object or change the cursor when the mouse moves out of an object during a drag operation.</p><pre><code>on dragLeave    -- remove any outline around the drop no-longer-target    set the borderColor of the target to emptyend dragLeave</code></pre><p>For more details, see the entries for <em>dragEnter</em>, <em>dragMove</em> and <em>dragLeave</em> in the <em>LiveCode Dictionary</em>.</p><h3>Responding to a Drag and Drop</h3><p>To perform an action when the user drops data onto a locked field or another object type, you handle the <strong>dragDrop</strong> message.</p><p>The <strong>dragDrop</strong> message is sent when the user drops data on an object.</p><pre><code>on dragDrop -- check whether a file is being dropped    if the dragData[&quot;files&quot;] is empty then beep 2    pass dragDropend dragDrop</code></pre><p>You must set the <strong>acceptDrop</strong> property to true before a drop will be allowed. Usually, you set this property to true in a <strong>dragEnter</strong> handler.</p><p>You can use the <strong>dragDestination</strong> function to retrieve the long id of the object that the dragged data was dropped on. You can use the <strong>dragSource</strong> function to retrieve the long id of the object that was the source of the drag.</p><p>When a drag drop has been completed, a <strong>dragEnd</strong> message is sent to the object the drag and drop started from.</p><pre><code>on dragEnd -- remove data being draggedd   elete the dragSourceend dragEnd</code></pre><p>You can use the <strong>dropChunk</strong> function to retrieve the location of the text that was dropped in a field. For example, you could select the text that was dropped by doing the following:</p><pre><code>select the dropChunk</code></pre><p>For more details, see the entries for <em>dragDrop</em>, <em>dragEnter</em>, <em>dragDestination</em>, <em>dragEnd</em>, <em>dragSource</em> , <em>dropChunk</em> and <em>acceptDrop</em> in the <em>LiveCode Dictionary</em>.</p><h3>Prevent Dragging and Dropping to a Field</h3><p>You prevent dropping data into a field during a drag and drop by setting the <strong>acceptDrop</strong> property to false when the mouse pointer enters the field.</p><p>If the <strong>acceptDrop</strong> is set to false, when you drop data, no <strong>dragDrop</strong> message is sent to the field. Since the drop is automatically processed only when LiveCode receives a <strong>dragDrop</strong> message, this prevents the usual automatic drop behavior.</p><p>Usually, you should set the <strong>acceptDrop</strong> in a <strong>dragEnter</strong> handler, as in the following example:</p><pre><code>on dragEnter -- in a field script    set the acceptDrop to falseend dragEnter</code></pre><p>If you want to prevent dragging text within a field, intercept the dragStart message:</p><pre><code>on dragStart    -- do nothingend dragStart</code></pre><p>For more details, see the entries for <em>acceptDrop</em>, <em>dragDrop</em> and <em>dragEnter</em> in the <em>LiveCode Dictionary</em>.</p></body></html>