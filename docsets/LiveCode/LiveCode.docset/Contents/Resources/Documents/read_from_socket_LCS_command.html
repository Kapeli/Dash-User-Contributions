<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>read from socket</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><table><tr><td colspan="2"><h1>read from socket</h1></td></tr><tr><td><b>Type</b></td><td>command</td></tr><tr><td><b>Dictionary</b></td><td>LCS</td></tr><tr><td><b>Library</b></td><td>LiveCode Script</td></tr><tr><td><b>Syntax</b></td><td><pre><b><span class="command">read</span></b><span class="normal"> </span><span class="function">from</span><span class="normal"> </span><span class="function">socket</span><span class="normal"> &lt;socketID&gt; [</span><font color="#FF0000">{</span><span class="function">until</span><span class="normal"> &lt;dataString&gt; | </span><span class="function">for</span><span class="normal"> &lt;readAmount&gt; [&lt;chunkType&gt;]</span><font color="#FF0000">}</span><span class="normal">] [</span><span class="function">with</span><span class="normal"> </span><span class="function">message</span><span class="normal"> &lt;callbackMessage&gt;]</span></pre></td></tr><tr><td><b>Summary</b></td><td><p>Accepts data from a <a href="socket_LCS_glossary.html">socket</a> and places the data in the <a href="it_LCS_keyword.html">it</a> <a href="variable_LCS_glossary.html">variable</a>.</p></td></tr><tr><td><b>Edition</b></td><td>Community</td></tr><tr><td><b>Introduced</b></td><td>1.0</td></tr><tr><td><b>OS</b></td><td>mac, windows, linux, ios, android</td></tr><tr><td><b>Platforms</b></td><td>desktop, server, mobile</td></tr><tr><td><b>Parameters</b></td><td><table class="inner"><tr><th>Name</th><th>Type</th><th>Description</th></tr><tr><td>socketID</td><td></td><td><p>The identifier (set when you opened the socket) of the socket you wantto get data from. The socket identifier starts with the IP address ofthe host the socket is connected to, and may optionally include a portnumber (separated from the IP address by a colon). If there is more thanone socket connected to that host and port, you can specify which socketby appending the connection name or number that was assigned when thesocket was opened, separated from the port number by a vertical bar (|).</p></td></tr><tr><td>dataString</td><td></td><td><p>When LiveCode encounters the string in the socket data, it stopsreading. If the string is not encountered, the read from socket commandcontinues reading as long as there is data to be read.</p></td></tr><tr><td>readAmount</td><td></td><td><p>A positive integer and specifies how much data to read.</p></td></tr><tr><td>chunkType</td><td></td><td><p>One of <em>chars, characters, words, items, lines, int1, uInt1, int2, uint2,int4, or uint4</em>. The read from socket command reads amount of thespecified chunkType. If you don&#39;t specify a chunkType, <b>readAmount</b> of <em>characters</em> are read.</p></td></tr><tr><td>callbackMessage</td><td></td><td><p>The name of a message to be sent when the read is successfullycompleted. </p></td></tr></table></td></tr><tr><td><b>Example</b></td><td><pre><b><span class="command">read</span></b><span class="normal"> </span><span class="function">from</span><span class="normal"> </span><span class="function">socket</span><span class="normal"> </span><span class="normal">"www.example.net:80"</span><span class="normal"> </span><span class="function">for</span><span class="normal"> </span><span class="normal">50</span><span class="normal"> </span><b><span class="comment">-- reads next 50 chars</span></b></pre><pre><b><span class="command">read</span></b><span class="normal"> </span><span class="function">from</span><span class="normal"> </span><span class="function">socket</span><span class="normal"> </span><span class="normal">"127.0.0.0:20|foo"</span><span class="normal"> </span><span class="function">until</span><span class="normal"> </span><span class="function">linefeed</span></pre><pre><b><span class="command">read</span></b><span class="normal"> </span><span class="function">from</span><span class="normal"> </span><span class="function">socket</span><span class="normal"> mySocket </span><span class="function">for</span><span class="normal"> </span><span class="normal">30</span><span class="normal"> </span><span class="function">uInt2s</span><span class="normal"> </span><span class="function">with</span><span class="normal"> </span><span class="function">message</span><span class="normal"> </span><span class="normal">"gotData"</span></pre></td></tr><tr><td><b>Values</b></td><td><table class="inner"><tr><th>Name</th><th>Type</th><th>Description</th></tr><tr><td>It</td><td></td><td><p>If you don&#39;t specify a <b>callbackMessage</b>, the <a href="handler_LCS_glossary.html">handler</a> pauses until theread has been completed, or until the time set in the<a href="socketTimeoutInterval_LCS_property.html">socketTimeoutInterval</a> <a href="property_LCS_glossary.html">property</a> has passed. The data is placed in the<a href="it_LCS_keyword.html">it</a> variable after reading. If you specified a <a href="binary_file_LCS_glossary.html">binarydata</a> <b>chunkType</b> (int1, uInt1, int2, uint2, int4, or uint4), the dataconsists of a comma-separated list of numbers, one for the numericalvalue of each chunk that was read. Otherwise, the data is placed in the<a href="it_LCS_keyword.html">it</a> <a href="variable_LCS_glossary.html">variable</a> as it appears in the incoming data stream.</p></td></tr><tr><td>The result</td><td></td><td><p>The socket to read from must be opened first with the <a href="open_socket_LCS_command.html">open socket</a><a href="command_LCS_glossary.html">command</a>. If the <a href="socket_LCS_glossary.html">socket</a> is not open, the <a href="result_LCS_function.html">result</a> <a href="function_LCS_glossary.html">function</a> is setto &quot;Socket is not open.&quot;.</p></td></tr></table></td></tr><tr><td><b>Related</b></td><td><b>Keyword</b>: <a href="character_LCS_keyword.html">character</a>, <a href="it_LCS_keyword.html">it</a><br><b>Property</b>: <a href="socketTimeoutInterval_LCS_property.html">socketTimeoutInterval</a>, <a href="script_LCS_property.html">script</a><br><b>Message</b>: <a href="socketTimeout_LCS_message.html">socketTimeout</a><br><b>Command</b>: <a href="accept_LCS_command.html">accept</a>, <a href="post_LCS_command.html">post</a>, <a href="open_socket_LCS_command.html">open socket</a><br><b>Function</b>: <a href="result_LCS_function.html">result</a><br><b>Glossary</b>: <a href="object_LCS_glossary.html">object</a>, <a href="property_LCS_glossary.html">property</a>, <a href="binary_file_LCS_glossary.html">binary file</a>, <a href="variable_LCS_glossary.html">variable</a>, <a href="handler_LCS_glossary.html">handler</a>, <a href="message_LCS_glossary.html">message</a>, <a href="socket_LCS_glossary.html">socket</a>, <a href="parameter_LCS_glossary.html">parameter</a>, <a href="TCP_LCS_glossary.html">TCP</a>, <a href="command_LCS_glossary.html">command</a><br></td></tr><tr><td><b>Description</b></td><td><p>Use the <a href="read_from_socket_LCS_command.html">read from socket</a> <a href="command_LCS_glossary.html">command</a> to get data from another system viaa <a href="TCP_LCS_glossary.html">TCP</a> <a href="socket_LCS_glossary.html">socket</a>.</p><p>The until <a href="string_LCS_glossary.html">string</a> form reads data until the specified string isencountered. The for <b>amount</b> form reads data until the specified numberof <a href="chunk_LCS_glossary.html">chunks</a> have arrived.</p><p>If you specify a <b>callbackMessage</b>, the <a href="message_LCS_glossary.html">message</a> is sent to the<a href="object_LCS_glossary.html">object</a> whose <a href="script_LCS_glossary.html">script</a> contains the <a href="read_from_socket_LCS_command.html">read from socket</a><a href="command_LCS_glossary.html">command</a>, as soon as the read is finished. This <a href="message_LCS_glossary.html">message</a> has two<a href="parameter_LCS_glossary.html">parameters</a>: the <b>socketID</b> and the data received from the<a href="socket_LCS_glossary.html">socket</a>. </p></td></tr><tr><td><b>Tags</b></td><td>networking</td></tr></table></body></html>