<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Processing Text and Data</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: intermediate</h2><h1>Processing Text and Data</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>LiveCode has first-class text and data processing capabilities.LiveCode’s unique chunk expressions – the ability to refer to text usingEnglish-like statements like &quot;word 3 to 5 of myVariable&quot;, combined withother powerful features which include regular expressions, XMLprocessing, associative arrays, data encoding and decoding functions andcompression and encryption algorithms – make it easy and simple toprocess text and data of any complexity. This chapter is a referenceguide - go <a href="https://livecode.com/resources/">here</a> for more resources.</p><p>The section <em>Processing Text and Data</em> in the <em>Sample Scripts</em> withinthe product documentation contains additional code examples.</p><h2><a name="//apple_ref/cpp/Guide/Using Chunk Expressions" class="dashAnchor"></a>Using Chunk Expressions</h2><p>Chunk expressions are the primary method of working with text inLiveCode. A chunk is an English-like way of describing an exact portionof text. You can use chunks both to retrieve a portion of text, and toedit text. This topic defines the types of chunks you can address anddescribes the syntax for specifying them.</p><h3>Types of Chunks</h3><p>The common types of chunks are the <strong>character</strong>, <strong>word</strong>, <strong>line</strong>, or<strong>item</strong>. An item can be delimited by any character you specify. Inaddition, the <strong>token</strong> chunk is useful when parsing script data.</p><p>Here is an example of a chunk expression using the <strong>word</strong> chunk:</p><pre><code>put word 1 to 3 of field &quot;text&quot; into myVariable</code></pre><h3>Using Chunks with Containers</h3><p>You can use a chunk of a <em>container</em> anywhere you use an entirecontainer. For example, you can use the <strong>add</strong> command to add a numberto a line of a field:</p><pre><code>add 1 to word 3 of field &quot;Numbers&quot;</code></pre><p>You can also use chunk expressions to replace (using the <strong>put</strong>command) or remove (using the <strong>delete</strong>command) any portion of acontainer.</p><h3>Using Chunks with Properties</h3><p>You <em>can</em> use chunk expressions to <em>read</em> portions of a <em>property</em> (suchas the <strong>script</strong> property). However, since you change a property withthe <strong>set</strong> command rather than the <strong>put</strong> command, you <em>can&#39;t</em> use achunk expression to <em>change</em> a part of a property&#39;s value. Instead,<strong>put</strong> the property value into a variable, use the chunk expression tochange the variable, then <strong>set</strong> the property to the variable&#39;scontents. The following example shows how to change the third line of anobject&#39;s <strong>script</strong> property:</p><pre><code>put the script of me into tempScriptput &quot;-- Last changed by Jane&quot; into line 3 of tempScriptset the script of me to tempScript</code></pre><h3>The basic chunk types</h3><p>There are four chunk types that are probably the most useful for basictext processing: <strong>character</strong>, <strong>segment</strong>, <strong>item</strong> and <strong>line</strong>.</p><h4>The Character Chunk</h4><p>A <strong>character</strong> is a single character, which may be a letter, digit,punctuation mark, or control character.</p><p>You can use the abbreviation <strong>char</strong> as a synonym for <strong>character</strong> ina chunk expression.</p><blockquote><p><strong>Important:</strong> The character chunk corresponds to the notion ofgrapheme in the Unicode standard.</p></blockquote><h4>The Segment Chunk</h4><p>A <strong>segment</strong> is a string of characters delimited by <strong>space</strong>, <strong>tab</strong>,or <strong>return</strong> characters or enclosed by double quotes.</p><blockquote><p><em>Note:</em> <strong>Word</strong> is a synonym of segment.</p></blockquote><h4>The Item Chunk and the itemDelimiter Property</h4><p>By default, an <strong>item</strong> is a string of characters delimited by commas.</p><p>Items are delimited by a string specified in the <strong>itemDelimiter</strong>property. You can change the default <em>comma</em> to create your own chunktype by setting the <strong>itemDelimiter</strong> property to any string.</p><h4>The Line Chunk and the lineDelimiter Property</h4><p>By default, a <strong>line</strong> is a string of characters delimited by the<strong>return</strong> character.</p><p>Lines are delimited by string in the <strong>lineDelimiter</strong> property. Bydefault, the <strong>lineDelimiter</strong> is set to <strong>return</strong>, but you can createyour own chunk type by setting the <strong>lineDelimiter</strong> property to anystring.</p><h3>Other chunks</h3><p>There are also some chunks which are useful for more advanced textprocessing. These are:- paragraph- sentence- trueWord- codepoint- codeunit- byte</p><p>A <strong>token</strong> is a string of characters delimited by certain punctuationmarks. The <strong>token</strong> chunk is useful in parsing LiveCode statements, andis generally used only for analyzing scripts.</p><p>The <strong>sentence</strong> and <strong>trueWord</strong> chunk expressions facilitate theprocessing of text, taking into account the different character sets andconventions used by various languages. They use the ICU library, whichuses a large database of rules for its boundary analysis, to determinesentence and word breaks.</p><p>The <strong>paragraph</strong> chunk is currently identical to the existing <strong>line</strong>chunk, however in the future <strong>paragraph</strong> chunks will also be delimitedby the Unicode paragraph separator.</p><p>The <strong>codepoint</strong> chunk type allows access to the sequence of Unicodecodepoints which make up the string. The <strong>codeunit</strong> chunk type allowsdirect access to the UTF-16 code-units which notionally make up theinternal storage of strings. The <strong>codeunit</strong> and <strong>codepoint</strong> chunkare the same if a string only contains unicode codepoints from the BasicMultilingual Plane.</p><p>The <strong>byte</strong> chunk is an 8-bit unit and should be used when processingbinary data.</p><p>For more information on the above chunk types, please consult theLiveCode Dictionary.</p><h3>Specifying a Chunk</h3><p>The simplest chunk expression specifies a single chunk of any type. Thefollowing statements all include valid chunk expressions:</p><pre><code>get char 2 of &quot;ABC&quot; *-- yields &quot;B&quot;*get segment 4 of &quot;This is a test&quot; *-- yields &quot;test&quot;*get line 7 of myTestDataput &quot;A&quot; into char 2 of myVariable</code></pre><p>You can also use the ordinal numbers <strong>first</strong>, <strong>last</strong>, <strong>middle</strong>,<strong>second</strong>, <strong>third</strong>, <strong>fourth</strong>, <strong>fifth</strong>, <strong>sixth</strong>, <strong>seventh</strong>,<strong>eighth</strong>, <strong>ninth</strong>, and <strong>tenth</strong> to designate single chunks. Thespecial ordinal <strong>any</strong> specifies a <em>random</em> chunk.</p><pre><code>put &quot;7&quot; into last char of &quot;1085&quot; -- yields &quot;1087&quot;</code></pre><h3>Negative Indexes in Chunk Expressions</h3><p>To count <em>backwards</em> from the end of the value instead of forward fromthe beginning, specify a <em>negative</em> number. For example, the number -1specifies the last chunk of the specified type, -2 specifies thenext-to-last chunk, and so forth. The following statements all includevalid chunk expressions:</p><pre><code>get item -1 of &quot;feather, ball, cap&quot; -- yields &quot;cap&quot;get char -3 of &quot;ABCD&quot; -- yields &quot;B&quot;</code></pre><h3>Complex Chunk Expressions</h3><p>More complex chunk expressions can be constructed by specifying a chunkwithin another chunk. For example, the chunk expression <code>segment 4 ofline 250</code> specifies the fourth segment of line 250.</p><p>When combining chunks of different types to construct a complex chunkexpression, you must specify the chunk types in order. The followingstatements all include valid chunk expressions:</p><pre><code>char 7 of segment 3 of myValuesegment 9 of item 2 of myValuelast char of segment 8 of line 4 of myValue</code></pre><p>These, however, are not valid chunk expressions:</p><pre><code>segment 8 of char 2 of myValue --chars can&#39;t contain segmentsitem 9 of first segment of myValue --segments can&#39;t contain itemsline 3 of last item of myValue --items can&#39;t contain lines</code></pre><p>The full hierarchy is as follows:</p><pre><code>paragraph &gt; sentence &gt; line &gt; item &gt; segment &gt;    trueWord &gt; token &gt; character &gt; codepoint &gt; codeunit &gt; byte</code></pre><h3>Using Parentheses in Chunk Expressions</h3><p>You use parentheses in chunk expressions for the same reasons they&#39;reused in arithmetic:</p><p>To make a complex expression clearer.</p><p>To change the order in which the parts of the expression are evaluated.</p><p>For example, consider the following statement:</p><pre><code>put item 2 of segment 3 of &quot;a,b,c i,j,k x,y,z&quot; -- BAD</code></pre><p>The desired result is &quot;y&quot;, the second item in the third segment. But thestatement above causes an execution error, because it asks for an itemof a segment, and segments can&#39;t contain items. You can obtain thedesired result by using parentheses to change the order of evaluation:</p><pre><code>put item 2 of (segment 3 of &quot;a,b,c i,j,k x,y,z&quot;) -- good</code></pre><p>In the example above, LiveCode gets the third segment first, then getsthe second item in that segment. By adding parentheses around (segment 3of &quot;a,b,c i,j,k x,y,z&quot;), you force LiveCode to evaluate that part of thechunk expression first. The value of the expression in parentheses is&quot;x,y,z&quot;, and item 2 of &quot;x,y,z&quot; is &quot;y&quot;.</p><p>As with arithmetic expressions, the parts of a chunk expression that arein parentheses are evaluated first. If parentheses are nested, the chunkexpression within the innermost set of parentheses is evaluated first.The part that is enclosed in parentheses must be a valid chunkexpression, as well as being part of a larger chunk expression:</p><pre><code>put line 2 of segment 1 to 15 of myValue -- won&#39;t workput line 2 of segment (1 to 15 of myValue) -- won&#39;t workput line 2 of segment 1 to 15 (of myValue) -- won&#39;t workput line 2 of (segment 1 to 15 of myValue) -- works!</code></pre><p>The first of the above examples doesn&#39;t work for much the same reason asthe previous example: segments can&#39;t contain lines. The second and thirdexamples don&#39;t work because neither &quot;1 to 15 of myValue&quot; nor &quot;ofmyValue&quot; is a valid chunk expression. However, &quot;segment 1 to 15 ofmyValue&quot; is a valid chunk expression, so the last example works.</p><h3>Nonexistent Chunks</h3><p>If you request a chunk number that doesn&#39;t exist, the chunk expressionevaluates to empty. For example, the expression <code>char 7 of &quot;AB&quot;</code> yieldsempty.</p><p>If you attempt to change a chunk that doesn&#39;t exist, what happensdepends on what kind of chunk you specify:</p><h4>Nonexistent character or segment:</h4><p>Putting text into a character or segment that doesn&#39;t exist <em>appends</em>the text to the end of the container, without inserting any extraspaces.</p><h4>Nonexistent item:</h4><p>Putting text into an item that doesn&#39;t exist <em>adds</em> enough<strong>itemDelimiter</strong> characters to bring the specified item into existence.</p><h4>Nonexistent line:</h4><p>Putting text into a line that doesn&#39;t exist <em>adds</em> enough <strong>return</strong>characters to bring the specified line number into existence.</p><h3>Specifying a Range</h3><p>To specify a portion larger than a single chunk, you specify thebeginning and end of the range. These are all valid chunk expressions:</p><pre><code>get char 1 to 3 of &quot;ABCD&quot; -- yields &quot;ABC&quot;get segment 2 to -1 of myValue -- second segment to last segmentput it into line 7 to 21 of myValue -- replaces</code></pre><p>The start and end of the range must be specified as the same chunk type,and the beginning of the range must occur <em>earlier</em> in the value thanthe end. The following are not valid chunk expressions:</p><pre><code>char 3 to 1 of myValue -- won&#39;t work -- end cannot be greater than startchar -1 to -4 of myValue -- won&#39;t work-- 4th from last comes before last</code></pre><blockquote><p><strong>Important:</strong> When using negative numbers in a range, remember thatnumerically, -x comes after <code>-x+1</code>. For example, -1 is greater than-2, and -4 is greater than -7. The greater number must come <strong>last</strong>in order to create a valid range.</p></blockquote><h3>Counting the Number of segments, Lines or Items</h3><p>The <strong>number</strong> function returns the number of chunks of a given type ina value. For example, to find out how many lines are in a variable, usean expression such as:</p><pre><code>the number of lines in myVariable</code></pre><p>You can also nest chunk expressions to find the number of chunks in asingle chunk of a larger chunk type:</p><pre><code>the number of chars of item 10 of myVariable</code></pre><h2><a name="//apple_ref/cpp/Guide/Comparing and Searching" class="dashAnchor"></a>Comparing and Searching</h2><p>LiveCode provides a number of ways of comparing and searching text. Formost types of searching and comparing, you will find chunk expressionseasy and convenient. However, if you have complex searching needs, youmay prefer to use Regular Expressions, covered in the next section.</p><h3>Checking if a Part is within a Whole</h3><p>You use the <strong>is in</strong> operator to check if some text or data is withinanother piece of text or data. You can use the reverse <strong>is not in</strong>operator to check if text or data is not within another piece of text ordata.</p><pre><code>&quot;A&quot; is in &quot;ABC&quot; -- evaluates to true&quot;123&quot; is in &quot;13&quot; -- evaluates to false</code></pre><p>You can also use the <strong>is in</strong> operator to check whether some text ordata is within a specified chunk of another container.</p><pre><code>&quot;A&quot; is in item 1 of &quot;A,B,C&quot; -- evaluates to true&quot;123&quot; is in segment 2 of &quot;123 456 789&quot; -- evaluates to false</code></pre><h3>Case Sensitivity</h3><p>Comparisons in LiveCode are case insensitive by default (except forRegular Expressions, which have their own syntax for specifying whetheror not a match should be case sensitive). To make a comparison casesensitive, set the <strong>caseSensitive</strong> property to true. For more details,see the <em>caseSensitive</em> property in the <em>LiveCode Dictionary</em>.</p><h3>Checking if text is True, False, a Number, an Integer, a Point,</h3><h3>a Rectangle, a Date or a Color</h3><p>Use the <strong>is a</strong> operator for checking whether the user has entered datacorrectly and for validating parameters before sending them to ahandler. The <strong>is an</strong> operator is equivalent to the <strong>is a</strong> operator.</p><p>A value <strong>is a</strong>:- <strong>boolean</strong> if it is either true or false- <strong>integer</strong> if it consists of digits (with an optional leading minus sign)- <strong>number</strong> if it consists of digits, optional leading minus sign, optional decimal point, and optional &quot;E&quot; or &quot;e&quot; (scientific notation)- <strong>point</strong> if it consists of two numbers separated by a comma- <strong>rect</strong> if it consists of four numbers separated by commas- <strong>date</strong> if it is in one of the formats produced by the date or time functions- <strong>color</strong> if it is a valid color reference</p><p>The text you are checking can contain leading or trailing white spacecharacters in all the types except boolean. For example:</p><pre><code>&quot; true&quot; is true -- evaluates to false</code></pre><p>The <strong>is a</strong> operator is the logical inverse of the <strong>is not a</strong>operator. When one is true, the other is false.</p><pre><code>&quot;1/16/98&quot; is a date -- evaluates to true1 is a boolean -- evaluates to false45.4 is an integer -- evaluates to false&quot;red&quot; is a color -- evaluates to true</code></pre><blockquote><p><strong>Tip:</strong> To restrict a user to typing numbers in a field, use thefollowing script</p></blockquote><pre><code>on keyDown pKey    if pKey is a number then pass keyDownend keyDown</code></pre><p>The <strong>keyDown</strong> message will only be passed if the key the user pressedis a number. If you trap a <strong>keyDown</strong> message and don’t pass it, thekey will not be entered into the field. For more details, see the<strong>keyDown</strong> message in the <em>LiveCode Dictionary</em>.</p><h3>Check if a segment, Item or Line Matches Exactly</h3><p>The <strong>is among</strong> operator tells you whether a whole chunk exists exactlywithin in a larger container. For example, to find out whether the wholesegment &quot;free&quot; is contained within a larger string, use the <strong>is among</strong>operator:</p><pre><code>&quot;free&quot; is among the segments of &quot;Live free or die&quot; -- true&quot;free&quot; is among the segments of &quot;Unfree world&quot; -- false</code></pre><p>The second example evaluates to false because, although the string&quot;free&quot; is found in the value, it&#39;s a portion of a larger segment, not anentire segment.</p><h3>Check if one String Starts or Ends With Another</h3><p>To check if one string begins with or ends with another, use the<strong>begins with</strong> or <strong>ends with</strong> binary operators. For example:</p><pre><code>“foobar” begins with “foo” -- true“foobar” ends with “bar” -- trueline 5 of tList begins with &quot;the&quot;</code></pre><h3>Replacing Text</h3><p>To replace one string with another, use the <strong>replace</strong> command. (If youwant the search string to contain a regular expression, see the sectionon the <em>replaceText command</em> below instead.)</p><pre><code>replace &quot;A&quot; with &quot;N&quot; in thisVariable -- changes A to N</code></pre><p>To delete text using replace, replace a string with the empty constant.</p><pre><code>replace return with empty in field 1 -- runs lines together</code></pre><p>To preserve styling when replacing one string with another in a field, use the <code>preserving styles</code> clause.        replace &quot;foo&quot; with &quot;bar&quot; in field &quot;myStyledField&quot; preserving styles        -- replaces instances of &quot;foo&quot; with &quot;bar&quot; in the given field,        --   &quot;bar&quot; will retain the styling of instances of &quot;foo&quot;</p><p>For more details, see the <em>replace command</em> and the <em>replace in field command</em> in the <em>LiveCode Dictionary</em>.</p><h3>Retrieving the Position of a Matching Chunk</h3><p>The <strong>offset</strong>, <strong>itemOffset</strong>, <strong>tokenOffset</strong>, <strong>trueWordOffset</strong>,<strong>segmentOffset</strong>, <strong>lineOffset</strong>, <strong>sentenceOffset</strong> and<strong>paragraphOffset</strong> functions can be used to locate the position chunkswithin a larger container. For example, this expression returns thecharacter number where the letter &quot;C&quot; was found:</p><pre><code>get offset(&quot;C&quot;,&quot;ABC&quot;) -- returns 3</code></pre><p>To check if an item, line or word matches <em>exactly</em> using offset, setthe <strong>wholeMatches</strong> property to true.</p><h3>Chunks Summary</h3><p>A chunk expression describes the location of a piece of text in a longerstring.</p><p>Chunk expressions can describe <strong>characters</strong>, <strong>items</strong>, <strong>tokens</strong>, <strong>trueWords</strong>, <strong>segments</strong>, <strong>lines</strong>, <strong>sentences</strong> and <strong>paragraphs</strong>of text.</p><p>To count backward from the end of a string, use negative numbers. Forexample, </p><pre><code>segment -2  -- indicates the second-to-last segment</code></pre><p>You can combine chunk expressions to specify one chunk that is containedin another chunk, as in </p><pre><code>segment 2 of line 3 of myVariable</code></pre><p>For a range of chunks, specify the start and end points of the range, asin     line 2 to 5 of myVariable</p><p>To check if a chunk is within another, use the <strong>is in</strong> operator. Tocheck if a chunk <strong>is a</strong> specified type of data, use the <strong>is a</strong>operator. To check if a chunk starts or ends with another uses the<strong>begins with</strong> or ends with operators.</p><p>To check if a chunk is contained exactly within a string use the <strong>is among</strong> operator. To get an index specifying where a chunk can befound in a container, use the <strong>&lt;chunk&gt;Offset</strong> functions describedabove. To match only a complete chunk within a string, set thewholeMatches to true before using the offset functions.</p><h2><a name="//apple_ref/cpp/Guide/Regular Expressions" class="dashAnchor"></a>Regular Expressions</h2><p>Regular expressions allow you to check if a <em>pattern</em> is containedwithin a string. Use regular expressions when one of the search orcomparison chunk expressions does not do what you need (see the sectionon <em>Comparing and Searching</em> above).</p><p>LiveCode supports searching for a pattern, replacing a pattern, orfiltering the lines in a container depending on whether or not each linecontains the pattern. Regular expressions use PERL compatible or &quot;PCRE&quot;syntax. Figure 52, below, shows the supported syntax. For more detailson the supported syntax, see the <a href="http://www.pcre.org/man.txt">PCRE manual</a></p><h3>Searching using a Regular Expression</h3><p>Use the <strong>matchText</strong> function to check whether a string contains aspecified pattern.</p><pre><code>matchText(string,regularExpression[,foundTextVarsList])</code></pre><p>The <em>string</em> is any expression that evaluates to a string.</p><p>The <em>regularExpression</em> is any expression that evaluates to a regularexpression.</p><p>The optional <em>foundTextVarsList</em> consists of one or more names ofexisting variables, separated by commas.</p><pre><code>matchText(&quot;Goodbye&quot;,&quot;bye&quot;) -- returns truematchText(&quot;Goodbye&quot;,&quot;^Good&quot;) -- also returns truematchText(phoneNumber,&quot;([0-9]+)-([0-9]+-[0-9]+)&quot;,areaCode,phone)</code></pre><p>For more details on this function see the <em>matchText</em> function in the <em>LiveCode Dictionary</em>.</p><p>If you need to retrieve the positions of the matched substrings in theoptional <em>foundTextVarsList</em>, use the <em>matchChunk</em> function instead ofthe <em>matchText</em> function. These functions are otherwise identical.</p><h3>Replacing using a Regular Expression</h3><p>Use the <strong>replaceText</strong> function to search for a regular expression andreplace the portions that match. If you simply want to replace textwithout using a regular expression, see the <strong>replace</strong> command instead.</p><pre><code>replaceText(stringToChange,matchExpression,replacementString)</code></pre><p>The <em>stringToChange</em> is any expression that evaluates to a string.</p><p>The <em>matchExpression</em> is a regular expression.</p><p>The <em>replacementString</em> is any expression that evaluates to a string.</p><pre><code>replaceText(&quot;malformed&quot;,&quot;mal&quot;,&quot;well&quot;)--returns &quot;wellformed&quot;replaceText(field &quot;Stats&quot;,return,comma)-- makes comma-delimited</code></pre><p>For more details, see the <em>replaceText</em> function in the <em>LiveCode Dictionary</em>.</p><table><thead><tr><th>Regex</th><th>Rule</th><th>Example</th></tr></thead><tbody><tr><td><strong>[chars]</strong></td><td>matches any one of the characters inside the brackets</td><td>A[BCD]E matches &quot;ACE&quot;, but not &quot;AFE&quot; or &quot;AB&quot;</td></tr><tr><td><strong>[<sup>chars]</sup></strong></td><td>matches any single character that is not inside the brackets</td><td>[<sup>ABC]D</sup> matches &quot;FD&quot; or &quot;ZD&quot;, but not &quot;AD&quot; or &quot;CD&quot;</td></tr><tr><td><strong>[char-char]</strong></td><td>matches the range from the first char to the second char. The first char’s ASCII value must be less than the second char’s ASCII value</td><td>A[B-D] matches &quot;AB&quot; or &quot;AC&quot;, but not &quot;AG&quot;<br><br>[A-Z0-9] matches any alphanumeric character</td></tr><tr><td><strong>.</strong></td><td>matches any single character (except a linefeed)</td><td>A.C matches &quot;ABC&quot; or &quot;AGC&quot;, but not &quot;AC&quot; or &quot;ABDC&quot;</td></tr><tr><td><strong>^</strong></td><td>matches the following character at the beginning of the string</td><td><sup>A</sup> matches &quot;ABC&quot; but not &quot;CAB&quot;</td></tr><tr><td><strong>$</strong></td><td>matches the preceding character at the end of a string</td><td>B$ matches &quot;CAB&quot; but not &quot;BBC&quot;</td></tr><tr><td><strong><code>*</code></strong></td><td>matches zero or more occurrences of the preceding character or pattern</td><td>ZA*B matches &quot;ZB&quot; or &quot;ZAB&quot; or &quot;ZAAB&quot;, but not &quot;ZXA&quot; or &quot;AB&quot; <br><br> [A-D]*G matches &quot;AG&quot; or &quot;G&quot; or &quot;CAG&quot;, but not &quot;AB&quot;</td></tr><tr><td><strong>+</strong></td><td>matches one or more occurrences of the preceding character or pattern</td><td>ZA+B matches &quot;ZAB&quot; or &quot;ZAAB&quot;, but not &quot;ZB&quot; <br><br>[A-D]+G matches &quot;AG&quot; or &quot;CAG&quot;, but not &quot;G&quot; or &quot;AB&quot;</td></tr><tr><td><strong>?</strong></td><td>matches zero or one occurrences of the preceding character or pattern</td><td>ZA?B matches &quot;ZB&quot; or &quot;ZAB&quot;, but not &quot;ZAAB&quot;<br><br>[A-D]?G matches &quot;AG&quot; or &quot;CAGZ&quot;, but not &quot;G&quot; or &quot;AB&quot;</td></tr><tr><td>**\</td><td>**</td><td>matches either the pattern before or the pattern after the \</td></tr><tr><td><strong>\</strong></td><td>Causes the following character to be matched literally, even if it has special meaning in a regular expression</td><td>A\.C matches &quot;A.C&quot;, but not &quot;A\.C&quot; or &quot;ABC&quot;\\ matches &quot;\&quot;</td></tr><tr><td><strong>any other character</strong></td><td>matches itself</td><td>ABC matches &quot;ABC&quot;</td></tr></tbody></table><p>Figure 50 – Regular Expression Syntax</p><h3>Filtering using a Wildcard Expression</h3><p>Use the <strong>filter</strong> command to remove lines in a container that eitherdo, or do not match a specified wildcard expression. Wildcardexpressions are similar to regular expressions.</p><pre><code>filter container {with | without} wildcardExpression</code></pre><p>The <em>container</em> is any expression that evaluates to a container.</p><p>The <em>wildcardExpression</em> is a pattern used to match certain lines.</p><pre><code>filter myVariable with &quot;A?2&quot;filter me without &quot;\*[a-zA-Z]\*&quot;</code></pre><p>For more details, including the format of wildcard expressions, see the <em>filter command</em> in the <em>LiveCode Dictionary</em>.</p><h2><a name="//apple_ref/cpp/Guide/International Text Support" class="dashAnchor"></a>International Text Support</h2><p>All LiveCode&#39;s text processing capabilities extend seamlessly tointernational text. This includes the ability to render and edit Unicodetext and convert between various encoding types.</p><h3>What are Text Encodings?</h3><p>Fundamentally computers use numbers to store information, convertingthose numbers to text to be displayed on the screen. A text encodingdescribes which number converts to a given character. There are manydifferent encoding systems for different languages. Below is a tablecontaining examples of some common encodings.</p><table><thead><tr><th>Encoding</th><th>Representation</th><th>Description</th></tr></thead><tbody><tr><td><strong>ASCII</strong></td><td>Single byte – English</td><td>ASCII is a 7-bit encoding, using one byte per character. It includes the full Roman alphabet, Arabic numerals, Western punctuation and control characters. See <a href="http://en.wikipedia.org/wiki/ASCII">http://en.wikipedia.org/wiki/ASCII</a> for more information.</td></tr><tr><td><strong>ISO8859</strong></td><td>Single byte</td><td>ISO8859 is a collection of 10 encodings. They are all 8-bit, using one byte per character. Each shares the first 128 ASCII characters. The upper 80 characters change depending on the language to be displayed. For example ISO8859-1 is used in Western Europe, whereas ISO8859-5 is used for Cyrillic. <strong>NB:</strong> LiveCode only supports ISO8859-1. You should use Unicode to represent other languages, converting if necessary (see below).</td></tr><tr><td><strong>Windows-1252</strong></td><td>Single byte – English</td><td>This is a superset of ISO8859-1 which uses the remaining 48 characters not used in the ISO character set to display characters on Windows systems. For example curly quotes are contained within this range.</td></tr><tr><td><strong>MacRoman</strong></td><td>Single byte – English</td><td>MacRoman is a superset of ASCII. The first 128 characters are the same. The upper 128 characters are entirely rearranged and bear no relation to either Windows-1252 or ISO8859-1. However while many of the symbols are in different positions many are equivalent so it is possible to convert between the two.</td></tr><tr><td><strong>UTF-16</strong></td><td>Double byte – Any</td><td>UTF-16 typically uses two bytes per code point (character) to display text in all the world’s languages (see <em>Introduction to Unicode</em>, below). UTF-16 will take more memory per character than a single-byte encoding and so is less efficient for displaying English.</td></tr><tr><td><strong>UTF-8</strong></td><td>Multi-byte - Any</td><td>UTF-8 is a multi-byte encoding. It has the advantage that ASCII is preserved. When displaying other languages, UTF-8 combines together multiple bytes to define each code point (character). The efficiency of UTF-8 depends on the language you are trying to display. If you are displaying Western European it will take (on average) 1.3 bytes per character, for Russian 2 bytes (equivalent to UTF-16) but for CJK 3-4 bytes per character.</td></tr></tbody></table><p>Figure 51 – Common text encodings</p><h3>What are scripts?</h3><p>A script is a way of writing a language. It takes the encoding of alanguage and combines it with its alphabet to render it on screen as asequence of glyphs. The same language can sometimes be written with morethan one script (common among languages in India). Scripts can often beused to write more than one language (common among European languages).</p><p>Scripts can be grouped together into four approximate classes. The&quot;small&quot; script class contains a small alphabet with a small set ofglyphs to represent each single character. The &quot;large&quot; script classcontains a large alphabet and with a larger set of glyphs. The&quot;contextual&quot; script class contains characters that can change appearancedepending on their context. And finally the &quot;complex&quot; script classcontains characters that are a complex function of the context of thecharacter – there isn’t a 1 to 1 mapping between code point and glyph.</p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Roman</strong></td><td>Small script</td><td>The Roman encoding has relatively few distinct characters. Each character has a single way of being written. It is written from left to right, top to bottom. Every character has a unique glyph. Characters do not join when written. For example: The quick brown fox.</td></tr><tr><td><strong>Chinese</strong></td><td>Large script</td><td>The Chinese encoding has a large number of distinct characters. Each character has a single way of being written.</td></tr><tr><td><strong>Greek</strong></td><td>Contextual script</td><td>Every character except sigma has a unique glyph. Sigma changes depending on whether it is at the end of a word or not. Characters do not join when written. The text runs left to right, top to bottom. For example: ???? ????????</td></tr><tr><td><strong>Arabic</strong></td><td>Contextual script</td><td>The glyph chosen is dependent on its position in a word. All characters have initial, medial and terminal glyphs. This results in a calligraphic (joined up) style of display. The text runs right to left, top to bottom display. For example: ???????</td></tr><tr><td><strong>Devanagari</strong></td><td>Complex script</td><td>In this script there is no direct mapping from character to glyph. Sequences of glyphs combine depending on their context. The text runs from left to right, top to bottom.</td></tr></tbody></table><p>Figure 52 – Common scripts</p><h3>Introduction to Unicode</h3><p>Traditionally, computer systems have stored text as 8-bit bytes, witheach byte representing a single character (for example, the letter &#39;A&#39;might be stored as 65). This has the advantage of being very simple andspace efficient whilst providing enough (256) different values torepresent all the symbols that might be provided on a typewriter. Theflaw in this scheme becomes obvious fairly quickly: there are far morethan 256 different characters in use in all the writing systems of theworld, especially when East Asian ideographic languages are considered.But, in the pre-internet days, this was not a big problem.</p><p>LiveCode, as a product first created before the rise of the internet,also adopted the 8-bit character sets of the platforms it ran on (whichalso meant that each platform used a different character set: MacRomanon Apple devices, CP1252 on Windows and ISO-8859-1 on Linux andSolaris). LiveCode terms these character encodings &quot;native&quot; encodings.</p><p>In order to overcome the limitations of 8-bit character sets, theUnicode Consortium was formed. This group aims to assign a uniquenumerical value (&quot;codepoint&quot;) to each symbol used in every writtenlanguage in use (and in a number that are no longer used!).Unfortunately, this means that a single byte cannot represent anypossible character.</p><p>The solution to this is to use multiple bytes to encode Unicodecharacters and there are a number of schemes for doing so. Some of theseschemes can be quite complex, requiring a varying number of bytes foreach character, depending on its codepoint.</p><p>LiveCode previously added support for the UTF-16 encoding for textstored in fields but this could be cumbersome to manipulate as thevariable-length aspects of it were not handled transparently and itcould only be used in limited contexts. Unicode could not be used incontrol names, directly in scripts or in many other places where itmight be useful.</p><p>From LiveCode 7.0, the LiveCode engine has been able to handle Unicodetext transparently throughout. The standard text manipulation operationswork on Unicode text without any additional effort on your part; Unicodetext can now be used to name controls, stacks and other objects; menuscontaining Unicode selections no longer require tags to be usable -anywhere text is used, Unicode should work.</p><h3>Creating Unicode Apps</h3><p>Creating stacks that support Unicode is no more difficult than creatingany other stack but there are a few things that should be borne in mindwhen developing with Unicode. The most important of these is thedifference between text and binary data - in previous versions ofLiveCode, these could be used interchangeably; doing this with Unicodemay not work as you expect (but it will continue to work for non-Unicode text).</p><p>When text is treated as binary data (i.e when it is written to a file,process, socket or other object outside of the LiveCode engine) it willlose its Unicode-ness: it will automatically be converted into theplatform&#39;s 8-bit native character set and any Unicode characters thatcannot be correctly represented will be converted into question mark &#39;?&#39;characters.</p><p>Similarly, treating binary data as text will interpret it as native textand won&#39;t support Unicode. To avoid this loss of data, text should beexplicitly encoded into binary data and decoded from binary data atthese boundaries - this is done using the textEncode and textDecodefunctions (or its equivalents, such as opening a file using a specificencoding).</p><p>Unfortunately, the correct text encoding depends on the other programsthat will be processing your data and cannot be automatically detectedby the LiveCode engine. If in doubt, UTF-8 is often a good choice as itis widely supported by a number of text processing tools and issometimes considered to be the &quot;default&quot; Unicode encoding.</p><h3>Things to look out for</h3><ul><li>When dealing with binary data, you should use the byte chunk expression rather than char - char is intended for use with textual data and represents a single graphical character rather than an 8-bit unit.</li><li>Try to avoid hard-coding assumptions based on your native language - the formatting of numbers or the correct direction for text layout, for example. LiveCode provides utilities to assist you with this.</li><li>Regardless of visual direction, text in LiveCode is always in logical order - word 1 is always the first word; it does not depend on whether it appears at the left or the right.</li><li>Even English text can contain Unicode characters - curly quotation marks, long and short dashes, accents on loanwords, currency symbols...</li></ul><h2><a name="//apple_ref/cpp/Guide/Using Arrays" class="dashAnchor"></a>Using Arrays</h2><p>For an introduction to arrays, see the section on <em>Array Variables</em> inthe chapter <em>Coding in LiveCode</em>.</p><h3>When to Use Arrays</h3><p>Each element in an array can be accessed in constant time. This comparesfavorably with other functions that become look up information bycounting through a variable from the beginning (for example the offsetfunctions). If you consider a problem that requires the computer tosearch through the data several times then if the computer has to startat the beginning of the variable, the search will get slower and sloweras the search function gets further through the data.</p><p>Each element in an array can contain data of any length, making iteasier to group together records that contain assorted lengths ordelimiter characters.</p><p>Arrays can contain nested elements. This makes them ideal forrepresenting complex data structures such as trees and XML data thatwould be hard to represent as a flat structure.</p><p>Each sub-array in an array can be accessed and operated onindependently. This makes it possible to copy a sub-array to anotherarray, get the keys of a sub-array, or pass a sub-array as a parameterin a function call.</p><p>LiveCode includes various functions for converting information to andfrom arrays, and for performing operations on the contents of arrays.</p><p>These characteristics make arrays useful for a number of data processingtasks, including tasks that involve processing or comparing largeamounts of data. For example, arrays are ideal if you want to count thenumber of instances of a specific word in a piece of text. It would bepossible to implement such a word count by iterating through each wordand checking if it is present in a list of words, then adding a commafollowed by a count to that list of words. Such a method is cumbersometo implement and as the list of words gets longer the routine will slowdown because LiveCode has to search the list from the start with eachnew word. Conversely, implementation with an array is simple. Becauseeach element in an array can be named using a text string, we can createan element for each word and add to the element’s contents. Not only isthe code much shorter but it is also an order of magnitude faster.</p><pre><code>on mouseUp    --cycle through each word adding each instance to an array    repeat for each word tWord in field &quot;sample text&quot;        add 1 to tWordCount[tWord]    end repeat    -- combine the array into text    combine tWordCount using return and comma    answer tWordCountend mouseUp</code></pre><table><thead><tr><th>Text in field &quot;Sample Text:</th><th>Resulting value of tWordCount:</th></tr></thead><tbody><tr><td>Single Line – execute single line and short scripts</td><td>Global,4</td></tr><tr><td>Multiple Lines – execute multiple line scripts</td><td>Line,3</td></tr><tr><td>Global Properties – view and edit global properties</td><td>Lines,1</td></tr><tr><td>Global Variables – view and edit global variables</td><td>Multiple,2</td></tr><tr><td></td><td>Properties,2</td></tr><tr><td></td><td>Single,2</td></tr><tr><td></td><td>Variables,2</td></tr><tr><td></td><td>and,3</td></tr><tr><td></td><td>edit,2</td></tr><tr><td></td><td>execute,2</td></tr><tr><td></td><td>scripts,2</td></tr><tr><td></td><td>short,1</td></tr><tr><td></td><td>view,2</td></tr><tr><td></td><td>-,4</td></tr></tbody></table><p>Figure 53 – Results of running word count script</p><h3>Array Functions in LiveCode</h3><p>The following is a list of all the syntax in LiveCode that works witharrays. For a full description of each one, see the corresponding entryin the LiveCode Dictionary.</p><p>Each of these functions can be used on subarrays within an array.Instead of referring to the array variable, refer to x[x]</p><ul><li><strong>add</strong> adds a value to every element in an array where the element is a number</li><li><strong>combine</strong> converts an array into text, placing delimiters you specify between the elements-**customProperties** returns an array of the custom properties of an object</li><li><strong>delete variable</strong> remove an element from an array</li><li><p><strong>divide</strong> divides each element in an array where the element is a number. For example:</p><p>divide tArray by 3</p></li></ul><table><thead><tr><th>Contents of array:</th><th>Resulting value of tWordCount:</th></tr></thead><tbody><tr><td>A = 1</td><td>0.333333</td></tr><tr><td>B = 2</td><td>0.666667</td></tr><tr><td>C = 3</td><td>1</td></tr><tr><td>D = 4</td><td>1.333333</td></tr><tr><td>E = 5</td><td>1.666667</td></tr></tbody></table><p>Figure 54 – Results of running the divide command on an array </p><ul><li><strong>element</strong> keyword is used in a repeat loop to loop through every element in an array</li><li><strong>extents</strong> finds the minimum and maximum row and column numbers of an array whose keys are integers</li><li><strong>intersect</strong> compares arrays, removing elements from one array if they have no corresponding element in the other</li><li><strong>keys</strong> returns a list of all the elements within an array</li><li><strong>matrixMultiply</strong> performs a matrix multiplication on two arrays whose elements are numbers and whose keys are sequential numbers</li><li><strong>multiply</strong> multiplies a value in every element in an array where the element is a number</li><li><strong>properties</strong> returns an array of the properties of an object</li><li><strong>split</strong> convert text to an array using delimiters that you define</li><li><strong>sum</strong> - returns the sum total of all the elements in an array where the element is a number</li><li><strong>transpose</strong> swaps the order of the keys in each element in an array whose elements are numbers and whose keys are sequential numbers</li><li><strong>union</strong> combines two arrays, eliminating duplicate elements</li></ul><h2><a name="//apple_ref/cpp/Guide/Encoding and Decoding" class="dashAnchor"></a>Encoding and Decoding</h2><p>LiveCode includes a number of built-in functions for encoding and decoding data in a variety of popular formats.</p><h3>Styled Text</h3><p>LiveCode supports encoding and decoding styled text as HTML and RTF.This feature is useful when you want to adjust text stylesprogrammatically, or import or export text with style information.</p><blockquote><p><strong>Important:</strong> At present HTML conversion support only extends to thestyles that the LiveCode field object is capable of rendering.</p></blockquote><p>To convert the contents of a field to HTML compatible tags, use the<strong>HTMLText</strong> property. This property is documented in detail in theLiveCode Dictionary. You can also set this property to display styledtext in a field.</p><blockquote><p><strong>Tip:</strong> You can get and set the HTMLText property of a chunk within afield, allowing you to view or change text attributes on a section ofthe text. </p></blockquote><p>For example, to set the text style of line 2 of a field to bold:</p><pre><code>on mouseUp    put the htmltext of line 2 of field &quot;sample text&quot; into tText`    replace &quot;\&lt;p\&gt;&quot; with &quot;\&lt;p\&gt;\&lt;b\&gt;&quot; in tText    replace &quot;\&lt;/p\&gt;&quot; with &quot;\&lt;/b\&gt;\&lt;/p\&gt;\&gt;&quot; in tText    set the htmltext of line 2 of field &quot;sample text&quot; to tText`end mouseUp</code></pre><p>While this is not as simple as directly applying the style to the text using:</p><pre><code>set the textStyle of line 2 of field &quot;sample&quot; to &quot;bold&quot;</code></pre><p>It does allow you to search and replace text styles or perform multiplecomplex changes to the text based on pattern matching. Performing aseries of changes on the HTMLText in a variable then setting the text ofa field once can be quicker than updating the style repeatedly directlyon the field.</p><p>Use the <strong>HTML</strong> keyword with the <em>Drag and Drop</em> features and the<em>Clipboard</em> features to perform conversion of data to and from HTML whenexchanging data with other applications. For more information see thesection on <em>Drag and Drop</em> in the <em>Programming a User Interface</em> guide.</p><p>Use the <strong>RTFText</strong> property and <strong>RTF</strong> keyword to work with the RTFformat.</p><p>Use the <strong>unicodeText</strong> property and <strong>Unicode</strong> keyword to work withUnicode. For more information see the section on <em>International TextSupport</em>, above.</p><h3>URLs</h3><p>To encode and decode URLs, use the <strong>URLEncode</strong> and <strong>URLDecode</strong>functions. The <strong>URLEncode</strong> function will make text safe to use with aURL – for example it will replace <em>space</em> with <em>+</em>. These functions areparticularly useful if you are posting data to a web form using the<strong>POST</strong> command, using the <strong>launch URL</strong> command or sending emailusing the <strong>revMail</strong> function. For more information see the <em>LiveCodeDictionary</em>.</p><table><thead><tr><th><strong>Text:</strong></th><th><strong>URL Encoded result:</strong></th></tr></thead><tbody><tr><td>&quot;Jo Bloggs&quot; &lt;<a href="mailto:jo@blogs.com">jo@blogs.com</a>&gt;</td><td>%22Jo+Bloggs%22+%3Cjo%40blogs.com%3E</td></tr></tbody></table><p>Figure 55 – Results of encoding a URL</p><h3>Binary Data – Base64 (for MIME Email Attachments and Http Transfers)</h3><p>To encode and decode data in Base64 (e.g. to create an emailattachment), use the <strong>base64Encode</strong> and <strong>base64Decode</strong> functions.These functions are useful anywhere you want to convert binary data totext data and back. For more information see the <em>LiveCode Dictionary</em>.</p><h3>Binary Data – Arbitrary Types</h3><p>Use the <strong>binaryEncode</strong> and <strong>binaryDecode</strong> functions to encode ordecode binary data. These functions are documented in detail in the<em>LiveCode Dictionary</em>.</p><h3>Character to Number conversion</h3><p>To convert a character to and from its corresponding ASCII value use the<strong>charToNum</strong> and <strong>numToChar</strong> functions.</p><pre><code>put charToNum(&quot;a&quot;) -- results in 97</code></pre><p>To convert Unicode characters, set the <strong>useUnicode</strong> local property totrue. For more information see the section on <em>International Text Support</em>, above.</p><h3>Data Compression</h3><p>To compress and decompress data using GZIP, use the <strong>compress</strong> and<strong>decompress</strong> functions.</p><p>The following routine asks the user to select a file, then creates aGZip compressed version with a &quot;.gz&quot; extension in the same directory asthe original.</p><pre><code>on mouseUp    answer file &quot;Select a file:&quot;    if it is empty then exit mouseUp    put it &amp; &quot;.gz&quot; into tFileCompressed    put compress(URL (&quot;binfile:&quot; &amp; it)) into URL (&quot;binfile:&quot; &amp; tFileCompressed)end mouseUp</code></pre><h3>Encryption</h3><p>To encrypt or decrypt data use the <strong>encrypt</strong> and <strong>decrypt</strong> commands.These commands are documented in the LiveCode Dictionary.</p><h3>Generating a Checksum</h3><p>Use the <strong>MD5Digest</strong> to generate a digest of some data. Use thisfunction later to determine if the data was changed or to check thattransmission of information was complete.</p><blockquote><p><strong>Tip:</strong> In this example we save the MD5Digest of a field when theuser opens it for editing. In the field script place:</p></blockquote><pre><code>on openField    set the cDigest of me to md5Digest(the htmlText of me)end openField</code></pre><p>If the field is modified (including if a text style is changed anywhere)then a subsequent check of the MD5Digest will return a different result.In the following example we check this digest to determine whether ornot to bring up a dialog alerting the user to save changes:</p><pre><code>on closeStackRequest    local tDigest    put md5Digest(the htmlText of field &quot;sample text&quot;) into tDigest    if the cDigest of field &quot;sample text&quot; is not tDigest then        answer &quot;Save changes before closing?&quot; with &quot;No&quot; or &quot;Yes&quot;        if it is &quot;Yes&quot; then            save this stack        end if    end ifend closeStackRequest</code></pre><h2><a name="//apple_ref/cpp/Guide/XML" class="dashAnchor"></a>XML</h2><p>Extensible Markup Language, or XML, is a general-purpose language forexchanging structured data between different applications and across theInternet. It consists of text documents organized into a tree structure.It can generally be understood by both human and machine.</p><p>LiveCode includes comprehensive support for XML through its built-in XMLlibrary. Additionally, standards exist to support exchange of XML over anetwork connection (or &quot;web services&quot;) – most notably through theXML-RPC and SOAP protocols. LiveCode includes a library for usingXML-RPC and there are examples of using LiveCode to build SOAPapplications available.</p><h3>The XML Tree Structure</h3><p>XML is simply a data tree. It must start with a root node, be wellformed and nested. Tags may not overlap. For more information on XML see<a href="http://en.wikipedia.org/wiki/XML">http://en.wikipedia.org/wiki/XML</a></p><p>Figure 52 below shows a typical XML tree. In this example we haverepresented a simple stack file as XML. The stack file has a singlestack with two cards. On the first card there is a field named &quot;Hello&quot;with the contents &quot;Hello World!&quot;. There is a second card, which is blank.</p><p><img src="images/text-xml_representation_stack.png" alt="XML Tree Representation of a Stack"/></p><table><thead><tr><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td><strong>Root node</strong></td><td>Root element, document element</td><td>The start of the XML document, which includes a declaration the file is XML, the version of XML in use and the text encoding</td></tr><tr><td><strong>Comment</strong></td><td></td><td>Comments can be placed anywhere in the tree. They start with &lt;! and end with -&gt;. They must not contain double dashes --</td></tr><tr><td><strong>Node</strong></td><td>Element, tag</td><td>The items that makes up the content within an XML document</td></tr><tr><td><strong>Attributes</strong></td><td></td><td>Properties attributable to a given node. A node may have zero or more properties</td></tr><tr><td><strong>Empty node</strong></td><td>Empty element</td><td>A method of specifying that a node exists but is empty</td></tr><tr><td><strong>Entity reference</strong></td><td></td><td>A method of specifying special characters. XML includes support for &amp;, &lt;, &gt;, ‘ and &quot;. Additional entities can be defined using a Document Type Definition or DTD.</td></tr></tbody></table><h3>When to use XML</h3><p>XML has a number of advantages and disadvantages. It is predominantlyuseful when exchanging data between different applications or systems.However like any method of data storage or transfer it is not suitablefor all types of application.</p><p>The advantages of XML are: it is text based making it more easilyreadable by humans as well as just machines; it is self describing; itis based on international standards and in widespread use with a largenumber of editors available for it; the hierarchical structure makes itsuitable for representing many types of document; and it is platformindependent.</p><p>The disadvantages are that: it is sometimes less efficient than binaryor even other forms of text representations of data; for simpleapplications it is more complicated than may strictly be necessary; andthe hierarchical model may not be suitable for all data types.</p><p>You may decide that using XML is the best solution for your particulardata storage or transmission requirements. Or you may be working on aproject with others where using XML or a web service based on it is arequirement. However in many cases a binary format or database will bemore appropriate. You should give consideration to the method you intendto use as early as possible in the design of your application.</p><h3>Methods for Handling XML in LiveCode</h3><p>LiveCode includes a comprehensive XML library for working with XMLdocuments. Using the XML library has the advantage that we includesyntax and functions for performing the common operations on XML thatyou may need. However the disadvantage is that at present the library isimplemented as an external command (included built-in to the LiveCodedistribution) and thus does not benefit from native LiveCode-enginesyntax. If you have simple XML processing requirements you may prefer touse LiveCode’s built in chunk expression support to do the parsing,matching or construction of XML. For more information see the section on<em>Using Chunk Expressions</em>. However if you are working with complex XMLthen the library includes a comprehensive suite of features.</p><p>In addition to the XML library, LiveCode has a built-in script-basedlibrary for working with XML-RPC.</p><blockquote><p><strong>Tip:</strong> To see a list of commands for working with XML-RPC, filterthe LiveCode Dictionary with the term XMLRPC.</p></blockquote><p>A lesson demonstrating using the LiveCode XML library is available<a href="http://lessons.runrev.com/m/4071/l/7011-how-to-read-in-data-from-%0Aan-xml-file">here</a></p><h3>The XML Library: Loading, Displaying and Unloading XML</h3><p>This section discusses using the XML library in detail.</p><p><strong>Getting Started – Creating an XML Tree in Memory</strong></p><p>In order to work with an XML document, you start by creating an XML treeof that document in memory. There are two functions<strong>revCreateXMLTreeFromFile</strong> and <strong>revCreateXMLTree</strong>. Use the former toload XML document from a file and create a tree in memory, use thelatter to create an XML tree from another data source such as avariable, field or download.</p><pre><code>revCreateXMLTree(XMLText, dontParseBadData, createTree, sendMessages)revCreateXMLTreeFromFile(filePath, dontParseBadData, createTree, sendMessages)</code></pre><p>In <strong>revCreateXMLTree</strong> the <em>XMLText*is the string containing the XML.In **revCreateXMLTreeFromFile</em>* this parameter is replaced with the<em>filePath</em> – the file path to the XML document. Both functions return asingle value – the ID of the tree that has been created.</p><blockquote><p><strong>Important:</strong> Both functions require you to specify all theparameters. You must store the ID returned by these functions in orderto access the XML tree later in your script.</p></blockquote><p>The dont*ParseBadData* specifies whether or not to attempt to parsepoorly formed XML. If this is set to true then bad data will be rejectedand generate an error instead of constructing the tree in memory.</p><p>The <em>createTree</em> specifies whether to create a tree in memory or not.You will generally want this to be true, unless you are intending onlyto read in an XML file to determine whether or not it is properlystructured.</p><p>The <em>sendMessages</em> specifies whether or not messages should be sent whenparsing the XML document. Messages can be useful if you want toimplement functionality such as a progress bar, progressively render orprogressively process data from a large XML file as it is being parsed.If you set this to true, <strong>revXMLStartTree</strong> will be sent when theparsing starts, <strong>revStartXMLNode</strong> will be sent when a new node isencountered, <strong>revEndXMLNode</strong> will be sent when a node has beencompleted, <strong>revStartXMLData</strong> will be sent at the start of a new blockof data and finally <strong>revXMLEndTree</strong> will be sent when processing isfinished.</p><p><strong>Retrieving information from an XML tree</strong></p><p>Now that you have created your XML tree in memory (above) and stored thetree ID you can use the functions in this section to retrieveinformation from within the tree.</p><blockquote><p><strong>Important:</strong> Any text you fetch using the LiveCode XML library willbe in the encoding specified in the root node of the XML tree.</p><p><strong>Note:</strong> All the examples in this section assume that we have loadedthe XML tree depicted in the figure below – XML Tree Representation of aStack, above. We assume that you have loaded this tree using the<code>revCreateXMLTree</code>function described above, and that this function hasreturned a value of 1 as the ID of the tree.</p></blockquote><p><strong>Retrieving the Root Node</strong></p><p>To retrieve the <em>root node</em> from your XML tree, use the<strong>revXMLRootNode</strong> function.</p><pre><code>revXMLRootNode(treeID)</code></pre><p>The <em>treeID</em> contains the ID of the XML tree you want to access. Forexample, using the following function with sample tree depicted above:</p><pre><code>put revXMLRootNode(1) into tRootNode</code></pre><p>Results in <em>tVar</em> containing: <em>stackFile</em></p><p><strong>Retrieving the First Child Element in a Node</strong></p><p>To retrieve the first child element use <strong>revXMLFirstChild</strong>.</p><pre><code>revXMLFirstChild(treeID,parentNode)</code></pre><p>The <em>parentNode</em> contains the path to the node we want to retrieve thefirst child from. Nodes are referenced using a file-path like formatwith / used to denote the root and delimit nodes.</p><p>We can use this function on our sample XML as follows:</p><pre><code>-- pass the *stackFile* result in retrieved in tRootNode-- to the revXMLFirstChild function:put revXMLFirstChild(1,tRootNode) into tFirstChild-- EQUIVALENT to the following:put revXMLFirstChild(1,&quot;stackFile&quot;) into tFirstChild</code></pre><p>This results in <em>tFirstChild</em> containing: <em>/stackFile/stack</em></p><p><strong>Retrieving a list of Children in a Node</strong></p><p>To retrieve a list of children of a node use <strong>revXMLChildNames</strong>.</p><pre><code>revXMLChildNames(treeID, startNode, nameDelim, childName,includeChildCount)</code></pre><p>The <em>nameDelim</em> is the delimiter that separates each name that isreturned. To get a list of names, specify return.</p><p>The <em>childName</em> is the name of the type of children to list.</p><p><em>includeChildCount</em> allows you to include the number of each child insquare brackets next to the name.</p><p>We can use this function on our sample XML as follows:</p><pre><code>put revXMLChildNames(1,&quot;/stackFile/stack&quot;, return, &quot;card&quot;, true) into tNamesList</code></pre><p>This results in <em>tNamesList</em> containing:</p><p><em>card[1]</em></p><p><em>card[2]</em></p><p><strong>Retrieving the Contents of the Children in a Node</strong></p><p>To retrieve a list of children of a node including their contents, use<strong>revXMLChildContents</strong>.</p><pre><code>revXMLChildContents(treeID,startNode,tagDelim,nodeDelim, includeChildCount,depth)</code></pre><p>See above for an explanation of <em>treeID</em>, <em>startNode</em> and <em>tagDelim</em>.</p><p>The <em>nodeDelim</em> indicates the delimiter that separates the contents ofthe node from its name.</p><p>The <em>depth</em> specifies the number of generations of children to include.If you use –1 as the depth then all children are return.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLChildContents(1, &quot;/stackFile/stack&quot;, space, return, true, -1) into tContents</code></pre><p>This results in <em>tContents</em> containing:</p><p><em>card[1]</em></p><p><em>field[1]</em></p><p><em>text[1] Hello World!</em></p><p><em>htmlText[1] &lt;p&gt;Hello World&lt;/p&gt;</em></p><p><em>card[2]</em></p><p><strong>Retrieving the Number of Children in a Node</strong></p><p>To retrieve the number of children of a node <strong>revXMLNumberOfChildren</strong>.</p><pre><code>revXMLNumberOfChildren(treeID,startNode,childName,depth)</code></pre><p>See above for an explanation of <em>treeID</em>, <em>startNode, childName</em> and<em>depth</em>.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLNumberOfChildren(1, &quot;/stackFile/stack&quot;, &quot;card&quot;, -1)into tContents</code></pre><p>This results in <em>tContents</em> containing: <em>2</em></p><p><strong>Retrieving the Parent of a Node</strong></p><p>To retrieve a node’s parent use the <strong>revXMLParent</strong> function.</p><pre><code>revXMLParent(treeID,childNode)</code></pre><p>See above for an explanation of <em>treeID</em> and <em>startNode</em>.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLParent(1,&quot;stackFile/stack&quot;) into tParent</code></pre><p>Results in <em>tParent</em> containing: <em>/stackFile</em></p><p><strong>Retrieving an Attributes from a Node</strong></p><p>To retrieve an attribute from a node use <strong>revXMLAttribute</strong>.</p><pre><code>revXMLAttribute(treeID,node,attributeName)</code></pre><p>See above for an explanation of <em>treeID</em> and <em>node</em>.</p><p>The <em>attributeName</em> is the name of the attribute you want to retrievethe value for.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLAttribute(1,&quot;/stackFile/stack&quot;,&quot;rect&quot;) into tRect</code></pre><p>This results in <em>tRect</em> containing: <em>117,109,517,509</em></p><p><strong>Retrieving all Attributes from a Node</strong></p><p>To retrieve all attributes from a node use <strong>revXMLAttributes</strong>.</p><pre><code>revXMLAttributes(treeID,node,valueDelim,attributeDelim)</code></pre><p>See above for an explanation of <em>treeID</em> and <em>node</em>.</p><p>The <em>valueDelim</em> is delimiter that separates the attribute’s name fromits value.</p><p>The <em>attributeDelim</em> is delimiter that separates the attribute’s name &amp;value pair from each other.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLAttributes(1, &quot;/stackFile/stack/card/field&quot;, tab, return) into tFieldAttributes</code></pre><p>This results in <em>tFieldAttributes</em> containing:</p><p>name Hello</p><p>rect 100,100,200,125</p><p><strong>Retrieving the Contents of Attributes</strong></p><p>To retrieve the contents of a specified attribute from a node and itschildren, use <strong>revXMLAttributeValues</strong>.</p><pre><code>revXMLAttributeValues(treeID, startNode, childName, attributeName, delimiter, depth)</code></pre><p>See above for an explanation of <em>treeID</em>, <em>startNode</em> and <em>depth</em>.</p><p>The <em>childName</em> is the name of the type of child to be searched. Leavethis blank to include all types of children.</p><p>The <em>attributeName</em> is the name of the attribute to return the valuesfor.</p><p>The <em>delimiter</em> is the delimiter to be used to separate the valuesreturned.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLAttributeValues(1, &quot;/stackFile/&quot;, , &quot;rect&quot;, return, -1) into tRectsList</code></pre><p>This results in <em>tRectsList</em> containing:</p><p>117,109,517,509</p><p>100,100,200,125</p><p><strong>Retrieving the Contents of a Node</strong></p><p>To retrieve the contents of a specified node, use <strong>revXMLNodeContents</strong>.</p><pre><code>revXMLNodeContents(treeID, node)</code></pre><p>See above for an explanation of <em>treeID</em> and <em>node</em>.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLNodeContents(1, &quot;/stackFile/stack/card/field/htmlText&quot;) into tFieldContents</code></pre><p>This results in <em>tFieldContents</em> containing:</p><p>&lt;p&gt;Hello World&lt;/p&gt;</p><p>The entity references for the &lt; and &gt; symbols have been translatedinto text in this result.</p><p><strong>Retrieving Siblings</strong></p><p>To retrieve the contents of the siblings of a node, use<strong>revXMLNextSibling</strong> and <strong>revXMLPreviousSibling</strong>.</p><pre><code>revXMLNextSibling(treeID,siblingNode)revXMLPreviousSibling(treeID,siblingNode)</code></pre><p>The <em>siblingNode</em> is the path to the node to retrieve the siblings from.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLPreviousSibling(1, &quot;/stackFile/stack/card[2]&quot;) into tPrevput revXMLNextSibling(1, &quot;/stackFile/stack/card&quot;) into tNext</code></pre><p>This results in <em>tPrev</em> containing:</p><p>/stackFile/stack/card[1]</p><p>And <em>tNext</em> containing:</p><p>/stackFile/stack/card[2]</p><p><strong>Searching for a Node</strong></p><p>To search for a node based on an attribute, use <strong>revXMLMatchingNode</strong>.</p><pre><code>revXMLMatchingNode(treeID, startNode, childName, \\ attributeName, attributeValue, depth, [caseSensitive])</code></pre><p>See above for an explanation of <em>treeID</em>, <em>startNode</em> and <em>depth</em>.</p><p>The <em>childName</em> is the name of the children you want to include in thesearch. If you leave this blank all children are searched.</p><p>The <em>attributeName</em> is the name of the attribute you want to search.</p><p><em>attributeValue</em> is the search term you want to match.</p><p><em>caseSensitive optionally</em> specifies whether the search should be casesensitive. The default is false.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLMatchingNode(106,&quot;/&quot;, ,&quot;name&quot;, &quot;Hello&quot;, -1) into tMatch</code></pre><p>This results in <em>tMatch</em> containing:</p><p>/stackFile/stack/card[1]/field</p><p><strong>Retrieving an Outline of the Tree (or Portion Thereof)</strong></p><p>To retrieve the contents of a specified node, use <strong>revXMLTree</strong>.</p><pre><code>revXMLTree(treeID, startNode, nodeDelim, padding, includeChildCount, depth)</code></pre><p>See above for an explanation of <em>treeID</em>, <em>startNode, includeChildCount</em>and <em>depth</em>.</p><p>The <em>nodeDelim</em> is the delimiter that separates each node in the tree.Use return to retrieve a list of nodes.</p><p><em>padding</em> is the character to use to indent each level in the tree.</p><p>Using this function on our example XML file as follows:</p><pre><code>put revXMLTree(106,&quot;/&quot;,return,space,true,-1) into tTree</code></pre><p>This results in <em>tTree</em> containing:</p><p>stackFile[1]</p><p>stack[1]</p><p>card[1]</p><p>field[1]</p><p>text[1]</p><p>htmlText[1]</p><p>card[2]</p><p><strong>Retrieving the Tree as XML (or Portion Thereof)</strong></p><p>To retrieve the tree as XML use <strong>revXMLText</strong>. Use this function tosave the XML to a file after modifying it.</p><pre><code>revXMLText(treeID, startNode, [formatTree])</code></pre><p>See above for an explanation of <em>treeID</em> and <em>startNode</em>.</p><p>The <em>formatTree</em> specifies whether or not to format the returned treewith return and space characters to make it easier to read by a human.</p><p>Using this function on our example XML file as follows:</p><pre><code>ask file &quot;Save XML as:&quot;put revXMLText(106,&quot;/&quot;,true) into URL (&quot;file:&quot; &amp; it)</code></pre><p>This results in the file the <em>user specifies</em> containing:</p><pre><code>&lt;stackFile&gt;&lt;stack name=&quot;Example&quot; rect=&quot;117,109,517,509&quot;&gt;&lt;card&gt;&lt;field name=&quot;Hello&quot; rect=&quot;100,100,200,125&quot;&gt;&lt;text&gt;Hello World!&lt;/text&gt;&lt;htmlText&gt;&amp;lt;&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/htmlText&gt;&lt;/field&gt;&lt;/card&gt;&lt;/stack&gt;&lt;/stackFile&gt;</code></pre><p><strong>Validating against a DTD</strong></p><p>To check the syntax of an XML file conforms to a DTD use<strong>revXMLValidateDTD</strong>. For more information on this function, see the<em>LiveCode Dictionary</em>.</p><p><strong>Listing all XML Trees in Memory</strong></p><p>To generate a list of all XML trees in memory, use <strong>revXMLTrees</strong>. Formore information on this function, see the <em>LiveCode Dictionary</em>.</p><p><strong>Removing an XML Tree from Memory</strong></p><p>To remove an XML tree from memory, use <strong>revDeleteXMLTree</strong>. To removeall XML trees from memory, use <strong>revDeleteAllXMLTrees</strong>. Both functionstake a single parameter – the ID of the tree to be deleted. You shoulddelete a tree when you have stopped using it. For more information onthese functions, see the <em>LiveCode Dictionary</em>.</p><p>Once an XML tree has been removed from memory, there is no way to get itback. Use the revXMLText function to retrieve the contents of the entiretree and save it first.</p><h3>The XML Library: Editing XML</h3><p>This section discusses how to edit XML trees. Before reading thissection you should read the section above on loading, displaying andunloading XML.</p><p><strong>Adding a new Child Node</strong></p><p>To add a new node use the <strong>revAddXMLNode</strong> command.</p><pre><code>revAddXMLNode treeID, parentNode, nodeName, nodeContents, [location]</code></pre><p>See above for an explanation of <em>treeID</em>.</p><p>The <em>parentNode</em> is the name of the node you want to add the child to.</p><p>The <em>nodeName</em> is the name of the new node to create.</p><p><em>nodeContents</em> is the contents of the new node.</p><p><em>location</em> - optionally specify &quot;before&quot; to place the new child at thestart of the child nodes.</p><p>Use this function to add a button to our example XML file as follows:</p><pre><code>revAddXMLNode 1, &quot;/stackFile/stack/card/&quot;, &quot;button&quot;, &quot;&quot;</code></pre><p>This results in our tree containing a new button:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- This is a comment. --&gt;&lt;stackFile&gt;&lt;stack name=&quot;Example&quot; rect=&quot;117,109,517,509&quot;&gt;&lt;card&gt;&lt;field name=&quot;Hello&quot; rect=&quot;100,100,200,125&quot;&gt;&lt;text&gt;Hello World!&lt;/text&gt;&lt;htmlText&gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/htmlText&gt;&lt;/field&gt;&lt;button&gt;&lt;/button&gt;&lt;/card&gt;&lt;/stack&gt;&lt;/stackFile&gt;</code></pre><p>To create another node at the same level as another node, use the<strong>revInsertXMLNode</strong> command instead.</p><p><strong>Appending XML to a tree</strong></p><p>To add a new node use the <strong>revAppendXML</strong> command.</p><pre><code>revAppendXML treeID, parentNode, newXML</code></pre><p>See above for an explanation of <em>treeID</em> and <em>parentNode</em>.</p><p>The <em>newXML</em> is XML you want to append to the tree.</p><p><strong>Moving, Copying or Deleting a Node</strong></p><p>To move a node use the <strong>revMoveXMLNode</strong> command.</p><pre><code>revMoveXMLNode treeID, sourceNode, destinationNode [, location] [, relationship]</code></pre><p>See above for an explanation of <em>treeID</em>.</p><p>The <em>sourceNode</em> is the path to the node you want to move.</p><p>The <em>destinationNode</em> is the path to the node you to move to.</p><p>The <em>location</em> specifies where the node should be moved to in the listof siblings – it can be either &quot;before&quot; or &quot;after&quot;.</p><p>The <em>relationship</em> allows you to specify whether to place the nodealongside the destination as a sibling or below the destination as achild.</p><p>To copy a node use <strong>revCopyXMLNode</strong>.</p><p>To delete a node use <strong>revDeleteXMLNode</strong>.</p><p><strong>Putting data into a Node</strong></p><p>To put data into a node use the <strong>revPutIntoXMLNode</strong> command.</p><pre><code>revPutIntoXMLNode treeID,node,newContents</code></pre><p>See above for an explanation of <em>treeID</em> and <em>node</em>.</p><p>The <em>newContents</em> is the text that the new node will contain.</p><p><strong>Setting an Attribute</strong></p><p>To set an attribute use the <strong>revSetXMLAttribute</strong> command.</p><pre><code>revSetXMLAttribute treeID,node,attributeName,newValue</code></pre><p>See above for an explanation of <em>treeID</em> and <em>node</em>.</p><p>The <em>attributeName</em> is the name of the attribute you want to set theattribute on.</p><p>The <em>newValue</em> is the value to set for the attribute.</p><p>Using this function to add a &quot;showBorder&quot; property to our field:</p><pre><code>revSetXMLAttribute 1, &quot;/stackFile/stack/card/button&quot;, &quot;showBorder&quot;,&quot;true&quot;</code></pre><p>The field tag in our tree now looks like this:</p><pre><code>&lt;field name=&quot;Hello&quot; rect=&quot;100,100,200,125&quot; showBorder=&quot;true&quot;&gt;</code></pre><p><strong>Adding a DTD</strong></p><p>To add a DTD to the tree, use the <strong>revXMLAddDTD</strong> command.</p><pre><code>revXMLAddDTD treeID,DTDText</code></pre><p>See above for an explanation of <em>treeID</em>.</p><p>The <em>DTDText</em> is the text of the DTD to add.</p><h2><a name="//apple_ref/cpp/Guide/Sorting" class="dashAnchor"></a>Sorting</h2><p>Sorting data is a common and fundamental operation. Sorting allows youto display data in a user-friendly fashion or code a number ofalgorithms. LiveCode&#39;s intuitive sort features give you the power andflexibility to perform any kind of sorting you may require.</p><h3>The Sort Container Command: Overview</h3><p>To sort data, use the <strong>sort container</strong> command.</p><pre><code>sort [{lines | items} of] container [direction] [sortType] [by sortKey]</code></pre><p>The <em>container</em> is a field, button, or variable, or the message box.</p><p>The <em>direction</em> is either ascending or descending. If you don&#39;t specifya direction, the sort is ascending.</p><p>The <em>sortType</em> is one of text, numeric, or dateTime. If you don&#39;tspecify a sortType, the sort is by text.</p><p>The <em>sortKey</em> is an expression that evaluates to a value for each lineor item in the container. If the <em>sortKey</em> contains a chunk expression,the keyword <em>each</em> indicates that the chunk expression is evaluated for<em>each</em> line or item. If you don&#39;t specify a sortKey, the entire line (oritem) is used as the sortKey.</p><p>The following example sorts the <em>lines</em> of a variable alphabetically:</p><pre><code>sort lines of field &quot;sample text&quot; ascending textsort lines of tText descending text</code></pre><p>The following example sorts a collection of <em>items</em> numerically:</p><pre><code>sort items of field &quot;sample csv&quot; ascending numericsort items of tItems descending numeric</code></pre><h3>The Sort Container Command: Using Sort Keys</h3><p>The <em>sortKey</em> syntax allows you to sort each line or item based on theresults of an evaluation performed on each line or item.</p><p>To sort the lines of a container by a specific item in each line:</p><pre><code>sort lines of tContainer by the first item of eachsort lines of tContainer by item 3 of each</code></pre><p>The <em>sortKey</em> expression will only be evaluated once for every elementthat is to be sorted. This syntax allows a variety of more complex sortoperations to be performed.</p><p>The following example will extract the minimum and maximum integerspresent in a list:</p><pre><code>set the itemDelimiter to &quot;.&quot;sort lines of fld 1 numeric by char 2 to -1 of the first item of eachput char 2 to -1 of the first item \    of the first line of fld 1 into tMinimumIntegerput char 2 to -1 of the first item \    of the last line of fld 1 into tMaximumInteger</code></pre><table><thead><tr><th><strong>Original list:</strong></th><th><strong>Result:</strong></th></tr></thead><tbody><tr><td>F54.mov</td><td>tMinimumInteger is 3</td></tr><tr><td>M27.mov</td><td>tMaximumInteger is 54</td></tr><tr><td>M7.mov</td><td></td></tr><tr><td>F3.mov</td><td></td></tr></tbody></table><p>Figure 57 – Results of sort command using sort key</p><h3>The Sort Container Command: Sorting Randomly</h3><p>To sort randomly, use the <strong>random</strong> function to generate a randomnumber as the <em>sortKey</em> for each line or item, instead of evaluating theline or item&#39;s contents. For example:</p><pre><code>put the number of lines of tExampleList into tElementCountsort lines of tExampleList ascending numeric by random(tElementCount)</code></pre><h3>The Sort Container Command: Stable Sorts – Sorting on Multiple Keys</h3><p>To sort a list by multiple criteria you can sort multiple times. This isbecause LiveCode uses a stable sort, meaning that if two items have thesame sort key their relative order in the output will not change. Toperform a stable sort, start with the least significant or importantcriteria and work up to the most important or significant. For example:</p><pre><code>sort lines of fld 1 ascending numeric by item 2 of eachsort lines of fld 1 ascending text by the first item of each</code></pre><table><thead><tr><th><strong>Original list:</strong></th><th><strong>Result:</strong></th></tr></thead><tbody><tr><td>Oliver,1.54</td><td>Elanor,5.67</td></tr><tr><td>Elanor,5.67</td><td>Elanor,6.3</td></tr><tr><td>Marcus,8.99</td><td>Marcus,8.99</td></tr><tr><td>Elanor,6.34</td><td>Oliver,1.54</td></tr><tr><td>Oliver,8.99</td><td>Oliver,8.99</td></tr><tr><td>Tim,3.44</td><td>Tim,3.44</td></tr></tbody></table><p>Figure 58 – Results of sorting multiple items</p><blockquote><p><strong>Tip:</strong> If you have a large data set and want to improve performanceby only performing a single sort, you can construct a sort key thatgives the appropriate ordering. In this example a good way to do thatis to use the <strong>format</strong> function to construct a fixed length string,one element per sort:</p></blockquote><pre><code>sort lines of fld 1 ascending text by \\format(&quot;%-16s%08.2f&quot;, item 1 of each, item 2 of each)</code></pre><p>This formats each individual line similar to the following:</p><pre><code>Oliver 00001.54 Elanor 00005.67</code></pre><p>These lines now sort the required way as if the first field (the name)ties, the order is determined by the second field – due to the use ofpadding characters making all the fields the same size.</p><h3>Sorting Cards</h3><p>To sort cards, use the <strong>sort</strong> command.</p><pre><code>sort [marked] cards [of stack] [direction] [sortType] by sortKey</code></pre><p>The <em>stack</em> is a reference to any open stack. If you don&#39;t specify a<em>stack</em>, the cards of the current stack are sorted.</p><p>The <em>direction</em> is either ascending or descending. If you don&#39;t specifya <em>direction</em>, the sort is ascending.</p><p>The <em>sortType</em> is one of text, international, numeric, or dateTime. Ifyou don&#39;t specify a <em>sortType</em>, the sort is by text.</p><p>The <em>sortKey</em> is an expression that evaluates to a value for each cardin the stack. Any object references within the <em>sortKey</em> are treated aspertaining to each card being evaluated, so for example, a reference toa field is evaluated according to that field&#39;s contents on each card.Typically the sort command is used with <em>background</em> fields that havetheir <em>sharedText</em> property set to false so that they contain adifferent value on each card.</p><p>For example to sort cards by the contents of the last name field on each:</p><pre><code>sort cards by field &quot;Last Name&quot;</code></pre><p>To sort cards by the numeric value in a ZIP Code:</p><pre><code>sort cards numeric by field &quot;ZIP code&quot;</code></pre><blockquote><p><strong>Tip:</strong> To sort cards by a custom expression that performs acalculation, you can create a custom function:</p></blockquote><pre><code>sort cards by myFunction() -- uses function belowfunction myFunction    put the number of buttons of this card into tValue    -- perform any calculation on tValue here    return tValue    -- sort will use this valueend myFunction</code></pre></body></html>