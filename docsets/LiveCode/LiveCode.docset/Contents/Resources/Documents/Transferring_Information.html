<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Transferring Information with Files, the Internet and Sockets</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><hr/><h2>group: intermediate</h2><h1>Transferring Information with Files, the Internet and Sockets</h1><h2><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h2><p>Reading and writing data to files or transferring data over the Internetare important functions in most applications. LiveCode provides a richfeature set for performing these operations.</p><p>Accessing data from a file typically takes just a single line of code.LiveCode&#39;s file path syntax uses the same format on each platform so youtypically don&#39;t have to rewrite your file handling routines to deploycross platform. A set of functions provides for copying, deleting orrenaming files, as well as accessing appropriate system and userfolders.</p><p>LiveCode includes functions for downloading and uploading data to theInternet. Simple downloads and uploads can be performed with just asingle line of code. Support for the http, ftp and post protocols isincluded. Syntax is included that allows downloading in both theforeground and background. Additional library commands allow you toconstruct multipart form data, send ftp commands and more.</p><p>LiveCode includes built-in support for https, SSL &amp; encryption.</p><p>If the built-in protocol support doesn&#39;t do what you need, LiveCode alsoallows you to implement your own Internet protocols using itsstraightforward socket support. A very basic client server applicationcan be written in a few lines of code.</p><h2><a name="//apple_ref/cpp/Guide/File Name Specifications and File Paths" class="dashAnchor"></a>File Name Specifications and File Paths</h2><p>A file path is a way of describing the location of a file or folder sothat it can be found by a handler. File paths are used throughoutLiveCode: when you read to and write from text files, when you referencean external video file to display in a player, and in many othersituations. If your application refers to external files in any way, anunderstanding of file path is essential.</p><p>This topic discusses the syntax for creating and reading a filereference, and how to relate file paths to the location of yourapplication so that they&#39;ll be accessible when your application isinstalled on another system with a different folder structure.</p><h3>What is a File Path?</h3><p>A file path is a description of the exact location of a file or folder.The file path is created by starting at the top of the computer&#39;s filesystem, naming the disk or volume that the file is on, then naming everyfolder that encloses the file, in descending order, until the file isreached.</p><h4>Locating a file</h4><p>For example, suppose you want to describe the location of a file called&quot;My File&quot;, which is located inside a folder called &quot;My Folder&quot;. Thatfolder is in turn located inside a folder called &quot;Top Folder&quot;, which ison a drive called &quot;Hard Disk&quot;. You need all this information tocompletely describe where the file is: - Hard Disk - Top Folder - MyFolder - My File</p><p>If someone tells you which disk the file is on, then which folder toopen, and so on, you can find the file by opening each successive iconon your computer&#39;s desktop. By starting with the disk, then opening eachenclosing folder in succession until you arrive at the file, you canfind exactly the file that&#39;s being described.</p><h4>The structure of a file path</h4><p>A file path specifies each level of the hierarchy that encloses thefile. LiveCode presents the information in a file path that might looklike this:</p><pre><code>/Hard Disk/Top Folder/My Folder/My File</code></pre><p>You can see that to write a file path, you start by naming the disk thefile is on, then add each enclosing folder in order until you arrive atthe file.</p><p>To see the path to a file, enter the following in the message box:</p><pre><code>answer file &quot;Choose a file:&quot;; put it</code></pre><p>This displays the file path for the file you choose.</p><blockquote><p><strong>Important:</strong> Each platform has its own way for programmers tospecify file paths. The file path shown above is in the usual style for file paths on Linux systems. For cross-platform compatibility, LiveCode uses this same forward slash / character in its file path regardless of the current platform. This way, you can generally specify file and work with paths in your scripts without having to convert them when you switch platforms.</p></blockquote><h4>File paths on Windows systems</h4><p>On Windows systems, disks are named with a drive letter followed by acolon character (:). A typical LiveCode file path on a Windows systemlooks like this:</p><pre><code>C:/folder/file.txt</code></pre><h4>File paths on OS X systems</h4><p>On OS X systems, the startup disk, rather than the desktop, is used asthe top level of the folder structure. This means that the startupdisk&#39;s name does not appear in file paths. Instead, the first part ofthe file path is the top-level folder that the file is in.</p><p>If the disk &quot;Hard Disk&quot; is the startup disk, a typical path on OS Xsystems might look like this:</p><pre><code>/Top Folder/My Folder/My File</code></pre><p>Notice that the disk name isn&#39;t part of this path.</p><blockquote><p><strong>Note:</strong> If you need to find out the startup disk&#39;s name, check thefirst disk name returned by the <strong>volumes</strong> function.</p></blockquote><p>For files on a disk that isn&#39;t the startup disk, the file path startswith &quot;/Volumes&quot; instead of &quot;/&quot;. A typical file path to a file that&#39;s ona non-startup disk on an OS X system looks like this:</p><pre><code>/Volumes/Swap Disk/Folder/file.txt</code></pre><h4>Folder paths</h4><p>You construct the path of a folder the same way as the path to a file. Afolder path always ends with a slash character (/). This final slashindicates that the path is to a folder rather than a file.</p><p>For example, this pathname describes a folder called &quot;Project&quot; inside afolder called &quot;Forbin&quot; on a disk named &quot;Doomsday&quot;:</p><pre><code>/Doomsday/Forbin/Project/</code></pre><p>If &quot;Project&quot; is a file, its pathname looks like this, without the finalslash:</p><pre><code>/Doomsday/Forbin/Project</code></pre><h4>File paths for OS X bundles</h4><p>A bundle is a special type of folder, used on OS X, that is presented tothe user as a single file but that is maintained internally by theoperating system as a folder. Many OS X applications – includingLiveCode and the applications it creates – are stored and distributed asbundles that contain several files. When the user double-clicks thebundle the application starts up instead of a folder window opening toshow the bundle&#39;s contents.</p><p>You can take advantage of the bundle concept to include any neededsupport files with your application. If you place the files in theapplication&#39;s bundle, users ordinarily never see them, and the entireapplication--support files and all--behaves as a single icon.</p><blockquote><p><strong>Tip:</strong> To see the contents of a bundle, right-click (or controlclick) the bundle and choose &quot;Show Package Contents&quot; from the contextual menu.</p></blockquote><p>Most of the time, the distinction between bundles and files doesn&#39;tmatter. However we recommend that you treat them as files when workingfrom the perspective of a user but otherwise refer to them as folderswhen coding. This will help to keep your code readable. Thus if you areselecting a bundle in a file dialog use the answer file form. Whenmoving or renaming a bundle, refer to them as a folder.</p><h4>Moving, renaming, or deleting a bundle</h4><p>When using the <strong>rename</strong> command, to rename a bundle, use the renamefolder form of the command:</p><pre><code>rename folder &quot;/Volumes/Disk/Applications/MyApp/&quot; to \    &quot;/Volumes/Disk/Applications/OtherApp/&quot;</code></pre><p>Similarly, when dealing with a bundle, use the <strong>delete folder</strong> commandinstead of <strong>delete file</strong>, and the <strong>revCopyFolder</strong> command instead of<strong>revCopyFile</strong>.</p><h4>Referring to files inside a bundle</h4><p>When referring to a file that&#39;s inside a bundle, you can treat thebundle just as if it were a folder. For example, if you have placed afile called &quot;My Support.txt&quot; inside your application&#39;s bundle, theabsolute path to the file might look like this:</p><pre><code>/Volumes/Disk/Applications/MyApp/My Support.txt</code></pre><h4>The / character in a file or folder name</h4><p>The slash (/) is not a legal character in Unix or Windows file or foldernames, but it is legal for Mac OS X file or folder names to contain aslash. Since a slash in a file or folder name would cause ambiguity – isthe slash part of a name, or does it separate one level of the hierarchyfrom the next? – LiveCode substitutes a colon (:) for any slashes infolder or file names on Mac OS X systems.</p><p>For example, if a file on a Mac OS X system is named &quot;Notes from12/21/93&quot;, you refer to it in a script as &quot;Notes from 12:21:93&quot;. Sincethe colon is not a legal character in Mac OS X folder or file names,this removes the ambiguity.</p><h3>Absolute and Relative File Paths</h3><p>When describing how to get to a file, you have two options. You canstart from the top level, the name of the disk, and name each of theenclosing folders until you get to the file. This is called an absolutepath, because it&#39;s independent of where you start from. Or you can startfrom the current folder and describe how to get to the file from there.This is called a relative path, because it depends on where you start.</p><p>All the file paths shown so far in this topic are absolute paths.</p><h4>Absolute file paths</h4><p>Absolute file paths do not depend on which folder your stack file is inor on where the current folder is. An absolute path to a particularfolder or file is always written the same way.</p><p>For example, suppose your application is in a folder called &quot;ApplicationFolder&quot;, and you want to specify a file called &quot;Westwind&quot; which is in afolder called &quot;Stories&quot; inside &quot;Application Folder&quot;. - Hard Disk - TopFolder - My Folder - My File - Application Folder - My Application -Stories - Westwind</p><p>The absolute file path of your application looks like this:</p><pre><code>/Hard Disk/Application Folder/My Application</code></pre><p>and the absolute path of the &quot;Westwind&quot; file looks like this:</p><pre><code>/Hard Disk/Application Folder/Stories/Westwind</code></pre><blockquote><p><strong>Note:</strong> On Mac OS X, and Linux systems, absolute file paths alwaysstart with a slash character. On Windows systems, absolute file paths always start with a drive letter followed by a colon (:).</p></blockquote><h4>Relative file paths</h4><p>Now suppose you want to tell someone how to get to the &quot;Westwind&quot; file,starting from the folder containing the application.</p><p>Since the application is in &quot;Application Folder&quot;, we don&#39;t need toinclude the steps to get to &quot;Application Folder&quot;. Instead, we candescribe the location of the &quot;Westwind&quot; file with this relativepathname:</p><pre><code>Stories/Westwind</code></pre><p>This relative pathname starts at &quot;Application Folder&quot;--the folder thatholds the application--and describes how to get to the &quot;Westwind&quot; filefrom there: you open the folder &quot;Stories&quot;, then find &quot;Westwind&quot; insideit.</p><p>A relative file path starts at a particular folder, rather than at thetop of the file system like an absolute file path. The relative filepath builds a file path from the starting folder to the file or folderwhose location is being specified.</p><h4>Finding the current folder</h4><p>By default, the current folder is set to the folder containing theapplication (either the LiveCode development environment or yourapplication, depending on whether your application is a standalone). Soin the example above, the current folder is &quot;Application Folder&quot;,because that&#39;s where the running application is located.</p><blockquote><p><strong>Note:</strong> To change the current folder, set the <strong>defaultFolder</strong>property.</p></blockquote><h4>Going up to the parent folder</h4><p>The relative path &quot;..&quot; indicates the current folder&#39;s parent folder. Ifthe current folder is &quot;Stories&quot;, the relative path</p><pre><code>..</code></pre><p>means the same thing as the absolute path</p><pre><code>/Hard Disk/Application Folder/</code></pre><h4>Going up multiple levels</h4><p>To go up more than one level, use more than one &quot;../&quot;. To go up twolevels, use &quot;../../&quot;; to go up three levels, use &quot;../../../&quot;, and soforth.</p><p>For example, suppose the current folder is &quot;Stories&quot;, and its absolutepath looks like this:</p><pre><code>/Hard Disk/Application Folder/Stories/</code></pre><p>To get to &quot;My Application&quot; in &quot;Application Folder&quot;, you go up one levelto &quot;Application Folder&quot;, then down one level to &quot;My Application&quot;. Therelative path looks like this:</p><pre><code>../My Application</code></pre><p>To get to &quot;Top Folder&quot; on &quot;Hard Disk&quot;, you go up two levels--to&quot;Application Folder&quot;, then to &quot;Hard Disk&quot;--and then down one level to&quot;Top Folder&quot;. The relative path looks like this:</p><pre><code>../../Top Folder/</code></pre><h4>Starting at the home directory</h4><p>On OS X and Unix systems, the &quot;~&quot; character designates a user&#39;s homedirectory.</p><p>A path that starts with &quot;~/&quot; is a relative path starting with thecurrent user&#39;s home directory. A path that starts with &quot;~&quot;, followed bythe user ID of a user on that system, is a relative path starting withthat user&#39;s home directory.</p><h3>When to use relative and absolute file paths</h3><p>Absolute file paths and relative file paths are interchangeable. Whichone to use depends on a couple of factors.</p><p>Absolute file paths are easy to understand and they don&#39;t changedepending on the current folder. This can be an advantage if you arechanging the defaultFolder regularly.</p><p>However absolute file paths always include the full name of the harddisk and folders leading up to the current working folder. Therefore, ifyou plan to distribute your application you will want to work withrelative paths, so that media shipped in subfolders with yourapplication is still easy to locate.</p><blockquote><p><strong>Tip:</strong> By default, when linking to an image or resource using theInspector, LiveCode inserts an absolute file path. If you plan to distribute your application, locate your media in a subfolder next to the stack you are working on and convert these file paths to relative file paths by deleting the directories up to the one you are working in. This will mean you don&#39;t need to make any changes when it comes time to distribute your application.</p></blockquote><p>It&#39;s OK to use absolute paths to specify files or folders that the userselects after installation. For example, if you ask the user to select afile (using the <strong>answer file</strong> command) and read data from the file,there&#39;s no need to convert the absolute path that the <strong>answer file</strong>command provides to a relative path. Because you&#39;re using the path rightafter you get it from the <strong>answer</strong> command, you know that the diskname and folder structure aren&#39;t going to change between getting thepath and using it.</p><h2><a name="//apple_ref/cpp/Guide/Special Folders" class="dashAnchor"></a>Special Folders</h2><p>Modern operating systems each have a set of special-purpose foldersdesignated for a variety of purposes. If you are writing an applicationit is recommended that you make use of these folders where appropriateso that you provide the best possible user experience. For example, thecontents of the desktop reside in a special folder; there is a folderset aside for fonts; there is a folder for application preferences; andso on.</p><p>These special folders don&#39;t always have the same name and location, soyou can&#39;t rely on a stored file path to locate them. For example, ifyour application is installed onto an OS localized into a differentlanguage, the names of the file path will be different, on some Windowsspecial folders are named or placed differently depending on whatversion of Windows is running, etc.</p><p>To find out the name and location of a special folder, regardless of anyof these factors, you use the <strong>specialFolderPath</strong> function. Thefunction supports a number of forms for each operating system,describing the special folders for each one. Some of the forms are thesame cross-platform. The following example will get the location of theDesktop folder on Windows, Mac OS X or Linux:</p><pre><code>put specialFolderPath(&quot;Desktop&quot;) into myPath</code></pre><p>To get the path to the Start menu&#39;s folder on a Windows system:</p><pre><code>put specialFolderPath(&quot;Start&quot;) into myPath</code></pre><p>For a complete list of possible folders see the, <strong>specialFolderPath</strong>in the <em>LiveCode Dictionary</em>.</p><h2><a name="//apple_ref/cpp/Guide/File Types, Application Signatures &amp; File Ownership" class="dashAnchor"></a>File Types, Application Signatures &amp; File Ownership</h2><p>When you double-click a document file, it automatically opens in theapplication it&#39;s associated with. Each operating system has a differentmethod for associating files with an application. In order to createfiles that belong to your standalone application, you need to set up theassociation appropriately for each platform you distribute on.</p><p>This topic describes how to correctly associate your application withthe files it creates.</p><h3>Windows File Extensions and Ownership</h3><p>When a file is saved on a Windows system, a three-character extension isusually added to the file&#39;s name. The extension specifies the format ofthe file.</p><p>To determine which application to launch when the user double-clicks afile, Windows checks the Windows registry to find out what applicationhas registered itself as owning the file&#39;s extension. Each applicationcan add keys to the registry to identify certain file extensions asbelonging to it.</p><h4>Applications that don&#39;t own files</h4><p>If your application does not create files that you want the applicationto own, you don&#39;t need to make any modifications to the registry orspecify any extensions.</p><h4>Applications that own their own files</h4><p>If your application creates files with its own custom extension, whenyou install the application, you should make changes to the Windowsregistry to identify the extension as belonging to your application.</p><p>Popular Windows installer programs will make these registry changesautomatically for you. You can also perform these registry changes usingthe <strong>setRegistry</strong> function.</p><h4>Installing custom icons</h4><p>Each Windows file can display its own icon. You can have separate iconsfor your application and for files it owns. Icon files must be stored in.ico format.</p><h4>Custom application icons</h4><p>If you want to include a custom icon for your application, use the&quot;Application Icon&quot; option on the Windows screen of the StandaloneApplication Settings window to specify the icon file. When you build theapplication, the icon will be included in the application. For moreinformation, see the chapter on <em>Deploying Your Application</em>.</p><h4>Custom file icons</h4><p>To include a custom icon for your documents, use the &quot;Document Icon&quot;option on the Windows screen of the Standalone Application Settingswindow to specify the icon file. When you build the application, theicon will be included in the application.</p><blockquote><p><strong>Important:</strong> For the correct icon to appear on files yourapplication creates, the file&#39;s extension must be registered in the Windows registry.</p></blockquote><h4>File extensions</h4><p>You can add an extension to the name of any Windows file. The extensionmay contain letters A-Z, digits 0-9, &#39; (single quote), !, @, #, $, %,<sup>,</sup> &amp;, (, ), -, _, {, }, `, or ~.</p><p>The Windows registry associates applications with the extension for thefiles they own.</p><h3>OS X File Types and Creators</h3><p>On OS X each file has a file extension which determines whichapplication owns it. However OS X systems can also use the uniquefour-character creator signature and a four-character file type (seebelow for more information).</p><p>OS X applications store file association information in a property listfile, or plist. Each application&#39;s plist is stored as part of itsapplication bundle.</p><h4>Applications that don&#39;t own files</h4><p>To assign your unique creator signature when building an application,enter the signature on the OS X screen of the Standalone ApplicationSettings window. LiveCode automatically includes the creator signaturein the application&#39;s plist.</p><h4>Applications that own their own files</h4><p>If your application creates files with your application&#39;s creatorsignature, you should include in your application&#39;s plist an entry foreach file type you use. Once you have built your standalone application,follow these steps to open the plist file:</p><p><strong>1.</strong> Right click on your application bundle, navigate to the contentsfolder and open the &quot;Info.plist&quot; file. If you have installed Apple&#39;sdeveloper tools, you have an application called &quot;Property List Editor&quot;,which you can use to make changes to the plist file. Otherwise, you canedit the file in a text editor.</p><p><strong>2.</strong> Locate the information for the document type. In Property ListEditor, expand the &quot;Root&quot; node, then expand the &quot;CFBundleDocumentTypes&quot;node, then expand the &quot;0&quot; node. In a text editor, locate&quot;CFBundleDocumentTypes&quot;. Below it, note the tags <code>&lt;array&gt;</code> and <code>&lt;dict&gt;</code>.The information for the first document type is between <code>&lt;dict&gt;</code> and<code>&lt;/dict&gt;</code>.</p><p><strong>3</strong>. Enter the file description, which is a short phrase describingwhat kind of file this is. In Property List Editor, change the value of&quot;CFBundleTypeName&quot; to the description you want to use. In a text editor,locate &quot;CFBundleTypeName&quot; in the document information. Below it is thefile description, enclosed between <code>&lt;string&gt;</code> and <code>&lt;/string&gt;</code>:</p><pre><code>&lt;string&gt;LiveCode Stack&lt;/string&gt;</code></pre><p>Change the description to the one you want to use.</p><p>Do not change the tags (enclosed in &quot;&lt;&quot; and &quot;&gt;&quot;). Only change what&#39;sbetween them.</p><p><strong>4.</strong> Enter the <code>file</code> extension. In Property List Editor, expand&quot;CFBundleTypeExtensions&quot; and enter the <code>file</code> extension in the &quot;0&quot; node.In a text editor, locate &quot;CFBundleTypeExtensions&quot; in the documentinformation. Below it is the extension, enclosed in <code>&lt;array&gt;</code> and<code>&lt;string&gt;</code> tags. Change the extension to the one you want to use.</p><p><strong>5.</strong> Enter the four-character file type. In Property List Editor,expand &quot;CFBundleTypeOSTypes&quot; and enter the file type in the &quot;0&quot; node. Ina text editor, locate &quot;CFBundleTypeOSTypes&quot; in the document information.Below it is the file type, enclosed in <code>&lt;array&gt;</code> and <code>&lt;string&gt;</code> tags.Change the file type to the one you want to use.</p><p>If the format for this type of file is standard (such as plain text),use a standard type (such as &quot;TEXT&quot;). If the format belongs to yourapplication, use a custom file type of your choice.</p><blockquote><p><strong>Important:</strong> Apple reserves all file types with no uppercaseletters. If you use a custom file type for your application, make sure it contains at least one uppercase letter.</p></blockquote><p>If you want to assign more file types to your application, copy theportion of the plist file inside the &quot;CFBundleTypes&quot; array between<code>&lt;dict&gt;</code> and <code>&lt;dict&gt;</code>, including these tags. The &quot;CFBundleTypes&quot; nodeshould now contain two <code>&lt;dict&gt;</code> nodes and all their contents. Repeat thesteps above for each different file type your application can create.</p><h4>Creating Files</h4><p>When your application creates files, set the <strong>fileType</strong> property tothe desired creator signature and file type for the new file. (For stackfiles created with the <strong>save</strong> command, use the <strong>stackFileType</strong>property instead.) When creating files, the application uses the currentvalue of the <strong>fileType</strong> or <strong>stackFileType</strong> property to determinewhat creator and file type the new file should have.</p><p>It&#39;s important to understand that a file&#39;s creator signature determineswhich application is launched automatically when you double-click thefile, but doesn&#39;t prevent other applications from being able to openthat file. For example, if your application creates files of type&quot;TEXT&quot;, any text editor can open the files. If your application createsstack files, and uses the file type &quot;RSTK&quot;, then LiveCode will be ableto open the stack files, as well as your application.</p><h4>File extensions</h4><p>You can add an extension to the name of any OS X file. When the userdouble-clicks a file with no creator signature, the operating systemuses the extension to determine which application to use to open thefile.</p><p>An application bundle&#39;s name should end with the extension &quot;.app&quot;.</p><blockquote><p><strong>Note:</strong> Apple&#39;s recommendations for determining file type andcreator on OS X systems are currently in flux. The recommended method for the present is to set a file type and creator signature, and also attach an extension to the end of each file&#39;s name when it is created. Valid extensions on OS X systems are up to twelve characters in length, and may include the letters a-z, the digits 0-9, $, %, _, or ~. For up-to-date information on Apple&#39;s recommendations for OS X, see Apple&#39;s <a href="http://www.apple.com/developer/">developer documentation</a>.</p></blockquote><h3>Mac OS X Classic File Types and Creators</h3><p>When a file is saved on a Mac OS X system, a four-character creatorsignature is saved with it. The creator signature specifies whichapplication owns the file. Every Mac OS X application should have aunique creator signature. (Apple maintains a registry of creatorsignatures on its <a href="http://developer.apple.com/dev/cftype/">web site</a>).</p><h4>Applications that don&#39;t own files</h4><p>To assign your unique creator signature when building an application,enter the signature on the Mac OS X screen of the Standalone ApplicationSettings window. LiveCode automatically includes the resources neededfor Mac OS X to recognize the creator signature.</p><h4>Applications that own their own files</h4><p>If your application creates files with your application&#39;s creatorsignature, you should include in your application a set of resources foreach file type you use. Once you have saved your standalone application,open the application file in ResEdit and follow these steps:</p><p><strong>1.</strong> Open the BNDL resource window, then open the BNDL 128 resource.The BNDL 128 resource contains a single entry (&quot;APPL&quot;).</p><p><strong>2.</strong> Choose &quot;Create New File Type&quot; from the Resources menu. A newentry appears below the &quot;APPL&quot; entry.</p><p><strong>3.</strong> In the Type field, enter the four-character file type. If theformat for this type of file is standard (such as plain text), use astandard type (such as &quot;TEXT&quot;). If the format belongs to yourapplication, use a custom file type of your choice.</p><p>Repeat steps 2-3 for each different file type your application cancreate.</p><p>When your application creates files, set the <strong>fileType</strong> property tothe desired creator signature and file type for the new file. For stackfiles created with the save command, use the <strong>stackFileType</strong> propertyinstead. When creating files, the application uses the current value ofthe <strong>fileType</strong> or <strong>stackFileType</strong> property to determine what creatorand file type the new file should have.</p><h4>Installing custom icons</h4><p>Each Mac OS <code>file</code>may display any of six different icons, depending oncontext and on the number of colors the screen can display: large (32x32pixel) icons and small (16x16 pixel) icons, each in black-and-white, 16colors, and 256 colors.</p><p>Mac OS provides default icons that are used for applications anddocuments that don&#39;t have their own. If you want your application or thedocuments it owns to display a custom icon, you must create the iconsand then attach them to the application.</p><h4>Custom application icons</h4><p>If you want to include a custom icon for your application, use ResEditor a similar tool to create a set of icon resources. There are sixstandard icon resource types: ICN# (black-and-white), icl4 (four-bitcolor), icl8 (8-bit color), ics# (black-and-white small), ics4 (4-bitsmall), and ics8 (8-bit small). Each of these application icons shouldhave the resource ID 128.</p><p>Save the icons in a single file, and use the &quot;Include resources fromfile&quot; option on the Mac OS X screen of the Standalone ApplicationSettings window to specify the file. When you build the application, theicons will be included in the application&#39;s file.</p><h3>Linux File Extensions</h3><p>Linux systems do not have an overall required method for specifying afile&#39;s type, but most files on a Linux system are created withextensions in the file name, similar to the extensions used on Windowssystems. These extensions may be of any length and may include anycharacters (other than /).</p><h2><a name="//apple_ref/cpp/Guide/Working with URLs" class="dashAnchor"></a>Working with URLs</h2><p>A URL is a container for a file (or other resource), which may either beon the same system the application is running on, or on another systemthat&#39;s accessible via the Internet.</p><p>This topic discusses the various URL schemes that LiveCode implements,how to create and manipulate files using URLs, and how to transfer databetween your system and an FTP or HTTP server.</p><p>To fully understand this topic, you should know how to create objectsand write short scripts, and understand how to use variables to holddata. You should also have a basic understanding of how the Internetworks.</p><h3>An Overview of URLs</h3><p>In the LiveCode language, a URL is a container for a <code>file</code> or otherdocument, such as the output of a CGI on a web server. The data in a URLmay be on the same system the application is running on, or may be onanother system.</p><p>URLs in LiveCode are written like the URLs you see in a browser. You usethe <strong>URL</strong> keyword to designate a URL, enclosing the URL&#39;s name indouble quotes:</p><pre><code>put field &quot;Info&quot; into URL &quot;file:myfile.txt&quot; get URL &quot;http://www.example.org/stuff/nonsense.html&quot; put URL &quot;ftp://ftp.example.net/myfile&quot; into field &quot;Data&quot;</code></pre><h3>URL Schemes</h3><p>A URL scheme is a type of URL. LiveCode supports five URL schemes withthe <strong>URL</strong> keyword: <strong>http</strong>, <strong>ftp</strong>, <strong>file</strong>, <strong>binfile</strong>, and (forbackwards compatibility on Mac OS X) <strong>resfile</strong>.</p><p>The <strong>http</strong> and <strong>ftp</strong> schemes designate documents or directories thatare located on another system that&#39;s accessible via the Internet. The<strong>file</strong>, <strong>binfile</strong>, and <strong>resfile</strong> schemes designate local files.</p><h3>The http scheme</h3><p>An <strong>http</strong> URL designates a document from a web server:</p><pre><code>put URL &quot;http://www.example.org/home.htm&quot; into field &quot;Page&quot;</code></pre><p>When you use an <code>http</code> URL in an expression, LiveCode downloads the URLfrom the server and substitutes the downloaded data for the URL.</p><p>When you put something into an <code>http</code> URL, LiveCode uploads the data tothe web server:</p><pre><code>put field &quot;Info&quot; into URL &quot;http://www.example.net/info.htm&quot;</code></pre><blockquote><p><strong>Note:</strong> Because most web servers do not allow <code>http</code> uploads,putting something into an <code>http</code> URL usually will not be successful. Check with the server&#39;s administrator to find out whether you can use the <code>http</code> protocol to upload files.</p></blockquote><p>For more details about <code>http</code> URLs, see the entry for the <code>http</code> keywordin the LiveCode Dictionary.</p><h3>The ftp scheme</h3><p>An <strong>ftp</strong> URL designates a file or directory on an FTP server:</p><pre><code>get URL &quot;ftp://user:passwd@ftp.example.net/picture.jpg&quot;</code></pre><p>When you use an <code>ftp</code> URL in an expression, LiveCode downloads the URLfrom the server and substitutes the downloaded data for the URL. Whenyou put something into an ftp URL, LiveCode uploads the data to the ftpserver:</p><pre><code>put image 10 into URL \    &quot;ftp://user:passwd@ftp.example.net/picture.jpg&quot;</code></pre><p>FTP servers require a user name and password, which you can specify inthe URL. If you don&#39;t specify a user name and password, LiveCode addsthe &quot;anonymous&quot; user name and a dummy password automatically, inaccordance with the convention for public FTP servers.</p><blockquote><p><strong>Note:</strong> Uploading to an FTP server usually requires a registereduser name and password.</p></blockquote><p>For more details about <code>ftp</code> URLs, see the entry for the <code>ftp</code> keywordin the LiveCode Dictionary.</p><h4>Directories on an FTP server</h4><p>A URL that ends with a slash (/) designates a directory (rather than afile). An <code>ftp</code> URL to a directory evaluates to a listing of thedirectory&#39;s contents.</p><h3>The file scheme</h3><p>A <strong>file</strong> URL designates a file on your system:</p><pre><code>put field &quot;Stuff&quot; into URL &quot;file:/Disk/Folder/testfile&quot;</code></pre><p>When you use a <code>file</code> URL in an expression, LiveCode gets the contentsof the <code>file</code> you designate and substitutes it for the URL. Thefollowing example puts the contents of a <code>file</code> into a variable:</p><pre><code>put URL &quot;file:myfile.txt&quot; into myVariable</code></pre><p>When you put data into a <code>file</code> URL, LiveCode puts the data into thefile:</p><pre><code>put myVariable into URL &quot;file:/Volumes/Backup/data&quot;</code></pre><blockquote><p><strong>Note:</strong> As with local variables, if the file doesn&#39;t exist, puttingdata into it creates the file.</p></blockquote><p>To create a URL from a file path that LiveCode provides, use the <strong>&amp;</strong>operator:</p><pre><code>answer file &quot;Please choose a file to get:&quot; get URL (&quot;file:&quot; &amp; it)</code></pre><h4>File path syntax and the file scheme:</h4><p>The <code>file</code> URL scheme uses the same <code>file</code> path syntax used elsewhere inLiveCode statements. You can use both absolute paths and relative pathsin a <code>file</code> URL.</p><h4>Conversion of end-of-line markers</h4><p>Different operating systems use different characters to mark the end ofa line. Mac OS X uses a return character (ASCII 13), Linux systems use alinefeed character (ASCII 10), and Windows systems use a return followedby a linefeed. To avoid problems when transporting a stack betweenplatforms, LiveCode always uses linefeeds internally when you use a<code>file</code> URL as a container. LiveCode translates as needed between theyour system&#39;s end-of-line marker and LiveCode&#39;s linefeed character. Toavoid this translation, use the <code>binfile</code> scheme (see below).</p><h3>The binfile scheme</h3><p>A <strong>binfile</strong> URL designates a file on your system that contains binarydata:</p><pre><code>put URL &quot;binfile:beachball.gif&quot; into image &quot;Beachball&quot;</code></pre><p>When you use a <strong>binfile</strong> URL in an expression, LiveCode gets thecontents of the file you designate and substitutes it for the URL. Thefollowing example puts the contents of a file into a variable:</p><pre><code>put URL &quot;binfile:picture.png&quot; into pictVar</code></pre><p>When you put data into a <strong>binfile</strong> URL, LiveCode puts the data intothe file:</p><pre><code>put pictVar into URL &quot;binfile:/Volumes/Backup/pict.png&quot; put image 1 into &quot;binfile:/image.png&quot;</code></pre><p>As with local variables, if the file doesn&#39;t exist, putting data into itcreates the file.</p><p>The <strong>binfile</strong> scheme works like the file scheme, except that LiveCodedoes not attempt to convert end-of-line markers. This is because returnand linefeed characters can be present in a binary file but not beintended to mark the end of the line. Changing these characters cancorrupt a binary file, so the <strong>binfile</strong> scheme leaves them alone.</p><h3>The resfile scheme</h3><p>On Mac OS Classic (and sometimes on OS X systems), files can consist ofeither a data fork or a resource fork or both.</p><blockquote><p><strong>Important:</strong> While LiveCode supports reading and writing resourcefork files on Mac OS X, this feature is only intended to help you access and work with legacy files. We do not generally recommend the use of resource forks when designing any new application.</p></blockquote><p>The resource fork contains defined resources such as icons, menudefinitions, dialog boxes, fonts, and so forth. A <strong>resfile</strong> URLdesignates the resource fork of a Mac OS X file:</p><pre><code>put myBinaryData into URL &quot;resfile:/Disk/Resources&quot;</code></pre><p>When you use a <strong>resfile</strong> URL in an expression, LiveCode gets theresource fork of the file you designate and substitutes it for the URL.</p><p>When you put data into a <strong>resfile</strong> URL, LiveCode puts the data intothe file&#39;s resource fork.</p><blockquote><p><strong>Note:</strong> A <strong>resfile</strong> URL specifies the entire resource fork, notjust one resource. To work with individual resources, use the <strong>getResource</strong>, <strong>setResource</strong>, <strong>deleteResource</strong> and <strong>copyResource</strong> functions.</p></blockquote><p>The most common use for this URL scheme is to copy an entire resourcefork from one file to another. To modify the data from a <strong>resfile</strong>URL, you need to understand the details of Apple&#39;s resource fork format.</p><h4>Creating a resource fork</h4><p>Unlike the <strong>file</strong> and <strong>binfile</strong> URL schemes, the <strong>resfile</strong> keywordcannot be used to create a file. If the file doesn&#39;t yet exist, youcannot use the <strong>resfile</strong> keyword to create it. To create a newresource file, first use a <strong>file</strong> URL to create the file with an emptydata fork, then write the needed data to its resource fork:</p><pre><code>put empty into URL &quot;file:myFile&quot; -- creates an empty file put myStoredResources into URL &quot;resfile:myFile&quot;</code></pre><h3>Manipulating URL contents</h3><p>You use a URL like any other container. You can get the content of a URLor use its content in any expression. You can also put any data into aURL.</p><p><strong>http</strong>, <strong>ftp</strong>, <strong>binfile</strong>, and <strong>resfile</strong> URLs can hold binarydata.</p><p><strong>http</strong>, <strong>ftp</strong>, and <strong>file</strong> URLs can hold text.</p><h4>The URL keyword</h4><p>To specify a URL container, you use the <strong>URL</strong> keyword before the URL,which can use any of the five schemes described above:</p><pre><code>if URL &quot;http://www.example.net/index.html&quot; is not empty then ...get URL &quot;binfile:/Applications/Hover.app/data&quot; put 1+1 into URL &quot;file:output.txt&quot;</code></pre><p>The <code>URL</code> keyword tells LiveCode that you are using the <code>URL</code> as acontainer.</p><p>Some properties (such as the <strong>filename</strong> of a player or image) let youspecify a URL as the property&#39;s value. Be careful not to include the<strong>URL</strong> keyword when specifying such properties, because using theURLkeyword indicates that you&#39;re treating the URL as a container. If youuse the URL keyword when specifying such a property, the property is setto the contents of the URL, not the URL itself, and this is usually notwhat&#39;s wanted.</p><h4>Using the content of a URL</h4><p>As with other containers, you use the content of a URL by using areference to the URL in an expression. LiveCode substitutes the URL&#39;scontent for the reference.</p><p>If the URL scheme refers to a local file (**file**, <strong>binfile</strong>, or<strong>resfile</strong> URLs), LiveCode reads the content of the file andsubstitutes it for the URL reference in the expression:</p><pre><code>answer URL &quot;file:../My File&quot; -- displays the file&#39;s content put URL &quot;binfile:flowers.jpg&quot; into myVariable put URL &quot;resfile:Icons&quot; into URL &quot;resfile:New Icons&quot;</code></pre><p>If the URL scheme refers to a document on another system (**http** or<strong>ftp</strong> URLs), LiveCode downloads the URL automatically, substitutingthe downloaded data for the URL reference:</p><pre><code>answer URL &quot;http://www.example.net/files/greeting.txt&quot;</code></pre><blockquote><p><strong>Note:</strong> If the server sends back an error message--for example, ifthe file you specify in an <strong>http</strong> URL doesn&#39;t exist--then the error message replaces the URL reference in the expression.</p><p><strong>Important:</strong> When you use an <strong>ftp</strong> or <strong>http</strong> URL in anexpression, the handler pauses until LiveCode is finished downloading the URL. If you do not want to block LiveCode when accessing these resources, use the <strong>load URL</strong> form of the command (see below).</p></blockquote><h4>Putting data into a URL</h4><p>As with other containers, you can put data into a URL. The result ofdoing so depends on whether the URL scheme specifies a file on yoursystem (**file**, <strong>binfile</strong>, or <strong>resfile</strong>) or on another system(**http** or <strong>ftp</strong>).</p><p>If the URL scheme refers to a local file (**file**, <strong>binfile</strong>, or<strong>resfile</strong> URLs), LiveCode puts the data into the specified file:</p><pre><code>put field &quot;My Text&quot; into URL &quot;file:storedtext.txt&quot; put image 1 into URL &quot;binfile:picture.png&quot;</code></pre><p>If the URL scheme refers to a document on the Internet (**http** or<strong>ftp</strong> URLs), LiveCode uploads the data to the URL:</p><pre><code>put myVar into URL &quot;ftp://me:pass@ftp.example.net/file.dat&quot;</code></pre><p>Because most web servers do not allow HTTP uploads, this usually willnot be successful with the <strong>http</strong> scheme.</p><h4>Chunk expressions and URLs</h4><p>Like other containers, URLs can be used with chunk expressions tospecify a portion of what&#39;s in a URL--a line, an item, a word, or acharacter. In this way, any chunk of a URL is like a container itself.For more information about Chunk Expressions, see the guide on<em>Processing Text and Data</em>.</p><p>You can use any chunk of a URL in an expression, in the same way you usea whole URL:</p><pre><code>get line 2 of URL &quot;http://www.example.net/index.html&quot; put word 8 of URL &quot;file:/Disk/Folder/myfile&quot; into field 4 if char 1 of URL &quot;ftp://ftp.example.org/test.jpg&quot; is &quot;0&quot; then ...</code></pre><p>You can also specify ranges, and even one chunk inside another:</p><pre><code>put char 1 to 30 of URL &quot;binfile:/marks.dat&quot; into myVar answer line 1 to 3 of URL &quot;http://www.example.com/file&quot;</code></pre><h4>Putting data into a chunk</h4><p>If the URL is local (that is, if it is a <strong>file</strong>, <strong>binfile</strong>, or<strong>resfile</strong> URL), you can put a value into a chunk of the URL:</p><pre><code>put it into char 7 of URL &quot;binfile:/picture.gif&quot; put return after \    word 25 of URL &quot;file:../datafile&quot; put field 3 into line 20 of URL &quot;file:myfile.txt&quot; </code></pre><p>You can also put a value into a chunk of an <strong>ftp</strong> or <strong>http</strong> URL.Because it&#39;s impossible to upload part of a file, LiveCode downloads thefile, makes the change, then uploads the file back to the server.</p><blockquote><p><strong>Tip:</strong> This method is inefficient if you need to make severalchanges. In this case, it&#39;s faster to first put the URL in a variable, replace the chunk youwant to change, then put the variable into the URL:</p></blockquote><pre><code>put URL &quot;ftp://me:secret@ftp.example.net/file.txt&quot; into myVar put field &quot;New Info&quot; after line 7 of myVar put field &quot;More&quot; into word 22 of line 3 of myVarput myVar into URL &quot;ftp://me:secret@ftp.example.net/file.txt&quot;</code></pre><p>This ensures that the file only needs to be downloaded once andre-uploaded once, no matter how many changes you need to make.</p><h3><strong>URLs and memory</strong></h3><p>URLs, unlike other containers, are only read into memory when you usethe URL in a statement. Other containers – like variables, fields,buttons, and images – are normally kept in memory, so accessing themdoesn&#39;t increase memory usage.</p><p>This means that in order to read a URL or place a value in a chunk of aURL, LiveCode reads the entire file into memory. Because of this, youshould be cautious when using a URL to refer to any very large file.</p><p>Even when referring to a single chunk in a URL, LiveCode must place theentire URL in memory. An expression such as     line 347882 of URL &quot;file:bigfile.txt&quot; may be evaluated very slowly or even not work at all, if insufficient memory is available. If you refer to a chunk of an <code>ftp</code> or http URL, LiveCode must download the entire file to find the chunk you specify.</p><p>If you need to read and write large quantities of data to a file, orseek through the contents of a large file without loading the entirecontents into memory, use the <strong>open file</strong>, <strong>read from file</strong>,<strong>seek</strong> and <strong>close file</strong> commands instead of the URL commands. Formore information on these commands see the <em>LiveCode Dictionary</em>.</p><h3><strong>Deleting URLs</strong></h3><p>You remove a URL with the <strong>delete URL</strong> command.</p><p>To delete a local file, you use a <strong>file</strong> or <strong>binfile</strong> URL:</p><pre><code>delete URL &quot;file:C:/My Programs/test.exe&quot; delete URL&quot;binfile:../mytext.txt&quot; </code></pre><p>It doesn&#39;t matter whether the file contains binary data or text; fordeletion, these URL schemes are equivalent.</p><blockquote><p><strong>Tip:</strong> You can also use the <strong>delete file</strong> command to remove a file.To delete the resource fork of a file, you use a <strong>resfile</strong> URL. Thefollowing example removes the resource fork along with all resources,but leaves the file in place:</p></blockquote><pre><code>delete URL &quot;resfile:/Volumes/Backup/proj.rev&quot; </code></pre><blockquote><p><strong>Tip:</strong> To delete a single resource instead of the entire resourcefork, use the <strong>deleteResource</strong> function.</p></blockquote><p>To remove a file or directory from an FTP server, you use an <strong>ftp</strong>URL:</p><pre><code>delete URL &quot;ftp://root:secret@ftp.example.org/deleteme.txt&quot; delete URL &quot;ftp://me:mine@ftp.example.net/trash/&quot; </code></pre><p>As with creating files, you can use an <strong>http</strong> URL to delete a file,but most HTTP servers are not configured to allow this.</p><h2><a name="//apple_ref/cpp/Guide/Uploading and Downloading Files" class="dashAnchor"></a>Uploading and Downloading Files</h2><p>The simplest way to transfer data to an FTP or HTTP server is to use the<strong>put</strong> command to upload, or use the URL in an expression to download.</p><p>The Internet library includes additional commands to upload and downloadfiles to and from an FTP server. These commands offer more versatileoptions for monitoring and controlling the progress of the filetransfer.</p><h4>Uploading using the put command</h4><p>As mentioned above, putting something into an <strong>ftp</strong> or <strong>http</strong> URLuploads the data to the server:</p><pre><code>put myVariable into URL&quot;ftp://user:pass@ftp.example.org/newfile.txt&quot;</code></pre><p>If you use the <strong>put</strong> command with a <strong>file</strong> or <strong>binfile</strong> URL as thesource, the file is uploaded:</p><pre><code>put URL &quot;file:newfile.txt&quot; into URL&quot;ftp://user:pass@ftp.example.org/newfile.txt&quot;</code></pre><p>When you upload data in this way, the operation is blocking: that is,the handler pauses until the upload is finished. (See below for detailson how to create a file transfer that is not blocking.) If there is anerror, the error is placed in the <strong>result</strong> function:</p><pre><code>put field &quot;Data&quot; into URL myFTPDestination if the result is not empty then beep 2</code></pre><blockquote><p><strong>Important:</strong> Uploading or downloading a URL does not prevent othermessages from being sent during the file transfer: the current handler is blocked, but other handlers are not. For example, the user might click a button that uploads or downloads another URL while the first URL is still being uploaded. In this case, the second file transfer is not performed and the <strong>result</strong> is set to &quot;Error Previous request has not completed.&quot; To avoid this problem, you can set a flag while a URL is being uploaded, and check that flag when trying to upload or download URLs to make sure that there is not already a file transfer in progress.</p></blockquote><h4>Downloading using a URL</h4><p>Referring to an <strong>ftp</strong> or <strong>http</strong> URL in an expression downloads thedocument.</p><pre><code>put URL &quot;ftp://ftp.example.net/myfile.jpg&quot; into image 1 get URL &quot;http://www.example.com/newstuff/newfile.html&quot;</code></pre><p>If you use the <strong>put</strong> command with a <strong>file</strong> or <strong>binfile</strong> URL as thedestination, the document is downloaded to the file:</p><pre><code>put URL &quot;ftp://ftp.example.net/myfile.jpg&quot; into URL \    &quot;binfile:/Disk/Folder/myfile.jpg&quot;</code></pre><h3>Non-blocking transfers</h3><p>When you transfer a file using URL containers, the file transfer stopsthe current handler until the transfer is done. This kind of operationis called a blocking operation, since it blocks the current handler aslong as it&#39;s going on.</p><p>If you want to transfer data using <em>http</em> without blocking, use the<strong>load</strong> command. if you want to transfer large files using <em>ftp</em>, usethe <strong>libURLftpUpload</strong>, <strong>libURLftpUploadFile</strong>, or<strong>libURLDownloadToFile</strong> commands.</p><p>Non-blocking file transfers have several advantages:</p><p>Since contacting a server may take some time due to network lag, thepause involved in a blocking operation may be long enough to benoticeable to the user.</p><p>If a blocking operation involving a URL is going on, no other blockingoperation can start until the previous one is finished. If anon-blocking file transfer is going on, however, you can start othernon-blocking file transfers. This means that if you use the librarycommands, the user can begin multiple file transfers without errors.</p><p>During a non-blocking file transfer, you can check and display thestatus of the transfer. This lets you display the transfer&#39;s progressand allow the user to cancel the file transfer.</p><h4>Using the load command</h4><p>The <strong>load</strong> command downloads the specified document in the backgroundand places it in a cache. Once a document has been cached, it can beaccessed nearly instantaneously when you use its URL, because LiveCodeuses the cached copy in memory instead of downloading the URL again.</p><p>To use a file that has been downloaded by the load command, refer to itusing the URL keyword as usual. When you request the original URL,LiveCode uses the cached file automatically.</p><p>For best performance, use the <code>load</code> command at a time when responsespeed isn&#39;t critical (such as when your application is starting up), andonly use it for documents that must be displayed quickly, such as imagesfrom the web that will be shown when you go to the next card.</p><h4>Checking status when using the load command</h4><p>While a file is being transferred using the load commands, you can checkthe status of the transfer using the <strong>URLStatus</strong> function. Thisfunction returns the current status of a URL that&#39;s being downloaded oruploaded:</p><pre><code>local tUrlput &quot;ftp://ftp.example.com/myfile.txt&quot; into tUrlput the URLStatus of tUrl into field &quot;Current Status&quot;</code></pre><p>The <strong>URLStatus</strong> function returns one of the following values:- <em>queued</em> : on hold until a previous request to the same site iscompleted- <em>contacted</em> : the site has been contacted but no data has been sent orreceived yet- <em>requested</em> : the URL has been requested- <em>loading</em> <em>bytesTotal</em>, <em>bytesReceived</em> : the URL data is being received- <em>uploading</em> <em>bytesTotal, bytesReceived</em> : the file is being uploaded to the URL- <em>cached</em> : the URL is in the cache and the download is complete- <em>uploaded</em> : the application has finished uploading the file to the URL- <em>error</em> : an error occurred and the URL was not transferred- <em>timeout</em> : the application timed out when attempting to transfer theURL</p><p>To monitor the progress of a file transfer or display a progress bar,you check the <strong>URLStatus</strong> function repeatedly during the transfer. Theeasiest way to do this is with timer based messaging – see the sectionof the same name in the <em>LiveCode Script</em> guide, for more information.</p><h4>Canceling a file transfer &amp; emptying the cache</h4><p>To cancel a transfer initiated with the load command and empty thecache, use the <strong>unload</strong> command.</p><pre><code>unload URL &quot;http://example.org/new\_beta&quot;</code></pre><h4>Uploading and downloading large files using FTP</h4><p>The Internet library provides a number of commands for transferringlarger files via FTP without blocking.- <strong>libURLftpUpload</strong> uploads data to an FTP server- <strong>libURLftpUploadFile</strong> uploads a file to an FTP server- <strong>libURLDownloadToFile</strong> downloads a file from an FTP server to a local file</p><p>The basic effect of these commands is the same as the effect of usingURLs: that is, the data is transferred to or from the server. However,there are several differences in how the actual file transfer ishandled. Because of these differences, the library commands are moresuitable for uploads and downloads, particularly if the file beingtransferred is large.</p><p>The following sets of statements each show one of the Internet librarycommands, with the equivalent use of a URL:</p><pre><code>libURLftpUpload myVar,&quot;ftp://me:pass@example.net/file.txt&quot; put myVar into URL &quot;ftp://me:pass@example.net/file.txt&quot;libURLftpUploadFile &quot;test.data&quot;,&quot;ftp://ftp.example.org/test&quot;put URL &quot;binfile:test.data&quot; into URL &quot;ftp://ftp.example.org/testlibURLDownloadToFile &quot;ftp://example.org/new\_beta&quot;,&quot;/HD/File&quot; put URL &quot;ftp://example.org/new\_beta&quot; into URL &quot;binfile:/HD/File&quot;</code></pre><h4>Using callback messages</h4><p>When you start a file transfer using the <strong>libURLftpUpload</strong>,<strong>libURLftpUploadFile</strong>, or <strong>libURLDownloadToFile</strong> command, you canoptionally specify a callback message, which is usually a custom messagethat you write a handler for. This message is sent whenever the filetransfer&#39;s <strong>URLStatus</strong> changes, so you can handle the callback messageto handle errors or to display the file transfer&#39;s status to the user.</p><p>The following simple example demonstrates how to display a statusmessage to the user. The following handlers might be found in a button&#39;sscript:</p><pre><code>on mouseUp     local tUrl    put &quot;ftp://example.org/new_beta&quot; into tUrl    libURLDownloadToFile tUrl,&quot;/HD/Latest Beta&quot;,&quot;showStatus&quot; end mouseUpon showStatus theURL     put the URLStatus of theURL into field &quot;Status&quot; end showStatus</code></pre><p>When you click the button, the <strong>mouseUp</strong> handler is executed. The<strong>libURLDownloadToFile</strong> command begins the file transfer, and its lastparameter specifies that a <em>showStatus</em> message will be sent to thebutton whenever the <strong>URLStatus</strong> changes.</p><p>As the <strong>URLStatus</strong> changes periodically throughout the downloadprocess, the button&#39;s <em>showStatus</em> handler is executed repeatedly. Eachtime a <em>showStatus</em> message is sent, the handler places the new statusin a field. The user can check this field at any time during the filetransfer to see whether the download has started, how much of the filehas been transferred, and whether there has been an error.</p><p>If a file transfer was started using the <strong>libURLftpUpload</strong>,<strong>libURLftpUploadFile</strong>, or <strong>libURLDownloadToFile</strong> command, you cancancel the transfer using the <strong>unload</strong> command.</p><h4>Uploading, downloading, and memory</h4><p>When you use a URL as a container, LiveCode places the entire URL inmemory. For example, if you download a file from an FTP server using the<strong>put</strong> command, LiveCode downloads the whole contents of the file intomemory before putting it into the destination container. If the file istoo large to fit into available memory, a file transfer using thismethod will fail (and may cause other unexpected results).</p><p>The library commands <strong>libURLftpUpload</strong>, <strong>libURLftpUploadFile</strong>, and<strong>libURLDownloadToFile</strong>, however, do not require the entire file to beloaded into memory. Instead, they transfer the file one piece at a time.If a file is (or might be) too large to comfortably fit into availablememory, you should always use the library commands to transfer it.</p><h3>Using a stack on a server</h3><p>Ordinarily, you use stack files that are located on a local disk. Youcan also open and use a stack that is located on an FTP or HTTP server.Using this capability, you can update an application by downloading newstacks, make new functionality available via the Internet, and even keepmost of your application on a server instead of storing it locally.</p><p>Going to a stack on a server:</p><p>As with local stack files, you use the <strong>go</strong> command to open a stackthat&#39;s stored on a server:</p><pre><code>go stack URL &quot;http://www.example.org/myapp/main.rev&quot; go stack URL &quot;ftp://user:pass@example.net/secret.rev&quot;</code></pre><blockquote><p><strong>Note:</strong> For such a statement to work, the stack file must have beenuploaded as binary data, uncompressed, and not use encodings such as BinHex.</p><p><strong>Tip:</strong> If you need to download a large stack, use the <strong>load</strong> command to complete the download before using the <strong>go</strong> command to display the stack. This allows you to display a progress bar during the download.</p></blockquote><p>LiveCode automatically downloads the stack file. The main stack of thestack file then opens in a window, just as though you had used the<strong>go</strong> command to open a local stack file.</p><p>You can go directly to a specific card in the stack:</p><pre><code>local tStackUrlput &quot;http://www.example.org/myapp/main.rev&quot; into tStackUrlgo card &quot;My Card&quot; of stack URL tStackUrl</code></pre><p>To open a substack instead, use the substack&#39;s name:</p><pre><code>local tStackUrlput &quot;http://www.example.org/myapp/main.rev&quot; into tStackUrlgo stack &quot;My Substack&quot; of stack URL tStackUrl</code></pre><h4>Using a compressed stack</h4><p>You cannot directly open a stack that&#39;s compressed. However, since thestack URL is a container, you can use the URL as the parameter for the<strong>decompress</strong> function. The function takes the stack file data anddecompresses it, producing the data of the original stack file. You canopen the output of the function directly as a stack.</p><p>The following statement opens a compressed stack file on a server:</p><pre><code>go decompress(stack URL &quot;http://www.example.net/comp.gz&quot;)</code></pre><p>The statement automatically downloads the file &quot;comp.gz&quot;, uncompressesit, and opens the main stack of the file.</p><h4>Saving stacks from a server</h4><p>When a stack is downloaded using the <strong>go</strong> command, it&#39;s loaded intomemory, but not saved on a local disk. Such a stack behaves like a new(unsaved) stack until you use the <strong>save</strong> command to save it as a stackfile.</p><blockquote><p><strong>Note:</strong> Saving a stack that has been downloaded with the <strong>go</strong>command does not re-upload it to its server. To upload a changedstack, you must save it to a local file, then use one of the methodsdescribed in this topic to upload the file to the server.</p></blockquote><h2><a name="//apple_ref/cpp/Guide/Other Internet Commands" class="dashAnchor"></a>Other Internet Commands</h2><p>The Internet library has a number of additional commands for workingwith web forms, ftp commands, custom settings and troubleshooting. Thesecommands are documented in more detail the LiveCode Dictionary.</p><h4>Launching the User&#39;s Browser with a URL</h4><p>To launch the default browser with a URL, use the <strong>launch URL</strong>command.</p><pre><code>launch URL &quot;http://www.livecode.com/&quot;</code></pre><blockquote><p><strong>Note:</strong> To render web pages within LiveCode, instead of launching anexternal browser, use the revBrowser. See the section on revBrowserfor more information.</p></blockquote><h3>Working with Web Forms</h3><p>To post data to a web form, use the <strong>post</strong> command. To encode data tomake it suitable for posting, use the <strong>libUrlFormData</strong> function. Tocreate multi-part form data (as described in RFC 1867) use the<strong>libUrlMultipartFormData</strong> function. To add data to a multipart formone part at a time, use the <strong>libUrlMultipartFormAddPart</strong> function.This can be useful if you need to specify the mime type or transferencoding for each part.</p><h3>Working with FTP</h3><p>For details on basic uploading and downloading using FTP, see thesection above.</p><p>The following commands provide additional capabilities when working withthe ftp protocol:</p><ul><li><strong>libURLSetFTPStopTime</strong> : Sets the timeout value for FTP transfers.</li><li><strong>libURLSetFTPMode</strong> : Switches between active and passive mode for FTP transfers.</li><li><strong>libURLSetFTPListCommand</strong> : Switches between sending LIST or NLSTformats when listing the contents of an FTP directory.</li><li><strong>libURLftpCommand</strong> : sends an ftp command to an ftp server.</li><li><strong>libURLftpUpload</strong> : uploads data. See the section above for moredetails.</li><li><strong>libURLftpUploadFile</strong> : uploads a file, without loading the entirefile into memory. See the section above for more details.</li><li><strong>libURLDownloadToFile</strong> – downloads data to a file, without loading the entire data into memory. See the section above for more details.</li></ul><h3>HTTP methods and http URLs</h3><p>The basic operations used by the HTTP protocol are called methods. For<strong>http</strong> URLs, the following HTTP methods are used under the followingcircumstances:</p><ul><li><p>GET: when an <strong>http</strong> URL in an expression is evaluated</p></li><li><p>PUT: when you put a value into an <strong>http</strong> URL</p></li><li><p>POST: when you use the <strong>post</strong> command</p></li><li><p>DELETE: when you use the <strong>delete URL</strong> command with an <strong>http</strong> URL</p></li></ul><blockquote><p><strong>Note:</strong> Many HTTP servers do not implement the PUT and DELETEmethods, which means that you can&#39;t put values into an <strong>http</strong> URL ordelete an <strong>http</strong> URL on such servers. It&#39;s common to use the FTPprotocol instead to upload and delete files; check with your server&#39;sadministrator to find out what methods are supported.</p></blockquote><h4>HTTP headers</h4><p>When LiveCode issues a GET or POST request, it constructs a minimal setof HTTP headers. For example, when issued on a Mac OS system, thestatement:</p><pre><code>put URL &quot;http://www.example.org/myfile&quot; into myVariable</code></pre><p>results in sending a GET request to the server:</p><pre><code>GET /myfile HTTP/1.1 Host: 127.0.0.0 User-Agent: LiveCode (MacOS)</code></pre><p>You can add headers, or replace the Host or User-Agent header, bysetting the <strong>HTTPHeaders</strong> property before using the URL:</p><pre><code>set the HTTPHeaders to &quot;User-Agent: MyApp&quot; &amp; return \    &amp; &quot;Connection: close&quot; put URL &quot;http://www.example.org/myfile&quot; into myVariable</code></pre><p>Now the request sent to the server looks like this:</p><p>GET /myfile HTTP/1.1 Host: 127.0.0.0 User-Agent: MyApp Connection: close</p><p>The <strong>ftp</strong> URL scheme can be used to create a new file to an FTPserver. As with the <strong>file</strong> and <strong>binfile</strong> schemes, putting somethinginto the URL creates the file:</p><pre><code>put dataToUpload into URL&quot;ftp://jane:pass@ftp.example.com/newfile.dat&quot;</code></pre><blockquote><p><strong>Tip:</strong> You can create an FTP directory by uploading a file to thenew (nonexistent) directory. The directory is automatically created.You can then delete the file, if you wish, leaving a new, emptydirectory on the server:</p></blockquote><pre><code>-- Create an empty file in the nonexistent directory: put empty into URL &quot;ftp://jane:pass@example.com/newdir/dummy&quot; -- Delete unwanted empty file to leave new directory: delete URL &quot;ftp://jane:pass@example.com/newdir/dummy&quot;</code></pre><h3>Additional Transmission Settings</h3><p>The following commands provide additional customization options for theInternet library:</p><ul><li><strong>libUrlSetExpect100</strong> : Allows you to set a limit to the size of databeing posted before requesting a continue response from the server.</li><li><strong>libURLSetCustomHTTPHeaders</strong> : Sets <code>the header</code>s to be sent with eachrequest to an HTTP server. See also the section on HTTPHeaders above.</li><li><strong>libURLFollowHttpRedirects</strong> : Specify that GET requests should followHTTP redirects and GET the page redirected to.</li><li><strong>libUrlSetAuthCallback</strong> : Sets a callback for handling authenticationwith http servers and proxies.</li></ul><h3>Troubleshooting</h3><p>The following commands and functions can be useful when debugging anapplication that uses the Internet library.</p><ul><li><strong>resetAll</strong> : Closes all open sockets and halts all pending Internetoperations.</li></ul><blockquote><p><strong>Caution:</strong> The <strong>resetAll</strong> command closes all open sockets, whichincludes any other sockets opened by your application and any socketsin use for other uploads and downloads. Because of this, you shouldavoid routine use of the <strong>resetAll</strong> command. Consider using it onlyduring development, to clear up connection problems during debugging.</p></blockquote><ul><li><strong>libURLErrorData</strong> : Returns any error that was caused during adownload that was started with the load command.</li><li><strong>libURLVersion</strong> : Returns the version of the Internet library.</li><li><strong>libURLSetLogField</strong> : Specifies a field for logging information aboutuploads and downloads on screen.</li><li><strong>libURLLastRHHeaders</strong> : Returns the headers sent by the remote host inthe most recent HTTP transaction.</li><li><strong>libURLLastHTTPHeaders</strong> : Returns the value of the httpHeaderspropertyused for the previous HTTP request.</li></ul><h2><a name="//apple_ref/cpp/Guide/revBrowser – Rendering a Web Page within a Stack" class="dashAnchor"></a>revBrowser – Rendering a Web Page within a Stack</h2><p>Use the revBrowser commands to render a web page within a stack.RevBrowser uses WebKit (Safari) on Mac OS X and Internet Explorer onWindows. Currently RevBrowser is not supported under Linux.</p><p>To create a browser object in a stack, use the <strong>revBrowserOpen</strong>function. This function takes the <strong>windowID</strong> for the stack you want toopen the browser in and a URL. Please note that the <code>windowID</code>is not thesame as the stack&#39;s ID property.</p><pre><code>put the windowid of this stack into tWinID put revBrowserOpen(tWinID,&quot;http://www.google.com&quot;) into sBrowserId</code></pre><p>To set properties on the browser, use the <strong>revBrowserSet</strong> command. Thefollowing commands makes the border visible then sets the rectangle tobe the same as an image named &quot;browserimage&quot;:</p><pre><code>revBrowserSet sBrowserId, &quot;showborder&quot;,&quot;true&quot; revBrowserSet sBrowserId, &quot;rect&quot;,rect of img &quot;browserimage&quot;</code></pre><p>To close a browser when you finished with it, use the<strong>revBrowserClose</strong> command. This command takes the <code>windowID</code>for thestack containing the browser:</p><pre><code>revBrowserClose sBrowserId</code></pre><p>RevBrowser supports a number of settings and messages. You can intercepta message whenever the user navigates to a link, prevent navigation,intercept clicks in the browser, requests to download files or to open anew window.</p><p>For a complete list of commands that operate on RevBrowser, open the<em>LiveCode Dictionary</em> and type &quot;browser&quot; into the filter box.</p><h2><a name="//apple_ref/cpp/Guide/SSL and Encryption" class="dashAnchor"></a>SSL and Encryption</h2><p>LiveCode includes support for using Secure Sockets Layer and the httpsprotocol. It also includes an industrial strength encryption library youcan use to encrypt files or data transmissions.</p><h3>Encrypting and Decrypting Data</h3><p>To encrypt data, use the <strong>encrypt</strong> command. The <strong>encrypt</strong> commandsupports a wide variety of industry standard methods of encryption. Thelist of installed methods can be retrieved by using the <strong>cipherNames</strong>function. To decrypt data, use the <strong>decrypt</strong> command. For moreinformation on these features, see the <em>LiveCode Dictionary</em>.</p><blockquote><p><strong>Tip:</strong> If you are using the encryption library on a Windows system,it is possible that another application will have installed DLLs thatuse the same name as the ones included with LiveCode to supportencryption. You can force your application to load LiveCode&#39;s SSL DLLsby setting the $PATH environment variable before loading the library.</p></blockquote><pre><code>put $PATH into tOldPath put &lt;path to SSL DLLs&gt; into $PATH get the cipherNames -- Force loading of the SSL DLLs put tOldPath into $PATH</code></pre><h3>Connecting using HTTPS</h3><p>You may connect and download data from a URL using <strong>https</strong> in the sameway that you access an http URL.</p><pre><code>put URL &quot;https://www.example.com/store.php&quot;</code></pre><p>If there is an error, it will be placed into <code>the result</code>. If you needto include a user name and password you can do so in the following form:</p><pre><code>https://user:password@www.example.com/</code></pre><h3>Implementing your own secure protocols</h3><p>To implement your own secure protocol, use the <strong>open secure socket</strong>variant of the <strong>open socket</strong> command. You can specify whether or notto include certification, a certificate and a key. For more informationon the <strong>open socket</strong> command, see the <em>LiveCode Dictionary</em>.</p><h2><a name="//apple_ref/cpp/Guide/Writing your own protocol with sockets" class="dashAnchor"></a>Writing your own protocol with sockets</h2><p>If you need to implement your own protocol, you can do so usingLiveCode&#39;s socket support. To understand this chapter it is assumed youunderstand the basics of how the Internet works, including the conceptsof sockets, IP addresses and ports. More information on these conceptscan be found in Wikipedia.</p><blockquote><p><strong>Tip:</strong> The standard protocols that LiveCode support such as http andftp, discussed earlier in this chapter, have all been implemented as ascripted library with LiveCode&#39;s socket support. You can examine thislibrary by running <code>edit script of stack &quot;revlibURL&quot;</code> in the Message Box. Beware, this library is not for the faint of heart. If you change anything, LiveCode&#39;s Internet commands may cease to operate.</p></blockquote><h4>Opening a connection</h4><p>To open a connection use the <strong>open socket</strong> command. The followingcommand opens a connection to the IP address specified in the<code>tIPAddress</code>variable and the port specified in the <code>tPort</code>variable. Itspecifies that LiveCode should send the message &quot;<code>chatConnected</code>&quot; when aconnection has been established.</p><pre><code>open socket (tIPAddress &amp; &quot;:&quot; &amp; tPort) with message &quot;chatConnected&quot;</code></pre><p>To open a secure socket, use the <strong>open secure socket</strong> variant of thecommand. To open a UDP datagram socket, use the <strong>open datagram socket</strong>variant of the command. For more information on these variants, see the<em>LiveCode Dictionary</em>.</p><h4>Looking up a host name or IP address</h4><p>You may look up an IP address from a host name with the<strong>hostNameToAddress</strong> function. For example, to get the IP address forthe livecode.com server:</p><pre><code>put hostNameToAddress(&quot;www.livecode.com&quot;) into tIPAddress</code></pre><p>To get the host name of the local machine, use the <strong>hostName</strong>function. To look up the name from an IP address, use the<strong>hostAddressToName</strong> function.</p><h4>Reading and writing data</h4><p>Once LiveCode opens a connection, it will send a <code>chatConnected</code>message.To receive data, use the <strong>read from socket</strong> command. The followingmessage reads data from the socket and sends a <code>chatReceived</code>messagewhen reading is completed.</p><pre><code>on chatConnected pSocket        read from socket pSocket with message chatReceived end chatConnected</code></pre><p>Once reading from the socket is completed the <code>chatReceived</code> message canbe used to process or display the data. It can then specify that itshould continue to read from the socket until more data is received,sending another <code>chatReceived</code> message when done.</p><pre><code>on chatReceived pSocket, pData     put pData after field &quot;chat output&quot;    read from socket pSocket with message &quot;chatReceived&quot; end chatReceived</code></pre><p>To write data to the socket, use the <strong>write</strong> command:</p><pre><code>write field &quot;chat text&quot; to socket tSocket</code></pre><h4>Disconnecting</h4><p>To disconnect, use the <strong>close socket</strong> command. You should store avariable with details of any open sockets and close them when you havefinished using them or when your stack closes.</p><pre><code>close socket (tIDAddress &amp; &quot;:&quot; &amp; tPort)</code></pre><h4>Listening for and accepting incoming connections</h4><p>To accept incoming connections on a given port, use the <strong>acceptconnections</strong> command. The following example tells LiveCode to listenfor connections on port 1987 and send the message <code>chatConnected</code>if aconnection is established. You can then start to read data from thesocket in the <code>chatConnected</code>handler.</p><pre><code>accept connections on port 1987 with message chatConnected</code></pre><h4>Handling errors</h4><p>If there is an error, LiveCode will send a <strong>socketError</strong> message withthe address of the socket and the error message. If a socket is closed a<strong>socketClosed</strong> message will be sent. If a socket times out waiting fordata a <strong>socketTimeout</strong> message will be sent. To get a list of socketsthat are open, use the <strong>openSockets</strong> function. You can set the defaulttimeout interval by setting the <strong>socketTimeOutInterval</strong> property. Formore details on all of these features, see the <em>LiveCode Dictionary</em>.</p><blockquote><p><strong>Tip:</strong> You can see a complete implementation of a basic clientserver &quot;chat&quot; application by navigating to Documentation -&gt; GettingStarted -&gt; Sample Projects -&gt; Internet Chat – creating a customprotocol using sockets -&gt; Launch. Most of the scripts for the&quot;server&quot; stack are in the &quot;start server&quot; button. Most of the scriptsfor the client are in the stack script for the &quot;chat client&quot; stack.</p></blockquote></body></html>