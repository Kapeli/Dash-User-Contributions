<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Extending LiveCode</title><link rel="stylesheet" type="text/css" href="userguide.css" /></head><body><h1>Extending LiveCode</h1><h3><a name="//apple_ref/cpp/Guide/Introduction" class="dashAnchor"></a>Introduction</h3><p>LiveCode has a simple way to extend the functionality or control set of your app using separately compiled modules. This guide will take you through the process of installing and using these new widgets and libraries and for the adventurous among you, provide a guide to building and sharing your own extensions. </p><h3><a name="//apple_ref/cpp/Guide/LiveCode Builder Extensions" class="dashAnchor"></a>LiveCode Builder Extensions</h3><p>To make it possible to create extensions and plug them into the LiveCode engine we&#39;ve created a new flavor of our language called <strong><em>LiveCode Builder</em></strong>. LiveCode Builder looks a lot like LiveCode Script so should feel familiar for any seasoned LiveCode developer. There is lots of new syntax which exposes parts of the LiveCode engine that were only previously available to those who were skilled c/c++ developers.</p><p>To learn more about LiveCode Builder and creating extensions, read on.</p><blockquote><p><em>Warning:</em> It is important to stress right at the start that <strong><em>no aspect of LiveCode Builder should be considered final</em></strong>. <strong><em>Every piece of syntax in LiveCode Builder is subject to change</em></strong>.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Creating LiveCode Builder Extensions" class="dashAnchor"></a>Creating LiveCode Builder Extensions</h3><p>The IDE provides an &quot;Extension Builder&quot; tool to help make development and packaging of extensions as easy as possible. </p><blockquote><p><strong>Note:</strong> LiveCode Builder is a different flavor of LiveCode so it is not possible to edit LiveCode Builder scripts in the main LiveCode Script IDE.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Extension Builder" class="dashAnchor"></a>Extension Builder</h3><p>Open the &quot;Extension Builder&quot; from the tools menu:</p><pre><code>Tools &gt; Extension Builder</code></pre><p><img src="images/extensions-plugin-overview.png" alt="Extension Builder plugin"/></p><ol><li>Shows the currently selected extension. </li><li>Data that the builder was able to parse from the directory such as icons, resources, API&#39;s the user guides.</li><li>Console: Shows status, error and log messages.</li><li>Test: Creates a stack, compiles the extensions and creates an instance.</li><li>Script: Opens the lcb script in an external default editor.</li><li>Install: Installs the extension into the IDE</li><li>Uninstall: Uninstalls the extension from the IDE</li><li>Package: Creates a .lce package which can uploaded to the extension store. It is placed in the extension directory</li></ol><blockquote><p><strong>Note:</strong> A great way to get started is to tweak the script of one of our widget examples.</p></blockquote><p>Using the selection dropdown (1), you can select the extension you wish to develop or click the &quot;open&quot; icon in the header back to locate an extension you&#39;ve not loaded before. </p><h3><a name="//apple_ref/cpp/Guide/Create your own simple widget" class="dashAnchor"></a>Create your own simple widget</h3><p>The main difference between widgets and libraries is that a widget draws to a pre-existing canvas. Apart from that, the authoring process is much the same for both extension types.</p><h3><a name="//apple_ref/cpp/Guide/Create a .lcb file" class="dashAnchor"></a>Create a .lcb file</h3><p>We recommend using the Atom text editor, available at <a href="https://atom.io/">https://atom.io/</a>. A LiveCode package is available which provides some colorization as well as indentation. If you prefer to use TextWrangler, there is a colorizing script <a href="https://github.com/livecode/livecode/tree/develop/contrib/TextWrangler">here</a>. It should be placed in /Application Support/TextWrangler/Language Modules/</p><p>Start by creating a plain text file in a new directory and save it to disk with the extension &quot;lcb&quot;:</p><pre><code>/Desktop/widgettest/main.lcb</code></pre><blockquote><p><strong>Note:</strong> The extension builder currently relies on there being only one main module file in a given directory.    </p></blockquote><h3><a name="//apple_ref/cpp/Guide/Declare Type and Identifier" class="dashAnchor"></a>Declare Type and Identifier</h3><p>Start by declaring the type of extension, either &quot;widget&quot; or &quot;library&quot; followed by your identifier (See &quot;Select A Developer ID&quot; below).</p><pre><code>widget community.livecode.beaumont.pinkCircle   ## Code for your widgetend widget</code></pre><p>This is the unique identifier by which your extension will be referred to by the LiveCode Engine.</p><blockquote><p><strong>Note:</strong> All LiveCode authored widgets are in the application package at /Tools/Extensions/. To play with one of these extensions we recommend copying the folder from the application package to your desktop and loading it from there. Changing the extension identifier in the source code will ensure it doesn&#39;t conflict with the existing extension.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Declare Metadata" class="dashAnchor"></a>Declare Metadata</h3><p>Next, provide metadata to help LiveCode display your widget correctly in the IDE and in the online portal.</p><pre><code>widget community.livecode.beaumont.pinkCirclemetadata title is &quot;My Pink Circle&quot;metadata author is &quot;Benjamin Beaumont&quot;metadata version is &quot;1.0.0&quot;end widget</code></pre><h3><a name="//apple_ref/cpp/Guide/Importing libraries" class="dashAnchor"></a>Importing libraries</h3><p>The LiveCode builder syntax is broken down into <strong>modules</strong>. There are 3 classes of module:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>Default</td><td>These modules are part of LiveCode builder and are included by default. Their syntax is always available to you as a LiveCode developer.</td></tr><tr><td>Optional</td><td>These modules are created and distributed by LiveCode Ltd and must be imported by the extension developer in order to make use of their syntax.</td></tr><tr><td>Custom</td><td>These modules are created and distributed through the online portal and must be imported by the extension developer in order to make use of their syntax.</td></tr></tbody></table><p>LiveCode builder contains the following modules:</p><table><thead><tr><th>Module</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>com.livecode.canvas</td><td>Optional</td><td>Provides the syntax and types for 2D drawing allowing developers to draw to a canvas. Required if creating a widget.</td></tr><tr><td>com.livecode.widget</td><td>Optional</td><td>Contains syntax specific to widget building such as &quot;my width&quot; and &quot;the mouse position&quot;.</td></tr><tr><td>com.livecode.engine</td><td>Optional</td><td>Contains syntax for all extension building such as &quot;dispatch&quot; and &quot;log&quot;.</td></tr><tr><td>com.livecode.arithmetic</td><td>Default</td><td>Contains syntax for basic mathematical operations.</td></tr><tr><td>com.livecode.array</td><td>Default</td><td>Contains syntax for operations on arrays.</td></tr><tr><td>com.livecode.assert</td><td>Default</td><td>Contains syntax for making assertions about program state.</td></tr><tr><td>com.livecode.binary</td><td>Default</td><td>Contains syntax for operations on binary data.</td></tr><tr><td>com.livecode.bitwise</td><td>Default</td><td>Contains syntax for bitwise logical operators.</td></tr><tr><td>com.livecode.byte</td><td>Default</td><td>Contains syntax for operations on byte chunks.</td></tr><tr><td>com.livecode.char</td><td>Default</td><td>Contains syntax for operations on char chunks.</td></tr><tr><td>com.livecode.codeunit</td><td>Default</td><td>Contains syntax for operations on codeunit chunks.</td></tr><tr><td>com.livecode.date</td><td>Default</td><td>Contains syntax for accessing the date and time.</td></tr><tr><td>com.livecode.file</td><td>Default</td><td>Contains syntax for file I/O operations.</td></tr><tr><td>com.livecode.foreign</td><td>Default</td><td>Provides the type bindings for foreign types.</td></tr><tr><td>com.livecode.java</td><td>Default</td><td>Provides helper functions and types for interfacing with Java.</td></tr><tr><td>com.livecode.list</td><td>Default</td><td>Contains syntax for operations on lists.</td></tr><tr><td>com.livecode.logic</td><td>Default</td><td>Contains syntax for logical operators.</td></tr><tr><td>com.livecode.math</td><td>Default</td><td>Contains syntax for mathematical operations.</td></tr><tr><td>com.livecode.mathfoundation</td><td>Default</td><td>Contains syntax for foundational mathematical operations.</td></tr><tr><td>com.livecode.objc</td><td>Default</td><td>Provides helper functions and types for interfacing with Objective-C.</td></tr><tr><td>com.livecode.sort</td><td>Default</td><td>Contains syntax for sorting operations.</td></tr><tr><td>com.livecode.stream</td><td>Default</td><td>Contains syntax for stream I/O operations.</td></tr><tr><td>com.livecode.string</td><td>Default</td><td>Contains syntax for operations on strings.</td></tr><tr><td>com.livecode.system</td><td>Default</td><td>Contains syntax for accessing system information.</td></tr><tr><td>com.livecode.type</td><td>Default</td><td>Contains syntax for general operations on types.</td></tr><tr><td>com.livecode.typeconvert</td><td>Default</td><td>Contains syntax for conversions between types.</td></tr><tr><td>com.livecode.unittest</td><td>Default</td><td>Contains syntax for unit testing LiveCode Builder programs.</td></tr></tbody></table><blockquote><p><strong>Warning!</strong> Module names are subject to change.</p></blockquote><p>The LiveCode dictionary has a full list of all available syntax as well as the module each belongs to. As a general rule we recommend importing all three optional modules whenever developing widgets.</p><pre><code>widget community.livecode.beaumont.pinkCircleuse com.livecode.canvasuse com.livecode.widgetuse com.livecode.enginemetadata title is &quot;My Pink Circle&quot;metadata author is &quot;Benjamin Beaumont&quot;metadata version is &quot;1.0.0&quot;end widget</code></pre><h3><a name="//apple_ref/cpp/Guide/Core Handlers" class="dashAnchor"></a>Core Handlers</h3><p>There are several core handlers that any widget developer should implement:</p><table><thead><tr><th>Handler</th><th>Description</th></tr></thead><tbody><tr><td>OnPaint</td><td>The <em>OnPaint</em> message is sent to your widget whenever LiveCode requires it to redraw. The performance of your widget is tied primarily to this handler and should be kept as efficient as possible.</td></tr><tr><td>OnCreate</td><td>The <em>OnCreate</em> message is sent to your widget when it is first created by LiveCode. This can be used to initialise default data and where applicable, reduce the burden for calculating constants etc in the onPaint handler.</td></tr><tr><td>OnGeometryChanged</td><td>The <em>OnGeometryChanged</em> message is sent when the control is changed in size.</td></tr><tr><td>OnSave</td><td>The <em>OnSave</em> message is sent when your widget is about to be destroyed and enables the widget to save data set on the widget.</td></tr><tr><td>OnLoad</td><td>The <em>OnLoad</em> message is sent when your widget is created and enables the widget to retrieve data saved on the widget.</td></tr></tbody></table><p>In the first instance we are going to create a widget with no settable properties, just using the <code>OnPaint</code> handler.</p><pre><code>widget community.livecode.beaumont.pinkCirclemetadata title is &quot;My Pink Circle&quot;metadata author is &quot;Benjamin Beaumont&quot;metadata version is &quot;1.0.0&quot;public handler OnPaint()   // Draw widgetend handlerend widget</code></pre><h3><a name="//apple_ref/cpp/Guide/Draw a Pink Circle" class="dashAnchor"></a>Draw a Pink Circle</h3><pre><code>widget community.livecode.beaumont.pinkCirclemetadata title is &quot;My Pink Circle&quot;metadata author is &quot;Benjamin Beaumont&quot;metadata version is &quot;1.0.0&quot;use com.livecode.canvaspublic handler OnPaint()   // Create a path with a radius of half the width of the canvas   variable tCirclePath as Path   put circle path centered at point [my width / 2, my height / 2] with radius (my width/2) into tCirclePath   // Set the paint that will be used to fill the circle to a solid   // pink color   set the paint of this canvas to solid paint with color [1, 0, 1]   // Fill the path   fill tCirclePath on this canvasend handlerend widget</code></pre><h3><a name="//apple_ref/cpp/Guide/Test the Code" class="dashAnchor"></a>Test the Code</h3><p>Now open the extension builder stack as shown above and click on the folder icon at the top right to load your <strong><em>.lcb</em></strong> file into the builder.</p><p><img src="images/extensions-widget-first.png" alt="enter image description here"/></p><p>Click test. Your widget should be displayed on the new stack. If you can&#39;t see it, check behind the extension stack.</p><h3><a name="//apple_ref/cpp/Guide/Properties" class="dashAnchor"></a>Properties</h3><p>In order to make a widget useful to end users it is likely that you&#39;ll want to expose properties that allow them to specify how your widget should behave. </p><p>To specify a property you must provide a name and the method to get and set the property.</p><pre><code>property &lt;name&gt; get &lt;variable/handler&gt; set &lt;variable/handler&gt;</code></pre><p>The simplest properties to get/set are numbers or strings. So lets create a <code>circleMargin</code> property that allows users to define a margin.</p><pre><code>property circleMargin get mMargin set setMargin</code></pre><p>In the above example, when the <strong>circleMargin</strong> property is requested, the variable <code>mMargin</code> is returned; when the property is set, the handler <strong>setMargin</strong> is called. To have a property linked directly to the value of a variable, simply provide the variable name. There will beno other side effects - notably, a redraw will not automatically be triggered in the case that a variable name is used for a setter. To process the value coming from and going into LiveCode Script, or to add side-effects when getting and setting properties, provide handler names. In our case we&#39;re defining a setter for the <strong>circleMargin</strong> property because we need to trigger a redraw when it is set.</p><pre><code>private variable mMargin as Real</code></pre><p>We&#39;ll define a member variable to store the value for the margin. LiveCode Builder is typed so you must also specify the type of your variable. Remember, the canvas you are drawing to has subpixel precision so our margin is a real number rather than an integer. For a full list of types available in LiveCode Builder please see the Typing section of the language specification guide. </p><p>We also suggest a naming convention for variables in the section on variable and case sensitivity.</p><p>Finally we have to implement our <code>setMargin</code> handler.</p><pre><code>public handler setMargin(in pMargin as Real) returns nothing    put pMargin into mMargin    redraw allend handler</code></pre><p>Implementing the &quot;setter&quot; ourselves provides us with a little more flexibility. In this case when the property is set we want our pink circle to immediately redraw to reflect the property change. We do this by calling &quot;redraw all&quot;.</p><p>To test the property click &quot;test&quot; and from the message box set the property.</p><pre><code>set the cicleMargin of widget 1 to 15</code></pre><p><strong>Full Example</strong></p><pre><code>widget community.livecode.beaumont.pinkCirclemetadata title is &quot;My Pink Circle&quot;metadata author is &quot;Benjamin Beaumont&quot;metadata version is &quot;1.0.0&quot;use com.livecode.canvasuse com.livecode.widgetuse com.livecode.engine// Propertiesproperty circleMargin get mMargin set setMargin// Local variablesprivate variable mMargin as Realpublic handler onCreate()     put 0 into mMarginend handlerpublic handler OnPaint()   // Create a path with a radius of half the width of the canvas   variable tCirclePath as Path   put circle path centered at point [my width / 2, my height / 2] with radius (my width/2) into tCirclePath   // Set the paint that will be used to fill the circle to a solid   // pink color   set the paint of this canvas to solid paint with color [1, 0, 1]   // Fill the path   fill tCirclePath on this canvasend handlerpublic handler setMargin(in pMargin as Real)    put pMargin into mMargin    redraw allend handlerend widget</code></pre><h3><a name="//apple_ref/cpp/Guide/Loading and Saving widget data" class="dashAnchor"></a>Loading and Saving widget data</h3><p>When a stack containing a widget is saved, the widget&#39;s <em>OnSave</em> handler is called by the engine. The <em>OnSave</em> handler has an array out parameter - you can fill this array with whatever widget data is neededto reconstruct the widget. LiveCode saves this data along with instances of the widget in the stack file.</p><pre><code>public handler OnSave(out rProperties as Array)    put the empty array into rProperties    put mMargin into rProperties[&quot;margin&quot;]    return rPropertiesend handler</code></pre><p>This same array is passed as a parameter to an <em>OnLoad</em> handler which iscalled when the stack the widget is on is loaded.</p><pre><code>public handler OnLoad(in pProperties as Array)    put pProperties[&quot;margin&quot;] into mMarginend handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Understanding Error Messages" class="dashAnchor"></a>Understanding Error Messages</h3><p>Clicking on the &quot;test&quot; button causes the extension builder to compile your source code file (***.lcb***) and produce a compiled module file (***.lcm***). If an error is encountered it is output in the &quot;console&quot; section of the builder:</p><pre><code>Error: &lt;source path&gt;: &lt;line number&gt;: &lt;char number&gt;: &lt;error message&gt;</code></pre><ul><li><em>source path</em> - The path the .lcb file that is being compiled</li><li><em>line number</em> - The line number in the script on which the error occurred.</li><li><em>char number</em> - The character number on which the error occurred. </li><li><em>error message</em> - The description of the error.</li></ul><h3><a name="//apple_ref/cpp/Guide/LiveCode Builder API" class="dashAnchor"></a>LiveCode Builder API</h3><p>To start creating more complex widgets see the LiveCode Builder api in the documentation stack in the IDE.</p><p><img src="images/extensions-canvas-docs.png" alt="enter image description here"/></p><ol><li>Open the dictionary (and stay in the &#39;API&#39; tab)</li><li>Click the drop-down button</li><li>Choose the &quot;LiveCode Builder&quot; API</li><li>The list of all the syntax available</li></ol><h3><a name="//apple_ref/cpp/Guide/Hello World library" class="dashAnchor"></a>Hello World library</h3><p>A extension library is written in much the same way as the above widget. The only difference is that all the public handlers implemented are inserted into the message path when the extension is loaded.</p><p>For example, here is a simple library with one handler which simply returns the string &quot;Hello World!&quot;:</p><pre><code>library community.livecode.elanorb.helloworldmetadata title is &quot;Hello World Library&quot;  metadata author is &quot;Elanor Buchanan&quot;  metadata version is &quot;1.0.0&quot;public handler sayHello() return &quot;Hello World!&quot;  end handlerend library</code></pre><p>Once this is compiled and loaded, the sayHello handler would be in the message path, before the backscripts. LiveCode Builder library handlers can be invoked in both command and function form:</p><pre><code>sayHelloput the result -- outputs &quot;Hello World!&quot;put sayHello() -- outputs &quot;Hello World!&quot;</code></pre><h3><a name="//apple_ref/cpp/Guide/Loading and Creating Widgets Manually" class="dashAnchor"></a>Loading and Creating Widgets Manually</h3><p>To load a compiled module file call:</p><pre><code>load extension &lt;filepath.lcm&gt;</code></pre><p>To create a widget from script call:</p><pre><code>create widget &lt;name&gt; as &lt;identifier&gt;</code></pre><p>e.g.</p><pre><code>create widget &quot;myWidget&quot; as &quot;com.livecode.extensions.waddingham.clock&quot; </code></pre><h3><a name="//apple_ref/cpp/Guide/Extensions Course" class="dashAnchor"></a>Extensions Course</h3><p>See the online <a href="https://livecode.com/topic/introduction-2/">extensions course</a> for a thoroughintroduction to LiveCode Builder, complete with examples. The followingextension examples are worked through:* Hello World library* Extended Hello World library* Rotated Text widget* Extended Rotated Text widget* Pie Chart widget* Modifying the Line Graph widget</p><h3><a name="//apple_ref/cpp/Guide/Canvas API" class="dashAnchor"></a>Canvas API</h3><p>If you are drawing to the widget canvas in the <code>OnPaint</code> handler (as opposed to <a href="#using-native-views-for-widgets">wrapping native views</a>) it is a good idea to familiarise yourself with the canvas API. It providesa set of operations for creating, measuring, transforming and drawing paths and text.</p><h3><a name="//apple_ref/cpp/Guide/Using path objects" class="dashAnchor"></a>Using path objects</h3><p>Paths corresponding to standard shapes can be created using the variouspath &#39;constructors&#39;:</p><ul><li>Line: <code>line path from mFrom to mTo</code></li><li>Rectangle: <code>rectangle path of mRect</code></li><li>Circle: <code>circle path centered at mCenter with radius mRadius</code></li><li>Ellips: <code>ellipse path centered at mPoint with radii mRadii</code></li><li>Rounded Rectangle: <code>rounded rectangle path of mRect with (radius mRadius | radii mRadii )</code></li><li>Arc: <code>arc path centered at mCenter with [ radius mRadius | radii mRadii ] from mStartAngle to mEndAngle</code></li><li>Sector: <code>sector path centered at mCenter with [ radius mRadius | radii mRadii ] from mStartAngle to mEndAngle</code></li><li>Segment: <code>segment path centered at mCenter with [ radius mRadius | radii mRadii ] from mStartAngle to mEndAngle</code></li><li>List of points: <code>( polygon | polyline ) path with points mPoints</code></li></ul><p>To create a path using the path operations, start with an empty path object:</p><pre><code>// Create a new empty pathvariable tPath as Pathput the empty path into tPath</code></pre><p>Then use the canvas path syntax to build the path. Simple paths with nosubpaths (i.e. ones you can draw without lifting the pencil), can be created using the following operations:</p><ul><li>Line: <code>line to mPoint on mPath</code></li><li>Arc: <code>arc through mThrough to mTo with radius mRadius on mPath</code></li><li>Curve: <code>curve through mThroughA [ then mThroughB ] to mTo on mPath</code></li><li>Elliptic arc:<code>arc to mEnd with radii mRadii rotated by mAngle [ taking ( largest | smallest ) ( clockwise | anticlockwise ) route ] on mPath</code></li><li>Close path: <code>close path on mPath</code></li></ul><p>Paths made up of disjoint subpaths (i.e. ones you need to lift the pencil for) can be created using the move operation:</p><ul><li>Move: <code>move to mPoint on mPath</code></li></ul><p>For example, to create a path consisting of a pair of parallel lines:</p><pre><code>public handler OnPaint()   // Create a new empty path   variable tPath as Path   put the empty path into tPath   // Begin a new subpath of tPath   move to point [50, 50] on tPath   // Add a line to tPath   line to point [100, 50] on tPath   // Begin a new subpath of tPath   move to point [50, 100] on tPath   // Add a line to tPath   line to point [100, 100] on tPath   stroke tPath on this canvasend handler</code></pre><p><img src="images/extensions_canvas_parallel_lines.png" alt="Path with subpaths"/></p><p>The following example illustrates how the parameters to elliptic arcs work. Take the ellipse with horizontal radius 50 and vertical radius 25. The red and green arcs start from the same point; the red is the smallest clockwise route to a given point, the green is the largest anticlockwise route. Together they make up the whole ellipse:</p><pre><code>public handler OnPaint()   variable tSmallest as Path   put the empty path into tSmallest   // Start at [50, 50]   move to point [50, 50] on tSmallest   // Continue path with an arc to 100, 25   arc to point [100, 25] with radii [50, 25] rotated by 0 taking smallest clockwise route on tSmallest   variable tLargest as Path   put the empty path into tLargest   // Start at [50, 50]   move to point [50, 50] on tLargest   // Continue path with an arc to 100, 25   arc to point [100, 25] with radii [50, 25] rotated by 0 taking largest anticlockwise route on tLargest   set the paint of this canvas to solid paint with color [255,0,0]   stroke tSmallest on this canvas   set the paint of this canvas to solid paint with color [0,255,0]   stroke tLargest on this canvasend handler</code></pre><p><img src="images/extensions_canvas_elliptic_arc.png" alt="Elliptic arcs"/></p><p>Paths may also be created using SVG instructions, for example:</p><pre><code>public handler OnPaint()    variable tPath as Path   put path &quot;M10,10 L50,100 Q100,100 100,50 C75,50 50,25 50,10z&quot; into tPath   stroke tPath on this canvasend handler</code></pre><p>Produces the following:</p><p><img src="images/extensions_canvas_svgpath.png" alt="SVG path"/></p><h3><a name="//apple_ref/cpp/Guide/Rendering text" class="dashAnchor"></a>Rendering text</h3><p>There is essentially only one piece of syntax for rendering text:</p><pre><code>fill text mText at (mPoint | mAlignment of mRect) on mCanvas</code></pre><p>for example, a widget that simply displays its name at its center wouldhave the following <code>OnPaint</code> handler:</p><pre><code>public handler OnPaint()   fill text my name at center of my bounds on this canvasend handler</code></pre><p>Text can be measured using the </p><pre><code>measure mText on mCanvas</code></pre><p>syntax. This can be used for example to do text wrapping, by calculatingthe widths of successive chunks of text and inserting line breaks whereappropriate.</p><h3><a name="//apple_ref/cpp/Guide/Transformations" class="dashAnchor"></a>Transformations</h3><p>Both Path objects and canvases can be transformed using the standardaffine transforms - either using the specific translate, rotate or scalesyntax, or arbitrary transform matrices.</p><h3><a name="//apple_ref/cpp/Guide/Composed Widgets" class="dashAnchor"></a>Composed Widgets</h3><p>Widgets can either be &#39;host&#39; widgets, as in the previous example, created when a widget is directly embedded in a stack, or &#39;child&#39; widgets which are created when a widget is  used as a child widget within another widget.The syntax for composed widgets is included in the com.livecode.widget module.</p><h3><a name="//apple_ref/cpp/Guide/A simple composed widget" class="dashAnchor"></a>A simple composed widget</h3><p>This composed widget example composes the clock widget and the selector widget, to create a version of the clock widget with adjustable time zone.<img src="images/extensions-composed.png" alt="enter image description here"/>The label at the top of the widget reflects which portion of the widget the mouse is over.</p><pre><code>widget com.livecode.extensions.example.simplecomposeduse com.livecode.canvasuse com.livecode.widgetmetadata title is &quot;Simple Composed Widget&quot;metadata author is &quot;LiveCode&quot;metadata version is &quot;1.0.0&quot;private variable mInsideChild as Stringprivate variable mInside as Booleanprivate variable mSelector as Widgetprivate variable mClock as Widgetpublic handler OnCreate()    put false into mInside    put the empty string into mInsideChild    put a new widget &quot;com.livecode.extensions.livecode.selector&quot; into mSelector    set property &quot;numSelections&quot; of mSelector to 6    set annotation &quot;Name&quot; of mSelector to &quot;Selector&quot;    put a new widget &quot;com.livecode.extensions.livecode.clock&quot; into mClock    set annotation &quot;Name&quot; of mClock to &quot;Clock&quot;    place mSelector    place mClockend handlerend widget</code></pre><p>Notice that Widget is a variable type. This widget stores references to its child widgets in private variables. In the <code>OnCreate</code> handler, the widget objects are created, stored in the private variables and &#39;placed&#39;. Child widgets can be stored as variables and manipulated without actually being drawn to a canvas if they are unplaced.Properties implemented by child widgets can be got and set using the <code>property &lt;propName&gt; of &lt;child widget&gt;</code> syntax.Placing a widget ensures that they are drawn, in placement order. Setting an annotation of a child widget assigns it a tag so that when an unknown child widget is returned by an operator, its annotation can be used to identify it.</p><pre><code>public handler OnMouseEnter()    put true into mInside    if the target is not nothing then        put annotation &quot;Name&quot; of the target into mInsideChild    end if    redraw allend handlerpublic handler OnMouseLeave()    if the target is not nothing then        put the empty string into mInsideChild    end if    put false into mInside    redraw allend handler</code></pre><p>In the <em>OnMouseEnter</em> and <em>OnMouseLeave</em> handlers, <em>the target</em> is used to obtain a reference to the child widget that triggered the <em>OnMouseEnter</em> and <em>OnMouseLeave</em> events, and the previously assigned annotation put into the <code>mInsideChild</code> variable, which in turn is rendered to the canvas in the <em>OnPaint</em> handler.</p><pre><code>public handler OnPaint()    set the paint of this canvas to solid paint with color [0.75, 0.75, 0.75]    fill rectangle path of my bounds on this canvas    if mInside then        set the paint of this canvas to solid paint with color [1.0, 0.0, 0.0]        set the stroke width of this canvas to 4.0        stroke rectangle path of my bounds on this canvas    end if    if mInsideChild is not the empty string then        set the paint of this canvas to solid paint with color [0.0, 0.0, 0.0]        fill text mInsideChild at top of my bounds on this canvas    end ifend handler</code></pre><p>The rectangle of each child widget is controlled using the following syntax:* <code>the rectangle of &lt;widget&gt;</code> - Enables manipulation of the rectangle property of a child widget.* <code>the width of &lt;widget&gt;</code> - Enables manipulation of the width property of a child widget.* <code>the height of &lt;widget&gt;</code> - Enables manipulation of the height property of a child widget.* <code>the location of &lt;widget&gt;</code> - Enables manipulation of the location property of a child widget.</p><pre><code>public handler OnGeometryChanged()    set the rectangle of mSelector to rectangle [ 0, 20, my width, 50 ]    set the rectangle of mClock to rectangle [ 0, 50, my width, my height ]end handler</code></pre><p>Finally, messages posted by child widgets can be handled in the direct parent by handling the appropriate message (prepending &#39;On&#39;). For example, the selector widget posts <em>optionChanged</em> when one of its numbers is selected. This is handled by this composed widget example in an <em>OnOptionChanged</em> handler.</p><pre><code>public handler OnOptionChanged(in pIndex)    set property &quot;timeZone&quot; of mClock to pIndex - 1end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Using native APIs for libraries" class="dashAnchor"></a>Using native APIs for libraries</h3><p>One of the most powerful features of LiveCode Builder is the foreign function interface (FFI). It can be used to access native APIs on all supported platforms.</p><p>The fundamental concept involved in using the FFI is the foreign handler binding. This is a string containing information about the native functionality that is being bound to.</p><p>The format of the binding string varies slightly depending on the language of the foreign handler - for a complete specification, see theLiveCode Builder Language Reference.</p><h3><a name="//apple_ref/cpp/Guide/C" class="dashAnchor"></a>C</h3><p>In order to bind to C functions from a dynamic library, there is one essential thing to know: the signature of the function. </p><blockquote><p><strong>Note:</strong> On Windows, it is also necessary to find out the calling convention of the function. In the majority of cases if binding to functions in the Windows API, the calling convention will be <code>stdcall</code>.</p></blockquote><p>The declared types of the foreign handler must match the signature, sothat the FFI call can be computed correctly. For example, to bind to the <code>atof</code> C standard library function that converts a C-string to a double,</p><pre><code>double atof(const char *str)</code></pre><p>We could use:</p><pre><code>foreign handler C_AToF(in pString as ZStringNative) returns CDouble \    binds to &quot;atof&quot;</code></pre><p>See the <a href="https://github.com/livecode/livecode/blob/develop/docs/guides/LiveCode%20Builder%20Language%20Reference.md#the-c-binding-string">Language Reference</a> for more information on C binding strings. </p><h3><a name="//apple_ref/cpp/Guide/Callbacks" class="dashAnchor"></a>Callbacks</h3><p>When used in the context of a foreign handler definition, a foreignhandler type will cause automatic bridging of the LCB handler to a Cfunction pointer which can be called directly by the native code.</p><p>The function pointers created in this fashion have lifetimeequivalent to that of the calling context. In particular, forwidgets they will last as long as the widget does, for all othermodule types they will last as long as the module is loaded.</p><p>For example, suppose you have the following function in <code>myLib</code>:</p><p>void qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p><pre><code>void c_function_with_callback(void* p_context, bool(*func)(void* p_context))</code></pre><p>This can be bound to using the following:</p><pre><code>public foreign handler type CallbackType(in pContext as Pointer) returns CBoolforeign handler CFunctionWithCallback(in pContext as Pointer, in pHandler as CallbackType) returns nothing \    binds to &quot;myLib&gt;c_function_with_callback&quot;   handler MyCallback(in pContext as Pointer) returns CBool    ...    return trueend handlerhandler CallCFunctionWithCallback(in pContext as Pointer)    CFunctionWithCallback(pContext, MyCallback)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Using compiled libraries" class="dashAnchor"></a>Using compiled libraries</h3><p>Extensions can include compiled libraries on which they depend. The libraries must be compiled for each platform and architecture they are required on and placed folders named with a platform ID in the extension code folder. The platform ID folder names are in the form:</p><pre><code>&lt;architecture&gt;-&lt;platform&gt;[-&lt;options&gt;]</code></pre><p>See the <a href="https://github.com/livecode/livecode/blob/develop/docs/development/platform-id.md">platform ID specification</a> for more details.</p><p>On all platforms with the exception of iOS, only dynamically linked libraries are supported.</p><p>On iOS 8+ dynamically linked frameworks (.framework) are supported and on all versions of iOS statically linked frameworks and libraries (.a) are supported. Static linking is not yet supported in iOS simulator builds.</p><p>If the iOS library requires linker dependencies a text file (.txt) may be included to list them in the form:</p><pre><code>{library | [weak-]framework} &lt;name&gt;</code></pre><p>Additionally, on iOS the .lcext extension is used to identify code resources that conform to the exported symbols and sectors of externals. Specifically they have a <code>__deps</code> sector that contains the content of the dependencies file mentioned above and they export a <code>LibInfo</code> struct named <code>__libinfoptr_&lt;libraryname&gt;</code>. Examples of generating .lcext files are available in the LiveCode source repository. This is a more efficient means of inclusion as it allows the compiler to strip unused symbols.</p><h3><a name="//apple_ref/cpp/Guide/Java" class="dashAnchor"></a>Java</h3><p>Java bindings are currently supported on Android, Mac and Linux. On desktop platforms the IDE will attempt to find the correct setting forthe <code>JAVA_HOME</code> environment variable. As this can vary from distro todistro on Linux, this may fail - in this case ensure you set <code>JAVA_HOME</code> in script or using the message box. </p><h3><a name="//apple_ref/cpp/Guide/Java Platform API" class="dashAnchor"></a>Java Platform API</h3><p>On any of the supported platforms, it is possible to bind to methods andfields of classes in the Java Platform API.</p><p>For example, take the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html">java.util.UUID class</a> . Here is a simple library which uses this class to return a new pseudo-randomly generated UUID as a string:</p><pre><code>// The following comment block forms the top-level documentation of// this library/**This library allows the creation of a UUID using the Java PlatformAPI. */library com.livecode.library.javauuidmetadata title is &quot;Java UUID&quot;metadata author is &quot;LiveCode&quot;metadata version is &quot;1.0.0&quot; // Bind to the static randomUUID() method of the java.util.UUID class__safe foreign handler JNI_RandomUUID() returns JObject \    binds to &quot;java:java.util.UUID&gt;randomUUID()Ljava/util/UUID;!static&quot;// Bind to the toString() instance method of the java.util.UUID class__safe foreign handler JNI_UUIDToString(in pUUID as JObject) returns JString \    binds to &quot;java:java.util.UUID&gt;toString()Ljava/lang/String;&quot;// Library public handler - this will be accessible from LiveCode// when this library is loaded. The following comment block will// be used to generate the documentation/**Returns a new random UUID.Returns (String): The string representation of a type 4 (pseudo randomly generated) UUID.*/public handler GetRandomUUIDJava() returns String    // Call the static randomUUID method to return an instance of     // the UUID class    variable tUUID as JObject    put JNI_RandomUUID() into tUUID    // Call the toString method on the UUID instance to obtain the     // (java) string representation of the UUID    variable tUUIDString as JString    put JNI_UUIDToString(tUUID) into tUUIDString    // Convert to a LiveCode String and return    return StringFromJString(tUUIDString)end handlerend library</code></pre><h3><a name="//apple_ref/cpp/Guide/Other binding examples" class="dashAnchor"></a>Other binding examples</h3><ul><li><p>Binding to a class constructor with no parameters:</p><p>__safe foreign handler CreateJavaObject() returns JObject binds to &quot;java:java.lang.Object&gt;new()&quot;</p></li><li><p>Binding to a class constructor with parameters:</p><p>__safe foreign handler CreateJavaString(in pBytes as JByteArray) returns JString binds to &quot;java:java.lang.String&gt;new([B)&quot;</p></li><li><p>Binding to a class instance method</p><p>__safe foreign handler JavaStringIsEmpty(in pString as JString) returns JBoolean binds to &quot;java:java.lang.String&gt;isEmpty()Z&quot;</p></li><li><p>Binding to a class static method</p><p>__safe foreign handler CallJavaAdd(in pLeft as JInt, in pRight as JInt) returns JInt binds to &quot;java:java.lang.Math&gt;addExact(JJ)J!static&quot;</p></li><li><p>Binding to a class field</p><p>__safe foreign handler JavaCalendarSetTime(in pCalendar as JObject, in pTime as JLong) returns nothing binds to &quot;java:java.util.Calendar&gt;set.time(J)&quot;__safe foreign handler JavaCalendarGetTime(in pCalendar as JObject) returns JLong binds to &quot;java:java.util.Calendar&gt;get.time()J&quot;</p></li><li><p>Binding to a class constant</p><p>__safe foreign handler GetJavaPi() returns JDouble binds to &quot;java:java.lang.Math&gt;get.PI()D!static&quot;</p></li></ul><h3><a name="//apple_ref/cpp/Guide/Android API" class="dashAnchor"></a>Android API</h3><p>On Android it is possible to access the standard platform APIs usingJava FFI.</p><p><a href="https://github.com/livecode/livecode/blob/develop/extensions/libraries/toast/toast.lcb">https://github.com/livecode/livecode/blob/develop/extensions/libraries/toast/toast.lcb</a></p><h3><a name="//apple_ref/cpp/Guide/Third%2Dparty libraries" class="dashAnchor"></a>Third-party libraries</h3><p>The standalone builder will look for .jar files in the <code>code/jvm</code> folderof an extension package and load them automatically on startup of astandalone. Due to the way things currently work, testing extensions with jar files in the IDE is not supported. However it can be done by setting the CLASSPATH environment variable before the Java VirtualMachine is initialized. See <a href="#custom-java-classes">Custom Java classes</a> for an example of how to do this.</p><p>For android, the possibilities for including third-party libraries expands substantially. The <code>code/jvm-android</code> folder of an extension package can contain .jar and .aar files, and obviously the .jar filescan make use of the Android API.</p><p>Classes in .jar files (either included directly, or within .aar packages) can be accessed using Java FFI in exactly the same way asclasses in the Android API.</p><p>.aar packages can also contain resources and AndroidManifest.xml files - these are merged with the manifest and resources generated by LiveCodewhen building an Android application.</p><h3><a name="//apple_ref/cpp/Guide/Custom Java classes" class="dashAnchor"></a>Custom Java classes</h3><p>As .jar file code resources are supported, you can write and compile custom Java classes for use with an LCB extension. </p><p>Assuming the current folder is the root of an extension, consider the following java code, in a file java/com/livecode/library/helloworldjava/HelloWorld.java:</p><pre><code>package com.livecode.library.helloworldjava;public class HelloWorld {    public static String sayHello()    {        return &quot;Hello World!&quot;    }}</code></pre><p>This can be compiled and packaged using java command-line tools:</p><pre><code>javac java/com/livecode/library/helloworldjava/HelloWorld.javajar cvf code/jvm/HelloWorld.jar -C java .</code></pre><p>Now there should be a HelloWorld.jar file in the appropriate location relative to the extension.</p><p>In helloworld.lcb,</p><pre><code>library com.livecode.library.helloworldjavause com.livecode.foreignuse com.livecode.java__safe foreign handler JNI_SayHello() returns JString \    binds to &quot;java:com.livecode.library.helloworldjava.HelloWorld&gt;sayHello()Ljava/lang/String;&quot;public handler SayHello() returns String    return StringFromJString(JNI_SayHello())end handlerend library</code></pre><p>A standalone including this extension would be able to execute the script</p><pre><code>answer SayHello() </code></pre><p>to pop up an answer dialog with the text &quot;Hello World!&quot;. Obviously that is a rather circuitous route when you can already do </p><pre><code>answer &quot;Hello World!&quot;</code></pre><p>but it does open up a lot of possibilities for interoperation with Javalibraries.</p><p>One such application would be the ability to record .wav files on Android. The MediaPlayer class does not come equipped with this functionality. </p><p>This can be compiled and packaged using java command-line tools, ensuring the appropriate android.jar is included in the dependencies (here we assume the location of the android toolchain is standard andthe android-23 platform is downloaded):</p><pre><code>javac -cp ~/android/toolchain/android-sdk/platforms/android-23/android.jar java/src/com/livecode/library/androidwavrecorder/ExtAudioRecorder.javajar cvf code/jvm-android/AndroidWavRecorder.jar -C java/src .</code></pre><p>Now there should be a AndroiWavRecorder.jar file in the appropriate location relative to the extension. </p><h3><a name="//apple_ref/cpp/Guide/Objective%2DC" class="dashAnchor"></a>Objective-C</h3><p>The types used in Objective-C foreign handler declarations are the usual C types, plus a few special ones for handling Obj-C <code>id</code> objects. Theseare:</p><ul><li><code>ObjcId</code> - an id with no implicit action on its reference count</li><li><code>ObjcRetainedId</code> - an id which is expected to already have been retained. (i.e. the caller or callee expects to receive it with +1 ref count)</li><li><code>ObjcAutoreleasedId</code> - an id which has been placed in the innermost autorelease pool before being returned to the caller</li></ul><p>The <code>ObjcObject</code> type is a wrapper round the raw <code>ObjcId</code> types, which manages the lifetime of the obj-c object it contains. It should generally be used when using obj-c objects within LCB.</p><p>Objective-C binding strings mirror as closely as possible the structure of method declarations in Objective-C. For example, the class <code>NSSpeechSynthesizer</code> has methods</p><pre><code>- (id)initWithVoice:(NSString *)voice;- (BOOL)startSpeakingString:(NSString *)string;</code></pre><p>In order to create an instance of the class, we first use the superclass <code>NSObject</code>&#39;s</p><pre><code>+ (id)alloc;</code></pre><p>method to allocate an instance, and then call <code>initWithVoice:</code> on it:</p><pre><code>foreign handler Objc_NSSpeechSynthesizerAlloc() returns ObjcRetainedId \    binds to &quot;objc:NSSpeechSynthesizer.+alloc&quot;</code></pre><p>The <code>+</code> indicates this is a class method, i.e. we don&#39;t require an instance of the class to call the method. </p><pre><code>foreign handler Objc_NSSpeechSynthesizerInitWithVoice(in pSynthesizer as ObjcId, in pVoice as optional ObjcId) returns ObjcId \    binds to &quot;objc:NSSpeechSynthesizer.-initWithVoice:&quot;</code></pre><p>The <code>-</code> here indicates this is an instance method, i.e. we require an instance of the class to call the method. This is always the first parameter. We can then create and initialize an NSSpeechSynthesizer using the following. We pass <code>nothing</code> to <code>initWithVoice:</code> to use thedefault voice.</p><pre><code>handler CreateSpeechSynthesizer() returns ObjcObject    variable tSynthesizer as ObjcObject    put Objc_NSSpeechSynthesizerAlloc() into tSynthesizer    return Objc_NSSpeechSynthesizerInitWithVoice(tSynthesizer, \        nothing)end handler</code></pre><p>To speak, we would bind to the <code>startSpeakingString:</code> method:</p><pre><code>foreign handler Objc_NSSpeechSynthesizerStartSpeaking(in pSynthesizer as ObjcId, in pString as ObjcId) returns CBool \    binds to &quot;objc:NSSpeechSynthesizer.-startSpeakingString:&quot;</code></pre><p>Then expose a public library handler to enable calls from LiveCode.</p><pre><code>private variable mSynthesizer as optional ObjcObjectpublic handler SynthesizeSpeech(in pString as String) returns Boolean    if mSynthesizer is nothing then        put CreateSpeechSynthesizer() into mSynthesizer    end if    Objc_NSSpeechSynthesizerStartSpeaking(mSynthesizer, \        StringToNSString(pString))end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Callbacks" class="dashAnchor"></a>Callbacks</h3><p>Callbacks are usually handled by creating delegates. A class delegate handles the events associated with that class and marshalls the callback message.</p><p>Objective-C delegate objects with LCB implementations of protocol methods can be created using the <code>CreateObjcDelegate</code> and <code>CreateObjcInformalDelegate</code> handlers, provided by the com.livecode.objc module.</p><p>In order to create a delegate to handle a particular protocol method, pass in the protocol name as the first argument and the mapping from method names to LCB handlers as the second argument. For example, to create a selectionChanged message for an <code>NSTextView</code>, we need to create a handler</p><pre><code>private handler DidChangeSelection(in pNotification as ObjcObject) returns nothing    post &quot;selectionChanged&quot;end handler</code></pre><p>and create a <code>NSTextViewDelegate</code>:</p><pre><code>variable tDelegate as optional ObjcObjectput CreateObjcDelegate( \    &quot;NSTextViewDelegate&quot;, \         {&quot;textViewDidChangeSelection:&quot;: DidChangeSelection}, \    ) into tDelegateif tDelegate is not nothing then    put tDelegate into mTextViewDelegateend if</code></pre><p>Optionally, a context parameter can be passed in at delegate creationtime:</p><pre><code>put CreateObjcDelegateWithContext( \    &quot;NSTextViewDelegate&quot;, \         {&quot;textViewDidChangeSelection:&quot;: DidChangeSelectionContext}, \    tContext) into tDelegateif tDelegate is not nothing then    put tDelegate into mTextViewDelegateend if</code></pre><p>In this case the context variable will be passed as first argument of the corresponding LCB callback:</p><pre><code>private handler DidChangeSelectionContext(in pContext, in pNotification as ObjcObject) returns nothing    post &quot;selectionChanged&quot; with [pContext]end handler</code></pre><p>Some protocols consist of purely optional methods. In this case the information about the protocol&#39;s methods are not available from the<br/>objective-c runtime API. For this eventuality there are also handlers<code>CreateObjcInformalDelegate</code> and <code>CreateObjcInformalDelegateWithContext</code>.</p><p>These handlers take a list of foreign handlers as their first argumentinstead of a protocol name. The foreign handlers&#39; information is used toresolve incoming selectors so that the desired LCB callback is called. For example the <code>NSSoundDelegate</code> protocol has only one method, and it is optional, </p><pre><code>- (void)sound:(NSSound *)sound didFinishPlaying:(BOOL)aBool;</code></pre><p>So in order to create an <code>NSSoundDelegate</code>, we need to create a list offoreign handlers, in this case just the following:</p><pre><code>foreign handler NSSoundDidFinishPlaying(in pSound as ObjcId, in pDidFinish as CSChar) binds to &quot;objc:.-sound:didFinishPlaying:&quot;</code></pre><p>and create the informal delegate</p><pre><code>handler DidSoundFinish(in pSound as ObjcId, in pDidFinish as Boolean) returns nothing    if pDidFinish then        post &quot;soundFinished&quot;    end ifend handlerforeign handler Objc_SetSoundDelegate(in pSound as ObjcId, in pDelegate as ObjcId) returns nothing \    binds to &quot;objc:NSSound.-setDelegate:&quot;...variable tDelegate as optional ObjcObjectput CreateObjcInformalDelegate( \    [NSSoundDidFinishPlaying], \        {&quot;textViewDidChangeSelection:&quot;: DidChangeSelection}) \    into tDelegateend ifif tDelegate is not nothing then    put tDelegate into mSoundDelegate    Objc_SetSoundDelegate(tSound, tDelegate)end if</code></pre><blockquote><p><em>Note:</em> Delegate properties are usually &#39;assigned&#39; rather than &#39;retained&#39;, so it is necessary to store them in module variables until they are no longer needed. Generally the pattern required isas follows:</p></blockquote><pre><code>handler OnOpen()    -- Create native view and set native layer    -- Set native view delegate property    -- Store view and delegate in module varsend handlerhandler OnClose()    -- Set native view delegate property to nothing    -- Put nothing into view and delegate module vars    -- Set native layer to nothingend handler</code></pre><p>For our speech synthesizer example, suppose we want to post a message when the speaking is finished. In NSSpeechSynthesizer.h, we can see thedefinition of the <code>NSSpeechSynthesizerDelegate</code>:</p><pre><code>@protocol NSSpeechSynthesizerDelegate &lt;NSObject&gt;@optional- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didFinishSpeaking:(BOOL)finishedSpeaking;...</code></pre><p>The first thing to note is that the protocol methods are all optional.This means that we have to use an informal delegate. To attach an LCB handler to the didFinishSpeaking event, we need to define both the foreign handler that binds to the protocol method and the LCB handler that should be called. Again this is an instance method of the delegate class, so the first parameter will be the delegate itself. </p><p>Again since the protocol method is optional, it will not be found if webind to <code>NSSpeechSynthesizerDelegate.-speechSynthesizer:didFinishSpeaking:</code>, so it is necessary to use dynamic binding for the foreign handler (i.e. simply omitting the class in the binding string):</p><pre><code>foreign handler Objc_SpeechSynthesizerDidFinishSpeaking(in pSynthesizerDelegate as ObjcId, in pSynthesizer as ObjcId, in pFinished as CBool) returns nothing \    binds to &quot;objc:.-speechSynthesizer:didFinishSpeaking:&quot;handler OnDidFinishSpeaking(in pSynthesizerDelegate as ObjcId, in pSynthesizer as ObjcId, in pFinished as CBool) returns nothing    post &quot;finishedSpeaking&quot;end handlerforeign handler Objc_SpeechSynthesizerSetDelegate(in pSynthesizer as ObjcId, in pDelegate as ObjcId) returns nothing \    binds to &quot;objc:NSSpeechSynthesizer.-setDelegate:&quot;handler SetSpeechSynthesizerDelegate()    variable tDelegate as ObjcObject    put CreateObjcInformalDelegate( \        [Objc_SpeechSynthesizerDidFinishSpeaking], \        { &quot;speechSynthesizer:didFinishSpeaking:&quot;: \          OnDidFinishSpeaking }) into tDelegate    Objc_SpeechSynthesizerSetDelegate(mSynthesizer, tDelegate)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Using native views for widgets" class="dashAnchor"></a>Using native views for widgets</h3><p>The key piece of syntax for creating widgets that hook into native view objects is <code>my native layer</code>:</p><pre><code>set my native layer to tView</code></pre><p>The <code>tView</code> object is different on each platform, as is the method of specifying LCB handlers for native view event callbacks. We will use theexample of a native button on each platform to illustrate this, wherepossible.</p><p>The native layer should be created and destroyed every time the cardthe widget is on is opened and closed respectively. Therefore the pattern that should be adopted when writing a native widget is to usethe <code>OnOpen</code> and <code>OnClose</code> messages as follows:</p><pre><code>private variable mNativeLayer as optional Pointerhandler OnOpen()    put CreateNativeLayer() into mNativeLayer    set my native layer to mNativeLayerend handlerhandler OnClose()    set my native layer to nothing    put nothing into mNativeLayerend handler</code></pre><p>When using a native layer, a widget&#39;s <code>OnPaint</code> handler is not called.However it is recommended to provide some sort of placeholder <code>OnPaint</code>method to represent the widget when the native layer is not supportedon the current platform.</p><h3><a name="//apple_ref/cpp/Guide/Android" class="dashAnchor"></a>Android</h3><h3><a name="//apple_ref/cpp/Guide/Native view" class="dashAnchor"></a>Native view</h3><p>Native views on Android are classes derived from android.view.View. The Android button widget&#39;s native layer is an instance of the <code>android.widget.Button</code> class:</p><pre><code>?   android.view.View    ?   android.widget.TextView        ?   android.widget.Button</code></pre><p>The following snippet shows how to bind to the button constructor and set the native layer:</p><pre><code>// Bind to Android engine methods in order to fetch the application// Context__safe foreign handler _JNI_GetAndroidEngine() returns JObject \    binds to &quot;java:com.runrev.android.Engine&gt;getEngine()Lcom/runrev/android/Engine;!static&quot;__safe foreign handler _JNI_GetEngineContext(in pEngine as JObject) returns JObject \    binds to &quot;java:android.view.View&gt;getContext()Landroid/content/Context;&quot;// Bind to the android.widget.Button constructor__safe foreign handler _JNI_ButtonNew(in pContext as JObject) returns JObject \    binds to &quot;java:android.widget.Button&gt;new(Landroid/content/Context;)?ui&quot;// Store a reference to the native viewprivate variable mNativeView as optional JObjecthandler CreateNativeLayer() returns Pointer    // Fetch the application Context    variable tContext as JObject    put _JNI_GetEngineContext(_JNI_GetAndroidEngine()) into tContext    // Create an instance of the android.widget.Button class    put _JNI_ButtonNew(tContext) into mNativeView    return PointerFromJObject(mNativeView)end handlerhandler SetNativeLayer()    set my native layer to CreateNativeLayer()end handler</code></pre><p>View objects on Android always require the application Context in theirconstructors.</p><p>View objects should always be created on the UI thread.</p><h3><a name="//apple_ref/cpp/Guide/Event handlers" class="dashAnchor"></a>Event handlers</h3><p>A button widget is obviously not complete without an action callback. Wewant a message to be received by the widget object in LiveCode wheneverthe native view is clicked. </p><p>On Android, the general procedure is to attach a <code>Listener</code> to an object. In Java, <code>Listener</code>s are classes which implement a specified setof callback methods defined in that listener&#39;s interface. The general method of defining <a href="#interface-proxy-callbacks">interface callbacks on Android</a>is used to create listeners with LCB handler callbacks. </p><p>The following snippet shows how to attach an <code>OnClickListener</code> to the Button instance:</p><pre><code>// Define handler type for button click callback. This matches// the android.view.View.OnClickListener&#39;s //      abstract void onClick(View v)// method.handler type ClickCallback(in pView as JObject) returns nothing// Bind to the interface proxy method. Since there is only one // method to be implemented for the OnClickListener interface,// we just pass in a handler of the appropriate type.__safe foreign handler _JNI_OnClickListener(in pHandler as ClickCallback) returns JObject \    binds to &quot;java:android.view.View$OnClickListener&gt;interface()&quot;// Bind to the method used to set the OnClickListener on the// Button object.__safe foreign handler _JNI_SetOnClickListener(in pButton as JObject, in pListener as JObject) returns nothing \    binds to &quot;java:android.view.View&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V?ui&quot;// Actual handler (of type ClickCallback) that will be called// when the button is clickedhandler OnButtonClick(in pView as JObject) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;mouseUp&quot;    // Ensure the engine thread is notified of a pending event    MCEngineRunloopBreakWait()end handler// Store the OnClickListener object in a private variableprivate variable mOnClickListener as optional JObject// Set the OnClickListenerhandler SetOnClickListener(in pButton as JObject) returns nothing    // Pass the OnButtonClick handler in the call to create a     // listener    put _JNI_OnClickListener(OnButtonClick) into mOnClickListener    // Set the OnClickListener on a Button instance    _JNI_SetOnClickListener(pButton, mOnClickListener)end handler</code></pre><p>Sometimes listener interfaces have multiple callback methods, for different events. In this case, you must pass an array mapping callback method names to handlers so that the correct handler is called for eachevent. This can also be done with single-method interfaces, and indeedis the recommended style to use as it will continue to work even ifadditional callback methods are added to the interface in subsequent API levels.</p><p>Switching to this style would require two small tweaks to the above code:</p><pre><code>// Bind to the interface proxy method.__safe foreign handler _JNI_OnClickListener(in pMapping as Array) returns JObject \    binds to &quot;java:android.view.View$OnClickListener&gt;interface()&quot;...// Set the OnClickListenerhandler SetOnClickListener(in pButtonView as JObject) returns nothing    // Map the OnButtonClick handler to the onClick method    put _JNI_OnClickListener({&quot;onClick&quot;:OnButtonClick}) \        into mOnClickListener    // Set the OnClickListener on a Button instance    _JNI_SetOnClickListener(pButtonView, mOnClickListener)end handler     </code></pre><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>Properties of Android native views can be set using methods of the view (or one of its parent classes). For example, to hook up the enabled property of the button, we bind to the <code>setEnabled</code> method of the parent<code>TextView</code> class:</p><pre><code>__safe foreign handler _JNI_SetTextViewEnabled(in pView as JObject, in pValue as JBoolean) returns nothing \    binds to &quot;java:android.view.View&gt;setEnabled(Z)V?ui&quot;handler SetEnabled(in pButtonView as Pointer)    _JNI_SetTextViewEnabled(pButtonView, my enabled)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/iOS" class="dashAnchor"></a>iOS</h3><h3><a name="//apple_ref/cpp/Guide/Native view" class="dashAnchor"></a>Native view</h3><p>Native views on iOS are classes derived from UIView. The iOS button widget&#39;s native layer is an instance of the <code>UIButton</code> class.</p><p>The following snippet shows how to bind to the button constructor and set the native layer:</p><pre><code>// Define an alias for CULongprivate type NSUInteger is CULong// Bind to the UIButton class method buttonWithType:private foreign handler ObjC_UIButtonButtonWithType(in pType as NSUInteger) returns ObjcId binds to &quot;objc:UIButton.+buttonWithType:?ui&quot;// For a standard push button we need the type to be // UIButtonTypeSystem, which is 1constant UIButtonTypeSystem is 1// Store a reference to the native viewprivate variable mNativeView as optional ObjcObjectunsafe handler CreateNativeLayer() returns Pointer    // Create an instance of the UIButton class    variable tButtonInstance as ObjcObject    put ObjC_UIButtonButtonWithType(UIButtonTypeSystem) \        into mNativeView    // Return the pointer    return PointerFromObjcObject(mNativeView)end handlerhandler SetNativeLayer()    set my native layer to CreateNativeLayer()end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Event handlers" class="dashAnchor"></a>Event handlers</h3><p>Views on iOS relay information about user interactions using either the <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html">target-action paradigm</a> or <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html">delegation</a></p><p>In general, simple widgets will use the target-action paradigm. In general, refer to the documentation for the particular class you are wrapping. According to the <code>UIButton</code> <a href="https://developer.apple.com/documentation/uikit/uibutton">API</a>, in thesection &#39;Responding to Button Taps&#39;, the <code>UIButton</code> class uses the target-action paradigm.</p><p>So, we can post a message to the widget script object in response to the click action as follows:</p><pre><code>// Bind to the UIButton addTarget:action:forControlEvents: methodprivate foreign handler ObjC_UIButtonAddTargetActionForControlEvents(in pObj as ObjcId, in pTarget as ObjcId, in pAction as UIntPtr, in pControlEvents as NSUInteger) returns nothing binds to &quot;objc:UIButton.-addTarget:action:forControlEvents:?ui&quot;// Actual handler that will be called when the button is clickedhandler OnButtonClick(in pSender as ObjcObject, in pContext as optional any) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;mouseUp&quot;    // Ensure the engine thread is notified of a pending event    MCEngineRunloopBreakWait()end handler// Store the action proxy object in a private variableprivate variable mButtonProxy as optional ObjcObject// The push button action type is UIControlEventTouchUpInside,// which is 1 &lt;&lt; 6. Constants cannot be evaluated expressions, so// just define the bit shiftconstant UIControlEventTouchUpInsideBit is 6// Add the target actionunsafe handler AddTargetAction(in pButtonView as ObjcObject) returns nothing    // Create a proxy for the button object. This will receive the     // button events and call the provided callback handler    put ObjcProxyGetTarget(OnButtonClick, nothing) into mButtonProxy    // Add the target-action to the button view    ObjC_UIButtonAddTargetActionForControlEvents(pButtonView, \        mButtonProxy, ObjcProxyGetAction(), \        1 shifted left by UIControlEventTouchUpInsideBit bitwise)end handler</code></pre><p>More complex views on iOS require creation of delegates. For example, there are several different user interactions possible with then <code>UITextField</code> view. In order to handle these interactions, we createa <code>UITextFieldDelegate</code> - see the <a href="https://developer.apple.com/documentation/uikit/uitextfielddelegate?language=objc">API</a>for the list of events that can be handled. </p><p>In this example we hook up <code>openField</code> and <code>textChanged</code> messages:</p><pre><code>// Bind to the text field&#39;s delegate property setterprivate foriegn handler Objc_SetTextFieldDelegate(in pTextField as ObjcId, in pDelegate as ObjcId) returns nothing \    binds to &quot;objc:UITextField.-setDelegate:?ui&quot;// Handler to be called when the field is openedhandler OnOpenField(in pField as ObjcId) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;openField&quot;    // Ensure the engine thread is notified of a pending event    MCEngineRunloopBreakWait()end handler // Define the NSRange type, one of the parameters in the // textFieldShouldChangeCharactersInRange methodpublic foreign type NSRange binds to &quot;MCAggregateTypeInfo:ff&quot;// Handler to be called when the field text is changedhandler OnTextChanged(in pField as ObjcId, in pRange as NSRange, in pReplacement as ObjcId) returns CBool    // The widget object in LiveCode will receive the posted message    post &quot;textChanged&quot;    // Ensure the engine thread is notified of a pending event    MCEngineRunloopBreakWait()    // Allow the text to be changed    return trueend handler     // Store the delegate in a private variableprivate variable mTextFieldDelegate as optional ObjcObject// Set the delegateunsafe handler SetTextFieldDelegate(in pTextFieldView as ObjcObject) returns nothing    // Create a delegate mapping the textFieldDidBeginEditing:     // method to OnOpenField, and the     // textFieldShouldChangeCharactersInRange: method to     // OnTextChanged    // First define the mapping    variable tMapping as Array    put { &quot;textFieldDidBeginEditing:&quot;: OnOpenField, \          &quot;textField:shouldChangeCharactersInRange:replacementString:&quot;: \          OnTextChanged } into tMapping    put CreateObjcDelegate(&quot;UITextFieldDelegate&quot;, tMapping) \        into mTextFieldDelegate    Objc_TextFieldSetDelegate(pTextFieldView, mTextFieldDelegate)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>Properties of iOS native views can be set using methods of the view (orone of its parent classes). For example, to hook up the enabled property:</p><pre><code>foreign handler ObjC_UIButtonSetEnabled(in pObj as ObjcId, in pEnabled as CBool) returns nothing \    binds to &quot;objc:UIButton.-setEnabled:?ui&quot;handler SetEnabled(in pButtonView as Pointer)    ObjC_UIButtonSetEnabled(pButtonView, my enabled)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Mac" class="dashAnchor"></a>Mac</h3><p>Native views on Mac are classes derived from NSView. The Mac button widget&#39;s native layer is an instance of the <code>NSButton</code> class.</p><p>The following snippet shows how to bind to the button constructor and set the native layer:</p><pre><code>// Define an alias for CULongprivate type NSUInteger is CULong// Bind to the NSButton class method to allocate a new NSButtonprivate foreign handler ObjC_NSButtonAlloc() returns ObjcRetainedId binds to &quot;objc:NSButton.+alloc&quot;// Bind to the NSButton instance method to initialize an NSButtonprivate foreign handler ObjC_NSButtonInit(in pObj as ObjcId) returns ObjcId binds to &quot;objc:NSButton.-init&quot;// Bind to NSButton instance methods setButtonType:, setBezelStyle:,// and -setBordered:private foreign handler ObjC_NSButtonSetButtonType(in pObj as ObjcId, in pStyle as NSUInteger) returns nothing binds to &quot;objc:NSButton.-setButtonType:&quot;private foreign handler ObjC_NSButtonSetBezelStyle(in pObj as ObjcId, in pStyle as NSUInteger) returns nothing binds to &quot;objc:NSButton.-setBezelStyle:&quot;private foreign handler ObjC_NSButtonSetBordered(in pObj as ObjcId, in pBordered as CBool) returns nothing binds to &quot;objc:NSButton.-setBordered:&quot;// For a standard push button we need:// buttonType to be NSMomentaryPushInButton = 7// bezelStyle to be NSRoundedBezelStyle = 1constant kNSMomentaryPushInButton is 7constant kNSRoundedBezelStyle is 1// Store a reference to the native viewprivate variable mNativeView as optional ObjcObjectunsafe handler CreateNativeLayer() returns Pointer    // Create an instance of the NSButton class    variable tButtonInstance as ObjcObject    put ObjC_NSButtonInit(ObjC_NSButtonAlloc()) into mNativeView    // Set the properties we need for a push button    ObjC_NSButtonSetButtonType(mNativeView, kNSMomentaryPushInButton)    ObjC_NSButtonSetBezelStyle(mNativeView, kNSRoundedBezelStyle)    ObjC_NSButtonSetBordered(mNativeView, true)         // Return the pointer    return PointerFromObjcObject(mNativeView)end handlerhandler SetNativeLayer()    set my native layer to CreateNativeLayer()end handler</code></pre><p>Views on Mac relay information about user interactions using either the <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html">target-action paradigm</a> or <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html">delegation</a></p><p>In general, simple widgets will use the target-action paradigm. In general, refer to the documentation for the particular class you are wrapping. The <code>NSButton</code> uses the target-action paradigm.</p><p>So, we can post a message to the widget script object in response to the click action as follows:</p><pre><code>private foreign handler ObjC_NSButtonSetTarget(in pObj as ObjcId, in pTarget as ObjcId) returns nothing binds to &quot;objc:NSButton.-setTarget:&quot;private foreign handler ObjC_NSButtonSetAction(in pObj as ObjcId, in pAction as UIntPtr) returns nothing binds to &quot;objc:NSButton.-setAction:&quot;// Actual handler that will be called when the button is clickedhandler OnButtonClick(in pSender as ObjcObject, in pContext as optional any) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;mouseUp&quot;    // Ensure the engine thread is notified of a pending event    MCEngineRunloopBreakWait()end handler// Store the action proxy object in a private variableprivate variable mButtonProxy as optional ObjcObject// Add the target actionunsafe handler AddTargetAction(in pButtonView as ObjcObject) returns nothing        put ObjcProxyGetTarget(OnButtonClick, nothing) \        into mButtonProxy    ObjC_NSButtonSetTarget(pButtonView, mButtonProxy)    ObjC_NSButtonSetAction(pButtonView, ObjcProxyGetAction())end handler</code></pre><p>More complex views on Mac require creation of delegates. See the discussion of delegates on iOS for more information.</p><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>Properties of Mac native views can be set using methods of the view (orone of its parent classes). For example, to hook up the enabled property:</p><pre><code>foreign handler ObjC_NSButtonSetEnabled(in pObj as ObjcId, in pEnabled as CBool) returns nothing \    binds to &quot;objc:NSButton.-setEnabled:&quot;handler SetEnabled(in pButtonView as Pointer)    ObjC_NSButtonSetEnabled(pButtonView, my enabled)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Windows" class="dashAnchor"></a>Windows</h3><blockquote><p><strong>Important:</strong> It is not yet possible to write a fully functionalnative widget on Windows, as there is no method to capture events onthe native view and pass them back to LiveCode Builder. This will beaddressed in future releases.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Native view" class="dashAnchor"></a>Native view</h3><p>Native views on Windows are HWNDs. The <code>CreateWindowEx</code> function is usedto create HWNDs with specified properties. See the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85%29.aspx">API documentation</a> for details on the parameters taken by <code>CreateWindowEx</code>.</p><p>The following snippet shows how to bind to <code>CreateWindowEx</code>, and use it to set the native layer to a button HWND:</p><pre><code>// Alias the types used in native callspublic type DWORD is CULongpublic type WIDESTRING is ZStringUTF16public type HINSTANCE is Pointerpublic type HMENU is Pointerpublic type HWND is Pointer// Bind to the CreateWindowEx function. It is defined in the // user32.dll library (hence `user32&gt;` in the binding string). // The CreateWindowEx function definition is preceded by the WINAPI // macro, which means it uses the stdcall calling convention (hence// `!stdcall` in the binding string)foreign handler CreateWindow(in pEx as DWORD, \    in pString as WIDESTRING, in pLabel as WIDESTRING, \    in pStyle as DWORD, in pX as CInt, in pY as CInt, \    in pWidth as CInt, in pHeight as CInt, in pParent as HWND, \    in pMenu as optional HMENU, in pInstance as optional HINSTANCE, \    in pParam as optional Pointer) \    returns HWND binds to &quot;user32&gt;CreateWindowExW!stdcall&quot;private variable mNativeView as optional Pointer// Constants for the CreateWindow style parameter. We construct the// DWORD by taking the bitwise or of the styles that aree // appropriate.// BS_DEFPUSHBUTTON is the push button style constantconstant BS_DEFPUSHBUTTON is 1// WS_CHILD is the child window style constant. If this is not used// then `CreateWindowEx` creates a new main window.constant WS_CHILD is 1073807361// CreateWindowEx requires the parent view pointer to be passed inunsafe handler CreateNativeView(in pParentView as Pointer)    // Compute the style DWORD    variable tStyle as DWORD    put WS_CHILD bitwise or BS_DEFPUSHBUTTON into tStyle    // Pass in the predefined BUTTON window class    variable tWindowClass as String    put &quot;BUTTON&quot; into tWindowClass    // Call CreateWindow, with empty/default values for all other    // parameters    put CreateWindow(0, tWindowClass, &quot;&quot;, tStyle, 0, 0, 0, 0, \        pParentView, nothing, nothing, nothing) \        into mNativeView    return mNativeViewend handlerunsafe handler SetNativeLayer()    // Get the parent view pointer    variable tParentView as Pointer    MCWidgetGetMyStackNativeView(tParentView)           set my native layer to CreateNativeLayer(tParentView)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Event handlers" class="dashAnchor"></a>Event handlers</h3><p>As the general callback method has not yet been implemented on Windows,<br/>unfortunately widgets that require user interaction are not yet possible. However, native widgets can be written that have only properties and no user interaction, such as a progress indicator orlabel field.</p><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>Properties of Windows native views can be set using functions in the user32 dll. For example, to hook up the enabled property of a Windows button:</p><pre><code>foreign handler EnableWindow(in pView as Pointer, in pEnable as CInt) \    returns CInt binds to &quot;user32&gt;EnableWindow!stdcall&quot;handler SetEnabled(in pButtonView as Pointer)    EnableWindow(pButtonView, my enabled)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Linux" class="dashAnchor"></a>Linux</h3><blockquote><p><strong>Important:</strong> It is not yet possible to write a fully functionalnative widget on Linux, as there are some issues with event handlingand focus. This will be addressed in future releases.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Native view" class="dashAnchor"></a>Native view</h3><p>Native views on Linux are <code>GtkPlug</code>s. A <code>GtkSocket</code> is used internally to render the view from the process in which it is running. In mostinstances you will want to embed a <code>GtkWidget</code> in a <code>GtkPlug</code>.</p><p>The following snippet shows how to bind to <code>gtk_button_new_with_label</code>, and use it to set the native layer to a suitable gtk plug id:</p><pre><code>// Bind to various useful functions in libgtk. We need to create a// GTK plug, and GTK button, add the button to the plug and then// show them. foreign handler GTK_PlugNew(in pType as CUInt) returns Pointer \    binds to &quot;c:libgtk-x11-2.0.so&gt;gtk_plug_new&quot;foreign handler GTK_ButtonNewWithLabel(in pLabel as ZStringNative) returns Pointer binds to \    &quot;c:libgtk-x11-2.0.so&gt;gtk_button_new_with_label&quot;foreign handler GTK_ContainerAdd(in pContainer as Pointer, in pWidget as Pointer) returns nothing \    binds to &quot;c:libgtk-x11-2.0.so&gt;gtk_container_add&quot;foreign handler GTK_WidgetShow(in pWidget as Pointer) returns nothing binds to \    &quot;c:libgtk-x11-2.0.so&gt;gtk_widget_show&quot;// The actual native layer will be set to the plug idforeign handler GTK_PlugGetId(in pPlug as Pointer) returns Pointer \    binds to &quot;c:libgtk-x11-2.0.so&gt;gtk_plug_get_id&quot;      // Store references to both the plug and buttonprivate variable mPlug as optional Pointerprivate variable mNativeView as optional Pointerunsafe handler CreateNativeView() returns Pointer    // Create a new default plug    put GTK_PlugNew(0) into mPlug    // Create a button with empty label    put GTK_ButtonNewWithLabel(&quot;&quot;) into mNativeView    // Add the button to the plug    GTK_ContainerAdd(mPlug, mNativeView)    // Ensure both button and plug are visible    GTK_WidgetShow(mNativeView)    GTK_WidgetShow(mPlug)    // Return the plug window id    return GTK_PlugGetId(mPlug)end handlerunsafe handler SetNativeLayer()    set my native layer to CreateNativeLayer()end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Event handlers" class="dashAnchor"></a>Event handlers</h3><p>Event callbacks are pretty simple on Linux, as you can pass a (foreign)handler into <code>g_signal_connect_data</code> directly:</p><pre><code>// Define the callback foreign handler typepublic foreign handler type ClickCallback(in pWidget as Pointer, in pContext as optional Pointer) returns nothing// Bind to g_signal_connect_data to connect a foreign handler to // a gtk signalforeign handler GTK_SignalConnect(in pObj as Pointer, in pEvent as ZStringNative, \    in pHandler as ClickCallback, in pData as optional Pointer, \    in pNotify as optional Pointer, in pFlags as CUInt) returns CULong \    binds to &quot;c:libgtk-x11-2.0.so&gt;g_signal_connect_data&quot;// Actual handler that will be called when the button is clickedhandler OnButtonClick(in pWidget as Pointer, in pContext as optional Pointer) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;mouseUp&quot;end handlerunsafe handler SignalConnect(in pButtonView as Pointer) returns nothing// Connect the foreign handler to the clicked signal. All other// parameters are empty/defaultGTK_SignalConnect(pButtonView, &quot;clicked&quot;, OnButtonClick, \    nothing, nothing, 0)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>Properties of Linux native views can be set using the GTK Widget API.For example, to hook up the enabled property of a Linux button (called<em>sensitive</em> in the GTK API:</p><pre><code>foreign handler GTK_WidgetSetSensitive(in pWidget as Pointer, in pValue as CBool) returns nothing \    binds to &quot;c:libgtk-x11-2.0.so&gt;gtk_widget_set_sensitive&quot;handler SetEnabled(in pButtonView as Pointer)    GTK_WidgetSetSensitive(pButtonView, my enabled)end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/HTML5" class="dashAnchor"></a>HTML5</h3><h3><a name="//apple_ref/cpp/Guide/Native view" class="dashAnchor"></a>Native view</h3><p>Native views on HTML5 are document elements, which can be created byevaluating JavaScript and returning the element.</p><p>The following snippet shows how to evaluate JavaScript using the <code>EvalJavaScript</code> handler from the emscripten module to create a newbutton element, and set the native layer of the widget.</p><pre><code>// Store the button element pointerprivate variable mNativeView as optional Pointerhandler CreateNativeView() returns Pointer    // Create an HTML5 button using JavaScript    put EvalJavaScript(&quot;document.createElement(&#39;button&#39;)&quot;) \        into mNativeView    return PointerFromJSObject(mNativeView)end handlerhandler SetNativeLayer() returns nothing    set my native layer to CreateNativeView()end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Event handlers" class="dashAnchor"></a>Event handlers</h3><p>Event handlers can be attached to native views again by evaluating JavaScript:</p><pre><code>// Utility function for adding an event listenerhandler AddJSEventHandler(in pElement as JSObject, in pEvent as String, in pHandler as JSObject)EvalJavaScriptWithArguments(&quot;arguments[0].addEventListener(arguments[1], arguments[2]);&quot;, [pElement, pEvent, pHandler])end handler// Actual handler that will be called when the button is clickedhandler OnJSClick(pEvent as JSObject) returns nothing    // The widget object in LiveCode will receive the posted message    post &quot;mouseUp&quot;end handler// Store a reference to the JS handlerprivate variable mOnClickHandler as optional Pointerhandler AttachEventHandler(in pButtonView as Pointer)    // Get a JS function that wraps the LCB callback    put HandlerAsJSFunction(OnJSClick) into mOnClickHandler    // Add the handler to the button for the click event    AddJSEventHandler(pButtonView, &quot;click&quot;, mOnClickHandler)    end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/Hooking up properties" class="dashAnchor"></a>Hooking up properties</h3><p>On HTML5, properties of the native view are manipulated by evaluatingJavaScript. For example, the enabled of the HTML5 button can be implemented as follows:</p><pre><code>handler SetEnabled(in pButtonView as JSObject)    // Set button enabled using JavaScript    EvalJavaScriptWithArguments( \        &quot;arguments[0].disabled=arguments[1];&quot;, \         [pButtonView, not my enabled])end handler</code></pre><h3><a name="//apple_ref/cpp/Guide/The extension package" class="dashAnchor"></a>The extension package</h3><p>The extension package is a zip file (with extension <code>.lce</code>) which, in addition to the actual compiled lcb file, contains various other components related to the extension: icons, documentation, guides, a manifest, sample stacks, extension resources and native code.</p><p>Packages can be uploaded to the extensions store to be shared with otherusers of LiveCode.</p><h3><a name="//apple_ref/cpp/Guide/Documenting Your Extension" class="dashAnchor"></a>Documenting Your Extension</h3><p>Extensions can provide an API (Dictionary) and User Guide as part of the installed package. They are installed and viewable through the LiveCode Dictionary stack.</p><p><strong>API (Dictionary)</strong></p><p><img src="images/extensions-documentation.png" alt="enter image description here"/></p><ol><li>Open the documentation stack from the menubar</li><li>API chooser - Choose which API to view. By default, LiveCode 8.0 comes with the LiveCode Script API and the new LiveCode Builder API. Any extension that contains an API is displayed here.</li><li>Category Filter - Click on the tags to filter the API entries. </li><li>Search Filter - Enter a text string to filter the API entries by a specific search string</li><li>History - Move back and forward through your API navigation history</li><li>Entry List - Select the entry to display from this list</li><li>Entry - The entry describing the syntax</li></ol><p><strong>User Guide</strong></p><p><img src="images/extensions-guides.jpg" alt="enter image description here"/></p><ol><li>Click on the &quot;Guide&quot; tab at the top of the documentation stack</li><li>Select the guide you wish to view</li></ol><h3><a name="//apple_ref/cpp/Guide/Adding API Markup" class="dashAnchor"></a>Adding API Markup</h3><p>Any extension can include an API. To do so, either add a file called <em>api.lcdoc</em> to your widget folder alongside the other widget files or markup your source code inline.</p><p>Marking up your scripts is simple and follows a similar model to other documentation formats.</p><p>Consider the following handler</p><pre><code>public handler myHandler(in pString as String, in pNumber as Number)   # Code end handler</code></pre><p>To add an entry to the API for this handler, place a formatted comment above the handler definition:</p><pre><code>/**Summary: Use this handler to do an actionParameters:pString: This parameter does xpNumber: This parameter does yDescription:# Markdown TitleHere is a full description in markdown for how this function works.     Once again, any GitHub flavoured markdown is accepted.*/public handler myHandler(in pString as String, in pNumber as Number)   # Code end handler</code></pre><p>The LiveCode API parser will combine the comment items with other data pulled directly from your handler definition such as name, type and some parameter details.</p><p>For a full list of acceptable documentation elements please see the LiveCode Documentation Format guide.</p><blockquote><p><strong>Important:</strong> Documentation is only added to the LiveCode dictionary when an extension is installed in the IDE.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Adding a User Guide" class="dashAnchor"></a>Adding a User Guide</h3><p>Any extension can include a user guide. To do so, add a markdown file called <em>guide.md</em> to your widget folder alongside the other widget files.</p><p>All GitHub flavoured markdown is accepted.</p><h3><a name="//apple_ref/cpp/Guide/Packaging Extensions" class="dashAnchor"></a>Packaging Extensions</h3><p>Packaging extensions is easy. Simply open the &quot;Extension Builder&quot; stack:</p><pre><code>Tools &gt; Extension Builder</code></pre><p>Load your <strong><em>.lcb</em></strong> file and click &quot;Build Package&quot;. A new file will appears in the same directory as your main file with the extension <strong><em>.lce</em></strong>. This is your final package file ready for upload to the extensions portal.</p><h3><a name="//apple_ref/cpp/Guide/Package requirements" class="dashAnchor"></a>Package requirements</h3><p>A valid package can be built from a minimum set of files:</p><pre><code>widget.lcb // Widget source filesupport/icon.png // 20x40 png imagesupport/icon@extra-high.png // 40x80 png image</code></pre><h3><a name="//apple_ref/cpp/Guide/The Extension Store" class="dashAnchor"></a>The Extension Store</h3><p>Once you have created and packaged your extension you can make it available to the LiveCode Community via the <a href="https://livecode.com/products/extensions">Extension Store</a>, in the <a href="https://livecode.com/products/widgets/">widgets</a> section.</p><h3><a name="//apple_ref/cpp/Guide/Registering as an Extension Developer" class="dashAnchor"></a>Registering as an Extension Developer</h3><p>The first step is to <a href="https://livecode.com/account/developer/register">register</a> as an Extension Developer.</p><ul><li>Log in to your LiveCode Account</li><li>Select the Register option under the Developer section</li></ul><p><img src="images/extensions-developer_id.png" alt="enter image description here"/></p><p>LiveCode Extensions must have unique identifiers. These identifiers use reverse domain notation.</p><p>You can sign up on this page for a LiveCode Community Developer ID. Having a developer ID will allow you to use extension identifiers of theform: <code>community.livecode.developerID.extensionName</code>.</p><p>Choose the Developer ID you want to use here. If your chosen ID is already in use you will be asked to choose a different one.</p><h3><a name="//apple_ref/cpp/Guide/Uploading Extensions to the Store" class="dashAnchor"></a>Uploading Extensions to the Store</h3><p>To upload a packaged extension to the store log in to your LiveCode account and go to the <a href="https://livecode.com/account/developer/extensions">Extensions</a> section of the Developer area.</p><p>Any extensions you have uploaded will be shown here, and you have the option to add new extensions.</p><ul><li>Click the &quot;Add New Extension&quot; button (if available)</li><li>Drag your packaged extension (<code>.lce</code>) file into the upload area</li><li>When the extension has uploaded it will appear in your list</li></ul><p><img src="images/extensions-upload.png" alt="enter image description here"/></p><h3><a name="//apple_ref/cpp/Guide/Activating your Extension" class="dashAnchor"></a>Activating your Extension</h3><p>When an extension is first uploaded it is not active so will not show in the Extension Store.</p><p>To activate your extension click &quot;activate&quot; under Status. At this stage you will be warned if any information is missing and you can add it by clicking the &quot;Edit&quot; button.</p><p><img src="images/extensions-activate.png" alt="enter image description here"/></p><p>Once your extension is activated its status will change to &quot;Active&quot;.</p><h3><a name="//apple_ref/cpp/Guide/The Extension Store in the Extension Manager" class="dashAnchor"></a>The Extension Store in the Extension Manager</h3><p>You can view and downlaod extensions via the Extension Store. To see the extensions that are available to download open the Extension Manager from the LiveCode Tools menu and select the &quot;Store&quot; tab.</p><p><img src="images/extensions-store.png" alt="enter image description here"/></p><p>You can also download extensions from the <a href="https://livecode.com/products/widgets/">Widget Store</a> on the LiveCode website then install the downloaded extension using the Extension Manager.</p><h3><a name="//apple_ref/cpp/Guide/Other ways to extend the Built%2Din Capabilities" class="dashAnchor"></a>Other ways to extend the Built-in Capabilities</h3><p>There are many other ways to extend LiveCode. This section explains how to run shell commands, start other applications, read and write to processes, execute AppleScript, VBScript, send and respond to AppleEvents and communicate between multiple LiveCode-based processes. It also tells you where to get information to create external commands and functions (code written in lower level languages).</p><h3><a name="//apple_ref/cpp/Guide/Communicating with other process and applications" class="dashAnchor"></a>Communicating with other process and applications</h3><h3><a name="//apple_ref/cpp/Guide/Reading and writing to the command shell" class="dashAnchor"></a>Reading and writing to the command shell</h3><p>Use the <strong>shell</strong> function to run shell commands and return the result. The following example displays a directory listing on Mac OS X:</p><pre><code>answer shell(&quot;ls&quot;)</code></pre><p>And this example stores a directory listing in a variable on Windows:</p><pre><code>put shell(&quot;dir&quot;) into tDirectory</code></pre><p>On Windows systems you can prevent a terminal window from being displayed by setting the <strong>hideConsoleWindows</strong> global property to true.</p><p>You can choose a different shell program by setting the <strong>shellPath</strong> global property. By default this is set to &quot;/bin/sh&quot; on Mac OS X and Linux and &quot;command.com&quot; on Windows.</p><blockquote><p><strong>Tip:</strong> The shell function blocks LiveCode until it is completed. If you want to run a shell command in the background, write the shell script to a text file then execute it with the <code>launch</code>command.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Launching other applications" class="dashAnchor"></a>Launching other applications</h3><p>Use the <strong>launch</strong> command to launch other applications, documents or URLs. To launch an application, supply the full path to the application. The following example opens a text document with TextEdit on OS X:</p><pre><code>launch &quot;/Users/someuser/Desktop/text document.rtf&quot; with &quot;/Applications/TextEdit.app&quot;</code></pre><blockquote><p><strong>Tip:</strong> To get the path to an application, use the <code>answer file</code> command to select the application then copy it into your script. Run this in the message box: </p></blockquote><pre><code>`answer file &quot;Select an application&quot;; put it`</code></pre><p>To open a document with the application it is associated with use the <strong>launch document</strong> command.</p><pre><code>launch document &quot;C:/My document.pdf&quot;</code></pre><p>To open a URL in the default web browser, use the <strong>launch URL</strong> command.</p><pre><code>launch URL &quot;&lt;http://www.livecode.com/&gt;&quot;</code></pre><p>For more information on launching URLs and details on how to render web pages within LiveCode, see the Transferring Information guide.</p><h3><a name="//apple_ref/cpp/Guide/Closing another application" class="dashAnchor"></a>Closing another application</h3><p>Use the <strong>kill process</strong> command to send a signal to another application, to close it or to force it to exit. For more details, see the LiveCode Dictionary.</p><h3><a name="//apple_ref/cpp/Guide/Communicating with other processes" class="dashAnchor"></a>Communicating with other processes</h3><p>Use the <strong>open process</strong> command to open an application or process you want to read and write data from. You can then read from the process with the <strong>read from process</strong> command and write to it with the <strong>write to process</strong> command. To close a process you have opened, use the <strong>close process</strong> command. The <strong>openProcesses</strong> returns a list of processes you have opened and the <strong>openProcessIDs</strong> returns the process IDs of each one. For more details see the <em>LiveCode Dictionary</em>.</p><h3><a name="//apple_ref/cpp/Guide/Using AppleScript and VBScript %28Open Scripting Architecture or" class="dashAnchor"></a>Using AppleScript and VBScript (Open Scripting Architecture or</h3><p>Windows Scripting Host)</p><p>To execute commands using AppleScript on Mac OS or VBScript on Windows, use the <strong>do as</strong> command. <strong>do as</strong> also allows you to use any other <em>Open Scripting Architecture</em> languages on Mac OS or languages installed into the <em>Windows Scripting Host</em> on Windows. To retrieve a list of the available installed languages, use the <strong>alternateLanguages</strong>.</p><p>For example, to execute an AppleScript that brings the Finder on OS X to the front, enter the following into a field:</p><p><em>tell application &quot;Finder&quot;</em><em>activate</em><em>end tell</em></p><p>Then run:</p><pre><code>do field 1 as &quot;appleScript&quot;</code></pre><p>To retrieve a result from commands executed using <code>do as</code>, use <code>the result</code> function. Any error message will also be returned in <code>the result</code>. The following example displays <code>the result</code> of an addition performed using VBScript:</p><pre><code>do &quot;result = 1 + 1&quot; as &quot;vbscript&quot;answer the result</code></pre><p>For more information on the do as command, see the LiveCode Dictionary.</p><h3><a name="//apple_ref/cpp/Guide/AppleEvents" class="dashAnchor"></a>AppleEvents</h3><p>To send an AppleEvent, use the <strong>send to program</strong> command.</p><p>If LiveCode receives an AppleEvent it will send an <strong>appleEvent</strong> message to the current card. Intercept this message to perform actions such as handling a request to quit your application or opening a document. The following example shows how you could handle a request to quit:</p><pre><code>on appleEvent pClass, pID, pSender    if pClass &amp; pID is &quot;aevtquit&quot; then    -- call a function that prompts the user to save changes    put checkSaveChanges() into tOkToQuit    -- returns false if the user presses &quot;cancel&quot;    if tOkToQuit is true then quit    else exit appleEvent    end ifend appleEvent</code></pre><p>To retrive additional information passed with the appleEvent use the <strong>request appleEvent data</strong> command. The following example shows how you could handle a request to open a stack:</p><pre><code>on appleEvent pClass, pID, pSender    --appleEvent sent when stack is opened from the finder    if pClass &amp; pID is &quot; aevtodoc &quot; then        -- get the file path(s)        request AppleEvent data        put it into tFilesList        repeat for each line l in tFilesList            go stack l        end repeat    end ifend appleEvent</code></pre><p>For more details see the <em>LiveCode Dictionary</em>.</p><h3><a name="//apple_ref/cpp/Guide/Using Local sockets" class="dashAnchor"></a>Using Local sockets</h3><p>If you want to communicate between local applications a common technique that can be used without code changes on all the platforms LiveCode supports, is to open a local socket and communicate using that. You should choose a port number that is not used by a standard protocol – typically a high number.</p><p>This technique is commonly used when you want to create multiple programs that run independently but communicate with each other. It is a viable technique for running background tasks and provides a straightforward way to create an application that behaves as if threaded – i.e. with benefits of multiple threads. You can design your application such that additional instances can be launched to perform processing, data transfer or other intensive activities. Modern OSes will allocate each application to an appropriate processor core. By using socket messaging to communicate with each one you can keep your main application&#39;s user interface responsive and display status information. The following example shows you how to open a socket to the local machine:</p><pre><code>open socket to &quot;127.0.0.1:10000&quot; with message gotConnection</code></pre><p>A detailed discussion of how to create a protocol using sockets can be found in the Transferring Information guide.</p><blockquote><p><strong>Tip:</strong> To simplify communication between multiple LiveCode programs, consider writing a simple library that sends and receives a handler name together with parameter data. To call a handler in the other LiveCode program, send the handler name and data to the library. The library will send the data over a socket. In the receiving program intercept the incoming data from the socket and use it to call the appropriate message with the parameter data received.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/Externals – code written in lower level languages" class="dashAnchor"></a>Externals – code written in lower level languages</h3><p>LiveCode provides an external interface which allows you to extend it using a lower level language (often C). For example, if you have preexisting code that performs processing in a lower level language, you can write a user interface in LiveCode and then call this library by writing a simple wrapper around it using LiveCode&#39;s externals interface. LiveCode supports transmitting data to and from externals, as well as drawing into image objects within LiveCode windows, manipulating the player object, and more.</p><blockquote><p><strong>Important:</strong> Much of what is provided by the externals API is now supported by the foreign function interface in LiveCode Builder, where it is not necessary to write any glue code in C. Whilst the externals interface is still supported, LCB is now the recommended way to wrap native code for LiveCode.</p><p><strong>Note:</strong> Some aspects of the built in functionality are supplied in the form of externals. These include the SSL library, the database library, the revBrowser library, zip library and XML libraries. These libraries can be included in a standalone application, or excluded if they are not needed – saving disk space.</p></blockquote><h3><a name="//apple_ref/cpp/Guide/The Externals SDK" class="dashAnchor"></a>The Externals SDK</h3><p>We provide a developer kit for writing externals which includes documentation and examples. You may download this kit from:</p><p><a href="http://downloads.runrev.com/resources/externals/revexternalssdk.zip">http://downloads.runrev.com/resources/externals/revexternalssdk.zip</a></p><p>The following newsletter articles will also help you get started:</p><ul><li><p><a href="http://newsletters.livecode.com/november/issue13/newsletter5.php">External Writing for the Uninitiated – Part 1</a></p></li><li><p><a href="http://newsletters.livecode.com/november/issue14/newsletter3.php">External Writing for the Uninitiated – Part 2</a></p></li><li><p><a href="http://newsletters.livecode.com/october/issue34/newsletter1.php">Writing Externals for Linux with 2.9 or later</a></p></li></ul></body></html>