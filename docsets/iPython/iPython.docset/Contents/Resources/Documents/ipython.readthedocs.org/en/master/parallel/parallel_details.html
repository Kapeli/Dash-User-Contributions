

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from ipython.readthedocs.org/en/master/parallel/parallel_details.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 22 Apr 2014 07:16:37 GMT -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Details of Parallel Computing with IPython &mdash; IPython 3.0.0-dev documentation</title>
  

  
  

  
  <link href='../../../../fonts.googleapis.com/css732b.css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  

  
    <link rel="stylesheet" href="../../../../media.readthedocs.org/css/sphinx_rtd_theme.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../../media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
  
    <link rel="top" title="IPython 3.0.0-dev documentation" href="../index-2.html"/>
        <link rel="up" title="Using IPython for parallel computing" href="index.html"/>
        <link rel="next" title="Transitioning from IPython.kernel to IPython.parallel" href="parallel_transition.html"/>
        <link rel="prev" title="DAG Dependencies" href="dag_dependencies.html"/>
 
<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://ipython.readthedocs.org/en/latest/parallel/parallel_details.html" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "ipython",
    version: "master",
    language: "en",
    page: "parallel/parallel_details",
    theme: "sphinx_rtd_theme",
    docroot: "/docs/source/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org"
  }
  // Old variables
  var doc_version = "master";
  var doc_slug = "ipython";
  var page_name = "parallel/parallel_details";
  var html_theme = "sphinx_rtd_theme";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->


  
  <script src="../../../../cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index-2.html" class="fa fa-home"> IPython</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="https://ipython.readthedocs.org/en/master/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#id1">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#enhanced-interactive-python-shell">Enhanced interactive Python shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#decoupled-two-process-model">Decoupled two-process model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#interactive-parallel-computing">Interactive parallel computing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew/index.html">What&#8217;s new in IPython</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/development.html">Development version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version2.0.html">2.0 Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/github-stats-2.0.html">Issues closed in the 2.0 development cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version1.0.html">1.0 Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/github-stats-1.0.html">Issues closed in the 1.0 development cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.13.html">0.13 Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/github-stats-0.13.html">Issues closed in the 0.13 development cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.12.html">0.12 Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/github-stats-0.12.html">Issues closed in the 0.12 development cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.11.html">0.11 Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/github-stats-0.11.html">Issues closed in the 0.11 development cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.10.html">0.10 series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.9.html">0.9 series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whatsnew/version0.8.html">0.8 series</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#installing-ipython-itself">Installing IPython itself</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#basic-optional-dependencies">Basic optional dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#dependencies-for-ipython-parallel-parallel-computing">Dependencies for IPython.parallel (parallel computing)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#dependencies-for-ipython-kernel-zmq">Dependencies for IPython.kernel.zmq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#dependencies-for-the-ipython-qt-console">Dependencies for the IPython QT console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#dependencies-for-the-ipython-html-notebook">Dependencies for the IPython HTML notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install/install.html#dependencies-for-nbconvert-converting-notebooks-to-various-formats">Dependencies for nbconvert (converting notebooks to various formats)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interactive/index.html">Using IPython for interactive work</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interactive/tutorial.html">Introducing IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive/tips.html">IPython Tips &amp; Tricks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive/reference.html">IPython reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive/shell.html">IPython as a system shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive/qtconsole.html">A Qt Console for IPython</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebook/index.html">The IPython notebook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebook/notebook.html">The IPython Notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebook/nbconvert.html">Converting notebooks to other formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebook/public_server.html">Running a notebook server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebook/security.html">Security in IPython notebooks</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Using IPython for parallel computing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="parallel_intro.html">Overview and getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_process.html">Starting the IPython controller and engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_multiengine.html">IPython&#8217;s Direct interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="magics.html">Parallel Magic Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_task.html">The IPython task interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="asyncresult.html">The AsyncResult object</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_mpi.html">Using MPI with IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_db.html">IPython&#8217;s Task Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_security.html">Security details of IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_winhpc.html">Getting started with Windows HPC Server 2008</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_demos.html">Parallel examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="dag_dependencies.html">DAG Dependencies</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Details of Parallel Computing with IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel_transition.html">Transitioning from IPython.kernel to IPython.parallel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../config/index.html">Configuration and customization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../config/index.html#configuring-ipython">Configuring IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="../config/index.html#extending-and-integrating-with-ipython">Extending and integrating with IPython</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">IPython developer&#8217;s guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../development/messaging.html">Messaging in IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/parallel_messages.html">Messaging for Parallel Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/parallel_connections.html">Connection Diagrams of The IPython ZMQ Cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/lexer.html">New IPython Console Lexer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/pycompat.html">Writing code for Python 2 and 3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/config.html">Overview of the IPython configuration system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/inputhook_app.html">IPython GUI Support Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">The IPython API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About IPython</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../about/credits.html">Credits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../about/history.html">History</a></li>
<li class="toctree-l2"><a class="reference internal" href="../about/license_and_copyright.html">License and Copyright</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index-2.html">IPython</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index-2.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Using IPython for parallel computing</a> &raquo;</li>
      
    <li>Details of Parallel Computing with IPython</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="https://github.com/ipython/ipython/blob/master/docs/source/parallel/parallel_details.rst" class="fa fa-github"> Edit on GitHub</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This documentation is for a development version of IPython. There may be
significant differences from the latest stable release.</p>
</div>
</div></blockquote>
<div class="section" id="details-of-parallel-computing-with-ipython">
<span id="parallel-details"></span><h1>Details of Parallel Computing with IPython<a class="headerlink" href="#details-of-parallel-computing-with-ipython" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are still many sections to fill out in this doc</p>
</div>
<div class="section" id="caveats">
<h2>Caveats<a class="headerlink" href="#caveats" title="Permalink to this headline">¶</a></h2>
<p>First, some caveats about the detailed workings of parallel computing with 0MQ and IPython.</p>
<div class="section" id="non-copying-sends-and-numpy-arrays">
<h3>Non-copying sends and numpy arrays<a class="headerlink" href="#non-copying-sends-and-numpy-arrays" title="Permalink to this headline">¶</a></h3>
<p>When numpy arrays are passed as arguments to apply or via data-movement methods, they are not
copied. This means that you must be careful if you are sending an array that you intend to work
on. PyZMQ does allow you to track when a message has been sent so you can know when it is safe
to edit the buffer, but IPython only allows for this.</p>
<p>It is also important to note that the non-copying receive of a message is <em>read-only</em>. That
means that if you intend to work in-place on an array that you have sent or received, you must
copy it. This is true for both numpy arrays sent to engines and numpy arrays retrieved as
results.</p>
<p>The following will fail:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [3]: A = numpy.zeros(2)

In [4]: def setter(a):
   ...:   a[0]=1
   ...:   return a

In [5]: rc[0].apply_sync(setter, A)
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)&lt;string&gt; in &lt;module&gt;()
&lt;ipython-input-12-c3e7afeb3075&gt; in setter(a)
RuntimeError: array is not writeable
</pre></div>
</div>
<p>If you do need to edit the array in-place, just remember to copy the array if it&#8217;s read-only.
The <tt class="xref py py-attr docutils literal"><span class="pre">ndarray.flags.writeable</span></tt> flag will tell you if you can write to an array.</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [3]: A = numpy.zeros(2)

In [4]: def setter(a):
   ...:     &quot;&quot;&quot;only copy read-only arrays&quot;&quot;&quot;
   ...:     if not a.flags.writeable:
   ...:         a=a.copy()
   ...:     a[0]=1
   ...:     return a

In [5]: rc[0].apply_sync(setter, A)
Out[5]: array([ 1.,  0.])

# note that results will also be read-only:
In [6]: _.flags.writeable
Out[6]: False
</pre></div>
</div>
<p>If you want to safely edit an array in-place after <em>sending</em> it, you must use the <cite>track=True</cite>
flag. IPython always performs non-copying sends of arrays, which return immediately. You must
instruct IPython track those messages <em>at send time</em> in order to know for sure that the send has
completed. AsyncResults have a <tt class="xref py py-attr docutils literal"><span class="pre">sent</span></tt> property, and <tt class="xref py py-meth docutils literal"><span class="pre">wait_on_send()</span></tt> method for
checking and waiting for 0MQ to finish with a buffer.</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [5]: A = numpy.random.random((1024,1024))

In [6]: view.track=True

In [7]: ar = view.apply_async(lambda x: 2*x, A)

In [8]: ar.sent
Out[8]: False

In [9]: ar.wait_on_send() # blocks until sent is True
</pre></div>
</div>
</div>
<div class="section" id="what-is-sendable">
<h3>What is sendable?<a class="headerlink" href="#what-is-sendable" title="Permalink to this headline">¶</a></h3>
<p>If IPython doesn&#8217;t know what to do with an object, it will pickle it. There is a short list of
objects that are not pickled: <tt class="docutils literal"><span class="pre">buffers</span></tt>, <tt class="docutils literal"><span class="pre">str/bytes</span></tt> objects, and <tt class="docutils literal"><span class="pre">numpy</span></tt>
arrays. These are handled specially by IPython in order to prevent the copying of data. Sending
bytes or numpy arrays will result in exactly zero in-memory copies of your data (unless the data
is very small).</p>
<p>If you have an object that provides a Python buffer interface, then you can always send that
buffer without copying - and reconstruct the object on the other side in your own code. It is
possible that the object reconstruction will become extensible, so you can add your own
non-copying types, but this does not yet exist.</p>
<div class="section" id="closures">
<h4>Closures<a class="headerlink" href="#closures" title="Permalink to this headline">¶</a></h4>
<p>Just about anything in Python is pickleable. The one notable exception is objects (generally
functions) with <em>closures</em>. Closures can be a complicated topic, but the basic principal is that
functions that refer to variables in their parent scope have closures.</p>
<p>An example of a function that uses a closure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="c"># inner will have a closure</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f1</span><span class="p">()</span> <span class="c"># returns 1</span>
<span class="n">f2</span><span class="p">()</span> <span class="c"># returns 2</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">f1</span></tt> and <tt class="docutils literal"><span class="pre">f2</span></tt> will have closures referring to the scope in which <cite>inner</cite> was defined,
because they use the variable &#8216;a&#8217;. As a result, you would not be able to send <tt class="docutils literal"><span class="pre">f1</span></tt> or <tt class="docutils literal"><span class="pre">f2</span></tt>
with IPython. Note that you <em>would</em> be able to send <cite>f</cite>. This is only true for interactively
defined functions (as are often used in decorators), and only when there are variables used
inside the inner function, that are defined in the outer function. If the names are <em>not</em> in the
outer function, then there will not be a closure, and the generated function will look in
<tt class="docutils literal"><span class="pre">globals()</span></tt> for the name:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="c"># note that `b` is not referenced in inner&#39;s scope</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="c"># this inner will *not* have a closure</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">inner</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g1</span><span class="p">()</span> <span class="c"># raises NameError on &#39;a&#39;</span>
<span class="n">a</span><span class="o">=</span><span class="mi">5</span>
<span class="n">g2</span><span class="p">()</span> <span class="c"># returns 5</span>
</pre></div>
</div>
<p><cite>g1</cite> and <cite>g2</cite> <em>will</em> be sendable with IPython, and will treat the engine&#8217;s namespace as
globals().  The <tt class="xref py py-meth docutils literal"><span class="pre">pull()</span></tt> method is implemented based on this principle.  If we did not
provide pull, you could implement it yourself with <cite>apply</cite>, by simply returning objects out
of the global namespace:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [10]: view.apply(lambda : a)

# is equivalent to
In [11]: view.pull(&#39;a&#39;)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="running-code">
<h2>Running Code<a class="headerlink" href="#running-code" title="Permalink to this headline">¶</a></h2>
<p>There are two principal units of execution in Python: strings of Python code (e.g. &#8216;a=5&#8217;),
and Python functions.  IPython is designed around the use of functions via the core
Client method, called <cite>apply</cite>.</p>
<div class="section" id="apply">
<h3>Apply<a class="headerlink" href="#apply" title="Permalink to this headline">¶</a></h3>
<p>The principal method of remote execution is <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>, of
<tt class="xref py py-class docutils literal"><span class="pre">View</span></tt> objects. The Client provides the full execution and
communication API for engines via its low-level <tt class="xref py py-meth docutils literal"><span class="pre">send_apply_message()</span></tt> method, which is used
by all higher level methods of its Views.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>The function to be called remotely</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list</span></dt>
<dd>The positional arguments passed to <cite>f</cite></dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>The keyword arguments passed to <cite>f</cite></dd>
</dl>
<p>flags for all views:</p>
<dl class="docutils">
<dt>block <span class="classifier-delimiter">:</span> <span class="classifier">bool (default: view.block)</span></dt>
<dd><p class="first">Whether to wait for the result, or return immediately.</p>
<dl class="last docutils">
<dt>False:</dt>
<dd>returns AsyncResult</dd>
<dt>True:</dt>
<dd><p class="first">returns actual result(s) of <tt class="docutils literal"><span class="pre">f(*args,</span> <span class="pre">**kwargs)</span></tt></p>
<dl class="last docutils">
<dt>if multiple targets:</dt>
<dd>list of results, matching <cite>targets</cite></dd>
</dl>
</dd>
</dl>
</dd>
<dt>track <span class="classifier-delimiter">:</span> <span class="classifier">bool [default view.track]</span></dt>
<dd>whether to track non-copying sends.</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">int,list of ints, &#8216;all&#8217;, None [default view.targets]</span></dt>
<dd><p class="first">Specify the destination of the job.</p>
<dl class="last docutils">
<dt>if &#8216;all&#8217; or None:</dt>
<dd>Run on all active engines</dd>
<dt>if list:</dt>
<dd>Run on each specified engine</dd>
<dt>if int:</dt>
<dd>Run on single engine</dd>
</dl>
</dd>
</dl>
<p>Note that <tt class="xref py py-class docutils literal"><span class="pre">LoadBalancedView</span></tt> uses targets to restrict possible destinations.
LoadBalanced calls will always execute in just one location.</p>
<p>flags only in LoadBalancedViews:</p>
<dl class="docutils">
<dt>after <span class="classifier-delimiter">:</span> <span class="classifier">Dependency or collection of msg_ids</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify a list of msg_ids as a time-based dependency.
This job will only be run <em>after</em> the dependencies
have been met.</dd>
<dt>follow <span class="classifier-delimiter">:</span> <span class="classifier">Dependency or collection of msg_ids</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify a list of msg_ids as a location-based dependency.
This job will only be run on an engine where this dependency
is met.</dd>
<dt>timeout <span class="classifier-delimiter">:</span> <span class="classifier">float/int or None</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify an amount of time (in seconds) for the scheduler to
wait for dependencies to be met before failing with a
DependencyTimeout.</dd>
</dl>
</div>
<div class="section" id="execute-and-run">
<h3>execute and run<a class="headerlink" href="#execute-and-run" title="Permalink to this headline">¶</a></h3>
<p>For executing strings of Python code, <tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt> &#8216;s also provide an <tt class="xref py py-meth docutils literal"><span class="pre">execute()</span></tt> and
a <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method, which rather than take functions and arguments, take simple strings.
<cite>execute</cite> simply takes a string of Python code to execute, and sends it to the Engine(s). <cite>run</cite>
is the same as <cite>execute</cite>, but for a <em>file</em>, rather than a string. It is simply a wrapper that
does something very similar to <tt class="docutils literal"><span class="pre">execute(open(f).read())</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: Examples for execute and run</p>
</div>
</div>
</div>
<div class="section" id="views">
<h2>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h2>
<p>The principal extension of the <tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt> is the <tt class="xref py py-class docutils literal"><span class="pre">View</span></tt>
class. The client is typically a singleton for connecting to a cluster, and presents a
low-level interface to the Hub and Engines. Most real usage will involve creating one or more
<tt class="xref py py-class docutils literal"><span class="pre">View</span></tt> objects for working with engines in various ways.</p>
<div class="section" id="directview">
<h3>DirectView<a class="headerlink" href="#directview" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt> is the class for the IPython <a class="reference internal" href="parallel_multiengine.html#parallel-multiengine"><em>Multiplexing Interface</em></a>.</p>
<div class="section" id="creating-a-directview">
<h4>Creating a DirectView<a class="headerlink" href="#creating-a-directview" title="Permalink to this headline">¶</a></h4>
<p>DirectViews can be created in two ways, by index access to a client, or by a client&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">view()</span></tt> method.  Index access to a Client works in a few ways.  First, you can create
DirectViews to single engines simply by accessing the client by engine id:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [2]: rc[0]
Out[2]: &lt;DirectView 0&gt;
</pre></div>
</div>
<p>You can also create a DirectView with a list of engines:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [2]: rc[0,1,2]
Out[2]: &lt;DirectView [0,1,2]&gt;
</pre></div>
</div>
<p>Other methods for accessing elements, such as slicing and negative indexing, work by passing
the index directly to the client&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">ids</span></tt> list, so:</p>
<div class="highlight-ipython"><div class="highlight"><pre># negative index
In [2]: rc[-1]
Out[2]: &lt;DirectView 3&gt;

# or slicing:
In [3]: rc[::2]
Out[3]: &lt;DirectView [0,2]&gt;
</pre></div>
</div>
<p>are always the same as:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [2]: rc[rc.ids[-1]]
Out[2]: &lt;DirectView 3&gt;

In [3]: rc[rc.ids[::2]]
Out[3]: &lt;DirectView [0,2]&gt;
</pre></div>
</div>
<p>Also note that the slice is evaluated at the time of construction of the DirectView, so the
targets will not change over time if engines are added/removed from the cluster.</p>
</div>
<div class="section" id="execution-via-directview">
<h4>Execution via DirectView<a class="headerlink" href="#execution-via-directview" title="Permalink to this headline">¶</a></h4>
<p>The DirectView is the simplest way to work with one or more engines directly (hence the name).</p>
<p>For instance, to get the process ID of all your engines:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [5]: import os

In [6]: dview.apply_sync(os.getpid)
Out[6]: [1354, 1356, 1358, 1360]
</pre></div>
</div>
<p>Or to see the hostname of the machine they are on:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [5]: import socket

In [6]: dview.apply_sync(socket.gethostname)
Out[6]: [&#39;tesla&#39;, &#39;tesla&#39;, &#39;edison&#39;, &#39;edison&#39;, &#39;edison&#39;]
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: expand on direct execution</p>
</div>
</div>
<div class="section" id="data-movement-via-directview">
<h4>Data movement via DirectView<a class="headerlink" href="#data-movement-via-directview" title="Permalink to this headline">¶</a></h4>
<p>Since a Python namespace is just a <a class="reference external" href="http://docs.python.org/2/library/stdtypes.html#dict" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt> objects provide
dictionary-style access by key and methods such as <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt> for convenience. This make the remote namespaces of the engines
appear as a local dictionary. Underneath, these methods call <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [51]: dview[&#39;a&#39;]=[&#39;foo&#39;,&#39;bar&#39;]

In [52]: dview[&#39;a&#39;]
Out[52]: [ [&#39;foo&#39;, &#39;bar&#39;], [&#39;foo&#39;, &#39;bar&#39;], [&#39;foo&#39;, &#39;bar&#39;], [&#39;foo&#39;, &#39;bar&#39;] ]
</pre></div>
</div>
</div>
</div>
<div class="section" id="scatter-and-gather">
<h3>Scatter and gather<a class="headerlink" href="#scatter-and-gather" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is useful to partition a sequence and push the partitions to
different engines. In MPI language, this is know as scatter/gather and we
follow that terminology. However, it is important to remember that in
IPython&#8217;s <tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt> class, <tt class="xref py py-meth docutils literal"><span class="pre">scatter()</span></tt> is from the
interactive IPython session to the engines and <tt class="xref py py-meth docutils literal"><span class="pre">gather()</span></tt> is from the
engines back to the interactive IPython session. For scatter/gather operations
between engines, MPI should be used:</p>
<div class="highlight-ipython"><div class="highlight"><pre>In [58]: dview.scatter(&#39;a&#39;,range(16))
Out[58]: [None,None,None,None]

In [59]: dview[&#39;a&#39;]
Out[59]: [ [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15] ]

In [60]: dview.gather(&#39;a&#39;)
Out[60]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
</pre></div>
</div>
</div>
<div class="section" id="push-and-pull">
<h3>Push and pull<a class="headerlink" href="#push-and-pull" title="Permalink to this headline">¶</a></h3>
<p><tt class="xref py py-meth docutils literal"><span class="pre">push()</span></tt></p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">pull()</span></tt></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
</div>
<div class="section" id="loadbalancedview">
<h3>LoadBalancedView<a class="headerlink" href="#loadbalancedview" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">LoadBalancedView</span></tt> is the class for load-balanced execution via the task scheduler.
These views always run tasks on exactly one engine, but let the scheduler determine where that
should be, allowing load-balancing of tasks. The LoadBalancedView does allow you to specify
restrictions on where and when tasks can execute, for more complicated load-balanced workflows.</p>
</div>
</div>
<div class="section" id="data-movement">
<h2>Data Movement<a class="headerlink" href="#data-movement" title="Permalink to this headline">¶</a></h2>
<p>Since the <tt class="xref py py-class docutils literal"><span class="pre">LoadBalancedView</span></tt> does not know where execution will take place, explicit
data movement methods like push/pull and scatter/gather do not make sense, and are not provided.</p>
</div>
<div class="section" id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this headline">¶</a></h2>
<div class="section" id="asyncresults">
<h3>AsyncResults<a class="headerlink" href="#asyncresults" title="Permalink to this headline">¶</a></h3>
<p>Our primary representation of the results of remote execution is the <a class="reference internal" href="#AsyncResult" title="AsyncResult"><tt class="xref py py-class docutils literal"><span class="pre">AsyncResult</span></tt></a>
object, based on the object of the same name in the built-in <a class="reference external" href="http://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.pool" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing.pool</span></tt></a>
module. Our version provides a superset of that interface.</p>
<p>The basic principle of the AsyncResult is the encapsulation of one or more results not yet completed.  Execution methods (including data movement, such as push/pull) will all return
AsyncResults when <cite>block=False</cite>.</p>
</div>
<div class="section" id="the-mp-pool-asyncresult-interface">
<h3>The mp.pool.AsyncResult interface<a class="headerlink" href="#the-mp-pool-asyncresult-interface" title="Permalink to this headline">¶</a></h3>
<p>The basic interface of the AsyncResult is exactly that of the AsyncResult in <a class="reference external" href="http://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.pool" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing.pool</span></tt></a>, and consists of four methods:</p>
<dl class="class">
<dt id="AsyncResult">
<em class="property">class </em><tt class="descname">AsyncResult</tt><a class="headerlink" href="#AsyncResult" title="Permalink to this definition">¶</a></dt>
<dd><p>The stdlib AsyncResult spec</p>
<dl class="method">
<dt id="AsyncResult.wait">
<tt class="descname">wait</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#AsyncResult.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until the result is available or until <em>timeout</em> seconds pass. This
method always returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.ready">
<tt class="descname">ready</tt><big>(</big><big>)</big><a class="headerlink" href="#AsyncResult.ready" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the call has completed.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.successful">
<tt class="descname">successful</tt><big>(</big><big>)</big><a class="headerlink" href="#AsyncResult.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the call completed without raising an exception.  Will
raise <tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt> if the result is not ready.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.get">
<tt class="descname">get</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#AsyncResult.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result when it arrives.  If <em>timeout</em> is not <tt class="docutils literal"><span class="pre">None</span></tt> and the
result does not arrive within <em>timeout</em> seconds then
<tt class="xref py py-exc docutils literal"><span class="pre">TimeoutError</span></tt> is raised.  If the remote call raised
an exception then that exception will be reraised as a <tt class="xref py py-exc docutils literal"><span class="pre">RemoteError</span></tt>
by <a class="reference internal" href="#AsyncResult.get" title="AsyncResult.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<p>While an AsyncResult is not done, you can check on it with its <tt class="xref py py-meth docutils literal"><span class="pre">ready()</span></tt> method, which will
return whether the AR is done. You can also wait on an AsyncResult with its <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method.
This method blocks until the result arrives. If you don&#8217;t want to wait forever, you can pass a
timeout (in seconds) as an argument to <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>. <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> will <em>always return None</em>, and
should never raise an error.</p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">ready()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> are insensitive to the success or failure of the call. After a
result is done, <tt class="xref py py-meth docutils literal"><span class="pre">successful()</span></tt> will tell you whether the call completed without raising an
exception.</p>
<p>If you actually want the result of the call, you can use <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>. Initially, <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>
behaves just like <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>, in that it will block until the result is ready, or until a
timeout is met. However, unlike <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> will raise a <tt class="xref py py-exc docutils literal"><span class="pre">TimeoutError</span></tt> if
the timeout is reached and the result is still not ready. If the result arrives before the
timeout is reached, then <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> will return the result itself if no exception was raised,
and will raise an exception if there was.</p>
<p>Here is where we start to expand on the multiprocessing interface. Rather than raising the
original exception, a RemoteError will be raised, encapsulating the remote exception with some
metadata. If the AsyncResult represents multiple calls (e.g. any time <cite>targets</cite> is plural), then
a CompositeError, a subclass of RemoteError, will be raised.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more information on remote exceptions, see <a class="reference internal" href="parallel_multiengine.html#parallel-exceptions"><em>the section in the Direct Interface</em></a>.</p>
</div>
<div class="section" id="extended-interface">
<h4>Extended interface<a class="headerlink" href="#extended-interface" title="Permalink to this headline">¶</a></h4>
<p>Other extensions of the AsyncResult interface include convenience wrappers for <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>.
AsyncResults have a property, <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt>, with the short alias <tt class="xref py py-attr docutils literal"><span class="pre">r</span></tt>, which simply call
<tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>. Since our object is designed for representing <em>parallel</em> results, it is expected
that many calls (any of those submitted via DirectView) will map results to engine IDs. We
provide a <tt class="xref py py-meth docutils literal"><span class="pre">get_dict()</span></tt>, which is also a wrapper on <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>, which returns a dictionary
of the individual results, keyed by engine ID.</p>
<p>You can also prevent a submitted job from actually executing, via the AsyncResult&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt> method. This will instruct engines to not execute the job when it arrives.</p>
<p>The larger extension of the AsyncResult API is the <tt class="xref py py-attr docutils literal"><span class="pre">metadata</span></tt> attribute.  The metadata
is a dictionary (with attribute access) that contains, logically enough, metadata about the
execution.</p>
<p>Metadata keys:</p>
<p>timestamps</p>
<dl class="docutils">
<dt>submitted</dt>
<dd>When the task left the Client</dd>
<dt>started</dt>
<dd>When the task started execution on the engine</dd>
<dt>completed</dt>
<dd>When execution finished on the engine</dd>
<dt>received</dt>
<dd><p class="first">When the result arrived on the Client</p>
<p class="last">note that it is not known when the result arrived in 0MQ on the client, only when it
arrived in Python via <tt class="xref py py-meth docutils literal"><span class="pre">Client.spin()</span></tt>, so in interactive use, this may not be
strictly informative.</p>
</dd>
</dl>
<p>Information about the engine</p>
<dl class="docutils">
<dt>engine_id</dt>
<dd>The integer id</dd>
<dt>engine_uuid</dt>
<dd>The UUID of the engine</dd>
</dl>
<p>output of the call</p>
<dl class="docutils">
<dt>pyerr</dt>
<dd>Python exception, if there was one</dd>
<dt>pyout</dt>
<dd>Python output</dd>
<dt>stderr</dt>
<dd>stderr stream</dd>
<dt>stdout</dt>
<dd>stdout (e.g. print) stream</dd>
</dl>
<p>And some extended information</p>
<dl class="docutils">
<dt>status</dt>
<dd>either &#8216;ok&#8217; or &#8216;error&#8217;</dd>
<dt>msg_id</dt>
<dd>The UUID of the message</dd>
<dt>after</dt>
<dd>For tasks: the time-based msg_id dependencies</dd>
<dt>follow</dt>
<dd>For tasks: the location-based msg_id dependencies</dd>
</dl>
<p>While in most cases, the Clients that submitted a request will be the ones using the results,
other Clients can also request results directly from the Hub. This is done via the Client&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">get_result()</span></tt> method. This method will <em>always</em> return an AsyncResult object. If the call
was not submitted by the client, then it will be a subclass, called <tt class="xref py py-class docutils literal"><span class="pre">AsyncHubResult</span></tt>.
These behave in the same way as an AsyncResult, but if the result is not ready, waiting on an
AsyncHubResult polls the Hub, which is much more expensive than the passive polling used
in regular AsyncResults.</p>
<p>The Client keeps track of all results
history, results, metadata</p>
</div>
</div>
</div>
<div class="section" id="querying-the-hub">
<h2>Querying the Hub<a class="headerlink" href="#querying-the-hub" title="Permalink to this headline">¶</a></h2>
<p>The Hub sees all traffic that may pass through the schedulers between engines and clients.
It does this so that it can track state, allowing multiple clients to retrieve results of
computations submitted by their peers, as well as persisting the state to a database.</p>
<p>queue_status</p>
<blockquote>
<div>You can check the status of the queues of the engines with this command.</div></blockquote>
<p>result_status</p>
<blockquote>
<div>check on results</div></blockquote>
<p>purge_results</p>
<blockquote>
<div>forget results (conserve resources)</div></blockquote>
</div>
<div class="section" id="controlling-the-engines">
<h2>Controlling the Engines<a class="headerlink" href="#controlling-the-engines" title="Permalink to this headline">¶</a></h2>
<p>There are a few actions you can do with Engines that do not involve execution.  These
messages are sent via the Control socket, and bypass any long queues of waiting execution
jobs</p>
<p>abort</p>
<blockquote>
<div>Sometimes you may want to prevent a job you have submitted from actually running. The method
for this is <tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt>. It takes a container of msg_ids, and instructs the Engines to not
run the jobs if they arrive. The jobs will then fail with an AbortedTask error.</div></blockquote>
<p>clear</p>
<blockquote>
<div>You may want to purge the Engine(s) namespace of any data you have left in it.  After
running <cite>clear</cite>, there will be no names in the Engine&#8217;s namespace</div></blockquote>
<p>shutdown</p>
<blockquote>
<div>You can also instruct engines (and the Controller) to terminate from a Client.  This
can be useful when a job is finished, since you can shutdown all the processes with a
single command.</div></blockquote>
</div>
<div class="section" id="synchronization">
<h2>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h2>
<p>Since the Client is a synchronous object, events do not automatically trigger in your
interactive session - you must poll the 0MQ sockets for incoming messages.  Note that
this polling <em>does not</em> actually make any network requests.  It simply performs a <cite>select</cite>
operation, to check if messages are already in local memory, waiting to be handled.</p>
<p>The method that handles incoming messages is <tt class="xref py py-meth docutils literal"><span class="pre">spin()</span></tt>. This method flushes any waiting
messages on the various incoming sockets, and updates the state of the Client.</p>
<p>If you need to wait for particular results to finish, you can use the <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method,
which will call <tt class="xref py py-meth docutils literal"><span class="pre">spin()</span></tt> until the messages are no longer outstanding. Anything that
represents a collection of messages, such as a list of msg_ids or one or more AsyncResult
objects, can be passed as argument to wait. A timeout can be specified, which will prevent
the call from blocking for more than a specified time, but the default behavior is to wait
forever.</p>
<p>The client also has an <tt class="docutils literal"><span class="pre">outstanding</span></tt> attribute - a <tt class="docutils literal"><span class="pre">set</span></tt> of msg_ids that are awaiting
replies. This is the default if wait is called with no arguments - i.e. wait on <em>all</em>
outstanding messages.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO wait example</p>
</div>
</div>
<div class="section" id="map">
<h2>Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h2>
<p>Many parallel computing problems can be expressed as a <tt class="docutils literal"><span class="pre">map</span></tt>, or running a single program with
a variety of different inputs. Python has a built-in <a class="reference external" href="http://docs.python.org/2/library/functions.html#map" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a>, which does exactly this,
and many parallel execution tools in Python, such as the built-in
<tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Pool</span></tt> object provide implementations of <cite>map</cite>. All View objects
provide a <tt class="xref py py-meth docutils literal"><span class="pre">map()</span></tt> method as well, but the load-balanced and direct implementations differ.</p>
<p>Views&#8217; map methods can be called on any number of sequences, but they can also take the <cite>block</cite>
and <cite>bound</cite> keyword arguments, just like <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>, but <em>only as keywords</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dview</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">*</span><span class="n">sequences</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>iter, map_async, reduce</li>
</ul>
</div>
<div class="section" id="decorators-and-remotefunctions">
<h2>Decorators and RemoteFunctions<a class="headerlink" href="#decorators-and-remotefunctions" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;parallel()</span></tt></p>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;remote()</span></tt></p>
<p><tt class="xref py py-class docutils literal"><span class="pre">RemoteFunction</span></tt></p>
<p><tt class="xref py py-class docutils literal"><span class="pre">ParallelFunction</span></tt></p>
</div>
<div class="section" id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;depend()</span></tt></p>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;require()</span></tt></p>
<p><tt class="xref py py-class docutils literal"><span class="pre">Dependency</span></tt></p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="parallel_transition.html" class="btn btn-neutral float-right" title="Transitioning from IPython.kernel to IPython.parallel">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dag_dependencies.html" class="btn btn-neutral" title="DAG Dependencies"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The IPython Development Team.
      Last updated on Apr 21, 2014.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="../index.html">master</a></dd>
        
          <dd><a href="https://ipython.readthedocs.org/en/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://media.readthedocs.org/pdf/ipython/master/ipython.pdf">PDF</a></dd>
        
          <dd><a href="https://media.readthedocs.org/htmlzip/ipython/master/ipython.zip">HTML</a></dd>
        
          <dd><a href="https://media.readthedocs.org/epub/ipython/master/ipython.epub">Epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="http://readthedocs.org/projects/ipython/?fromdocs=ipython">Project Home</a>
          </dd>
          <dd>
            <a href="http://readthedocs.org/builds/ipython/?fromdocs=ipython">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org/">Read the Docs</a>.

    </div>
  </div>



  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.0.0-dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
      <script type="text/javascript" src="../../../../media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
      <script type="text/javascript" src="../../../../media.readthedocs.org/javascript/underscore.js"></script>
      <script type="text/javascript" src="../../../../media.readthedocs.org/javascript/doctools.js"></script>
      <script type="text/javascript" src="../../../../media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>

<!-- Mirrored from ipython.readthedocs.org/en/master/parallel/parallel_details.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 22 Apr 2014 07:16:37 GMT -->
</html>