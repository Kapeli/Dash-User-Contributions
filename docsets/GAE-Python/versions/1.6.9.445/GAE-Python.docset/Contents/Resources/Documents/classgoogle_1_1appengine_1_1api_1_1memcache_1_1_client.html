<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>App Engine Python SDK: google.appengine.api.memcache.Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="common.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gae-python.logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">App Engine Python SDK
   &#160;<span id="projectnumber">v1.6.9 rev.445</span>
   </div>
   <div id="projectbrief">The Python runtime is available as an experimental Preview feature.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>google</b></li><li class="navelem"><b>appengine</b></li><li class="navelem"><b>api</b></li><li class="navelem"><b>memcache</b></li><li class="navelem"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html">Client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google.appengine.api.memcache.Client Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for google.appengine.api.memcache.Client:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.png" usemap="#google.appengine.api.memcache.Client_map" alt=""/>
  <map id="google.appengine.api.memcache.Client_map" name="google.appengine.api.memcache.Client_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab11226cb7213eb4385abf6d8e2b4a37f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ab11226cb7213eb4385abf6d8e2b4a37f">__init__</a></td></tr>
<tr class="separator:ab11226cb7213eb4385abf6d8e2b4a37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d7b57fc8e5ac61f902a2dc56711d03"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ad6d7b57fc8e5ac61f902a2dc56711d03">cas_reset</a></td></tr>
<tr class="separator:ad6d7b57fc8e5ac61f902a2dc56711d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee48e46ab6f7cbab9e73482e41c583c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a9ee48e46ab6f7cbab9e73482e41c583c">set_servers</a></td></tr>
<tr class="separator:a9ee48e46ab6f7cbab9e73482e41c583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73b09d1c3592bc674c40424320599f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ae73b09d1c3592bc674c40424320599f3">disconnect_all</a></td></tr>
<tr class="separator:ae73b09d1c3592bc674c40424320599f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893443776a1cc1fa8e7e7fee68b32e54"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a893443776a1cc1fa8e7e7fee68b32e54">forget_dead_hosts</a></td></tr>
<tr class="separator:a893443776a1cc1fa8e7e7fee68b32e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb572e576d9c2997001d45f0d3448d8a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#acb572e576d9c2997001d45f0d3448d8a">debuglog</a></td></tr>
<tr class="separator:acb572e576d9c2997001d45f0d3448d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dc0633f638fd5df09f869fb4938d3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ad8dc0633f638fd5df09f869fb4938d3f">get_stats</a></td></tr>
<tr class="separator:ad8dc0633f638fd5df09f869fb4938d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e0727cdcb5462f51e572055bc2c673"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ae0e0727cdcb5462f51e572055bc2c673">get_stats_async</a></td></tr>
<tr class="separator:ae0e0727cdcb5462f51e572055bc2c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6176af67ff37d8e156a35a136ec77fb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a6176af67ff37d8e156a35a136ec77fb3">flush_all</a></td></tr>
<tr class="separator:a6176af67ff37d8e156a35a136ec77fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685ce45af8457bd2241999c2336340b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a685ce45af8457bd2241999c2336340b1">flush_all_async</a></td></tr>
<tr class="separator:a685ce45af8457bd2241999c2336340b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a40cd055713a76e2762302d5716c456"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a4a40cd055713a76e2762302d5716c456">get</a></td></tr>
<tr class="separator:a4a40cd055713a76e2762302d5716c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168db4d27f5227bed44f27e8deae805c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a168db4d27f5227bed44f27e8deae805c">gets</a></td></tr>
<tr class="separator:a168db4d27f5227bed44f27e8deae805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e20bb82254543609f0e77e45fcd36d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#af9e20bb82254543609f0e77e45fcd36d">get_multi</a></td></tr>
<tr class="separator:af9e20bb82254543609f0e77e45fcd36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4828e406a12b7df3490788c54f7b7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a6c4828e406a12b7df3490788c54f7b7d">get_multi_async</a></td></tr>
<tr class="separator:a6c4828e406a12b7df3490788c54f7b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc24fd2743dc03341f6774eccf60a06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#aedc24fd2743dc03341f6774eccf60a06">delete</a></td></tr>
<tr class="separator:aedc24fd2743dc03341f6774eccf60a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9da04b2f9d0a5e42e77e06fecbf912d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ab9da04b2f9d0a5e42e77e06fecbf912d">delete_multi</a></td></tr>
<tr class="separator:ab9da04b2f9d0a5e42e77e06fecbf912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c02942744aa77de5d500da0567884"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a044c02942744aa77de5d500da0567884">delete_multi_async</a></td></tr>
<tr class="separator:a044c02942744aa77de5d500da0567884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e296c12222157c17295bcb95467c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ab48e296c12222157c17295bcb95467c0">set</a></td></tr>
<tr class="separator:ab48e296c12222157c17295bcb95467c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99198bc12d80a286e2caba14fffb5628"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a99198bc12d80a286e2caba14fffb5628">add</a></td></tr>
<tr class="separator:a99198bc12d80a286e2caba14fffb5628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e43fa66cbfba00067a33a838229ce8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#af8e43fa66cbfba00067a33a838229ce8">replace</a></td></tr>
<tr class="separator:af8e43fa66cbfba00067a33a838229ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1607c4b4fb60b573f73c0a933ed6dfc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a1607c4b4fb60b573f73c0a933ed6dfc4">cas</a></td></tr>
<tr class="separator:a1607c4b4fb60b573f73c0a933ed6dfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6911c84c85d9d19df98c09da283981ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a6911c84c85d9d19df98c09da283981ed">set_multi</a></td></tr>
<tr class="separator:a6911c84c85d9d19df98c09da283981ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10860f18fa9b49eaa7813661af0837"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a0c10860f18fa9b49eaa7813661af0837">set_multi_async</a></td></tr>
<tr class="separator:a0c10860f18fa9b49eaa7813661af0837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae653393a19906231dd7903350c41a1b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ae653393a19906231dd7903350c41a1b4">add_multi</a></td></tr>
<tr class="separator:ae653393a19906231dd7903350c41a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fb2b7c394b27e35427fee3f3d830aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a96fb2b7c394b27e35427fee3f3d830aa">add_multi_async</a></td></tr>
<tr class="separator:a96fb2b7c394b27e35427fee3f3d830aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed268ee19484f04aad9822c5a6e9ea4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#aed268ee19484f04aad9822c5a6e9ea4e">replace_multi</a></td></tr>
<tr class="separator:aed268ee19484f04aad9822c5a6e9ea4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf676c3e0268c620ab76c1c8ee1123a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#aaf676c3e0268c620ab76c1c8ee1123a6">replace_multi_async</a></td></tr>
<tr class="separator:aaf676c3e0268c620ab76c1c8ee1123a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935554b61d486de2a824d77be4b69f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#ab935554b61d486de2a824d77be4b69f1">cas_multi</a></td></tr>
<tr class="separator:ab935554b61d486de2a824d77be4b69f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19efafadbf96ab3cde9fc82f1e2436d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a19efafadbf96ab3cde9fc82f1e2436d8">cas_multi_async</a></td></tr>
<tr class="separator:a19efafadbf96ab3cde9fc82f1e2436d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b90626f2da1fd13e4d502f18368d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a510b90626f2da1fd13e4d502f18368d0">incr</a></td></tr>
<tr class="separator:a510b90626f2da1fd13e4d502f18368d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034633cc4a4f33e19f07925bee4e7ef0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#a034633cc4a4f33e19f07925bee4e7ef0">incr_async</a></td></tr>
<tr class="separator:a034633cc4a4f33e19f07925bee4e7ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8acecc88793cecbc27046fc72903e85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#af8acecc88793cecbc27046fc72903e85">decr</a></td></tr>
<tr class="separator:af8acecc88793cecbc27046fc72903e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe702ce47bc0146d7181c8d74f63169"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#adbe702ce47bc0146d7181c8d74f63169">decr_async</a></td></tr>
<tr class="separator:adbe702ce47bc0146d7181c8d74f63169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfec4bfe9858a479ca5f00c758ca012"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#addfec4bfe9858a479ca5f00c758ca012">offset_multi</a></td></tr>
<tr class="separator:addfec4bfe9858a479ca5f00c758ca012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa857665999e2e87a41ac208e705740c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1api_1_1memcache_1_1_client.html#aa857665999e2e87a41ac208e705740c0">offset_multi_async</a></td></tr>
<tr class="separator:aa857665999e2e87a41ac208e705740c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Memcache client object, through which one invokes all memcache operations.

Several methods are no-ops to retain source-level compatibility
with the existing popular Python memcache library.

Any method that takes a 'key' argument will accept that key as a string
(unicode or not) or a tuple of (hash_value, string) where the hash_value,
normally used for sharding onto a memcache instance, is instead ignored, as
Google App Engine deals with the sharding transparently. Keys in memcache are
just bytes, without a specified encoding. All such methods may raise TypeError
if provided a bogus key value and a ValueError if the key is too large.

Any method that takes a 'value' argument will accept as that value any
string (unicode or not), int, long, or pickle-able Python object, including
all native types.  You'll get back from the cache the same type that you
originally put in.

The Client class is not thread-safe with respect to the gets(), cas() and
cas_multi() methods (and other compare-and-set-related methods). Therefore,
Client objects should not be used by more than one thread for CAS purposes.
Note that the global Client for the module-level functions is okay because it
does not expose any of the CAS methods.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab11226cb7213eb4385abf6d8e2b4a37f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>servers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>debug</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickleProtocol</em> = <code>cPickle.HIGHEST_PROTOCOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickler</em> = <code>cPickle.Pickler</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpickler</em> = <code>cPickle.Unpickler</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pload</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>make_sync_call</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_app_id</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new Client object.

No parameters are required.

Arguments:
  servers: Ignored; only for compatibility.
  debug: Ignored; only for compatibility.
  pickleProtocol: Pickle protocol to use for pickling the object.
  pickler: pickle.Pickler sub-class to use for pickling.
  unpickler: pickle.Unpickler sub-class to use for unpickling.
  pload: Callable to use for retrieving objects by persistent id.
  pid: Callable to use for determine the persistent id for objects, if any.
  make_sync_call: Ignored; only for compatibility with an earlier version.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a99198bc12d80a286e2caba14fffb5628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets a key's value, iff item is not already in memcache.

Args:
  key: Key to set.  See docs on Client for details.
  value: Value to set.  Any type.  If complex, will be pickled.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  min_compress_len: Ignored option for compatibility.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  True if added.  False on error.
</pre> 
</div>
</div>
<a class="anchor" id="ae653393a19906231dd7903350c41a1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.add_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set multiple keys' values iff items are not already in memcache.

Args:
  mapping: Dictionary of keys to values.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  key_prefix: Prefix for to prepend to all keys.
  min_compress_len: Unimplemented compatibility option.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  A list of keys whose values were NOT set because they did not already
  exist in memcache.  On total success, this list should be empty.
</pre> 
</div>
</div>
<a class="anchor" id="a96fb2b7c394b27e35427fee3f3d830aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.add_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of add_multi() -- note different return value.

Returns:
  See _set_multi_async_with_policy().
</pre> 
</div>
</div>
<a class="anchor" id="a1607c4b4fb60b573f73c0a933ed6dfc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.cas </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compare-And-Set update.

This requires that the key has previously been successfully
fetched with gets() or get(..., for_cas=True), and that no changes
have been made to the key since that fetch.  Typical usage is:

  key = ...
  client = memcache.Client()
  value = client.gets(key)  # OR client.get(key, for_cas=True)
  &lt;updated value&gt;
  ok = client.cas(key, value)

If two processes run similar code, the first one calling cas()
will succeed (ok == True), while the second one will fail (ok ==
False).  This can be used to detect race conditions.

NOTE: some state (the CAS id) is stored on the Client object for
each key ever used with gets().  To prevent ever-increasing memory
usage, you must use a Client object when using cas(), and the
lifetime of your Client object should be limited to that of one
incoming HTTP request.  You cannot use the global-function-based
API.

Args:
  key: Key to set.  See docs on Client for details.
  value: The new value.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  min_compress_len: Ignored option for compatibility.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  True if updated.  False on RPC error or if the CAS id didn't match.
</pre> 
</div>
</div>
<a class="anchor" id="ab935554b61d486de2a824d77be4b69f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.cas_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compare-And-Set update for multiple keys.

See cas() docstring for an explanation.

Args:
  mapping: Dictionary of keys to values.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  key_prefix: Prefix for to prepend to all keys.
  min_compress_len: Unimplemented compatibility option.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  A list of keys whose values were NOT set because the compare
  failed.  On total success, this list should be empty.
</pre> 
</div>
</div>
<a class="anchor" id="a19efafadbf96ab3cde9fc82f1e2436d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.cas_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of cas_multi() -- note different return value.

Returns:
  See _set_multi_async_with_policy().
</pre> 
</div>
</div>
<a class="anchor" id="ad6d7b57fc8e5ac61f902a2dc56711d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.cas_reset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear the remembered CAS ids.</pre> 
</div>
</div>
<a class="anchor" id="acb572e576d9c2997001d45f0d3448d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.debuglog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Logging function for debugging information.

This is purely a compatibility method.  In Google App Engine, it's a no-op.
</pre> 
</div>
</div>
<a class="anchor" id="af8acecc88793cecbc27046fc72903e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.decr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Atomically decrements a key's value.

Internally, the value is a unsigned 64-bit integer.  Memcache
caps decrementing below zero to zero.

The key must already exist in the cache to be decremented.  See
docs on incr() for details.

Args:
  key: Key to decrement. If an iterable collection, each one of the keys
  will be offset.  See Client's docstring for details.
  delta: Non-negative integer value (int or long) to decrement key by,
defaulting to 1.
  namespace: a string specifying an optional namespace to use in
the request.
  initial_value: initial value to put in the cache, if it doesn't
already exist.  The default value, None, will not create a cache
entry if it doesn't already exist.

Returns:
  If key was a single value, the new long integer value, or None if key
  was not in the cache, could not be decremented for any other reason, or
  a network/RPC/server error occurred.

  If key was an iterable collection, a dictionary will be returned
  mapping supplied keys to values, with the values having the same meaning
  as the singular return value of this method.

Raises:
  ValueError: If number is negative.
  TypeError: If delta isn't an int or long.
</pre> 
</div>
</div>
<a class="anchor" id="adbe702ce47bc0146d7181c8d74f63169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.decr_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of decr().

Returns:
  A UserRPC instance whose get_result() method returns the same
  kind of value as decr() returns.
</pre> 
</div>
</div>
<a class="anchor" id="aedc24fd2743dc03341f6774eccf60a06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seconds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deletes a key from memcache.

Args:
  key: Key to delete.  See docs on Client for detils.
  seconds: Optional number of seconds to make deleted items 'locked'
for 'add' operations. Value can be a delta from current time (up to
1 month), or an absolute Unix epoch time.  Defaults to 0, which means
items can be immediately added.  With or without this option,
a 'set' operation will always work.  Float values will be rounded up to
the nearest whole second.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  DELETE_NETWORK_FAILURE (0) on network failure,
  DELETE_ITEM_MISSING (1) if the server tried to delete the item but
  didn't have it, or
  DELETE_SUCCESSFUL (2) if the item was actually deleted.
  This can be used as a boolean value, where a network failure is the
  only bad condition.
</pre> 
</div>
</div>
<a class="anchor" id="ab9da04b2f9d0a5e42e77e06fecbf912d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.delete_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seconds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Delete multiple keys at once.

Args:
  keys: List of keys to delete.
  seconds: Optional number of seconds to make deleted items 'locked'
for 'add' operations. Value can be a delta from current time (up to
1 month), or an absolute Unix epoch time.  Defaults to 0, which means
items can be immediately added.  With or without this option,
a 'set' operation will always work.  Float values will be rounded up to
the nearest whole second.
  key_prefix: Prefix to put on all keys when sending specified
keys to memcache.  See docs for get_multi() and set_multi().
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  True if all operations completed successfully.  False if one
  or more failed to complete.
</pre> 
</div>
</div>
<a class="anchor" id="a044c02942744aa77de5d500da0567884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.delete_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seconds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of delete_multi() -- note different return value.

Returns:
  A UserRPC instance whose get_result() method returns None if
  there was a network error, or a list of status values otherwise,
  where each status corresponds to a key and is either
  DELETE_SUCCESSFUL, DELETE_ITEM_MISSING, or DELETE_NETWORK_FAILURE
  (see delete() docstring for details).
</pre> 
</div>
</div>
<a class="anchor" id="ae73b09d1c3592bc674c40424320599f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.disconnect_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Closes all connections to memcache servers.

This is purely a compatibility method.  In Google App Engine, it's a no-op.
</pre> 
</div>
</div>
<a class="anchor" id="a6176af67ff37d8e156a35a136ec77fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.flush_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deletes everything in memcache.

Returns:
  True on success, False on RPC or server error.
</pre> 
</div>
</div>
<a class="anchor" id="a685ce45af8457bd2241999c2336340b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.flush_all_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of flush_all().

Returns:
  A UserRPC instance whose get_result() method returns True on
  success, False on RPC or server error.
</pre> 
</div>
</div>
<a class="anchor" id="a893443776a1cc1fa8e7e7fee68b32e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.forget_dead_hosts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resets all servers to the alive status.

This is purely a compatibility method.  In Google App Engine, it's a no-op.
</pre> 
</div>
</div>
<a class="anchor" id="a4a40cd055713a76e2762302d5716c456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.get </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>for_cas</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Looks up a single key in memcache.

If you have multiple items to load, though, it's much more efficient
to use get_multi() instead, which loads them in one bulk operation,
reducing the networking latency that'd otherwise be required to do
many serialized get() operations.

Args:
  key: The key in memcache to look up.  See docs on Client
for details of format.
  namespace: a string specifying an optional namespace to use in
the request.
  for_cas: If True, request and store CAS ids on the client (see
cas() operation below).

Returns:
  The value of the key, if found in memcache, else None.
</pre> 
</div>
</div>
<a class="anchor" id="af9e20bb82254543609f0e77e45fcd36d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.get_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>for_cas</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Looks up multiple keys from memcache in one operation.

This is the recommended way to do bulk loads.

Args:
  keys: List of keys to look up.  Keys may be strings or
tuples of (hash_value, string).  Google App Engine
does the sharding and hashing automatically, though, so the hash
value is ignored.  To memcache, keys are just series of bytes,
and not in any particular encoding.
  key_prefix: Prefix to prepend to all keys when talking to the server;
not included in the returned dictionary.
  namespace: a string specifying an optional namespace to use in
the request.
  for_cas: If True, request and store CAS ids on the client.

Returns:
  A dictionary of the keys and values that were present in memcache.
  Even if the key_prefix was specified, that key_prefix won't be on
  the keys in the returned dictionary.
</pre> 
</div>
</div>
<a class="anchor" id="a6c4828e406a12b7df3490788c54f7b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.get_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>for_cas</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of get_multi().

Returns:
  A UserRPC instance whose get_result() method returns {} if
  there was a network error, otherwise a dict just like
  get_multi() returns.
</pre> 
</div>
</div>
<a class="anchor" id="ad8dc0633f638fd5df09f869fb4938d3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.get_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets memcache statistics for this application.

All of these statistics may reset due to various transient conditions. They
provide the best information available at the time of being called.

Returns:
  Dictionary mapping statistic names to associated values. Statistics and
  their associated meanings:

hits: Number of cache get requests resulting in a cache hit.
misses: Number of cache get requests resulting in a cache miss.
byte_hits: Sum of bytes transferred on get requests. Rolls over to
  zero on overflow.
items: Number of key/value pairs in the cache.
bytes: Total size of all items in the cache.
oldest_item_age: How long in seconds since the oldest item in the
  cache was accessed. Effectively, this indicates how long a new
  item will survive in the cache without being accessed. This is
  _not_ the amount of time that has elapsed since the item was
  created.

  On error, returns None.
</pre> 
</div>
</div>
<a class="anchor" id="ae0e0727cdcb5462f51e572055bc2c673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.get_stats_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of get_stats().

Returns:
  A UserRPC instance whose get_result() method returns None if
  there was a network error, otherwise a dict just like
  get_stats() returns.
</pre> 
</div>
</div>
<a class="anchor" id="a168db4d27f5227bed44f27e8deae805c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.gets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An alias for get(..., for_cas=True).</pre> 
</div>
</div>
<a class="anchor" id="a510b90626f2da1fd13e4d502f18368d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.incr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Atomically increments a key's value.

Internally, the value is a unsigned 64-bit integer.  Memcache
doesn't check 64-bit overflows.  The value, if too large, will
wrap around.

Unless an initial_value is specified, the key must already exist
in the cache to be incremented.  To initialize a counter, either
specify initial_value or set() it to the initial value, as an
ASCII decimal integer.  Future get()s of the key, post-increment,
will still be an ASCII decimal value.

Args:
  key: Key to increment. If an iterable collection, each one of the keys
  will be offset. See Client's docstring for details.
  delta: Non-negative integer value (int or long) to increment key by,
defaulting to 1.
  namespace: a string specifying an optional namespace to use in
the request.
  initial_value: initial value to put in the cache, if it doesn't
already exist.  The default value, None, will not create a cache
entry if it doesn't already exist.

Returns:
  If key was a single value, the new long integer value, or None if key
  was not in the cache, could not be incremented for any other reason, or
  a network/RPC/server error occurred.

  If key was an iterable collection, a dictionary will be returned
  mapping supplied keys to values, with the values having the same meaning
  as the singular return value of this method.

Raises:
  ValueError: If number is negative.
  TypeError: If delta isn't an int or long.
</pre> 
</div>
</div>
<a class="anchor" id="a034633cc4a4f33e19f07925bee4e7ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.incr_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of incr().

Returns:
  A UserRPC instance whose get_result() method returns the same
  kind of value as incr() returns.
</pre> 
</div>
</div>
<a class="anchor" id="addfec4bfe9858a479ca5f00c758ca012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.offset_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Offsets multiple keys by a delta, incrementing and decrementing in batch.

Args:
  mapping: Dictionary mapping keys to deltas (positive or negative integers)
to apply to each corresponding key.
  key_prefix: Prefix for to prepend to all keys.
  initial_value: Initial value to put in the cache, if it doesn't
already exist. The default value, None, will not create a cache
entry if it doesn't already exist.
  namespace: A string specifying an optional namespace to use in
the request.

Returns:
  Dictionary mapping input keys to new integer values. The new value will
  be None if an error occurs, the key does not already exist, or the value
  was not an integer type. The values will wrap-around at unsigned 64-bit
  integer-maximum and underflow will be floored at zero.
</pre> 
</div>
</div>
<a class="anchor" id="aa857665999e2e87a41ac208e705740c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.offset_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of offset_multi().

Returns:
  A UserRPC instance whose get_result() method returns a dict just
  like offset_multi() returns.
</pre> 
</div>
</div>
<a class="anchor" id="af8e43fa66cbfba00067a33a838229ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replaces a key's value, failing if item isn't already in memcache.

Args:
  key: Key to set.  See docs on Client for details.
  value: Value to set.  Any type.  If complex, will be pickled.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  min_compress_len: Ignored option for compatibility.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  True if replaced.  False on RPC error or cache miss.
</pre> 
</div>
</div>
<a class="anchor" id="aed268ee19484f04aad9822c5a6e9ea4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.replace_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace multiple keys' values, failing if the items aren't in memcache.

Args:
  mapping: Dictionary of keys to values.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  key_prefix: Prefix for to prepend to all keys.
  min_compress_len: Unimplemented compatibility option.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  A list of keys whose values were NOT set because they already existed
  in memcache.  On total success, this list should be empty.
</pre> 
</div>
</div>
<a class="anchor" id="aaf676c3e0268c620ab76c1c8ee1123a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.replace_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of replace_multi() -- note different return value.

Returns:
  See _set_multi_async_with_policy().
</pre> 
</div>
</div>
<a class="anchor" id="ab48e296c12222157c17295bcb95467c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.set </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets a key's value, regardless of previous contents in cache.

Unlike add() and replace(), this method always sets (or
overwrites) the value in memcache, regardless of previous
contents.

Args:
  key: Key to set.  See docs on Client for details.
  value: Value to set.  Any type.  If complex, will be pickled.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  min_compress_len: Ignored option for compatibility.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  True if set.  False on error.
</pre> 
</div>
</div>
<a class="anchor" id="a6911c84c85d9d19df98c09da283981ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.set_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set multiple keys' values at once, regardless of previous contents.

Args:
  mapping: Dictionary of keys to values.
  time: Optional expiration time, either relative number of seconds
from current time (up to 1 month), or an absolute Unix epoch time.
By default, items never expire, though items may be evicted due to
memory pressure.  Float values will be rounded up to the nearest
whole second.
  key_prefix: Prefix for to prepend to all keys.
  min_compress_len: Unimplemented compatibility option.
  namespace: a string specifying an optional namespace to use in
the request.

Returns:
  A list of keys whose values were NOT set.  On total success,
  this list should be empty.
</pre> 
</div>
</div>
<a class="anchor" id="a0c10860f18fa9b49eaa7813661af0837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.set_multi_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_compress_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rpc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async version of set_multi() -- note different return value.

Returns:
  See _set_multi_async_with_policy().
</pre> 
</div>
</div>
<a class="anchor" id="a9ee48e46ab6f7cbab9e73482e41c583c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.api.memcache.Client.set_servers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>servers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets the pool of memcache servers used by the client.

This is purely a compatibility method.  In Google App Engine, it's a no-op.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>code/googleappengine-read-only/python/google/appengine/api/memcache/__init__.py</li>
</ul>
</div><!-- contents -->
<address class="footer">
    <small>Maintained by <a href="http://www.tzmartin.com">tzmartin</a></small>
</address>