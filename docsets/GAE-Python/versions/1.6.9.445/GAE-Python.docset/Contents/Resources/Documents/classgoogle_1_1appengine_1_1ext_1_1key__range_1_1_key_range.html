<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>App Engine Python SDK: google.appengine.ext.key_range.KeyRange Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="common.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gae-python.logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">App Engine Python SDK
   &#160;<span id="projectnumber">v1.6.9 rev.445</span>
   </div>
   <div id="projectbrief">The Python runtime is available as an experimental Preview feature.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>google</b></li><li class="navelem"><b>appengine</b></li><li class="navelem"><b>ext</b></li><li class="navelem"><b>key_range</b></li><li class="navelem"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html">KeyRange</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google.appengine.ext.key_range.KeyRange Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for google.appengine.ext.key_range.KeyRange:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.png" usemap="#google.appengine.ext.key_range.KeyRange_map" alt=""/>
  <map id="google.appengine.ext.key_range.KeyRange_map" name="google.appengine.ext.key_range.KeyRange_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6a32379ad674b070131b7c74bc4645a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#aa6a32379ad674b070131b7c74bc4645a">__init__</a></td></tr>
<tr class="separator:aa6a32379ad674b070131b7c74bc4645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5021f2eb73d57643e193ac7d116579ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5021f2eb73d57643e193ac7d116579ff"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__str__</b></td></tr>
<tr class="separator:a5021f2eb73d57643e193ac7d116579ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e1741c295a8934fa284e585f9e0b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e1741c295a8934fa284e585f9e0b5c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__repr__</b></td></tr>
<tr class="separator:a58e1741c295a8934fa284e585f9e0b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae368fb5f197e65f3fe52a00cda188acb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#ae368fb5f197e65f3fe52a00cda188acb">advance</a></td></tr>
<tr class="separator:ae368fb5f197e65f3fe52a00cda188acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30597527f365c8f487fef71085d338c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#ae30597527f365c8f487fef71085d338c">filter_query</a></td></tr>
<tr class="separator:ae30597527f365c8f487fef71085d338c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56338fc83524f7baacaf002b4413c32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#aa56338fc83524f7baacaf002b4413c32">filter_ndb_query</a></td></tr>
<tr class="separator:aa56338fc83524f7baacaf002b4413c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca521f374c2fe9c6d14a5aa985c84f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#acca521f374c2fe9c6d14a5aa985c84f1">filter_datastore_query</a></td></tr>
<tr class="separator:acca521f374c2fe9c6d14a5aa985c84f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff349c6ecd3143d65866f8c1684a14f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a1ff349c6ecd3143d65866f8c1684a14f">make_directed_query</a></td></tr>
<tr class="separator:a1ff349c6ecd3143d65866f8c1684a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d23b44236eabcff76c4723d043ba77f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a4d23b44236eabcff76c4723d043ba77f">make_directed_ndb_query</a></td></tr>
<tr class="separator:a4d23b44236eabcff76c4723d043ba77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04709b62cd963e0b3e50632ccc3d0ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#ae04709b62cd963e0b3e50632ccc3d0ca">make_directed_datastore_query</a></td></tr>
<tr class="separator:ae04709b62cd963e0b3e50632ccc3d0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69db87f1c2de28b809a7c91ea52f0565"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a69db87f1c2de28b809a7c91ea52f0565">make_ascending_query</a></td></tr>
<tr class="separator:a69db87f1c2de28b809a7c91ea52f0565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44cf8d510979e8e883f6a3dcad54af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a4d44cf8d510979e8e883f6a3dcad54af">make_ascending_ndb_query</a></td></tr>
<tr class="separator:a4d44cf8d510979e8e883f6a3dcad54af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1c41ecb6e27201978f86fcc3474ecc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#acc1c41ecb6e27201978f86fcc3474ecc">make_ascending_datastore_query</a></td></tr>
<tr class="separator:acc1c41ecb6e27201978f86fcc3474ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf87fd8ec86d3818c3a274cccb59217e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#aaf87fd8ec86d3818c3a274cccb59217e">split_range</a></td></tr>
<tr class="separator:aaf87fd8ec86d3818c3a274cccb59217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd569730e05e22c4d8c136ed9b52c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefdd569730e05e22c4d8c136ed9b52c8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__hash__</b></td></tr>
<tr class="separator:aefdd569730e05e22c4d8c136ed9b52c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fe18efd8971e4e7469335c6f21f3ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a20fe18efd8971e4e7469335c6f21f3ce">__cmp__</a></td></tr>
<tr class="separator:a20fe18efd8971e4e7469335c6f21f3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6258fed9d0d1c94cfab413b1e46056e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a6258fed9d0d1c94cfab413b1e46056e4">compute_split_points</a></td></tr>
<tr class="separator:a6258fed9d0d1c94cfab413b1e46056e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11df5d081b7b4f5c1481a9cfceba5a1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a11df5d081b7b4f5c1481a9cfceba5a1c">to_json</a></td></tr>
<tr class="separator:a11df5d081b7b4f5c1481a9cfceba5a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af4af6c22bf1181d88ff827fb516dc4a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#af4af6c22bf1181d88ff827fb516dc4a7">bisect_string_range</a></td></tr>
<tr class="separator:af4af6c22bf1181d88ff827fb516dc4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cb243f24c0d80f3994dd600988e305"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a30cb243f24c0d80f3994dd600988e305">split_keys</a></td></tr>
<tr class="separator:a30cb243f24c0d80f3994dd600988e305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda71883ff637c9cea6442448da1622c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#abda71883ff637c9cea6442448da1622c">guess_end_key</a></td></tr>
<tr class="separator:abda71883ff637c9cea6442448da1622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0cb9c4dc081974dab323d11bb2182a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1ext_1_1key__range_1_1_key_range.html#a2e0cb9c4dc081974dab323d11bb2182a">from_json</a></td></tr>
<tr class="separator:a2e0cb9c4dc081974dab323d11bb2182a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4a8a164285663791b2ada099a8acc9cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a8a164285663791b2ada099a8acc9cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>direction</b></td></tr>
<tr class="separator:a4a8a164285663791b2ada099a8acc9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5a561808c1d788e22b8693993053e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bd5a561808c1d788e22b8693993053e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_start</b></td></tr>
<tr class="separator:a4bd5a561808c1d788e22b8693993053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277b8ea26e2602ac51c82e1879f65cba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a277b8ea26e2602ac51c82e1879f65cba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_end</b></td></tr>
<tr class="separator:a277b8ea26e2602ac51c82e1879f65cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807acc2e76bb0b218c7154324a8aaab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a807acc2e76bb0b218c7154324a8aaab3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>include_start</b></td></tr>
<tr class="separator:a807acc2e76bb0b218c7154324a8aaab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07dce684bc4ee13cad8f849d303917f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07dce684bc4ee13cad8f849d303917f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>include_end</b></td></tr>
<tr class="separator:ab07dce684bc4ee13cad8f849d303917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf9b0f3be0e2ce18f0ccd8e6cfb6055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf9b0f3be0e2ce18f0ccd8e6cfb6055"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>namespace</b></td></tr>
<tr class="separator:aedf9b0f3be0e2ce18f0ccd8e6cfb6055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a61296f9885caebabeaf9b5a424e3bc6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61296f9885caebabeaf9b5a424e3bc6f"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>DESC</b> = &quot;DESC&quot;</td></tr>
<tr class="separator:a61296f9885caebabeaf9b5a424e3bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7608a71d05126177973922dff2f642"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea7608a71d05126177973922dff2f642"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>ASC</b> = &quot;ASC&quot;</td></tr>
<tr class="separator:aea7608a71d05126177973922dff2f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Represents a range of keys in the datastore.

A KeyRange object represents a key range
  (key_start, include_start, key_end, include_end)
and a scan direction (KeyRange.DESC or KeyRange.ASC).
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa6a32379ad674b070131b7c74bc4645a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_start</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_end</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>direction</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include_start</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include_end</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_app</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize a KeyRange object.

Args:
  key_start: The starting key for this range (db.Key or ndb.Key).
  key_end: The ending key for this range (db.Key or ndb.Key).
  direction: The direction of the query for this range.
  include_start: Whether the start key should be included in the range.
  include_end: Whether the end key should be included in the range.
  namespace: The namespace for this range. If None then the current
  namespace is used.

NOTE: If NDB keys are passed in, they are converted to db.Key
instances before being stored.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a20fe18efd8971e4e7469335c6f21f3ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.__cmp__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compare two key ranges.

Key ranges with a value of None for key_start or key_end, are always
considered to have include_start=False or include_end=False, respectively,
when comparing.  Since None indicates an unbounded side of the range,
the include specifier is meaningless.  The ordering generated is total
but somewhat arbitrary.

Args:
  other: An object to compare to this one.

Returns:
  -1: if this key range is less than other.
  0:  if this key range is equal to other.
  1: if this key range is greater than other.
</pre> 
</div>
</div>
<a class="anchor" id="ae368fb5f197e65f3fe52a00cda188acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.advance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Updates the start of the range immediately past the specified key.

Args:
  key: A db.Key or ndb.Key.
</pre> 
</div>
</div>
<a class="anchor" id="af4af6c22bf1181d88ff827fb516dc4a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.bisect_string_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns a string that is approximately in the middle of the range.

(start, end) is treated as a string range, and it is assumed
start &lt;= end in the usual lexicographic string ordering. The output key
mid is guaranteed to satisfy start &lt;= mid &lt;= end.

The method proceeds by comparing initial characters of start and
end.  When the characters are equal, they are appended to the mid
string.  In the first place that the characters differ, the
difference characters are averaged and this average is appended to
the mid string.  If averaging resulted in rounding down, and
additional character is added to the mid string to make up for the
rounding down.  This extra step is necessary for correctness in
the case that the average of the two characters is equal to the
character in the start string.

This method makes the assumption that most keys are ascii and it
attempts to perform splitting within the ascii range when that
results in a valid split.

Args:
  start: A string.
  end: A string such that start &lt;= end.

Returns:
  A string mid such that start &lt;= mid &lt;= end.
</pre> 
</div>
</div>
<a class="anchor" id="a6258fed9d0d1c94cfab413b1e46056e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.compute_split_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a set of KeyRanges that are split points for a kind.

Args:
  kind: String with the entity kind to split.
  count: Number of non-overlapping KeyRanges to generate.

Returns:
  A list of KeyRange objects that are non-overlapping. At most "count" + 1
  KeyRange objects will be returned. At least one will be returned.
</pre> 
</div>
</div>
<a class="anchor" id="acca521f374c2fe9c6d14a5aa985c84f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.filter_datastore_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add query filter to restrict to this key range.

Args:
  query: A datastore.Query instance.
  filters: optional list of filters to apply to the query. Each filter is
a tuple: (&lt;property_name_as_str&gt;, &lt;query_operation_as_str&gt;, &lt;value&gt;).
User filters are applied first.

Returns:
  The input query restricted to this key range.
</pre> 
</div>
</div>
<a class="anchor" id="aa56338fc83524f7baacaf002b4413c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.filter_ndb_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add query filter to restrict to this key range.

Args:
  query: An ndb.Query instance.
  filters: optional list of filters to apply to the query. Each filter is
a tuple: (&lt;property_name_as_str&gt;, &lt;query_operation_as_str&gt;, &lt;value&gt;).
User filters are applied first.

Returns:
  The input query restricted to this key range.
</pre> 
</div>
</div>
<a class="anchor" id="ae30597527f365c8f487fef71085d338c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.filter_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add query filter to restrict to this key range.

Args:
  query: A db.Query or ndb.Query instance.
  filters: optional list of filters to apply to the query. Each filter is
a tuple: (&lt;property_name_as_str&gt;, &lt;query_operation_as_str&gt;, &lt;value&gt;).
User filters are applied first.

Returns:
  The input query restricted to this key range.
</pre> 
</div>
</div>
<a class="anchor" id="a2e0cb9c4dc081974dab323d11bb2182a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.from_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>json_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Deserialize KeyRange from its json representation.

Args:
  json_str: string with json representation created by key_range_to_json.

Returns:
  deserialized KeyRange instance.
</pre> 
</div>
</div>
<a class="anchor" id="abda71883ff637c9cea6442448da1622c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.guess_end_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>probe_count</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>split_rate</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Guess the end of a key range with a binary search of probe queries.

When the 'key_start' parameter has a key hierarchy, this function will
only determine the key range for keys in a similar hierarchy. That means
if the keys are in the form:

  kind=Foo, name=bar/kind=Stuff, name=meep

only this range will be probed:

  kind=Foo, name=*/kind=Stuff, name=*

That means other entities of kind 'Stuff' that are children of another
parent entity kind will be skipped:

  kind=Other, name=cookie/kind=Stuff, name=meep

Args:
  key_start: The starting key of the search range. In most cases this
should be id = 0 or name = '\0'.  May be db.Key or ndb.Key.
  kind: String name of the entity kind.
  probe_count: Optional, how many probe queries to run.
  split_rate: Exponential rate to use for splitting the range on the
way down from the full key space. For smaller ranges this should
be higher so more of the keyspace is skipped on initial descent.

Returns:
  db.Key that is guaranteed to be as high or higher than the
  highest key existing for this Kind. Doing a query between 'key_start' and
  this returned Key (inclusive) will contain all entities of this Kind.

NOTE: Even though an ndb.Key instance is accepted as argument,
the return value is always a db.Key instance.
</pre> 
</div>
</div>
<a class="anchor" id="acc1c41ecb6e27201978f86fcc3474ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_ascending_datastore_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a query for this key range without setting the scan direction.

Args:
  kind: A string.
  keys_only: bool, default False, use keys_only on Query?
  filters: optional list of filters to apply to the query. Each filter is
a tuple: (&lt;property_name_as_str&gt;, &lt;query_operation_as_str&gt;, &lt;value&gt;).
User filters are applied first.

Returns:
  A datastore.Query instance.
</pre> 
</div>
</div>
<a class="anchor" id="a4d44cf8d510979e8e883f6a3dcad54af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_ascending_ndb_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an NDB query for this key range, without the scan direction.

Args:
  kind_class: An ndb.Model subclass.
  keys_only: bool, default False, query only for keys.

Returns:
  An ndb.Query instance.
</pre> 
</div>
</div>
<a class="anchor" id="a69db87f1c2de28b809a7c91ea52f0565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_ascending_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filters</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a query for this key range without setting the scan direction.

Args:
  kind_class: A kind implementation class (a subclass of either
db.Model or ndb.Model).
  keys_only: bool, default False, query only for keys.
  filters: optional list of filters to apply to the query. Each filter is
a tuple: (&lt;property_name_as_str&gt;, &lt;query_operation_as_str&gt;, &lt;value&gt;).
User filters are applied first.

Returns:
  A db.Query or ndb.Query instance (corresponding to kind_class).
</pre> 
</div>
</div>
<a class="anchor" id="ae04709b62cd963e0b3e50632ccc3d0ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_directed_datastore_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a query for this key range, including the scan direction.

Args:
  kind: A string.
  keys_only: bool, default False, use keys_only on Query?

Returns:
  A datastore.Query instance.

Raises:
  KeyRangeError: if self.direction is not in (KeyRange.ASC, KeyRange.DESC).
</pre> 
</div>
</div>
<a class="anchor" id="a4d23b44236eabcff76c4723d043ba77f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_directed_ndb_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an NDB query for this key range, including the scan direction.

Args:
  kind_class: An ndb.Model subclass.
  keys_only: bool, default False, use keys_only on Query?

Returns:
  An ndb.Query instance.

Raises:
  KeyRangeError: if self.direction is not in (KeyRange.ASC, KeyRange.DESC).
</pre> 
</div>
</div>
<a class="anchor" id="a1ff349c6ecd3143d65866f8c1684a14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.make_directed_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a query for this key range, including the scan direction.

Args:
  kind_class: A kind implementation class (a subclass of either
db.Model or ndb.Model).
  keys_only: bool, default False, use keys_only on Query?

Returns:
  A db.Query or ndb.Query instance (corresponding to kind_class).

Raises:
  KeyRangeError: if self.direction is not in (KeyRange.ASC, KeyRange.DESC).
</pre> 
</div>
</div>
<a class="anchor" id="a30cb243f24c0d80f3994dd600988e305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.split_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a key that is between key_start and key_end inclusive.

This method compares components of the ancestor paths of key_start
and key_end.  The first place in the path that differs is
approximately split in half.  If the kind components differ, a new
non-existent kind halfway between the two is used to split the
space. If the id_or_name components differ, then a new id_or_name
that is halfway between the two is selected.  If the lower
id_or_name is numeric and the upper id_or_name is a string, then
the minumum string key u'\0' is used as the split id_or_name.  The
key that is returned is the shared portion of the ancestor path
followed by the generated split component.

Args:
  key_start: A db.Key or ndb.Key instance for the lower end of a range.
  key_end: A db.Key or ndb.Key instance for the upper end of a range.
  batch_size: The maximum size of a range that should not be split.

Returns:
  A db.Key instance, k, such that key_start &lt;= k &lt;= key_end.

NOTE: Even though ndb.Key instances are accepted as arguments,
the return value is always a db.Key instance.
</pre> 
</div>
</div>
<a class="anchor" id="aaf87fd8ec86d3818c3a274cccb59217e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.split_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split this key range into a list of at most two ranges.

This method attempts to split the key range approximately in half.
Numeric ranges are split in the middle into two equal ranges and
string ranges are split lexicographically in the middle.  If the
key range is smaller than batch_size it is left unsplit.

Note that splitting is done without knowledge of the distribution
of actual entities in the key range, so there is no guarantee (nor
any particular reason to believe) that the entities of the range
are evenly split.

Args:
  batch_size: The maximum size of a key range that should not be split.

Returns:
  A list of one or two key ranges covering the same space as this range.
</pre> 
</div>
</div>
<a class="anchor" id="a11df5d081b7b4f5c1481a9cfceba5a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def google.appengine.ext.key_range.KeyRange.to_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Serialize KeyRange to json.

Returns:
  string with KeyRange json representation.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>code/googleappengine-read-only/python/google/appengine/ext/key_range/__init__.py</li>
</ul>
</div><!-- contents -->
<address class="footer">
    <small>Maintained by <a href="http://www.tzmartin.com">tzmartin</a></small>
</address>