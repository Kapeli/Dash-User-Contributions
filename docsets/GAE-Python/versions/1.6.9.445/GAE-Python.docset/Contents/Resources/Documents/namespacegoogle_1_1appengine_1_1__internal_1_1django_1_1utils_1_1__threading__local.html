<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>App Engine Python SDK: google.appengine._internal.django.utils._threading_local Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="common.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gae-python.logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">App Engine Python SDK
   &#160;<span id="projectnumber">v1.6.9 rev.445</span>
   </div>
   <div id="projectbrief">The Python runtime is available as an experimental Preview feature.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>google</b></li><li class="navelem"><b>appengine</b></li><li class="navelem"><b>_internal</b></li><li class="navelem"><b>django</b></li><li class="navelem"><b>utils</b></li><li class="navelem"><a class="el" href="namespacegoogle_1_1appengine_1_1__internal_1_1django_1_1utils_1_1__threading__local.html">_threading_local</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">google.appengine._internal.django.utils._threading_local Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1__internal_1_1django_1_1utils_1_1__threading__local_1_1__localbase.html">_localbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1appengine_1_1__internal_1_1django_1_1utils_1_1__threading__local_1_1local.html">local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Thread-local objects

(Note that this module provides a Python version of thread
 threading.local class.  Depending on the version of Python you're
 using, there may be a faster one available.  You should always import
 the local class from threading.)

Thread-local objects support the management of thread-local data.
If you have data that you want to be local to a thread, simply create
a thread-local object and use its attributes:

  &gt;&gt;&gt; mydata = local()
  &gt;&gt;&gt; mydata.number = 42
  &gt;&gt;&gt; mydata.number
  42

You can also access the local-object's dictionary:

  &gt;&gt;&gt; mydata.__dict__
  {'number': 42}
  &gt;&gt;&gt; mydata.__dict__.setdefault('widgets', [])
  []
  &gt;&gt;&gt; mydata.widgets
  []

What's important about thread-local objects is that their data are
local to a thread. If we access the data in a different thread:

  &gt;&gt;&gt; log = []
  &gt;&gt;&gt; def f():
  ...     items = mydata.__dict__.items()
  ...     items.sort()
  ...     log.append(items)
  ...     mydata.number = 11
  ...     log.append(mydata.number)

  &gt;&gt;&gt; import threading
  &gt;&gt;&gt; thread = threading.Thread(target=f)
  &gt;&gt;&gt; thread.start()
  &gt;&gt;&gt; thread.join()
  &gt;&gt;&gt; log
  [[], 11]

we get different data.  Furthermore, changes made in the other thread
don't affect data seen in this thread:

  &gt;&gt;&gt; mydata.number
  42

Of course, values you get from a local object, including a __dict__
attribute, are for whatever thread was current at the time the
attribute was read.  For that reason, you generally don't want to save
these values across threads, as they apply only to the thread they
came from.

You can create custom local objects by subclassing the local class:

  &gt;&gt;&gt; class MyLocal(local):
  ...     number = 2
  ...     initialized = False
  ...     def __init__(self, **kw):
  ...         if self.initialized:
  ...             raise SystemError('__init__ called too many times')
  ...         self.initialized = True
  ...         self.__dict__.update(kw)
  ...     def squared(self):
  ...         return self.number ** 2

This can be useful to support default values, methods and
initialization.  Note that if you define an __init__ method, it will be
called each time the local object is used in a separate thread.  This
is necessary to initialize each thread's dictionary.

Now if we create a local object:

  &gt;&gt;&gt; mydata = MyLocal(color='red')

Now we have a default number:

  &gt;&gt;&gt; mydata.number
  2

an initial color:

  &gt;&gt;&gt; mydata.color
  'red'
  &gt;&gt;&gt; del mydata.color

And a method that operates on the data:

  &gt;&gt;&gt; mydata.squared()
  4

As before, we can access the data in a separate thread:

  &gt;&gt;&gt; log = []
  &gt;&gt;&gt; thread = threading.Thread(target=f)
  &gt;&gt;&gt; thread.start()
  &gt;&gt;&gt; thread.join()
  &gt;&gt;&gt; log
  [[('color', 'red'), ('initialized', True)], 11]

without affecting this thread's data:

  &gt;&gt;&gt; mydata.number
  2
  &gt;&gt;&gt; mydata.color
  Traceback (most recent call last):
  ...
  AttributeError: 'MyLocal' object has no attribute 'color'

Note that subclasses can define slots, but they are not thread
local. They are shared across threads:

  &gt;&gt;&gt; class MyLocal(local):
  ...     __slots__ = 'number'

  &gt;&gt;&gt; mydata = MyLocal()
  &gt;&gt;&gt; mydata.number = 42
  &gt;&gt;&gt; mydata.color = 'red'

So, the separate thread:

  &gt;&gt;&gt; thread = threading.Thread(target=f)
  &gt;&gt;&gt; thread.start()
  &gt;&gt;&gt; thread.join()

affects what we see:

  &gt;&gt;&gt; mydata.number
  11

&gt;&gt;&gt; del mydata
</pre> </div></div><!-- contents -->
<address class="footer">
    <small>Maintained by <a href="http://www.tzmartin.com">tzmartin</a></small>
</address>