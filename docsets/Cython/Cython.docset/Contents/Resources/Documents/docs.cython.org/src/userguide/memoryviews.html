

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from docs.cython.org/src/userguide/memoryviews.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 22 Apr 2014 23:32:58 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Typed Memoryviews &mdash; Cython 0.20 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.20',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Cython 0.20 documentation" href="../../index-2.html" />
    <link rel="up" title="Users Guide" href="index.html" />
    <link rel="next" title="Using Parallelism" href="parallelism.html" />
    <link rel="prev" title="Differences between Cython and Pyrex" href="pyrex_differences.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="parallelism.html" title="Using Parallelism"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="pyrex_differences.html" title="Differences between Cython and Pyrex"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index-2.html">Cython 0.20 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Users Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="typed-memoryviews">
<span id="memoryviews"></span><h1>Typed Memoryviews<a class="headerlink" href="#typed-memoryviews" title="Permalink to this headline">¶</a></h1>
<p>Typed memoryviews allow efficient access to memory buffers, such as those
underlying NumPy arrays, without incurring any Python overhead.
Memoryviews are similar to the current NumPy array buffer support
(<tt class="docutils literal"><span class="pre">np.ndarray[np.float64_t,</span> <span class="pre">ndim=2]</span></tt>), but
they have more features and cleaner syntax.</p>
<p>Memoryviews are more general than the old NumPy array buffer support, because
they can handle a wider variety of sources of array data.  For example, they can
handle C arrays and the Cython array type (<a class="reference internal" href="#view-cython-arrays"><em>Cython arrays</em></a>).</p>
<p>A memoryview can be used in any context (function parameters, module-level, cdef
class attribute, etc) and can be obtained from nearly any object that
exposes writable buffer through the <a class="reference external" href="http://www.python.org/peps/pep-3118.html">PEP 3118</a> buffer interface.</p>
<div class="section" id="quickstart">
<span id="view-quickstart"></span><h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">from</span> <span class="nn">cython.view</span> <span class="k">cimport</span> <span class="n">array</span> <span class="k">as</span> <span class="n">cvarray</span>
<span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c"># Memoryview on a NumPy array</span>
<span class="n">narr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">27</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">))</span>
<span class="k">cdef</span> <span class="kt">int</span> [<span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">narr_view</span> <span class="o">=</span> <span class="n">narr</span>

<span class="c"># Memoryview on a C array</span>
<span class="k">cdef</span> <span class="kt">int</span> <span class="kt">carr</span>[3][3][3]
<span class="k">cdef</span> <span class="kt">int</span> [<span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">carr_view</span> <span class="o">=</span> <span class="n">carr</span>

<span class="c"># Memoryview on a Cython array</span>
<span class="n">cyarr</span> <span class="o">=</span> <span class="n">cvarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">),</span> <span class="n">itemsize</span><span class="o">=</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;i&quot;</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">int</span> [<span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">cyarr_view</span> <span class="o">=</span> <span class="n">cyarr</span>

<span class="c"># Show the sum of all the arrays before altering it</span>
<span class="k">print</span> <span class="s">&quot;NumPy sum of the NumPy array before assignments:&quot;</span><span class="p">,</span> <span class="n">narr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c"># We can copy the values from one memoryview into another using a single</span>
<span class="c"># statement, by either indexing with ... or (NumPy-style) with a colon.</span>
<span class="n">carr_view</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">narr_view</span>
<span class="n">cyarr_view</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">narr_view</span>
<span class="c"># NumPy-style syntax for assigning a single value to all elements.</span>
<span class="n">narr_view</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">3</span>

<span class="c"># Just to distinguish the arrays</span>
<span class="n">carr_view</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">100</span>
<span class="n">cyarr_view</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1000</span>

<span class="c"># Assigning into the memoryview on the NumPy array alters the latter</span>
<span class="k">print</span> <span class="s">&quot;NumPy sum of NumPy array after assignments:&quot;</span><span class="p">,</span> <span class="n">narr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c"># A function using a memoryview does not usually need the GIL</span>
<span class="k">cpdef</span> <span class="kt">int</span> <span class="nf">sum3d</span><span class="p">(</span><span class="nb">int</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">arr</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">total</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="c"># A function accepting a memoryview knows how to use a NumPy array,</span>
<span class="c"># a C array, a Cython array...</span>
<span class="k">print</span> <span class="s">&quot;Memoryview sum of NumPy array is&quot;</span><span class="p">,</span> <span class="n">sum3d</span><span class="p">(</span><span class="n">narr</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Memoryview sum of C array is&quot;</span><span class="p">,</span> <span class="n">sum3d</span><span class="p">(</span><span class="n">carr</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Memoryview sum of Cython array is&quot;</span><span class="p">,</span> <span class="n">sum3d</span><span class="p">(</span><span class="n">cyarr</span><span class="p">)</span>
<span class="c"># ... and of course, a memoryview.</span>
<span class="k">print</span> <span class="s">&quot;Memoryview sum of C memoryview is&quot;</span><span class="p">,</span> <span class="n">sum3d</span><span class="p">(</span><span class="n">carr_view</span><span class="p">)</span>
</pre></div>
</div>
<p>This code should give the following output:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">NumPy</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">NumPy</span> <span class="n">array</span> <span class="n">before</span> <span class="n">assignments</span><span class="p">:</span> <span class="mf">351</span>
<span class="n">NumPy</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">NumPy</span> <span class="n">array</span> <span class="n">after</span> <span class="n">assignments</span><span class="p">:</span> <span class="mf">81</span>
<span class="n">Memoryview</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">NumPy</span> <span class="n">array</span> <span class="ow">is</span> <span class="mf">81</span>
<span class="n">Memoryview</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">C</span> <span class="n">array</span> <span class="ow">is</span> <span class="mf">451</span>
<span class="n">Memoryview</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">Cython</span> <span class="n">array</span> <span class="ow">is</span> <span class="mf">1351</span>
<span class="n">Memoryview</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">C</span> <span class="n">memoryview</span> <span class="ow">is</span> <span class="mf">451</span>
</pre></div>
</div>
</div>
<div class="section" id="using-memoryviews">
<h2>Using memoryviews<a class="headerlink" href="#using-memoryviews" title="Permalink to this headline">¶</a></h2>
<div class="section" id="indexing-and-slicing">
<h3>Indexing and Slicing<a class="headerlink" href="#indexing-and-slicing" title="Permalink to this headline">¶</a></h3>
<p>Indexing and slicing can be done with or without the GIL. It basically works
like NumPy. If indices are specified for every dimension you will get an element
of the base type (e.g. <cite>int</cite>), otherwise you will get a new view. An Ellipsis
means you get consecutive slices for every unspecified dimension:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">my_view</span> <span class="o">=</span> <span class="o">...</span>

<span class="c"># These are all equivalent</span>
<span class="n">my_view</span><span class="p">[</span><span class="mf">10</span><span class="p">]</span>
<span class="n">my_view</span><span class="p">[</span><span class="mf">10</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
<span class="n">my_view</span><span class="p">[</span><span class="mf">10</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="copying">
<h3>Copying<a class="headerlink" href="#copying" title="Permalink to this headline">¶</a></h3>
<p>Memoryviews can be copied inplace:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">to_view</span><span class="p">,</span> <span class="n">from_view</span>
<span class="o">...</span>

<span class="c"># copy the elements in from_view to to_view</span>
<span class="n">to_view</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_view</span>
<span class="c"># or</span>
<span class="n">to_view</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">from_view</span>
<span class="c"># or</span>
<span class="n">to_view</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">from_view</span>
</pre></div>
</div>
<p>They can also be copied with the <tt class="docutils literal"><span class="pre">copy()</span></tt> and <tt class="docutils literal"><span class="pre">copy_fortran()</span></tt> methods; see
<a class="reference internal" href="#view-copy-c-fortran"><em>C and Fortran contiguous copies</em></a>.</p>
</div>
<div class="section" id="transposing">
<span id="view-transposing"></span><h3>Transposing<a class="headerlink" href="#transposing" title="Permalink to this headline">¶</a></h3>
<p>In most cases (see below), the memoryview can be transposed in the same way that
NumPy slices can be transposed:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">c_contig</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">:]</span> <span class="n">f_contig</span> <span class="o">=</span> <span class="n">c_contig</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>This gives a new, transposed, view on the data.</p>
<p>Transposing requires that all dimensions of the memoryview have a
direct access memory layout (i.e., there are no indirections through pointers).
See <a class="reference internal" href="#view-general-layouts"><em>Specifying more general memory layouts</em></a> for details.</p>
</div>
<div class="section" id="newaxis">
<h3>Newaxis<a class="headerlink" href="#newaxis" title="Permalink to this headline">¶</a></h3>
<p>As for NumPy, new axes can be introduced by indexing an array with <tt class="docutils literal"><span class="pre">None</span></tt></p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">double</span>[<span class="p">:]</span> <span class="n">myslice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mf">50</span><span class="p">)</span>

<span class="c"># 2D array with shape (1, 50)</span>
<span class="n">myslice</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="c"># or</span>
<span class="n">myslice</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>

<span class="c"># 2D array with shape (50, 1)</span>
<span class="n">myslice</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>
</pre></div>
</div>
<p>One may mix new axis indexing with all other forms of indexing and slicing.
See also an <a class="reference external" href="http://www.scipy.org/Numpy_Example_List#newaxis">example</a>.</p>
</div>
</div>
<div class="section" id="comparison-to-the-old-buffer-support">
<h2>Comparison to the old buffer support<a class="headerlink" href="#comparison-to-the-old-buffer-support" title="Permalink to this headline">¶</a></h2>
<p>You will probably prefer memoryviews to the older syntax because:</p>
<ul class="simple">
<li>The syntax is cleaner</li>
<li>Memoryviews do not usually need the GIL (see <a class="reference internal" href="#view-needs-gil"><em>Memoryviews and the GIL</em></a>)</li>
<li>Memoryviews are considerably faster</li>
</ul>
<p>For example, this is the old syntax equivalent of the <tt class="docutils literal"><span class="pre">sum3d</span></tt> function above:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cpdef</span> <span class="kt">int</span> <span class="nf">old_sum3d</span><span class="p">(</span><span class="nb">object</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;strided&#39;</span><span class="p">]</span> <span class="n">arr</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">I</span><span class="p">,</span> <span class="nf">J</span><span class="p">,</span> <span class="nf">K</span><span class="p">,</span> <span class="nf">total</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>
</pre></div>
</div>
<p>Note that we can&#8217;t use <tt class="docutils literal"><span class="pre">nogil</span></tt> for the buffer version of the function as we
could for the memoryview version of <tt class="docutils literal"><span class="pre">sum3d</span></tt> above, because buffer objects
are Python objects.  However, even if we don&#8217;t use <tt class="docutils literal"><span class="pre">nogil</span></tt> with the
memoryview, it is significantly faster.  This is a output from an IPython
session after importing both versions:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">2</span><span class="p">]:</span> <span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">In</span> <span class="p">[</span><span class="mf">3</span><span class="p">]:</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mf">40</span><span class="p">,</span> <span class="mf">40</span><span class="p">,</span> <span class="mf">40</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mf">4</span><span class="p">]:</span> <span class="n">timeit</span> <span class="o">-</span><span class="n">r15</span> <span class="n">old_sum3d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="mf">1000</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mf">15</span><span class="p">:</span> <span class="mf">298</span> <span class="n">us</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mf">5</span><span class="p">]:</span> <span class="n">timeit</span> <span class="o">-</span><span class="n">r15</span> <span class="n">sum3d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="mf">1000</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mf">15</span><span class="p">:</span> <span class="mf">219</span> <span class="n">us</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
</div>
<div class="section" id="python-buffer-support">
<h2>Python buffer support<a class="headerlink" href="#python-buffer-support" title="Permalink to this headline">¶</a></h2>
<p>Cython memoryviews support nearly all objects exporting the interface of Python
<a class="reference external" href="http://docs.python.org/c-api/buffer.html">new style buffers</a>.  This is the buffer interface described in <a class="reference external" href="http://www.python.org/peps/pep-3118.html">PEP 3118</a>.
NumPy arrays support this interface, as do <a class="reference internal" href="#view-cython-arrays"><em>Cython arrays</em></a>.  The
&#8220;nearly all&#8221; is because the Python buffer interface allows the <em>elements</em> in the
data array to themselves be pointers; Cython memoryviews do not yet support
this.</p>
</div>
<div class="section" id="memory-layout">
<span id="view-memory-layout"></span><h2>Memory layout<a class="headerlink" href="#memory-layout" title="Permalink to this headline">¶</a></h2>
<p>The buffer interface allows objects to identify the underlying memory in a
variety of ways.  With the exception of pointers for data elements, Cython
memoryviews support all Python new-type buffer layouts. It can be useful to know
or specify memory layout if the memory has to be in a particular format for an
external routine, or for code optimization.</p>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>The concepts are as follows: there is data access and data packing. Data access
means either direct (no pointer) or indirect (pointer).  Data packing means your
data may be contiguous or not contiguous in memory, and may use <em>strides</em> to
identify the jumps in memory consecutive indices need to take for each dimension.</p>
<p>NumPy arrays provide a good model of strided direct data access, so we&#8217;ll use
them for a refresher on the concepts of C and Fortran contiguous arrays, and
data strides.</p>
</div>
<div class="section" id="brief-recap-on-c-fortran-and-strided-memory-layouts">
<h3>Brief recap on C, Fortran and strided memory layouts<a class="headerlink" href="#brief-recap-on-c-fortran-and-strided-memory-layouts" title="Permalink to this headline">¶</a></h3>
<p>The simplest data layout might be a C contiguous array.  This is the default
layout in NumPy and Cython arrays.  C contiguous means that the array data is
continuous in memory (see below) and that neighboring elements in the first
dimension of the array are furthest apart in memory, whereas neighboring
elements in the last dimension are closest together. For example, in NumPy:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">2</span><span class="p">]:</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;3&#39;</span><span class="p">,</span> <span class="s">&#39;4&#39;</span><span class="p">,</span> <span class="s">&#39;5&#39;</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">arr[0,</span> <span class="pre">0]</span></tt> and <tt class="docutils literal"><span class="pre">arr[0,</span> <span class="pre">1]</span></tt> are one byte apart in memory, whereas
<tt class="docutils literal"><span class="pre">arr[0,</span> <span class="pre">0]</span></tt> and <tt class="docutils literal"><span class="pre">arr[1,</span> <span class="pre">0]</span></tt> are 3 bytes apart.  This leads us to the idea of
<em>strides</em>.  Each axis of the array has a stride length, which is the number of
bytes needed to go from one element on this axis to the next element.  In the
case above, the strides for axes 0 and 1 will obviously be:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">3</span><span class="p">]:</span> <span class="n">arr</span><span class="o">.</span><span class="n">strides</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">4</span><span class="p">]:</span> <span class="p">(</span><span class="mf">3</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<p>For a 3D C contiguous array:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">5</span><span class="p">]:</span> <span class="n">c_contig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">))</span>
<span class="n">In</span> <span class="p">[</span><span class="mf">6</span><span class="p">]</span> <span class="n">c_contig</span><span class="o">.</span><span class="n">strides</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">6</span><span class="p">]:</span> <span class="p">(</span><span class="mf">12</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A Fortran contiguous array has the opposite memory ordering, with the elements
on the first axis closest togther in memory:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">7</span><span class="p">]:</span> <span class="n">f_contig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_contig</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mf">8</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">f_contig</span> <span class="o">==</span> <span class="n">c_contig</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">8</span><span class="p">]:</span> <span class="bp">True</span>
<span class="n">In</span> <span class="p">[</span><span class="mf">9</span><span class="p">]:</span> <span class="n">f_contig</span><span class="o">.</span><span class="n">strides</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">9</span><span class="p">]:</span> <span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">6</span><span class="p">)</span>
</pre></div>
</div>
<p>A contiguous array is one for which a single continuous block of memory contains
all the data for the elements of the array, and therefore the memory block
length is the product of number of elements in the array and the size of the
elements in bytes. In the example above, the memory block is 2 * 3 * 4 * 1 bytes
long, where 1 is the length of an int8.</p>
<p>An array can be contiguous without being C or Fortran order:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">10</span><span class="p">]:</span> <span class="n">c_contig</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">2</span><span class="p">))</span><span class="o">.</span><span class="n">strides</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">10</span><span class="p">]:</span> <span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="mf">12</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Slicing an NumPy array can easily make it not contiguous:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mf">11</span><span class="p">]:</span> <span class="n">sliced</span> <span class="o">=</span> <span class="n">c_contig</span><span class="p">[:,</span><span class="mf">1</span><span class="p">,:]</span>
<span class="n">In</span> <span class="p">[</span><span class="mf">12</span><span class="p">]:</span> <span class="n">sliced</span><span class="o">.</span><span class="n">strides</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">12</span><span class="p">]:</span> <span class="p">(</span><span class="mf">12</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mf">13</span><span class="p">]:</span> <span class="n">sliced</span><span class="o">.</span><span class="n">flags</span>
<span class="n">Out</span><span class="p">[</span><span class="mf">13</span><span class="p">]:</span>
<span class="n">C_CONTIGUOUS</span> <span class="p">:</span> <span class="bp">False</span>
<span class="n">F_CONTIGUOUS</span> <span class="p">:</span> <span class="bp">False</span>
<span class="n">OWNDATA</span> <span class="p">:</span> <span class="bp">False</span>
<span class="n">WRITEABLE</span> <span class="p">:</span> <span class="bp">True</span>
<span class="n">ALIGNED</span> <span class="p">:</span> <span class="bp">True</span>
<span class="n">UPDATEIFCOPY</span> <span class="p">:</span> <span class="bp">False</span>
</pre></div>
</div>
</div>
<div class="section" id="default-behavior-for-memoryview-layouts">
<h3>Default behavior for memoryview layouts<a class="headerlink" href="#default-behavior-for-memoryview-layouts" title="Permalink to this headline">¶</a></h3>
<p>As you&#8217;ll see in <a class="reference internal" href="#view-general-layouts"><em>Specifying more general memory layouts</em></a>, you can specify memory layout for
any dimension of an memoryview.  For any dimension for which you don&#8217;t specify a
layout, then the data access is assumed to be direct, and the data packing
assumed to be strided.  For example, that will be the assumption for memoryviews
like:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="nb">int</span> <span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">my_memoryview</span> <span class="o">=</span> <span class="n">obj</span>
</pre></div>
</div>
</div>
<div class="section" id="c-and-fortran-contiguous-memoryviews">
<h3>C and Fortran contiguous memoryviews<a class="headerlink" href="#c-and-fortran-contiguous-memoryviews" title="Permalink to this headline">¶</a></h3>
<p>You can specify C and Fortran contiguous layouts for the memoryview by using the
<tt class="docutils literal"><span class="pre">::1</span></tt> step syntax at definition.  For example, if you know for sure your
memoryview will be on top of a 3D C contiguous layout, you could write:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">c_contiguous</span> <span class="o">=</span> <span class="n">c_contig</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">c_contig</span></tt> could be a C contiguous NumPy array.  The <tt class="docutils literal"><span class="pre">::1</span></tt> at the 3rd
position means that the elements in this 3rd dimension will be one element apart
in memory.  If you know you will have a 3D Fortran contiguous array:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">f_contiguous</span> <span class="o">=</span> <span class="n">f_contig</span>
</pre></div>
</div>
<p>If you try to do this kind of thing:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="c"># This array is C contiguous</span>
<span class="n">c_contig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">))</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">c_contiguous</span> <span class="o">=</span> <span class="n">c_contig</span>

<span class="c"># But this isn&#39;t</span>
<span class="n">c_contiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_contig</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>you will get a <tt class="docutils literal"><span class="pre">ValueError</span></tt> like this at runtime:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">mb312</span><span class="o">/</span><span class="n">dev_trees</span><span class="o">/</span><span class="n">minimal</span><span class="o">-</span><span class="n">cython</span><span class="o">/</span><span class="n">mincy</span><span class="o">.</span><span class="n">pyx</span> <span class="ow">in</span> <span class="n">init</span> <span class="n">mincy</span> <span class="p">(</span><span class="n">mincy</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mf">17267</span><span class="p">)()</span>
    <span class="mf">69</span>
    <span class="mf">70</span> <span class="c"># But this isn&#39;t</span>
<span class="o">---&gt;</span> <span class="mf">71</span> <span class="n">c_contiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_contig</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
    <span class="mf">72</span>
    <span class="mf">73</span> <span class="c"># Show the sum of all the arrays before altering it</span>

<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">mb312</span><span class="o">/</span><span class="n">dev_trees</span><span class="o">/</span><span class="n">minimal</span><span class="o">-</span><span class="n">cython</span><span class="o">/</span><span class="n">stringsource</span> <span class="ow">in</span> <span class="n">View</span><span class="o">.</span><span class="n">MemoryView</span><span class="o">.</span><span class="n">memoryview_cwrapper</span> <span class="p">(</span><span class="n">mincy</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mf">9995</span><span class="p">)()</span>

<span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">mb312</span><span class="o">/</span><span class="n">dev_trees</span><span class="o">/</span><span class="n">minimal</span><span class="o">-</span><span class="n">cython</span><span class="o">/</span><span class="n">stringsource</span> <span class="ow">in</span> <span class="n">View</span><span class="o">.</span><span class="n">MemoryView</span><span class="o">.</span><span class="n">memoryview</span><span class="o">.</span><span class="n">__cinit__</span> <span class="p">(</span><span class="n">mincy</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mf">6799</span><span class="p">)()</span>

<span class="ne">ValueError</span><span class="p">:</span> <span class="n">ndarray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">C</span><span class="o">-</span><span class="n">contiguous</span>
</pre></div>
</div>
<p>Thus the <cite>::1</cite> in the slice type specification indicates in which dimension the
data is contiguous.  It can only be used to specify full C or Fortran
contiguity.</p>
</div>
<div class="section" id="c-and-fortran-contiguous-copies">
<span id="view-copy-c-fortran"></span><h3>C and Fortran contiguous copies<a class="headerlink" href="#c-and-fortran-contiguous-copies" title="Permalink to this headline">¶</a></h3>
<p>Copies can be made C or Fortran contiguous using the <tt class="docutils literal"><span class="pre">.copy()</span></tt> and
<tt class="docutils literal"><span class="pre">.copy_fortran()</span></tt> methods:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="c"># This view is C contiguous</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">c_contiguous</span> <span class="o">=</span> <span class="n">myview</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c"># This view is Fortran contiguous</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">:]</span> <span class="n">f_contiguous_slice</span> <span class="o">=</span> <span class="n">myview</span><span class="o">.</span><span class="n">copy_fortran</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-more-general-memory-layouts">
<span id="view-general-layouts"></span><h3>Specifying more general memory layouts<a class="headerlink" href="#specifying-more-general-memory-layouts" title="Permalink to this headline">¶</a></h3>
<p>Data layout can be specified using the previously seen <tt class="docutils literal"><span class="pre">::1</span></tt> slice syntax, or
by using any of the constants in <tt class="docutils literal"><span class="pre">cython.view</span></tt>. If no specifier is given in
any dimension, then the data access is assumed to be direct, and the data
packing assumed to be strided.  If you don&#8217;t know whether a dimension will be
direct or indirect (because you&#8217;re getting an object with a buffer interface
from some library perhaps), then you can specify the <cite>generic</cite> flag, in which
case it will be determined at runtime.</p>
<p>The flags are as follows:</p>
<ul class="simple">
<li>generic - strided and direct or indirect</li>
<li>strided - strided and direct (this is the default)</li>
<li>indirect - strided and indirect</li>
<li>contiguous - contiguous and direct</li>
<li>indirect_contiguous - the list of pointers is contiguous</li>
</ul>
<p>and they can be used like this:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">from</span> <span class="nn">cython</span> <span class="k">cimport</span> <span class="n">view</span>

<span class="c"># direct access in both dimensions, strided in the first dimension, contiguous in the last</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">contiguous</span><span class="p">]</span> <span class="n">a</span>

<span class="c"># contiguous list of pointers to contiguous lists of ints</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect_contiguous</span><span class="p">,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">b</span>

<span class="c"># direct or indirect in the first dimension, direct in the second dimension</span>
<span class="c"># strided in both dimensions</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">generic</span><span class="p">,</span> <span class="p">:]</span> <span class="n">c</span>
</pre></div>
</div>
<p>Only the first, last or the dimension following an indirect dimension may be
specified contiguous:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="c"># INVALID</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">contiguous</span><span class="p">,</span> <span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect</span><span class="p">,</span> <span class="p">:]</span> <span class="n">a</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect</span><span class="p">,</span> <span class="p">:]</span> <span class="n">b</span>

<span class="c"># VALID</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect</span><span class="p">,</span> <span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">:]</span> <span class="n">a</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect</span><span class="p">,</span> <span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">b</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">indirect_contiguous</span><span class="p">,</span> <span class="p">::</span><span class="mf">1</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<p>The difference between the <cite>contiguous</cite> flag and the <cite>::1</cite> specifier is that the
former specifies contiguity for only one dimension, whereas the latter specifies
contiguity for all following (Fortran) or preceding (C) dimensions:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">c_contig</span> <span class="o">=</span> <span class="o">...</span>

<span class="c"># VALID</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="n">view</span><span class="o">.</span><span class="n">contiguous</span><span class="p">]</span> <span class="n">myslice</span> <span class="o">=</span> <span class="n">c_contig</span><span class="p">[::</span><span class="mf">2</span><span class="p">]</span>

<span class="c"># INVALID</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">myslice</span> <span class="o">=</span> <span class="n">c_contig</span><span class="p">[::</span><span class="mf">2</span><span class="p">]</span>
</pre></div>
</div>
<p>The former case is valid because the last dimension remains contiguous, but the
first dimension does not &#8220;follow&#8221; the last one anymore (meaning, it was strided
already, but it is not C or Fortran contiguous any longer), since it was sliced.</p>
</div>
</div>
<div class="section" id="memoryviews-and-the-gil">
<span id="view-needs-gil"></span><h2>Memoryviews and the GIL<a class="headerlink" href="#memoryviews-and-the-gil" title="Permalink to this headline">¶</a></h2>
<p>As you will see from the <a class="reference internal" href="#view-quickstart"><em>Quickstart</em></a> section, memoryviews often do
not need the GIL:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cpdef</span> <span class="kt">int</span> <span class="nf">sum3d</span><span class="p">(</span><span class="nb">int</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="n">arr</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>In particular, you do not need the GIL for memoryview indexing, slicing or
transposing. Memoryviews require the GIL for the copy methods
(<a class="reference internal" href="#view-copy-c-fortran"><em>C and Fortran contiguous copies</em></a>), or when the dtype is object and an object
element is read or written.</p>
</div>
<div class="section" id="memoryview-objects-and-cython-arrays">
<h2>Memoryview Objects and Cython Arrays<a class="headerlink" href="#memoryview-objects-and-cython-arrays" title="Permalink to this headline">¶</a></h2>
<p>These typed memoryviews can be converted to Python memoryview objects
(<cite>cython.view.memoryview</cite>).  These Python objects are indexable, slicable and
transposable in the same way that the original memoryviews are. They can also be
converted back to Cython-space memoryviews at any time.</p>
<p>They have the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li>shape</li>
<li>strides</li>
<li>suboffsets</li>
<li>ndim</li>
<li>size</li>
<li>itemsize</li>
<li>nbytes</li>
<li>base</li>
</ul>
</div></blockquote>
<p>And of course the aforementioned <tt class="docutils literal"><span class="pre">T</span></tt> attribute (<a class="reference internal" href="#view-transposing"><em>Transposing</em></a>).
These attributes have the same semantics as in <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#memory-layout">NumPy</a>.  For instance, to
retrieve the original object:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">import</span> <span class="nn">numpy</span>
<span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">cnp</span>

<span class="k">cdef</span> <span class="kt">cnp</span>.<span class="kt">int32_t</span>[<span class="p">:]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="mf">2</span><span class="p">]</span>

<span class="k">print</span> <span class="n">a</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">base</span>

<span class="c"># this prints: &lt;MemoryView of &#39;ndarray&#39; object&gt; [0 2 4 6 8] [0 1 2 3 4 5 6 7 8 9]</span>
</pre></div>
</div>
<p>Note that this example returns the original object from which the view was
obtained, and that the view was resliced in the meantime.</p>
</div>
<div class="section" id="cython-arrays">
<span id="view-cython-arrays"></span><h2>Cython arrays<a class="headerlink" href="#cython-arrays" title="Permalink to this headline">¶</a></h2>
<p>Whenever a Cython memoryview is copied (using any of the <cite>copy</cite> or
<cite>copy_fortran</cite> methods), you get a new memoryview slice of a newly created
<tt class="docutils literal"><span class="pre">cython.view.array</span></tt> object. This array can also be used manually, and will
automatically allocate a block of data. It can later be assigned to a C or
Fortran contiguous slice (or a strided slice). It can be used like:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">from</span> <span class="nn">cython</span> <span class="k">cimport</span> <span class="n">view</span>

<span class="n">my_array</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">itemsize</span><span class="o">=</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;i&quot;</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">:]</span> <span class="n">my_slice</span> <span class="o">=</span> <span class="n">my_array</span>
</pre></div>
</div>
<p>It also takes an optional argument <cite>mode</cite> (&#8216;c&#8217; or &#8216;fortran&#8217;) and a boolean
<cite>allocate_buffer</cite>, that indicates whether a buffer should be allocated and freed
when it goes out of scope:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">view</span>.<span class="kt">array</span> <span class="nf">my_array</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;fortran&quot;</span><span class="p">,</span> <span class="n">allocate_buffer</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">my_array</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">char</span> <span class="o">*&gt;</span> <span class="n">my_data_pointer</span>

<span class="c"># define a function that can deallocate the data (if needed)</span>
<span class="n">my_array</span><span class="o">.</span><span class="n">callback_free_data</span> <span class="o">=</span> <span class="n">free</span>
</pre></div>
</div>
<p>You can also cast pointers to array, or C arrays to arrays:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">view</span>.<span class="kt">array</span> <span class="nf">my_array</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nb">int</span><span class="p">[:</span><span class="mf">10</span><span class="p">,</span> <span class="p">:</span><span class="mf">2</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">my_data_pointer</span>
<span class="k">cdef</span> <span class="kt">view</span>.<span class="kt">array</span> <span class="nf">my_array</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nb">int</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">&gt;</span> <span class="n">my_c_array</span>
</pre></div>
</div>
<p>Of course, you can also immediately assign a cython.view.array to a typed memoryview slice. A C array
may be assigned directly to a memoryview slice:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cdef</span> <span class="kt">int</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">myslice</span> <span class="o">=</span> <span class="n">my_2d_c_array</span>
</pre></div>
</div>
<p>The arrays are indexable and slicable from Python space just like memoryview objects, and have the same
attributes as memoryview objects.</p>
</div>
<div class="section" id="cpython-array-module">
<h2>CPython array module<a class="headerlink" href="#cpython-array-module" title="Permalink to this headline">¶</a></h2>
<p>An alternative to <tt class="docutils literal"><span class="pre">cython.view.array</span></tt> is the <tt class="docutils literal"><span class="pre">array</span></tt> module in the
Python standard library.  In Python 3, the <tt class="docutils literal"><span class="pre">array.array</span></tt> type supports
the buffer interface natively, so memoryviews work on top of it without
additional setup.</p>
<p>Starting with Cython 0.17, however, it is possible to use these arrays
as buffer providers also in Python 2.  This is done through explicitly
cimporting the <tt class="docutils literal"><span class="pre">cpython.array</span></tt> module as follows:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cimport</span> <span class="nn">cpython.array</span>

<span class="k">def</span> <span class="nf">sum_array</span><span class="p">(</span><span class="nb">int</span><span class="p">[:]</span> <span class="n">view</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; from array import array</span>
<span class="sd">    &gt;&gt;&gt; sum_array( array(&#39;i&#39;, [1,2,3]) )</span>
<span class="sd">    6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">total</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">view</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>
</pre></div>
</div>
<p>Note that the cimport also enables the old buffer syntax for the array
type.  Therefore, the following also works:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">from</span> <span class="nn">cpython</span> <span class="k">cimport</span> <span class="n">array</span>

<span class="k">def</span> <span class="nf">sum_array</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="n">arr</span><span class="p">):</span>  <span class="c"># using old buffer syntax</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="coercion-to-numpy">
<h2>Coercion to NumPy<a class="headerlink" href="#coercion-to-numpy" title="Permalink to this headline">¶</a></h2>
<p>Memoryview (and array) objects can be coerced to a NumPy ndarray, without having
to copy the data. You can e.g. do:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">numpy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">int32_t</span><span class="p">[:</span><span class="mf">10</span><span class="p">,</span> <span class="p">:</span><span class="mf">10</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">my_pointer</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, you are not restricted to using NumPy&#8217;s type (such as <tt class="docutils literal"><span class="pre">np.int32_t</span></tt>
here), you can use any usable type.</p>
</div>
<div class="section" id="none-slices">
<h2>None Slices<a class="headerlink" href="#none-slices" title="Permalink to this headline">¶</a></h2>
<p>Although memoryview slices are not objects they can be set to None and they can
be be checked for being None as well:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">myarray</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">myarray</span> <span class="ow">is</span> <span class="bp">None</span>
</pre></div>
</div>
<p>If the function requires real memory views as input, it is therefore best to
reject None input straight away in the signature, which is supported in Cython
0.17 and later as follows:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">double</span><span class="p">[:]</span> <span class="n">myarray</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Unlike object attributes of extension classes, memoryview slices are not
initialized to None.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index-2.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Typed Memoryviews</a><ul>
<li><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li><a class="reference internal" href="#using-memoryviews">Using memoryviews</a><ul>
<li><a class="reference internal" href="#indexing-and-slicing">Indexing and Slicing</a></li>
<li><a class="reference internal" href="#copying">Copying</a></li>
<li><a class="reference internal" href="#transposing">Transposing</a></li>
<li><a class="reference internal" href="#newaxis">Newaxis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparison-to-the-old-buffer-support">Comparison to the old buffer support</a></li>
<li><a class="reference internal" href="#python-buffer-support">Python buffer support</a></li>
<li><a class="reference internal" href="#memory-layout">Memory layout</a><ul>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#brief-recap-on-c-fortran-and-strided-memory-layouts">Brief recap on C, Fortran and strided memory layouts</a></li>
<li><a class="reference internal" href="#default-behavior-for-memoryview-layouts">Default behavior for memoryview layouts</a></li>
<li><a class="reference internal" href="#c-and-fortran-contiguous-memoryviews">C and Fortran contiguous memoryviews</a></li>
<li><a class="reference internal" href="#c-and-fortran-contiguous-copies">C and Fortran contiguous copies</a></li>
<li><a class="reference internal" href="#specifying-more-general-memory-layouts">Specifying more general memory layouts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memoryviews-and-the-gil">Memoryviews and the GIL</a></li>
<li><a class="reference internal" href="#memoryview-objects-and-cython-arrays">Memoryview Objects and Cython Arrays</a></li>
<li><a class="reference internal" href="#cython-arrays">Cython arrays</a></li>
<li><a class="reference internal" href="#cpython-array-module">CPython array module</a></li>
<li><a class="reference internal" href="#coercion-to-numpy">Coercion to NumPy</a></li>
<li><a class="reference internal" href="#none-slices">None Slices</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyrex_differences.html"
                        title="previous chapter">Differences between Cython and Pyrex</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parallelism.html"
                        title="next chapter">Using Parallelism</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/src/userguide/memoryviews.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.cython.org/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="parallelism.html" title="Using Parallelism"
             >next</a></li>
        <li class="right" >
          <a href="pyrex_differences.html" title="Differences between Cython and Pyrex"
             >previous</a> |</li>
        <li><a href="../../index-2.html">Cython 0.20 documentation</a> &raquo;</li>
          <li><a href="index.html" >Users Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2014, Stefan Behnel, Robert Bradshaw, Dag Sverre Seljebotn, Greg Ewing, William Stein, Gabriel Gellner, et al..
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6139100-3");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>

<!-- Mirrored from docs.cython.org/src/userguide/memoryviews.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 22 Apr 2014 23:32:58 GMT -->
</html>